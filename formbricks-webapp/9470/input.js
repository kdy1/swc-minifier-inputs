exports.id = 9470;
exports.ids = [9470];
exports.modules = {

/***/ 238505:
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return Object.propertyIsEnumerable.call(target, symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ 154289:
/***/ ((module) => {

"use strict";
/*! @license DOMPurify 3.2.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.3/LICENSE */



const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);

const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*}/gm); // eslint-disable-line unicorn/better-regex
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARIA_ATTR: ARIA_ATTR,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT,
  DATA_ATTR: DATA_ATTR,
  DOCTYPE_NAME: DOCTYPE_NAME,
  ERB_EXPR: ERB_EXPR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR
});

/* eslint-disable @typescript-eslint/indent */
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
const _createHooksMap = function _createHooksMap() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.2.3';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */
  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;
  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;
  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;
  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };
  /**
   * _forceRemove
   *
   * @param node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    // We void attribute values for unremovable "is" attributes
    if (name === 'is') {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {}
      } else {
        try {
          element.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };
  /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
  };
  /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */
  const _isNode = function _isNode(value) {
    return typeof Node === 'function' && value instanceof Node;
  };
  function _executeHooks(hooks, currentNode, data) {
    arrayForEach(hooks, hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    /* Check if we have attributes; if not we might have a text node */
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: undefined
    };
    let l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === 'value' ? attrValue : stringTrim(attrValue);
      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);
        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Remove attribute */
      _removeAttribute(name, currentNode);
      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      /* Sanitize tags and elements */
      _sanitizeElements(shadowNode);
      /* Check attributes next */
      _sanitizeAttributes(shadowNode);
      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */
    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */
      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      _sanitizeElements(currentNode);
      /* Check attributes next */
      _sanitizeAttributes(currentNode);
      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint) {
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function (entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function () {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

module.exports = purify;
//# sourceMappingURL=purify.cjs.js.map


/***/ }),

/***/ 482167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function e(e){return e&&e.default||e}module.exports=global.DOMPurify=global.DOMPurify||("undefined"!=typeof window?e(__webpack_require__(154289)):function(){const r=e(__webpack_require__(154289)),{JSDOM:u}=e(__webpack_require__(832325)),{window:o}=new u("<!DOCTYPE html>");return r(o)}());

/***/ }),

/***/ 197098:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ FileDigit)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(652793);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const FileDigit = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("FileDigit", [
    [
        "path",
        {
            d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4",
            key: "1pf5j1"
        }
    ],
    [
        "path",
        {
            d: "M14 2v4a2 2 0 0 0 2 2h4",
            key: "tnqrlb"
        }
    ],
    [
        "rect",
        {
            width: "4",
            height: "6",
            x: "2",
            y: "12",
            rx: "2",
            key: "jm304g"
        }
    ],
    [
        "path",
        {
            d: "M10 12h2v6",
            key: "12zw74"
        }
    ],
    [
        "path",
        {
            d: "M10 18h4",
            key: "1ulq68"
        }
    ]
]);
 //# sourceMappingURL=file-digit.js.map


/***/ }),

/***/ 298940:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ FileType2)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(652793);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const FileType2 = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("FileType2", [
    [
        "path",
        {
            d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4",
            key: "1pf5j1"
        }
    ],
    [
        "path",
        {
            d: "M14 2v4a2 2 0 0 0 2 2h4",
            key: "tnqrlb"
        }
    ],
    [
        "path",
        {
            d: "M2 13v-1h6v1",
            key: "1dh9dg"
        }
    ],
    [
        "path",
        {
            d: "M5 12v6",
            key: "150t9c"
        }
    ],
    [
        "path",
        {
            d: "M4 18h2",
            key: "1xrofg"
        }
    ]
]);
 //# sourceMappingURL=file-type-2.js.map


/***/ }),

/***/ 188388:
/***/ ((module) => {

"use strict";


/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @return {Object} Address object
 */
function _handleAddress(tokens) {
    let isGroup = false;
    let state = 'text';
    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: []
    };
    let i;
    let len;

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        let token = tokens[i];
        let prevToken = i ? tokens[i - 1] : null;
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    break;
                case '(':
                    state = 'comment';
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    break;
                default:
                    state = 'text';
                    break;
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a "<"
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }

            if (prevToken && prevToken.noBreak && data[state].length) {
                // join values
                data[state][data[state].length - 1] += token.value;
            } else {
                data[state].push(token.value);
            }
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');
        addresses.push({
            name: data.text || (address && address.name),
            group: data.group.length ? addressparser(data.group.join(',')) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    break;
                }
            }

            let _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // fixed the regex to parse email address correctly when email address has more than one @
                    data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                    if (data.address.length) {
                        break;
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }

        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }

        // Join values with spaces
        data.text = data.text.join(' ');
        data.address = data.address.join(' ');

        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || '',
                name: data.text || data.address || ''
            };

            if (address.address === address.name) {
                if ((address.address || '').match(/@/)) {
                    address.name = '';
                } else {
                    address.address = '';
                }
            }

            addresses.push(address);
        }
    }

    return addresses;
}

/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */
class Tokenizer {
    constructor(str) {
        this.str = (str || '').toString();
        this.operatorCurrent = '';
        this.operatorExpecting = '';
        this.node = null;
        this.escaped = false;

        this.list = [];
        /**
         * Operator tokens and which tokens are expected to end the sequence
         */
        this.operators = {
            '"': '"',
            '(': ')',
            '<': '>',
            ',': '',
            ':': ';',
            // Semicolons are not a legal delimiter per the RFC2822 grammar other
            // than for terminating a group, but they are also not valid for any
            // other use in this context.  Given that some mail clients have
            // historically allowed the semicolon as a delimiter equivalent to the
            // comma in their UI, it makes sense to treat them the same as a comma
            // when used outside of a group.
            ';': ''
        };
    }

    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */
    tokenize() {
        let list = [];

        for (let i = 0, len = this.str.length; i < len; i++) {
            let chr = this.str.charAt(i);
            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
            this.checkChar(chr, nextChr);
        }

        this.list.forEach(node => {
            node.value = (node.value || '').toString().trim();
            if (node.value) {
                list.push(node);
            }
        });

        return list;
    }

    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */
    checkChar(chr, nextChr) {
        if (this.escaped) {
            // ignore next condition blocks
        } else if (chr === this.operatorExpecting) {
            this.node = {
                type: 'operator',
                value: chr
            };

            if (nextChr && ![' ', '\t', '\r', '\n', ',', ';'].includes(nextChr)) {
                this.node.noBreak = true;
            }

            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = '';
            this.escaped = false;

            return;
        } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
                type: 'operator',
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
        } else if (['"', "'"].includes(this.operatorExpecting) && chr === '\\') {
            this.escaped = true;
            return;
        }

        if (!this.node) {
            this.node = {
                type: 'text',
                value: ''
            };
            this.list.push(this.node);
        }

        if (chr === '\n') {
            // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
            // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
            chr = ' ';
        }

        if (chr.charCodeAt(0) >= 0x21 || [' ', '\t'].includes(chr)) {
            // skip command bytes
            this.node.value += chr;
        }

        this.escaped = false;
    }
}

/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @return {Array} An array of address objects
 */
function addressparser(str, options) {
    options = options || {};

    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();

    let addresses = [];
    let address = [];
    let parsedAddresses = [];

    tokens.forEach(token => {
        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });

    if (address.length) {
        addresses.push(address);
    }

    addresses.forEach(address => {
        address = _handleAddress(address);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });

    if (options.flatten) {
        let addresses = [];
        let walkAddressList = list => {
            list.forEach(address => {
                if (address.group) {
                    return walkAddressList(address.group);
                } else {
                    addresses.push(address);
                }
            });
        };
        walkAddressList(parsedAddresses);
        return addresses;
    }

    return parsedAddresses;
}

// expose to the world
module.exports = addressparser;


/***/ }),

/***/ 866322:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Transform = (__webpack_require__(927910).Transform);

/**
 * Encodes a Buffer into a base64 encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} base64 encoded string
 */
function encode(buffer) {
    if (typeof buffer === 'string') {
        buffer = Buffer.from(buffer, 'utf-8');
    }

    return buffer.toString('base64');
}

/**
 * Adds soft line breaks to a base64 string
 *
 * @param {String} str base64 encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped base64 encoded string
 */
function wrap(str, lineLength) {
    str = (str || '').toString();
    lineLength = lineLength || 76;

    if (str.length <= lineLength) {
        return str;
    }

    let result = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos < str.length) {
        let wrappedLines = str
            .substr(pos, chunkLength)
            .replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\r\n')
            .trim();
        result.push(wrappedLines);
        pos += chunkLength;
    }

    return result.join('\r\n').trim();
}

/**
 * Creates a transform stream for encoding data to base64 encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */
class Encoder extends Transform {
    constructor(options) {
        super();
        // init Transform
        this.options = options || {};

        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }

        this._curLine = '';
        this._remainingBytes = false;

        this.inputBytes = 0;
        this.outputBytes = 0;
    }

    _transform(chunk, encoding, done) {
        if (encoding !== 'buffer') {
            chunk = Buffer.from(chunk, encoding);
        }

        if (!chunk || !chunk.length) {
            return setImmediate(done);
        }

        this.inputBytes += chunk.length;

        if (this._remainingBytes && this._remainingBytes.length) {
            chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
            this._remainingBytes = false;
        }

        if (chunk.length % 3) {
            this._remainingBytes = chunk.slice(chunk.length - (chunk.length % 3));
            chunk = chunk.slice(0, chunk.length - (chunk.length % 3));
        } else {
            this._remainingBytes = false;
        }

        let b64 = this._curLine + encode(chunk);

        if (this.options.lineLength) {
            b64 = wrap(b64, this.options.lineLength);

            // remove last line as it is still most probably incomplete
            let lastLF = b64.lastIndexOf('\n');
            if (lastLF < 0) {
                this._curLine = b64;
                b64 = '';
            } else if (lastLF === b64.length - 1) {
                this._curLine = '';
            } else {
                this._curLine = b64.substr(lastLF + 1);
                b64 = b64.substr(0, lastLF + 1);
            }
        }

        if (b64) {
            this.outputBytes += b64.length;
            this.push(Buffer.from(b64, 'ascii'));
        }

        setImmediate(done);
    }

    _flush(done) {
        if (this._remainingBytes && this._remainingBytes.length) {
            this._curLine += encode(this._remainingBytes);
        }

        if (this._curLine) {
            this._curLine = wrap(this._curLine, this.options.lineLength);
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, 'ascii');
            this._curLine = '';
        }
        done();
    }
}

// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 835754:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// FIXME:
// replace this Transform mess with a method that pipes input argument to output argument

const MessageParser = __webpack_require__(630961);
const RelaxedBody = __webpack_require__(417334);
const sign = __webpack_require__(399093);
const PassThrough = (__webpack_require__(927910).PassThrough);
const fs = __webpack_require__(629021);
const path = __webpack_require__(333873);
const crypto = __webpack_require__(455511);

const DKIM_ALGO = 'sha256';
const MAX_MESSAGE_SIZE = 128 * 1024; // buffer messages larger than this to disk

/*
// Usage:

let dkim = new DKIM({
    domainName: 'example.com',
    keySelector: 'key-selector',
    privateKey,
    cacheDir: '/tmp'
});
dkim.sign(input).pipe(process.stdout);

// Where inputStream is a rfc822 message (either a stream, string or Buffer)
// and outputStream is a DKIM signed rfc822 message
*/

class DKIMSigner {
    constructor(options, keys, input, output) {
        this.options = options || {};
        this.keys = keys;

        this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
        this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;

        this.cacheDir = this.options.cacheDir || false;

        this.chunks = [];
        this.chunklen = 0;
        this.readPos = 0;
        this.cachePath = this.cacheDir ? path.join(this.cacheDir, 'message.' + Date.now() + '-' + crypto.randomBytes(14).toString('hex')) : false;
        this.cache = false;

        this.headers = false;
        this.bodyHash = false;
        this.parser = false;
        this.relaxedBody = false;

        this.input = input;
        this.output = output;
        this.output.usingCache = false;

        this.hasErrored = false;

        this.input.on('error', err => {
            this.hasErrored = true;
            this.cleanup();
            output.emit('error', err);
        });
    }

    cleanup() {
        if (!this.cache || !this.cachePath) {
            return;
        }
        fs.unlink(this.cachePath, () => false);
    }

    createReadCache() {
        // pipe remainings to cache file
        this.cache = fs.createReadStream(this.cachePath);
        this.cache.once('error', err => {
            this.cleanup();
            this.output.emit('error', err);
        });
        this.cache.once('close', () => {
            this.cleanup();
        });
        this.cache.pipe(this.output);
    }

    sendNextChunk() {
        if (this.hasErrored) {
            return;
        }

        if (this.readPos >= this.chunks.length) {
            if (!this.cache) {
                return this.output.end();
            }
            return this.createReadCache();
        }
        let chunk = this.chunks[this.readPos++];
        if (this.output.write(chunk) === false) {
            return this.output.once('drain', () => {
                this.sendNextChunk();
            });
        }
        setImmediate(() => this.sendNextChunk());
    }

    sendSignedOutput() {
        let keyPos = 0;
        let signNextKey = () => {
            if (keyPos >= this.keys.length) {
                this.output.write(this.parser.rawHeaders);
                return setImmediate(() => this.sendNextChunk());
            }
            let key = this.keys[keyPos++];
            let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
                domainName: key.domainName,
                keySelector: key.keySelector,
                privateKey: key.privateKey,
                headerFieldNames: this.options.headerFieldNames,
                skipFields: this.options.skipFields
            });
            if (dkimField) {
                this.output.write(Buffer.from(dkimField + '\r\n'));
            }
            return setImmediate(signNextKey);
        };

        if (this.bodyHash && this.headers) {
            return signNextKey();
        }

        this.output.write(this.parser.rawHeaders);
        this.sendNextChunk();
    }

    createWriteCache() {
        this.output.usingCache = true;
        // pipe remainings to cache file
        this.cache = fs.createWriteStream(this.cachePath);
        this.cache.once('error', err => {
            this.cleanup();
            // drain input
            this.relaxedBody.unpipe(this.cache);
            this.relaxedBody.on('readable', () => {
                while (this.relaxedBody.read() !== null) {
                    // do nothing
                }
            });
            this.hasErrored = true;
            // emit error
            this.output.emit('error', err);
        });
        this.cache.once('close', () => {
            this.sendSignedOutput();
        });
        this.relaxedBody.removeAllListeners('readable');
        this.relaxedBody.pipe(this.cache);
    }

    signStream() {
        this.parser = new MessageParser();
        this.relaxedBody = new RelaxedBody({
            hashAlgo: this.hashAlgo
        });

        this.parser.on('headers', value => {
            this.headers = value;
        });

        this.relaxedBody.on('hash', value => {
            this.bodyHash = value;
        });

        this.relaxedBody.on('readable', () => {
            let chunk;
            if (this.cache) {
                return;
            }
            while ((chunk = this.relaxedBody.read()) !== null) {
                this.chunks.push(chunk);
                this.chunklen += chunk.length;
                if (this.chunklen >= this.cacheTreshold && this.cachePath) {
                    return this.createWriteCache();
                }
            }
        });

        this.relaxedBody.on('end', () => {
            if (this.cache) {
                return;
            }
            this.sendSignedOutput();
        });

        this.parser.pipe(this.relaxedBody);
        setImmediate(() => this.input.pipe(this.parser));
    }
}

class DKIM {
    constructor(options) {
        this.options = options || {};
        this.keys = [].concat(
            this.options.keys || {
                domainName: options.domainName,
                keySelector: options.keySelector,
                privateKey: options.privateKey
            }
        );
    }

    sign(input, extraOptions) {
        let output = new PassThrough();
        let inputStream = input;
        let writeValue = false;

        if (Buffer.isBuffer(input)) {
            writeValue = input;
            inputStream = new PassThrough();
        } else if (typeof input === 'string') {
            writeValue = Buffer.from(input);
            inputStream = new PassThrough();
        }

        let options = this.options;
        if (extraOptions && Object.keys(extraOptions).length) {
            options = {};
            Object.keys(this.options || {}).forEach(key => {
                options[key] = this.options[key];
            });
            Object.keys(extraOptions || {}).forEach(key => {
                if (!(key in options)) {
                    options[key] = extraOptions[key];
                }
            });
        }

        let signer = new DKIMSigner(options, this.keys, inputStream, output);
        setImmediate(() => {
            signer.signStream();
            if (writeValue) {
                setImmediate(() => {
                    inputStream.end(writeValue);
                });
            }
        });

        return output;
    }
}

module.exports = DKIM;


/***/ }),

/***/ 630961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Transform = (__webpack_require__(927910).Transform);

/**
 * MessageParser instance is a transform stream that separates message headers
 * from the rest of the body. Headers are emitted with the 'headers' event. Message
 * body is passed on as the resulting stream.
 */
class MessageParser extends Transform {
    constructor(options) {
        super(options);
        this.lastBytes = Buffer.alloc(4);
        this.headersParsed = false;
        this.headerBytes = 0;
        this.headerChunks = [];
        this.rawHeaders = false;
        this.bodySize = 0;
    }

    /**
     * Keeps count of the last 4 bytes in order to detect line breaks on chunk boundaries
     *
     * @param {Buffer} data Next data chunk from the stream
     */
    updateLastBytes(data) {
        let lblen = this.lastBytes.length;
        let nblen = Math.min(data.length, lblen);

        // shift existing bytes
        for (let i = 0, len = lblen - nblen; i < len; i++) {
            this.lastBytes[i] = this.lastBytes[i + nblen];
        }

        // add new bytes
        for (let i = 1; i <= nblen; i++) {
            this.lastBytes[lblen - i] = data[data.length - i];
        }
    }

    /**
     * Finds and removes message headers from the remaining body. We want to keep
     * headers separated until final delivery to be able to modify these
     *
     * @param {Buffer} data Next chunk of data
     * @return {Boolean} Returns true if headers are already found or false otherwise
     */
    checkHeaders(data) {
        if (this.headersParsed) {
            return true;
        }

        let lblen = this.lastBytes.length;
        let headerPos = 0;
        this.curLinePos = 0;
        for (let i = 0, len = this.lastBytes.length + data.length; i < len; i++) {
            let chr;
            if (i < lblen) {
                chr = this.lastBytes[i];
            } else {
                chr = data[i - lblen];
            }
            if (chr === 0x0a && i) {
                let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
                let pr2 = i > 1 ? (i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen]) : false;
                if (pr1 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                } else if (pr1 === 0x0d && pr2 === 0x0a) {
                    this.headersParsed = true;
                    headerPos = i - lblen + 1;
                    this.headerBytes += headerPos;
                    break;
                }
            }
        }

        if (this.headersParsed) {
            this.headerChunks.push(data.slice(0, headerPos));
            this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
            this.headerChunks = null;
            this.emit('headers', this.parseHeaders());
            if (data.length - 1 > headerPos) {
                let chunk = data.slice(headerPos);
                this.bodySize += chunk.length;
                // this would be the first chunk of data sent downstream
                setImmediate(() => this.push(chunk));
            }
            return false;
        } else {
            this.headerBytes += data.length;
            this.headerChunks.push(data);
        }

        // store last 4 bytes to catch header break
        this.updateLastBytes(data);

        return false;
    }

    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }

        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding);
        }

        let headersFound;

        try {
            headersFound = this.checkHeaders(chunk);
        } catch (E) {
            return callback(E);
        }

        if (headersFound) {
            this.bodySize += chunk.length;
            this.push(chunk);
        }

        setImmediate(callback);
    }

    _flush(callback) {
        if (this.headerChunks) {
            let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
            this.bodySize += chunk.length;
            this.push(chunk);
            this.headerChunks = null;
        }
        callback();
    }

    parseHeaders() {
        let lines = (this.rawHeaders || '').toString().split(/\r?\n/);
        for (let i = lines.length - 1; i > 0; i--) {
            if (/^\s/.test(lines[i])) {
                lines[i - 1] += '\n' + lines[i];
                lines.splice(i, 1);
            }
        }
        return lines
            .filter(line => line.trim())
            .map(line => ({
                key: line.substr(0, line.indexOf(':')).trim().toLowerCase(),
                line
            }));
    }
}

module.exports = MessageParser;


/***/ }),

/***/ 417334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// streams through a message body and calculates relaxed body hash

const Transform = (__webpack_require__(927910).Transform);
const crypto = __webpack_require__(455511);

class RelaxedBody extends Transform {
    constructor(options) {
        super();
        options = options || {};
        this.chunkBuffer = [];
        this.chunkBufferLen = 0;
        this.bodyHash = crypto.createHash(options.hashAlgo || 'sha1');
        this.remainder = '';
        this.byteLength = 0;

        this.debug = options.debug;
        this._debugBody = options.debug ? [] : false;
    }

    updateHash(chunk) {
        let bodyStr;

        // find next remainder
        let nextRemainder = '';

        // This crux finds and removes the spaces from the last line and the newline characters after the last non-empty line
        // If we get another chunk that does not match this description then we can restore the previously processed data
        let state = 'file';
        for (let i = chunk.length - 1; i >= 0; i--) {
            let c = chunk[i];

            if (state === 'file' && (c === 0x0a || c === 0x0d)) {
                // do nothing, found \n or \r at the end of chunk, stil end of file
            } else if (state === 'file' && (c === 0x09 || c === 0x20)) {
                // switch to line ending mode, this is the last non-empty line
                state = 'line';
            } else if (state === 'line' && (c === 0x09 || c === 0x20)) {
                // do nothing, found ' ' or \t at the end of line, keep processing the last non-empty line
            } else if (state === 'file' || state === 'line') {
                // non line/file ending character found, switch to body mode
                state = 'body';
                if (i === chunk.length - 1) {
                    // final char is not part of line end or file end, so do nothing
                    break;
                }
            }

            if (i === 0) {
                // reached to the beginning of the chunk, check if it is still about the ending
                // and if the remainder also matches
                if (
                    (state === 'file' && (!this.remainder || /[\r\n]$/.test(this.remainder))) ||
                    (state === 'line' && (!this.remainder || /[ \t]$/.test(this.remainder)))
                ) {
                    // keep everything
                    this.remainder += chunk.toString('binary');
                    return;
                } else if (state === 'line' || state === 'file') {
                    // process existing remainder as normal line but store the current chunk
                    nextRemainder = chunk.toString('binary');
                    chunk = false;
                    break;
                }
            }

            if (state !== 'body') {
                continue;
            }

            // reached first non ending byte
            nextRemainder = chunk.slice(i + 1).toString('binary');
            chunk = chunk.slice(0, i + 1);
            break;
        }

        let needsFixing = !!this.remainder;
        if (chunk && !needsFixing) {
            // check if we even need to change anything
            for (let i = 0, len = chunk.length; i < len; i++) {
                if (i && chunk[i] === 0x0a && chunk[i - 1] !== 0x0d) {
                    // missing \r before \n
                    needsFixing = true;
                    break;
                } else if (i && chunk[i] === 0x0d && chunk[i - 1] === 0x20) {
                    // trailing WSP found
                    needsFixing = true;
                    break;
                } else if (i && chunk[i] === 0x20 && chunk[i - 1] === 0x20) {
                    // multiple spaces found, needs to be replaced with just one
                    needsFixing = true;
                    break;
                } else if (chunk[i] === 0x09) {
                    // TAB found, needs to be replaced with a space
                    needsFixing = true;
                    break;
                }
            }
        }

        if (needsFixing) {
            bodyStr = this.remainder + (chunk ? chunk.toString('binary') : '');
            this.remainder = nextRemainder;
            bodyStr = bodyStr
                .replace(/\r?\n/g, '\n') // use js line endings
                .replace(/[ \t]*$/gm, '') // remove line endings, rtrim
                .replace(/[ \t]+/gm, ' ') // single spaces
                .replace(/\n/g, '\r\n'); // restore rfc822 line endings
            chunk = Buffer.from(bodyStr, 'binary');
        } else if (nextRemainder) {
            this.remainder = nextRemainder;
        }

        if (this.debug) {
            this._debugBody.push(chunk);
        }
        this.bodyHash.update(chunk);
    }

    _transform(chunk, encoding, callback) {
        if (!chunk || !chunk.length) {
            return callback();
        }

        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding);
        }

        this.updateHash(chunk);

        this.byteLength += chunk.length;
        this.push(chunk);
        callback();
    }

    _flush(callback) {
        // generate final hash and emit it
        if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
            // add terminating line end
            this.bodyHash.update(Buffer.from('\r\n'));
        }
        if (!this.byteLength) {
            // emit empty line buffer to keep the stream flowing
            this.push(Buffer.from('\r\n'));
            // this.bodyHash.update(Buffer.from('\r\n'));
        }

        this.emit('hash', this.bodyHash.digest('base64'), this.debug ? Buffer.concat(this._debugBody) : false);
        callback();
    }
}

module.exports = RelaxedBody;


/***/ }),

/***/ 399093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const punycode = __webpack_require__(155338);
const mimeFuncs = __webpack_require__(595311);
const crypto = __webpack_require__(455511);

/**
 * Returns DKIM signature header line
 *
 * @param {Object} headers Parsed headers object from MessageParser
 * @param {String} bodyHash Base64 encoded hash of the message
 * @param {Object} options DKIM options
 * @param {String} options.domainName Domain name to be signed for
 * @param {String} options.keySelector DKIM key selector to use
 * @param {String} options.privateKey DKIM private key to use
 * @return {String} Complete header line
 */

module.exports = (headers, hashAlgo, bodyHash, options) => {
    options = options || {};

    // all listed fields from RFC4871 #5.5
    let defaultFieldNames =
        'From:Sender:Reply-To:Subject:Date:Message-ID:To:' +
        'Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:' +
        'Content-Description:Resent-Date:Resent-From:Resent-Sender:' +
        'Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:' +
        'List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:' +
        'List-Owner:List-Archive';

    let fieldNames = options.headerFieldNames || defaultFieldNames;

    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);

    let signer, signature;

    canonicalizedHeaderData.headers += 'dkim-signature:' + relaxedHeaderLine(dkimHeader);

    signer = crypto.createSign(('rsa-' + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
        signature = signer.sign(options.privateKey, 'base64');
    } catch (E) {
        return false;
    }

    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, '$&\r\n ').trim();
};

module.exports.relaxedHeaders = relaxedHeaders;

function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
        'v=1',
        'a=rsa-' + hashAlgo,
        'c=relaxed/relaxed',
        'd=' + punycode.toASCII(domainName),
        'q=dns/txt',
        's=' + keySelector,
        'bh=' + bodyHash,
        'h=' + fieldNames
    ].join('; ');

    return mimeFuncs.foldLines('DKIM-Signature: ' + dkim, 76) + ';\r\n b=';
}

function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = new Set();
    let skip = new Set();
    let headerFields = new Map();

    (skipFields || '')
        .toLowerCase()
        .split(':')
        .forEach(field => {
            skip.add(field.trim());
        });

    (fieldNames || '')
        .toLowerCase()
        .split(':')
        .filter(field => !skip.has(field.trim()))
        .forEach(field => {
            includedFields.add(field.trim());
        });

    for (let i = headers.length - 1; i >= 0; i--) {
        let line = headers[i];
        // only include the first value from bottom to top
        if (includedFields.has(line.key) && !headerFields.has(line.key)) {
            headerFields.set(line.key, relaxedHeaderLine(line.line));
        }
    }

    let headersList = [];
    let fields = [];
    includedFields.forEach(field => {
        if (headerFields.has(field)) {
            fields.push(field);
            headersList.push(field + ':' + headerFields.get(field));
        }
    });

    return {
        headers: headersList.join('\r\n') + '\r\n',
        fieldNames: fields.join(':')
    };
}

function relaxedHeaderLine(line) {
    return line
        .substr(line.indexOf(':') + 1)
        .replace(/\r?\n/g, '')
        .replace(/\s+/g, ' ')
        .trim();
}


/***/ }),

/***/ 256304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// module to handle cookies

const urllib = __webpack_require__(379551);

const SESSION_TIMEOUT = 1800; // 30 min

/**
 * Creates a biskviit cookie jar for managing cookie values in memory
 *
 * @constructor
 * @param {Object} [options] Optional options object
 */
class Cookies {
    constructor(options) {
        this.options = options || {};
        this.cookies = [];
    }

    /**
     * Stores a cookie string to the cookie storage
     *
     * @param {String} cookieStr Value from the 'Set-Cookie:' header
     * @param {String} url Current URL
     */
    set(cookieStr, url) {
        let urlparts = urllib.parse(url || '');
        let cookie = this.parse(cookieStr);
        let domain;

        if (cookie.domain) {
            domain = cookie.domain.replace(/^\./, '');

            // do not allow cross origin cookies
            if (
                // can't be valid if the requested domain is shorter than current hostname
                urlparts.hostname.length < domain.length ||
                // prefix domains with dot to be sure that partial matches are not used
                ('.' + urlparts.hostname).substr(-domain.length + 1) !== '.' + domain
            ) {
                cookie.domain = urlparts.hostname;
            }
        } else {
            cookie.domain = urlparts.hostname;
        }

        if (!cookie.path) {
            cookie.path = this.getPath(urlparts.pathname);
        }

        // if no expire date, then use sessionTimeout value
        if (!cookie.expires) {
            cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
        }

        return this.add(cookie);
    }

    /**
     * Returns cookie string for the 'Cookie:' header.
     *
     * @param {String} url URL to check for
     * @returns {String} Cookie header or empty string if no matches were found
     */
    get(url) {
        return this.list(url)
            .map(cookie => cookie.name + '=' + cookie.value)
            .join('; ');
    }

    /**
     * Lists all valied cookie objects for the specified URL
     *
     * @param {String} url URL to check for
     * @returns {Array} An array of cookie objects
     */
    list(url) {
        let result = [];
        let i;
        let cookie;

        for (i = this.cookies.length - 1; i >= 0; i--) {
            cookie = this.cookies[i];

            if (this.isExpired(cookie)) {
                this.cookies.splice(i, i);
                continue;
            }

            if (this.match(cookie, url)) {
                result.unshift(cookie);
            }
        }

        return result;
    }

    /**
     * Parses cookie string from the 'Set-Cookie:' header
     *
     * @param {String} cookieStr String from the 'Set-Cookie:' header
     * @returns {Object} Cookie object
     */
    parse(cookieStr) {
        let cookie = {};

        (cookieStr || '')
            .toString()
            .split(';')
            .forEach(cookiePart => {
                let valueParts = cookiePart.split('=');
                let key = valueParts.shift().trim().toLowerCase();
                let value = valueParts.join('=').trim();
                let domain;

                if (!key) {
                    // skip empty parts
                    return;
                }

                switch (key) {
                    case 'expires':
                        value = new Date(value);
                        // ignore date if can not parse it
                        if (value.toString() !== 'Invalid Date') {
                            cookie.expires = value;
                        }
                        break;

                    case 'path':
                        cookie.path = value;
                        break;

                    case 'domain':
                        domain = value.toLowerCase();
                        if (domain.length && domain.charAt(0) !== '.') {
                            domain = '.' + domain; // ensure preceeding dot for user set domains
                        }
                        cookie.domain = domain;
                        break;

                    case 'max-age':
                        cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                        break;

                    case 'secure':
                        cookie.secure = true;
                        break;

                    case 'httponly':
                        cookie.httponly = true;
                        break;

                    default:
                        if (!cookie.name) {
                            cookie.name = key;
                            cookie.value = value;
                        }
                }
            });

        return cookie;
    }

    /**
     * Checks if a cookie object is valid for a specified URL
     *
     * @param {Object} cookie Cookie object
     * @param {String} url URL to check for
     * @returns {Boolean} true if cookie is valid for specifiec URL
     */
    match(cookie, url) {
        let urlparts = urllib.parse(url || '');

        // check if hostname matches
        // .foo.com also matches subdomains, foo.com does not
        if (
            urlparts.hostname !== cookie.domain &&
            (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)
        ) {
            return false;
        }

        // check if path matches
        let path = this.getPath(urlparts.pathname);
        if (path.substr(0, cookie.path.length) !== cookie.path) {
            return false;
        }

        // check secure argument
        if (cookie.secure && urlparts.protocol !== 'https:') {
            return false;
        }

        return true;
    }

    /**
     * Adds (or updates/removes if needed) a cookie object to the cookie storage
     *
     * @param {Object} cookie Cookie value to be stored
     */
    add(cookie) {
        let i;
        let len;

        // nothing to do here
        if (!cookie || !cookie.name) {
            return false;
        }

        // overwrite if has same params
        for (i = 0, len = this.cookies.length; i < len; i++) {
            if (this.compare(this.cookies[i], cookie)) {
                // check if the cookie needs to be removed instead
                if (this.isExpired(cookie)) {
                    this.cookies.splice(i, 1); // remove expired/unset cookie
                    return false;
                }

                this.cookies[i] = cookie;
                return true;
            }
        }

        // add as new if not already expired
        if (!this.isExpired(cookie)) {
            this.cookies.push(cookie);
        }

        return true;
    }

    /**
     * Checks if two cookie objects are the same
     *
     * @param {Object} a Cookie to check against
     * @param {Object} b Cookie to check against
     * @returns {Boolean} True, if the cookies are the same
     */
    compare(a, b) {
        return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
    }

    /**
     * Checks if a cookie is expired
     *
     * @param {Object} cookie Cookie object to check against
     * @returns {Boolean} True, if the cookie is expired
     */
    isExpired(cookie) {
        return (cookie.expires && cookie.expires < new Date()) || !cookie.value;
    }

    /**
     * Returns normalized cookie path for an URL path argument
     *
     * @param {String} pathname
     * @returns {String} Normalized path
     */
    getPath(pathname) {
        let path = (pathname || '/').split('/');
        path.pop(); // remove filename part
        path = path.join('/').trim();

        // ensure path prefix /
        if (path.charAt(0) !== '/') {
            path = '/' + path;
        }

        // ensure path suffix /
        if (path.substr(-1) !== '/') {
            path += '/';
        }

        return path;
    }
}

module.exports = Cookies;


/***/ }),

/***/ 34843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const http = __webpack_require__(781630);
const https = __webpack_require__(55591);
const urllib = __webpack_require__(379551);
const zlib = __webpack_require__(74075);
const PassThrough = (__webpack_require__(927910).PassThrough);
const Cookies = __webpack_require__(256304);
const packageData = __webpack_require__(227761);
const net = __webpack_require__(491645);

const MAX_REDIRECTS = 5;

module.exports = function (url, options) {
    return nmfetch(url, options);
};

module.exports.Cookies = Cookies;

function nmfetch(url, options) {
    options = options || {};

    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;

    if (options.cookie) {
        [].concat(options.cookie || []).forEach(cookie => {
            options.cookies.set(cookie, url);
        });
        options.cookie = false;
    }

    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || '').toString().trim().toUpperCase() || 'GET';
    let finished = false;
    let cookies;
    let body;

    let handler = parsed.protocol === 'https:' ? https : http;

    let headers = {
        'accept-encoding': 'gzip,deflate',
        'user-agent': 'nodemailer/' + packageData.version
    };

    Object.keys(options.headers || {}).forEach(key => {
        headers[key.toLowerCase().trim()] = options.headers[key];
    });

    if (options.userAgent) {
        headers['user-agent'] = options.userAgent;
    }

    if (parsed.auth) {
        headers.Authorization = 'Basic ' + Buffer.from(parsed.auth).toString('base64');
    }

    if ((cookies = options.cookies.get(url))) {
        headers.cookie = cookies;
    }

    if (options.body) {
        if (options.contentType !== false) {
            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';
        }

        if (typeof options.body.pipe === 'function') {
            // it's a stream
            headers['Transfer-Encoding'] = 'chunked';
            body = options.body;
            body.on('error', err => {
                if (finished) {
                    return;
                }
                finished = true;
                err.type = 'FETCH';
                err.sourceUrl = url;
                fetchRes.emit('error', err);
            });
        } else {
            if (options.body instanceof Buffer) {
                body = options.body;
            } else if (typeof options.body === 'object') {
                try {
                    // encodeURIComponent can fail on invalid input (partial emoji etc.)
                    body = Buffer.from(
                        Object.keys(options.body)
                            .map(key => {
                                let value = options.body[key].toString().trim();
                                return encodeURIComponent(key) + '=' + encodeURIComponent(value);
                            })
                            .join('&')
                    );
                } catch (E) {
                    if (finished) {
                        return;
                    }
                    finished = true;
                    E.type = 'FETCH';
                    E.sourceUrl = url;
                    fetchRes.emit('error', E);
                    return;
                }
            } else {
                body = Buffer.from(options.body.toString().trim());
            }

            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';
            headers['Content-Length'] = body.length;
        }
        // if method is not provided, use POST instead of GET
        method = (options.method || '').toString().trim().toUpperCase() || 'POST';
    }

    let req;
    let reqOptions = {
        method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : parsed.protocol === 'https:' ? 443 : 80,
        headers,
        rejectUnauthorized: false,
        agent: false
    };

    if (options.tls) {
        Object.keys(options.tls).forEach(key => {
            reqOptions[key] = options.tls[key];
        });
    }

    if (parsed.protocol === 'https:' && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {
        reqOptions.servername = parsed.hostname;
    }

    try {
        req = handler.request(reqOptions);
    } catch (E) {
        finished = true;
        setImmediate(() => {
            E.type = 'FETCH';
            E.sourceUrl = url;
            fetchRes.emit('error', E);
        });
        return fetchRes;
    }

    if (options.timeout) {
        req.setTimeout(options.timeout, () => {
            if (finished) {
                return;
            }
            finished = true;
            req.abort();
            let err = new Error('Request Timeout');
            err.type = 'FETCH';
            err.sourceUrl = url;
            fetchRes.emit('error', err);
        });
    }

    req.on('error', err => {
        if (finished) {
            return;
        }
        finished = true;
        err.type = 'FETCH';
        err.sourceUrl = url;
        fetchRes.emit('error', err);
    });

    req.on('response', res => {
        let inflate;

        if (finished) {
            return;
        }

        switch (res.headers['content-encoding']) {
            case 'gzip':
            case 'deflate':
                inflate = zlib.createUnzip();
                break;
        }

        if (res.headers['set-cookie']) {
            [].concat(res.headers['set-cookie'] || []).forEach(cookie => {
                options.cookies.set(cookie, url);
            });
        }

        if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
            // redirect
            options.redirects++;
            if (options.redirects > options.maxRedirects) {
                finished = true;
                let err = new Error('Maximum redirect count exceeded');
                err.type = 'FETCH';
                err.sourceUrl = url;
                fetchRes.emit('error', err);
                req.abort();
                return;
            }
            // redirect does not include POST body
            options.method = 'GET';
            options.body = false;
            return nmfetch(urllib.resolve(url, res.headers.location), options);
        }

        fetchRes.statusCode = res.statusCode;
        fetchRes.headers = res.headers;

        if (res.statusCode >= 300 && !options.allowErrorResponse) {
            finished = true;
            let err = new Error('Invalid status code ' + res.statusCode);
            err.type = 'FETCH';
            err.sourceUrl = url;
            fetchRes.emit('error', err);
            req.abort();
            return;
        }

        res.on('error', err => {
            if (finished) {
                return;
            }
            finished = true;
            err.type = 'FETCH';
            err.sourceUrl = url;
            fetchRes.emit('error', err);
            req.abort();
        });

        if (inflate) {
            res.pipe(inflate).pipe(fetchRes);
            inflate.on('error', err => {
                if (finished) {
                    return;
                }
                finished = true;
                err.type = 'FETCH';
                err.sourceUrl = url;
                fetchRes.emit('error', err);
                req.abort();
            });
        } else {
            res.pipe(fetchRes);
        }
    });

    setImmediate(() => {
        if (body) {
            try {
                if (typeof body.pipe === 'function') {
                    return body.pipe(req);
                } else {
                    req.write(body);
                }
            } catch (err) {
                finished = true;
                err.type = 'FETCH';
                err.sourceUrl = url;
                fetchRes.emit('error', err);
                return;
            }
        }
        req.end();
    });

    return fetchRes;
}


/***/ }),

/***/ 44719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const packageData = __webpack_require__(227761);
const shared = __webpack_require__(835028);

/**
 * Generates a Transport object to generate JSON output
 *
 * @constructor
 * @param {Object} optional config parameter
 */
class JSONTransport {
    constructor(options) {
        options = options || {};

        this.options = options || {};

        this.name = 'JSONTransport';
        this.version = packageData.version;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'json-transport'
        });
    }

    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;

        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();

        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push('...and ' + recipients.splice(2).length + ' more');
        }
        this.logger.info(
            {
                tnx: 'send',
                messageId
            },
            'Composing JSON structure of  to <%s>',
            messageId,
            recipients.join(', ')
        );

        setImmediate(() => {
            mail.normalize((err, data) => {
                if (err) {
                    this.logger.error(
                        {
                            err,
                            tnx: 'send',
                            messageId
                        },
                        'Failed building JSON structure for %s. %s',
                        messageId,
                        err.message
                    );
                    return done(err);
                }

                delete data.envelope;
                delete data.normalizedHeaders;

                return done(null, {
                    envelope,
                    messageId,
                    message: this.options.skipEncoding ? data : JSON.stringify(data)
                });
            });
        });
    }
}

module.exports = JSONTransport;


/***/ }),

/***/ 896335:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0 */



const MimeNode = __webpack_require__(758820);
const mimeFuncs = __webpack_require__(595311);
const parseDataURI = (__webpack_require__(835028).parseDataURI);

/**
 * Creates the object for composing a MimeNode instance out from the mail options
 *
 * @constructor
 * @param {Object} mail Mail options
 */
class MailComposer {
    constructor(mail) {
        this.mail = mail || {};
        this.message = false;
    }

    /**
     * Builds MimeNode instance
     */
    compile() {
        this._alternatives = this.getAlternatives();
        this._htmlNode = this._alternatives.filter(alternative => /^text\/html\b/i.test(alternative.contentType)).pop();
        this._attachments = this.getAttachments(!!this._htmlNode);

        this._useRelated = !!(this._htmlNode && this._attachments.related.length);
        this._useAlternative = this._alternatives.length > 1;
        this._useMixed = this._attachments.attached.length > 1 || (this._alternatives.length && this._attachments.attached.length === 1);

        // Compose MIME tree
        if (this.mail.raw) {
            this.message = new MimeNode('message/rfc822', { newline: this.mail.newline }).setRaw(this.mail.raw);
        } else if (this._useMixed) {
            this.message = this._createMixed();
        } else if (this._useAlternative) {
            this.message = this._createAlternative();
        } else if (this._useRelated) {
            this.message = this._createRelated();
        } else {
            this.message = this._createContentNode(
                false,
                []
                    .concat(this._alternatives || [])
                    .concat(this._attachments.attached || [])
                    .shift() || {
                    contentType: 'text/plain',
                    content: ''
                }
            );
        }

        // Add custom headers
        if (this.mail.headers) {
            this.message.addHeader(this.mail.headers);
        }

        // Add headers to the root node, always overrides custom headers
        ['from', 'sender', 'to', 'cc', 'bcc', 'reply-to', 'in-reply-to', 'references', 'subject', 'message-id', 'date'].forEach(header => {
            let key = header.replace(/-(\w)/g, (o, c) => c.toUpperCase());
            if (this.mail[key]) {
                this.message.setHeader(header, this.mail[key]);
            }
        });

        // Sets custom envelope
        if (this.mail.envelope) {
            this.message.setEnvelope(this.mail.envelope);
        }

        // ensure Message-Id value
        this.message.messageId();

        return this.message;
    }

    /**
     * List all attachments. Resulting attachment objects can be used as input for MimeNode nodes
     *
     * @param {Boolean} findRelated If true separate related attachments from attached ones
     * @returns {Object} An object of arrays (`related` and `attached`)
     */
    getAttachments(findRelated) {
        let icalEvent, eventObject;
        let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
            let data;
            let isMessageNode = /^message\//i.test(attachment.contentType);

            if (/^data:/i.test(attachment.path || attachment.href)) {
                attachment = this._processDataUrl(attachment);
            }

            let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');
            let isImage = /^image\//i.test(contentType);
            let contentDisposition = attachment.contentDisposition || (isMessageNode || (isImage && attachment.cid) ? 'inline' : 'attachment');

            data = {
                contentType,
                contentDisposition,
                contentTransferEncoding: 'contentTransferEncoding' in attachment ? attachment.contentTransferEncoding : 'base64'
            };

            if (attachment.filename) {
                data.filename = attachment.filename;
            } else if (!isMessageNode && attachment.filename !== false) {
                data.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);
                if (data.filename.indexOf('.') < 0) {
                    data.filename += '.' + mimeFuncs.detectExtension(data.contentType);
                }
            }

            if (/^https?:\/\//i.test(attachment.path)) {
                attachment.href = attachment.path;
                attachment.path = undefined;
            }

            if (attachment.cid) {
                data.cid = attachment.cid;
            }

            if (attachment.raw) {
                data.raw = attachment.raw;
            } else if (attachment.path) {
                data.content = {
                    path: attachment.path
                };
            } else if (attachment.href) {
                data.content = {
                    href: attachment.href,
                    httpHeaders: attachment.httpHeaders
                };
            } else {
                data.content = attachment.content || '';
            }

            if (attachment.encoding) {
                data.encoding = attachment.encoding;
            }

            if (attachment.headers) {
                data.headers = attachment.headers;
            }

            return data;
        });

        if (this.mail.icalEvent) {
            if (
                typeof this.mail.icalEvent === 'object' &&
                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)
            ) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }

            eventObject = {};
            Object.keys(icalEvent).forEach(key => {
                eventObject[key] = icalEvent[key];
            });

            eventObject.contentType = 'application/ics';
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
            eventObject.filename = eventObject.filename || 'invite.ics';
            eventObject.headers['Content-Disposition'] = 'attachment';
            eventObject.headers['Content-Transfer-Encoding'] = 'base64';
        }

        if (!findRelated) {
            return {
                attached: attachments.concat(eventObject || []),
                related: []
            };
        } else {
            return {
                attached: attachments.filter(attachment => !attachment.cid).concat(eventObject || []),
                related: attachments.filter(attachment => !!attachment.cid)
            };
        }
    }

    /**
     * List alternatives. Resulting objects can be used as input for MimeNode nodes
     *
     * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
     */
    getAlternatives() {
        let alternatives = [],
            text,
            html,
            watchHtml,
            amp,
            icalEvent,
            eventObject;

        if (this.mail.text) {
            if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
                text = this.mail.text;
            } else {
                text = {
                    content: this.mail.text
                };
            }
            text.contentType = 'text/plain; charset=utf-8';
        }

        if (this.mail.watchHtml) {
            if (
                typeof this.mail.watchHtml === 'object' &&
                (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)
            ) {
                watchHtml = this.mail.watchHtml;
            } else {
                watchHtml = {
                    content: this.mail.watchHtml
                };
            }
            watchHtml.contentType = 'text/watch-html; charset=utf-8';
        }

        if (this.mail.amp) {
            if (typeof this.mail.amp === 'object' && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
                amp = this.mail.amp;
            } else {
                amp = {
                    content: this.mail.amp
                };
            }
            amp.contentType = 'text/x-amp-html; charset=utf-8';
        }

        // NB! when including attachments with a calendar alternative you might end up in a blank screen on some clients
        if (this.mail.icalEvent) {
            if (
                typeof this.mail.icalEvent === 'object' &&
                (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)
            ) {
                icalEvent = this.mail.icalEvent;
            } else {
                icalEvent = {
                    content: this.mail.icalEvent
                };
            }

            eventObject = {};
            Object.keys(icalEvent).forEach(key => {
                eventObject[key] = icalEvent[key];
            });

            if (eventObject.content && typeof eventObject.content === 'object') {
                // we are going to have the same attachment twice, so mark this to be
                // resolved just once
                eventObject.content._resolve = true;
            }

            eventObject.filename = false;
            eventObject.contentType = 'text/calendar; charset=utf-8; method=' + (eventObject.method || 'PUBLISH').toString().trim().toUpperCase();
            if (!eventObject.headers) {
                eventObject.headers = {};
            }
        }

        if (this.mail.html) {
            if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
                html = this.mail.html;
            } else {
                html = {
                    content: this.mail.html
                };
            }
            html.contentType = 'text/html; charset=utf-8';
        }

        []
            .concat(text || [])
            .concat(watchHtml || [])
            .concat(amp || [])
            .concat(html || [])
            .concat(eventObject || [])
            .concat(this.mail.alternatives || [])
            .forEach(alternative => {
                let data;

                if (/^data:/i.test(alternative.path || alternative.href)) {
                    alternative = this._processDataUrl(alternative);
                }

                data = {
                    contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),
                    contentTransferEncoding: alternative.contentTransferEncoding
                };

                if (alternative.filename) {
                    data.filename = alternative.filename;
                }

                if (/^https?:\/\//i.test(alternative.path)) {
                    alternative.href = alternative.path;
                    alternative.path = undefined;
                }

                if (alternative.raw) {
                    data.raw = alternative.raw;
                } else if (alternative.path) {
                    data.content = {
                        path: alternative.path
                    };
                } else if (alternative.href) {
                    data.content = {
                        href: alternative.href
                    };
                } else {
                    data.content = alternative.content || '';
                }

                if (alternative.encoding) {
                    data.encoding = alternative.encoding;
                }

                if (alternative.headers) {
                    data.headers = alternative.headers;
                }

                alternatives.push(data);
            });

        return alternatives;
    }

    /**
     * Builds multipart/mixed node. It should always contain different type of elements on the same level
     * eg. text + attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createMixed(parentNode) {
        let node;

        if (!parentNode) {
            node = new MimeNode('multipart/mixed', {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild('multipart/mixed', {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }

        if (this._useAlternative) {
            this._createAlternative(node);
        } else if (this._useRelated) {
            this._createRelated(node);
        }

        []
            .concat((!this._useAlternative && this._alternatives) || [])
            .concat(this._attachments.attached || [])
            .forEach(element => {
                // if the element is a html node from related subpart then ignore it
                if (!this._useRelated || element !== this._htmlNode) {
                    this._createContentNode(node, element);
                }
            });

        return node;
    }

    /**
     * Builds multipart/alternative node. It should always contain same type of elements on the same level
     * eg. text + html view of the same data
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createAlternative(parentNode) {
        let node;

        if (!parentNode) {
            node = new MimeNode('multipart/alternative', {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild('multipart/alternative', {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }

        this._alternatives.forEach(alternative => {
            if (this._useRelated && this._htmlNode === alternative) {
                this._createRelated(node);
            } else {
                this._createContentNode(node, alternative);
            }
        });

        return node;
    }

    /**
     * Builds multipart/related node. It should always contain html node with related attachments
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @returns {Object} MimeNode node element
     */
    _createRelated(parentNode) {
        let node;

        if (!parentNode) {
            node = new MimeNode('multipart/related; type="text/html"', {
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild('multipart/related; type="text/html"', {
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }

        this._createContentNode(node, this._htmlNode);

        this._attachments.related.forEach(alternative => this._createContentNode(node, alternative));

        return node;
    }

    /**
     * Creates a regular node with contents
     *
     * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
     * @param {Object} element Node data
     * @returns {Object} MimeNode node element
     */
    _createContentNode(parentNode, element) {
        element = element || {};
        element.content = element.content || '';

        let node;
        let encoding = (element.encoding || 'utf8')
            .toString()
            .toLowerCase()
            .replace(/[-_\s]/g, '');

        if (!parentNode) {
            node = new MimeNode(element.contentType, {
                filename: element.filename,
                baseBoundary: this.mail.baseBoundary,
                textEncoding: this.mail.textEncoding,
                boundaryPrefix: this.mail.boundaryPrefix,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        } else {
            node = parentNode.createChild(element.contentType, {
                filename: element.filename,
                textEncoding: this.mail.textEncoding,
                disableUrlAccess: this.mail.disableUrlAccess,
                disableFileAccess: this.mail.disableFileAccess,
                normalizeHeaderKey: this.mail.normalizeHeaderKey,
                newline: this.mail.newline
            });
        }

        // add custom headers
        if (element.headers) {
            node.addHeader(element.headers);
        }

        if (element.cid) {
            node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');
        }

        if (element.contentTransferEncoding) {
            node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);
        } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
            node.setHeader('Content-Transfer-Encoding', this.mail.encoding);
        }

        if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
            node.setHeader(
                'Content-Disposition',
                element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? 'inline' : 'attachment')
            );
        }

        if (typeof element.content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {
            element.content = Buffer.from(element.content, encoding);
        }

        // prefer pregenerated raw content
        if (element.raw) {
            node.setRaw(element.raw);
        } else {
            node.setContent(element.content);
        }

        return node;
    }

    /**
     * Parses data uri and converts it to a Buffer
     *
     * @param {Object} element Content element
     * @return {Object} Parsed element
     */
    _processDataUrl(element) {
        let parsedDataUri;
        if ((element.path || element.href).match(/^data:/)) {
            parsedDataUri = parseDataURI(element.path || element.href);
        }

        if (!parsedDataUri) {
            return element;
        }

        element.content = parsedDataUri.data;
        element.contentType = element.contentType || parsedDataUri.contentType;

        if ('path' in element) {
            element.path = false;
        }

        if ('href' in element) {
            element.href = false;
        }

        return element;
    }
}

module.exports = MailComposer;


/***/ }),

/***/ 787897:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(594735);
const shared = __webpack_require__(835028);
const mimeTypes = __webpack_require__(311847);
const MailComposer = __webpack_require__(896335);
const DKIM = __webpack_require__(835754);
const httpProxyClient = __webpack_require__(861103);
const util = __webpack_require__(328354);
const urllib = __webpack_require__(379551);
const packageData = __webpack_require__(227761);
const MailMessage = __webpack_require__(290416);
const net = __webpack_require__(491645);
const dns = __webpack_require__(714985);
const crypto = __webpack_require__(455511);

/**
 * Creates an object for exposing the Mail API
 *
 * @constructor
 * @param {Object} transporter Transport object instance to pass the mails to
 */
class Mail extends EventEmitter {
    constructor(transporter, options, defaults) {
        super();

        this.options = options || {};
        this._defaults = defaults || {};

        this._defaultPlugins = {
            compile: [(...args) => this._convertDataImages(...args)],
            stream: []
        };

        this._userPlugins = {
            compile: [],
            stream: []
        };

        this.meta = new Map();

        this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;

        this.transporter = transporter;
        this.transporter.mailer = this;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'mail'
        });

        this.logger.debug(
            {
                tnx: 'create'
            },
            'Creating transport: %s',
            this.getVersionString()
        );

        // setup emit handlers for the transporter
        if (typeof this.transporter.on === 'function') {
            // deprecated log interface
            this.transporter.on('log', log => {
                this.logger.debug(
                    {
                        tnx: 'transport'
                    },
                    '%s: %s',
                    log.type,
                    log.message
                );
            });

            // transporter errors
            this.transporter.on('error', err => {
                this.logger.error(
                    {
                        err,
                        tnx: 'transport'
                    },
                    'Transport Error: %s',
                    err.message
                );
                this.emit('error', err);
            });

            // indicates if the sender has became idle
            this.transporter.on('idle', (...args) => {
                this.emit('idle', ...args);
            });
        }

        /**
         * Optional methods passed to the underlying transport object
         */
        ['close', 'isIdle', 'verify'].forEach(method => {
            this[method] = (...args) => {
                if (typeof this.transporter[method] === 'function') {
                    if (method === 'verify' && typeof this.getSocket === 'function') {
                        this.transporter.getSocket = this.getSocket;
                        this.getSocket = false;
                    }
                    return this.transporter[method](...args);
                } else {
                    this.logger.warn(
                        {
                            tnx: 'transport',
                            methodName: method
                        },
                        'Non existing method %s called for transport',
                        method
                    );
                    return false;
                }
            };
        });

        // setup proxy handling
        if (this.options.proxy && typeof this.options.proxy === 'string') {
            this.setupProxy(this.options.proxy);
        }
    }

    use(step, plugin) {
        step = (step || '').toString();
        if (!this._userPlugins.hasOwnProperty(step)) {
            this._userPlugins[step] = [plugin];
        } else {
            this._userPlugins[step].push(plugin);
        }

        return this;
    }

    /**
     * Sends an email using the preselected transport object
     *
     * @param {Object} data E-data description
     * @param {Function?} callback Callback to run once the sending succeeded or failed
     */
    sendMail(data, callback = null) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) => {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        if (typeof this.getSocket === 'function') {
            this.transporter.getSocket = this.getSocket;
            this.getSocket = false;
        }

        let mail = new MailMessage(this, data);

        this.logger.debug(
            {
                tnx: 'transport',
                name: this.transporter.name,
                version: this.transporter.version,
                action: 'send'
            },
            'Sending mail using %s/%s',
            this.transporter.name,
            this.transporter.version
        );

        this._processPlugins('compile', mail, err => {
            if (err) {
                this.logger.error(
                    {
                        err,
                        tnx: 'plugin',
                        action: 'compile'
                    },
                    'PluginCompile Error: %s',
                    err.message
                );
                return callback(err);
            }

            mail.message = new MailComposer(mail.data).compile();

            mail.setMailerHeader();
            mail.setPriorityHeaders();
            mail.setListHeaders();

            this._processPlugins('stream', mail, err => {
                if (err) {
                    this.logger.error(
                        {
                            err,
                            tnx: 'plugin',
                            action: 'stream'
                        },
                        'PluginStream Error: %s',
                        err.message
                    );
                    return callback(err);
                }

                if (mail.data.dkim || this.dkim) {
                    mail.message.processFunc(input => {
                        let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
                        this.logger.debug(
                            {
                                tnx: 'DKIM',
                                messageId: mail.message.messageId(),
                                dkimDomains: dkim.keys.map(key => key.keySelector + '.' + key.domainName).join(', ')
                            },
                            'Signing outgoing message with %s keys',
                            dkim.keys.length
                        );
                        return dkim.sign(input, mail.data._dkim);
                    });
                }

                this.transporter.send(mail, (...args) => {
                    if (args[0]) {
                        this.logger.error(
                            {
                                err: args[0],
                                tnx: 'transport',
                                action: 'send'
                            },
                            'Send Error: %s',
                            args[0].message
                        );
                    }
                    callback(...args);
                });
            });
        });

        return promise;
    }

    getVersionString() {
        return util.format('%s (%s; +%s; %s/%s)', packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }

    _processPlugins(step, mail, callback) {
        step = (step || '').toString();

        if (!this._userPlugins.hasOwnProperty(step)) {
            return callback();
        }

        let userPlugins = this._userPlugins[step] || [];
        let defaultPlugins = this._defaultPlugins[step] || [];

        if (userPlugins.length) {
            this.logger.debug(
                {
                    tnx: 'transaction',
                    pluginCount: userPlugins.length,
                    step
                },
                'Using %s plugins for %s',
                userPlugins.length,
                step
            );
        }

        if (userPlugins.length + defaultPlugins.length === 0) {
            return callback();
        }

        let pos = 0;
        let block = 'default';
        let processPlugins = () => {
            let curplugins = block === 'default' ? defaultPlugins : userPlugins;
            if (pos >= curplugins.length) {
                if (block === 'default' && userPlugins.length) {
                    block = 'user';
                    pos = 0;
                    curplugins = userPlugins;
                } else {
                    return callback();
                }
            }
            let plugin = curplugins[pos++];
            plugin(mail, err => {
                if (err) {
                    return callback(err);
                }
                processPlugins();
            });
        };

        processPlugins();
    }

    /**
     * Sets up proxy handler for a Nodemailer object
     *
     * @param {String} proxyUrl Proxy configuration url
     */
    setupProxy(proxyUrl) {
        let proxy = urllib.parse(proxyUrl);

        // setup socket handler for the mailer object
        this.getSocket = (options, callback) => {
            let protocol = proxy.protocol.replace(/:$/, '').toLowerCase();

            if (this.meta.has('proxy_handler_' + protocol)) {
                return this.meta.get('proxy_handler_' + protocol)(proxy, options, callback);
            }

            switch (protocol) {
                // Connect using a HTTP CONNECT method
                case 'http':
                case 'https':
                    httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, {
                            connection: socket
                        });
                    });
                    return;
                case 'socks':
                case 'socks5':
                case 'socks4':
                case 'socks4a': {
                    if (!this.meta.has('proxy_socks_module')) {
                        return callback(new Error('Socks module not loaded'));
                    }
                    let connect = ipaddress => {
                        let proxyV2 = !!this.meta.get('proxy_socks_module').SocksClient;
                        let socksClient = proxyV2 ? this.meta.get('proxy_socks_module').SocksClient : this.meta.get('proxy_socks_module');
                        let proxyType = Number(proxy.protocol.replace(/\D/g, '')) || 5;
                        let connectionOpts = {
                            proxy: {
                                ipaddress,
                                port: Number(proxy.port),
                                type: proxyType
                            },
                            [proxyV2 ? 'destination' : 'target']: {
                                host: options.host,
                                port: options.port
                            },
                            command: 'connect'
                        };

                        if (proxy.auth) {
                            let username = decodeURIComponent(proxy.auth.split(':').shift());
                            let password = decodeURIComponent(proxy.auth.split(':').pop());
                            if (proxyV2) {
                                connectionOpts.proxy.userId = username;
                                connectionOpts.proxy.password = password;
                            } else if (proxyType === 4) {
                                connectionOpts.userid = username;
                            } else {
                                connectionOpts.authentication = {
                                    username,
                                    password
                                };
                            }
                        }

                        socksClient.createConnection(connectionOpts, (err, info) => {
                            if (err) {
                                return callback(err);
                            }
                            return callback(null, {
                                connection: info.socket || info
                            });
                        });
                    };

                    if (net.isIP(proxy.hostname)) {
                        return connect(proxy.hostname);
                    }

                    return dns.resolve(proxy.hostname, (err, address) => {
                        if (err) {
                            return callback(err);
                        }
                        connect(Array.isArray(address) ? address[0] : address);
                    });
                }
            }
            callback(new Error('Unknown proxy configuration'));
        };
    }

    _convertDataImages(mail, callback) {
        if ((!this.options.attachDataUrls && !mail.data.attachDataUrls) || !mail.data.html) {
            return callback();
        }
        mail.resolveContent(mail.data, 'html', (err, html) => {
            if (err) {
                return callback(err);
            }
            let cidCounter = 0;
            html = (html || '')
                .toString()
                .replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
                    let cid = crypto.randomBytes(10).toString('hex') + '@localhost';
                    if (!mail.data.attachments) {
                        mail.data.attachments = [];
                    }
                    if (!Array.isArray(mail.data.attachments)) {
                        mail.data.attachments = [].concat(mail.data.attachments || []);
                    }
                    mail.data.attachments.push({
                        path: dataUri,
                        cid,
                        filename: 'image-' + ++cidCounter + '.' + mimeTypes.detectExtension(mimeType)
                    });
                    return prefix + 'cid:' + cid;
                });
            mail.data.html = html;
            callback();
        });
    }

    set(key, value) {
        return this.meta.set(key, value);
    }

    get(key) {
        return this.meta.get(key);
    }
}

module.exports = Mail;


/***/ }),

/***/ 290416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const shared = __webpack_require__(835028);
const MimeNode = __webpack_require__(758820);
const mimeFuncs = __webpack_require__(595311);

class MailMessage {
    constructor(mailer, data) {
        this.mailer = mailer;
        this.data = {};
        this.message = null;

        data = data || {};
        let options = mailer.options || {};
        let defaults = mailer._defaults || {};

        Object.keys(data).forEach(key => {
            this.data[key] = data[key];
        });

        this.data.headers = this.data.headers || {};

        // apply defaults
        Object.keys(defaults).forEach(key => {
            if (!(key in this.data)) {
                this.data[key] = defaults[key];
            } else if (key === 'headers') {
                // headers is a special case. Allow setting individual default headers
                Object.keys(defaults.headers).forEach(key => {
                    if (!(key in this.data.headers)) {
                        this.data.headers[key] = defaults.headers[key];
                    }
                });
            }
        });

        // force specific keys from transporter options
        ['disableFileAccess', 'disableUrlAccess', 'normalizeHeaderKey'].forEach(key => {
            if (key in options) {
                this.data[key] = options[key];
            }
        });
    }

    resolveContent(...args) {
        return shared.resolveContent(...args);
    }

    resolveAll(callback) {
        let keys = [
            [this.data, 'html'],
            [this.data, 'text'],
            [this.data, 'watchHtml'],
            [this.data, 'amp'],
            [this.data, 'icalEvent']
        ];

        if (this.data.alternatives && this.data.alternatives.length) {
            this.data.alternatives.forEach((alternative, i) => {
                keys.push([this.data.alternatives, i]);
            });
        }

        if (this.data.attachments && this.data.attachments.length) {
            this.data.attachments.forEach((attachment, i) => {
                if (!attachment.filename) {
                    attachment.filename = (attachment.path || attachment.href || '').split('/').pop().split('?').shift() || 'attachment-' + (i + 1);
                    if (attachment.filename.indexOf('.') < 0) {
                        attachment.filename += '.' + mimeFuncs.detectExtension(attachment.contentType);
                    }
                }

                if (!attachment.contentType) {
                    attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin');
                }

                keys.push([this.data.attachments, i]);
            });
        }

        let mimeNode = new MimeNode();

        let addressKeys = ['from', 'to', 'cc', 'bcc', 'sender', 'replyTo'];

        addressKeys.forEach(address => {
            let value;
            if (this.message) {
                value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === 'replyTo' ? 'reply-to' : address)) || []);
            } else if (this.data[address]) {
                value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
            }
            if (value && value.length) {
                this.data[address] = value;
            } else if (address in this.data) {
                this.data[address] = null;
            }
        });

        let singleKeys = ['from', 'sender'];
        singleKeys.forEach(address => {
            if (this.data[address]) {
                this.data[address] = this.data[address].shift();
            }
        });

        let pos = 0;
        let resolveNext = () => {
            if (pos >= keys.length) {
                return callback(null, this.data);
            }
            let args = keys[pos++];
            if (!args[0] || !args[0][args[1]]) {
                return resolveNext();
            }
            shared.resolveContent(...args, (err, value) => {
                if (err) {
                    return callback(err);
                }

                let node = {
                    content: value
                };
                if (args[0][args[1]] && typeof args[0][args[1]] === 'object' && !Buffer.isBuffer(args[0][args[1]])) {
                    Object.keys(args[0][args[1]]).forEach(key => {
                        if (!(key in node) && !['content', 'path', 'href', 'raw'].includes(key)) {
                            node[key] = args[0][args[1]][key];
                        }
                    });
                }

                args[0][args[1]] = node;
                resolveNext();
            });
        };

        setImmediate(() => resolveNext());
    }

    normalize(callback) {
        let envelope = this.data.envelope || this.message.getEnvelope();
        let messageId = this.message.messageId();

        this.resolveAll((err, data) => {
            if (err) {
                return callback(err);
            }

            data.envelope = envelope;
            data.messageId = messageId;

            ['html', 'text', 'watchHtml', 'amp'].forEach(key => {
                if (data[key] && data[key].content) {
                    if (typeof data[key].content === 'string') {
                        data[key] = data[key].content;
                    } else if (Buffer.isBuffer(data[key].content)) {
                        data[key] = data[key].content.toString();
                    }
                }
            });

            if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
                data.icalEvent.content = data.icalEvent.content.toString('base64');
                data.icalEvent.encoding = 'base64';
            }

            if (data.alternatives && data.alternatives.length) {
                data.alternatives.forEach(alternative => {
                    if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
                        alternative.content = alternative.content.toString('base64');
                        alternative.encoding = 'base64';
                    }
                });
            }

            if (data.attachments && data.attachments.length) {
                data.attachments.forEach(attachment => {
                    if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
                        attachment.content = attachment.content.toString('base64');
                        attachment.encoding = 'base64';
                    }
                });
            }

            data.normalizedHeaders = {};
            Object.keys(data.headers || {}).forEach(key => {
                let value = [].concat(data.headers[key] || []).shift();
                value = (value && value.value) || value;
                if (value) {
                    if (['references', 'in-reply-to', 'message-id', 'content-id'].includes(key)) {
                        value = this.message._encodeHeaderValue(key, value);
                    }
                    data.normalizedHeaders[key] = value;
                }
            });

            if (data.list && typeof data.list === 'object') {
                let listHeaders = this._getListHeaders(data.list);
                listHeaders.forEach(entry => {
                    data.normalizedHeaders[entry.key] = entry.value.map(val => (val && val.value) || val).join(', ');
                });
            }

            if (data.references) {
                data.normalizedHeaders.references = this.message._encodeHeaderValue('references', data.references);
            }

            if (data.inReplyTo) {
                data.normalizedHeaders['in-reply-to'] = this.message._encodeHeaderValue('in-reply-to', data.inReplyTo);
            }

            return callback(null, data);
        });
    }

    setMailerHeader() {
        if (!this.message || !this.data.xMailer) {
            return;
        }
        this.message.setHeader('X-Mailer', this.data.xMailer);
    }

    setPriorityHeaders() {
        if (!this.message || !this.data.priority) {
            return;
        }
        switch ((this.data.priority || '').toString().toLowerCase()) {
            case 'high':
                this.message.setHeader('X-Priority', '1 (Highest)');
                this.message.setHeader('X-MSMail-Priority', 'High');
                this.message.setHeader('Importance', 'High');
                break;
            case 'low':
                this.message.setHeader('X-Priority', '5 (Lowest)');
                this.message.setHeader('X-MSMail-Priority', 'Low');
                this.message.setHeader('Importance', 'Low');
                break;
            default:
            // do not add anything, since all messages are 'Normal' by default
        }
    }

    setListHeaders() {
        if (!this.message || !this.data.list || typeof this.data.list !== 'object') {
            return;
        }
        // add optional List-* headers
        if (this.data.list && typeof this.data.list === 'object') {
            this._getListHeaders(this.data.list).forEach(listHeader => {
                listHeader.value.forEach(value => {
                    this.message.addHeader(listHeader.key, value);
                });
            });
        }
    }

    _getListHeaders(listData) {
        // make sure an url looks like <protocol:url>
        return Object.keys(listData).map(key => ({
            key: 'list-' + key.toLowerCase().trim(),
            value: [].concat(listData[key] || []).map(value => ({
                prepared: true,
                foldLines: true,
                value: []
                    .concat(value || [])
                    .map(value => {
                        if (typeof value === 'string') {
                            value = {
                                url: value
                            };
                        }

                        if (value && value.url) {
                            if (key.toLowerCase().trim() === 'id') {
                                // List-ID: "comment" <domain>
                                let comment = value.comment || '';
                                if (mimeFuncs.isPlainText(comment)) {
                                    comment = '"' + comment + '"';
                                } else {
                                    comment = mimeFuncs.encodeWord(comment);
                                }

                                return (value.comment ? comment + ' ' : '') + this._formatListUrl(value.url).replace(/^<[^:]+\/{,2}/, '');
                            }

                            // List-*: <http://domain> (comment)
                            let comment = value.comment || '';
                            if (!mimeFuncs.isPlainText(comment)) {
                                comment = mimeFuncs.encodeWord(comment);
                            }

                            return this._formatListUrl(value.url) + (value.comment ? ' (' + comment + ')' : '');
                        }

                        return '';
                    })
                    .filter(value => value)
                    .join(', ')
            }))
        }));
    }

    _formatListUrl(url) {
        url = url.replace(/[\s<]+|[\s>]+/g, '');
        if (/^(https?|mailto|ftp):/.test(url)) {
            return '<' + url + '>';
        }
        if (/^[^@]+@[^@]+$/.test(url)) {
            return '<mailto:' + url + '>';
        }

        return '<http://' + url + '>';
    }
}

module.exports = MailMessage;


/***/ }),

/***/ 595311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-control-regex:0 */



const base64 = __webpack_require__(866322);
const qp = __webpack_require__(620964);
const mimeTypes = __webpack_require__(311847);

module.exports = {
    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */
    isPlainText(value, isParam) {
        const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
        if (typeof value !== 'string' || re.test(value)) {
            return false;
        } else {
            return true;
        }
    },

    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all –
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */
    hasLongerLines(str, lineLength) {
        if (str.length > 128 * 1024) {
            // do not test strings longer than 128kB
            return true;
        }
        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */
    encodeWord(data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;

        let encodedStr;
        let toCharset = 'UTF-8';

        if (maxLength && maxLength > 7 + toCharset.length) {
            maxLength -= 7 + toCharset.length;
        }

        if (mimeWordEncoding === 'Q') {
            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
            encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, chr => {
                let ord = chr.charCodeAt(0).toString(16).toUpperCase();
                if (chr === ' ') {
                    return '_';
                } else {
                    return '=' + (ord.length === 1 ? '0' + ord : ord);
                }
            });
        } else if (mimeWordEncoding === 'B') {
            encodedStr = typeof data === 'string' ? data : base64.encode(data);
            maxLength = maxLength ? Math.max(3, ((maxLength - (maxLength % 4)) / 4) * 3) : 0;
        }

        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : base64.encode(data)).length > maxLength) {
            if (mimeWordEncoding === 'Q') {
                encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
            } else {
                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                let parts = [];
                let lpart = '';
                for (let i = 0, len = encodedStr.length; i < len; i++) {
                    let chr = encodedStr.charAt(i);

                    if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
                        // composite emoji byte, so add the next byte as well
                        chr += encodedStr.charAt(++i);
                    }

                    // check if we can add this character to the existing string
                    // without breaking byte length limit
                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                        lpart += chr;
                    } else {
                        // we hit the length limit, so push the existing string and start over
                        parts.push(base64.encode(lpart));
                        lpart = chr;
                    }
                }
                if (lpart) {
                    parts.push(base64.encode(lpart));
                }

                if (parts.length > 1) {
                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
                } else {
                    encodedStr = parts.join('');
                }
            }
        } else if (mimeWordEncoding === 'B') {
            encodedStr = base64.encode(data);
        }

        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');
    },

    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String} value String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {Boolean} [encodeAll=false] If true and the value needs encoding then encodes entire string, not just the smallest match
     * @return {String} String with possible mime words
     */
    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
        maxLength = maxLength || 0;

        let encodedValue;

        // find first word with a non-printable ascii or special symbol in it
        let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
        if (!firstMatch) {
            return value;
        }

        if (encodeAll) {
            // if it is requested to encode everything or the string contains something that resebles encoded word, then encode everything

            return this.encodeWord(value, mimeWordEncoding, maxLength);
        }

        // find the last word with a non-printable ascii in it
        let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
        if (!lastMatch) {
            // should not happen
            return value;
        }

        let startIndex =
            firstMatch.index +
            (
                firstMatch[0].match(/[^\s]/) || {
                    index: 0
                }
            ).index;
        let endIndex = lastMatch.index + (lastMatch[1] || '').length;

        encodedValue =
            (startIndex ? value.substr(0, startIndex) : '') +
            this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || 'Q', maxLength) +
            (endIndex < value.length ? value.substr(endIndex) : '');

        return encodedValue;
    },

    /**
     * Joins parsed header value together as 'value; param1=value1; param2=value2'
     * PS: We are following RFC 822 for the list of special characters that we need to keep in quotes.
     *      Refer: https://www.w3.org/Protocols/rfc1341/4_Content-Type.html
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */
    buildHeaderValue(structured) {
        let paramsArray = [];

        Object.keys(structured.params || {}).forEach(param => {
            // filename might include unicode characters so it is a special case
            // other values probably do not
            let value = structured.params[param];
            if (!this.isPlainText(value, true) || value.length >= 75) {
                this.buildHeaderParam(param, value, 50).forEach(encodedParam => {
                    if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {
                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);
                    } else {
                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));
                    }
                });
            } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
                paramsArray.push(param + '=' + JSON.stringify(value));
            } else {
                paramsArray.push(param + '=' + value);
            }
        });

        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title="unicode string"
     * becomes
     *     title*0*=utf-8''unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */
    buildHeaderParam(key, data, maxLength) {
        let list = [];
        let encodedStr = typeof data === 'string' ? data : (data || '').toString();
        let encodedStrArr;
        let chr, ord;
        let line;
        let startPos = 0;
        let i, len;

        maxLength = maxLength || 50;

        // process ascii only text
        if (this.isPlainText(data, true)) {
            // check if conversion is even needed
            if (encodedStr.length <= maxLength) {
                return [
                    {
                        key,
                        value: encodedStr
                    }
                ];
            }

            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), str => {
                list.push({
                    line: str
                });
                return '';
            });

            if (encodedStr) {
                list.push({
                    line: encodedStr
                });
            }
        } else {
            if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                // string containts surrogate pairs, so normalize it to an array of bytes
                encodedStrArr = [];
                for (i = 0, len = encodedStr.length; i < len; i++) {
                    chr = encodedStr.charAt(i);
                    ord = chr.charCodeAt(0);
                    if (ord >= 0xd800 && ord <= 0xdbff && i < len - 1) {
                        chr += encodedStr.charAt(i + 1);
                        encodedStrArr.push(chr);
                        i++;
                    } else {
                        encodedStrArr.push(chr);
                    }
                }
                encodedStr = encodedStrArr;
            }

            // first line includes the charset and language info and needs to be encoded
            // even if it does not contain any unicode characters
            line = 'utf-8\x27\x27';
            let encoded = true;
            startPos = 0;

            // process text with unicode or special chars
            for (i = 0, len = encodedStr.length; i < len; i++) {
                chr = encodedStr[i];

                if (encoded) {
                    chr = this.safeEncodeURIComponent(chr);
                } else {
                    // try to urlencode current char
                    chr = chr === ' ' ? chr : this.safeEncodeURIComponent(chr);
                    // By default it is not required to encode a line, the need
                    // only appears when the string contains unicode or special chars
                    // in this case we start processing the line over and encode all chars
                    if (chr !== encodedStr[i]) {
                        // Check if it is even possible to add the encoded char to the line
                        // If not, there is no reason to use this line, just push it to the list
                        // and start a new line with the char that needs encoding
                        if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                            list.push({
                                line,
                                encoded
                            });
                            line = '';
                            startPos = i - 1;
                        } else {
                            encoded = true;
                            i = startPos;
                            line = '';
                            continue;
                        }
                    }
                }

                // if the line is already too long, push it to the list and start a new one
                if ((line + chr).length >= maxLength) {
                    list.push({
                        line,
                        encoded
                    });
                    line = chr = encodedStr[i] === ' ' ? ' ' : this.safeEncodeURIComponent(encodedStr[i]);
                    if (chr === encodedStr[i]) {
                        encoded = false;
                        startPos = i - 1;
                    } else {
                        encoded = true;
                    }
                } else {
                    line += chr;
                }
            }

            if (line) {
                list.push({
                    line,
                    encoded
                });
            }
        }

        return list.map((item, i) => ({
            // encoded lines: {name}*{part}*
            // unencoded lines: {name}*{part}
            // if any line needs to be encoded then the first line (part==0) is always encoded
            key: key + '*' + i + (item.encoded ? '*' : ''),
            value: item.line
        }));
    },

    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
     *   {
     *     'value': 'text/plain',
     *     'params': {
     *       'charset': 'UTF-8'
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */
    parseHeaderValue(str) {
        let response = {
            value: false,
            params: {}
        };
        let key = false;
        let value = '';
        let type = 'value';
        let quote = false;
        let escaped = false;
        let chr;

        for (let i = 0, len = str.length; i < len; i++) {
            chr = str.charAt(i);
            if (type === 'key') {
                if (chr === '=') {
                    key = value.trim().toLowerCase();
                    type = 'value';
                    value = '';
                    continue;
                }
                value += chr;
            } else {
                if (escaped) {
                    value += chr;
                } else if (chr === '\\') {
                    escaped = true;
                    continue;
                } else if (quote && chr === quote) {
                    quote = false;
                } else if (!quote && chr === '"') {
                    quote = chr;
                } else if (!quote && chr === ';') {
                    if (key === false) {
                        response.value = value.trim();
                    } else {
                        response.params[key] = value.trim();
                    }
                    type = 'key';
                    value = '';
                } else {
                    value += chr;
                }
                escaped = false;
            }
        }

        if (type === 'value') {
            if (key === false) {
                response.value = value.trim();
            } else {
                response.params[key] = value.trim();
            }
        } else if (value.trim()) {
            response.params[value.trim().toLowerCase()] = '';
        }

        // handle parameter value continuations
        // https://tools.ietf.org/html/rfc2231#section-3

        // preprocess values
        Object.keys(response.params).forEach(key => {
            let actualKey, nr, match, value;
            if ((match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/))) {
                actualKey = key.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;

                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {
                    response.params[actualKey] = {
                        charset: false,
                        values: []
                    };
                }

                value = response.params[key];

                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
                    response.params[actualKey].charset = match[1] || 'iso-8859-1';
                    value = match[2];
                }

                response.params[actualKey].values[nr] = value;

                // remove the old reference
                delete response.params[key];
            }
        });

        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
        Object.keys(response.params).forEach(key => {
            let value;
            if (response.params[key] && Array.isArray(response.params[key].values)) {
                value = response.params[key].values.map(val => val || '').join('');

                if (response.params[key].charset) {
                    // convert "%AB" to "=?charset?Q?=AB?="
                    response.params[key] =
                        '=?' +
                        response.params[key].charset +
                        '?Q?' +
                        value
                            // fix invalidly encoded chars
                            .replace(/[=?_\s]/g, s => {
                                let c = s.charCodeAt(0).toString(16);
                                if (s === ' ') {
                                    return '_';
                                } else {
                                    return '%' + (c.length < 2 ? '0' : '') + c;
                                }
                            })
                            // change from urlencoding to percent encoding
                            .replace(/%/g, '=') +
                        '?=';
                } else {
                    response.params[key] = value;
                }
            }
        });

        return response;
    },

    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, 'bin' is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */
    detectExtension: mimeType => mimeTypes.detectExtension(mimeType),

    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, 'application/octet-stream' is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */
    detectMimeType: extension => mimeTypes.detectMimeType(extension),

    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */
    foldLines(str, lineLength, afterSpace) {
        str = (str || '').toString();
        lineLength = lineLength || 76;

        let pos = 0,
            len = str.length,
            result = '',
            line,
            match;

        while (pos < len) {
            line = str.substr(pos, lineLength);
            if (line.length < lineLength) {
                result += line;
                break;
            }
            if ((match = line.match(/^[^\n\r]*(\r?\n|\r)/))) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
            } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));
            } else if ((match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/))) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));
            }

            result += line;
            pos += line.length;
            if (pos < len) {
                result += '\r\n';
            }
        }

        return result;
    },

    /**
     * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
     *
     * @param {String} str Mime encoded string to be split up
     * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
     * @return {Array} Split string
     */
    splitMimeEncodedString: (str, maxlen) => {
        let curLine,
            match,
            chr,
            done,
            lines = [];

        // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
        maxlen = Math.max(maxlen || 0, 12);

        while (str.length) {
            curLine = str.substr(0, maxlen);

            // move incomplete escaped char back to main
            if ((match = curLine.match(/[=][0-9A-F]?$/i))) {
                curLine = curLine.substr(0, match.index);
            }

            done = false;
            while (!done) {
                done = true;
                // check if not middle of a unicode char sequence
                if ((match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i))) {
                    chr = parseInt(match[1], 16);
                    // invalid sequence, move one char back anc recheck
                    if (chr < 0xc2 && chr > 0x7f) {
                        curLine = curLine.substr(0, curLine.length - 3);
                        done = false;
                    }
                }
            }

            if (curLine.length) {
                lines.push(curLine);
            }
            str = str.substr(curLine.length);
        }

        return lines;
    },

    encodeURICharComponent: chr => {
        let res = '';
        let ord = chr.charCodeAt(0).toString(16).toUpperCase();

        if (ord.length % 2) {
            ord = '0' + ord;
        }

        if (ord.length > 2) {
            for (let i = 0, len = ord.length / 2; i < len; i++) {
                res += '%' + ord.substr(i, 2);
            }
        } else {
            res += '%' + ord;
        }

        return res;
    },

    safeEncodeURIComponent(str) {
        str = (str || '').toString();

        try {
            // might throw if we try to encode invalid sequences, eg. partial emoji
            str = encodeURIComponent(str);
        } catch (E) {
            // should never run
            return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, '');
        }

        // ensure chars that are not handled by encodeURICompent are converted as well
        return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, chr => this.encodeURICharComponent(chr));
    }
};


/***/ }),

/***/ 311847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint quote-props: 0 */



const path = __webpack_require__(333873);

const defaultMimeType = 'application/octet-stream';
const defaultExtension = 'bin';

const mimeTypes = new Map([
    ['application/acad', 'dwg'],
    ['application/applixware', 'aw'],
    ['application/arj', 'arj'],
    ['application/atom+xml', 'xml'],
    ['application/atomcat+xml', 'atomcat'],
    ['application/atomsvc+xml', 'atomsvc'],
    ['application/base64', ['mm', 'mme']],
    ['application/binhex', 'hqx'],
    ['application/binhex4', 'hqx'],
    ['application/book', ['book', 'boo']],
    ['application/ccxml+xml,', 'ccxml'],
    ['application/cdf', 'cdf'],
    ['application/cdmi-capability', 'cdmia'],
    ['application/cdmi-container', 'cdmic'],
    ['application/cdmi-domain', 'cdmid'],
    ['application/cdmi-object', 'cdmio'],
    ['application/cdmi-queue', 'cdmiq'],
    ['application/clariscad', 'ccad'],
    ['application/commonground', 'dp'],
    ['application/cu-seeme', 'cu'],
    ['application/davmount+xml', 'davmount'],
    ['application/drafting', 'drw'],
    ['application/dsptype', 'tsp'],
    ['application/dssc+der', 'dssc'],
    ['application/dssc+xml', 'xdssc'],
    ['application/dxf', 'dxf'],
    ['application/ecmascript', ['js', 'es']],
    ['application/emma+xml', 'emma'],
    ['application/envoy', 'evy'],
    ['application/epub+zip', 'epub'],
    ['application/excel', ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],
    ['application/exi', 'exi'],
    ['application/font-tdpfr', 'pfr'],
    ['application/fractals', 'fif'],
    ['application/freeloader', 'frl'],
    ['application/futuresplash', 'spl'],
    ['application/geo+json', 'geojson'],
    ['application/gnutar', 'tgz'],
    ['application/groupwise', 'vew'],
    ['application/hlp', 'hlp'],
    ['application/hta', 'hta'],
    ['application/hyperstudio', 'stk'],
    ['application/i-deas', 'unv'],
    ['application/iges', ['iges', 'igs']],
    ['application/inf', 'inf'],
    ['application/internet-property-stream', 'acx'],
    ['application/ipfix', 'ipfix'],
    ['application/java', 'class'],
    ['application/java-archive', 'jar'],
    ['application/java-byte-code', 'class'],
    ['application/java-serialized-object', 'ser'],
    ['application/java-vm', 'class'],
    ['application/javascript', 'js'],
    ['application/json', 'json'],
    ['application/lha', 'lha'],
    ['application/lzx', 'lzx'],
    ['application/mac-binary', 'bin'],
    ['application/mac-binhex', 'hqx'],
    ['application/mac-binhex40', 'hqx'],
    ['application/mac-compactpro', 'cpt'],
    ['application/macbinary', 'bin'],
    ['application/mads+xml', 'mads'],
    ['application/marc', 'mrc'],
    ['application/marcxml+xml', 'mrcx'],
    ['application/mathematica', 'ma'],
    ['application/mathml+xml', 'mathml'],
    ['application/mbedlet', 'mbd'],
    ['application/mbox', 'mbox'],
    ['application/mcad', 'mcd'],
    ['application/mediaservercontrol+xml', 'mscml'],
    ['application/metalink4+xml', 'meta4'],
    ['application/mets+xml', 'mets'],
    ['application/mime', 'aps'],
    ['application/mods+xml', 'mods'],
    ['application/mp21', 'm21'],
    ['application/mp4', 'mp4'],
    ['application/mspowerpoint', ['ppt', 'pot', 'pps', 'ppz']],
    ['application/msword', ['doc', 'dot', 'w6w', 'wiz', 'word']],
    ['application/mswrite', 'wri'],
    ['application/mxf', 'mxf'],
    ['application/netmc', 'mcp'],
    ['application/octet-stream', ['*']],
    ['application/oda', 'oda'],
    ['application/oebps-package+xml', 'opf'],
    ['application/ogg', 'ogx'],
    ['application/olescript', 'axs'],
    ['application/onenote', 'onetoc'],
    ['application/patch-ops-error+xml', 'xer'],
    ['application/pdf', 'pdf'],
    ['application/pgp-encrypted', 'asc'],
    ['application/pgp-signature', 'pgp'],
    ['application/pics-rules', 'prf'],
    ['application/pkcs-12', 'p12'],
    ['application/pkcs-crl', 'crl'],
    ['application/pkcs10', 'p10'],
    ['application/pkcs7-mime', ['p7c', 'p7m']],
    ['application/pkcs7-signature', 'p7s'],
    ['application/pkcs8', 'p8'],
    ['application/pkix-attr-cert', 'ac'],
    ['application/pkix-cert', ['cer', 'crt']],
    ['application/pkix-crl', 'crl'],
    ['application/pkix-pkipath', 'pkipath'],
    ['application/pkixcmp', 'pki'],
    ['application/plain', 'text'],
    ['application/pls+xml', 'pls'],
    ['application/postscript', ['ps', 'ai', 'eps']],
    ['application/powerpoint', 'ppt'],
    ['application/pro_eng', ['part', 'prt']],
    ['application/prs.cww', 'cww'],
    ['application/pskc+xml', 'pskcxml'],
    ['application/rdf+xml', 'rdf'],
    ['application/reginfo+xml', 'rif'],
    ['application/relax-ng-compact-syntax', 'rnc'],
    ['application/resource-lists+xml', 'rl'],
    ['application/resource-lists-diff+xml', 'rld'],
    ['application/ringing-tones', 'rng'],
    ['application/rls-services+xml', 'rs'],
    ['application/rsd+xml', 'rsd'],
    ['application/rss+xml', 'xml'],
    ['application/rtf', ['rtf', 'rtx']],
    ['application/sbml+xml', 'sbml'],
    ['application/scvp-cv-request', 'scq'],
    ['application/scvp-cv-response', 'scs'],
    ['application/scvp-vp-request', 'spq'],
    ['application/scvp-vp-response', 'spp'],
    ['application/sdp', 'sdp'],
    ['application/sea', 'sea'],
    ['application/set', 'set'],
    ['application/set-payment-initiation', 'setpay'],
    ['application/set-registration-initiation', 'setreg'],
    ['application/shf+xml', 'shf'],
    ['application/sla', 'stl'],
    ['application/smil', ['smi', 'smil']],
    ['application/smil+xml', 'smi'],
    ['application/solids', 'sol'],
    ['application/sounder', 'sdr'],
    ['application/sparql-query', 'rq'],
    ['application/sparql-results+xml', 'srx'],
    ['application/srgs', 'gram'],
    ['application/srgs+xml', 'grxml'],
    ['application/sru+xml', 'sru'],
    ['application/ssml+xml', 'ssml'],
    ['application/step', ['step', 'stp']],
    ['application/streamingmedia', 'ssm'],
    ['application/tei+xml', 'tei'],
    ['application/thraud+xml', 'tfi'],
    ['application/timestamped-data', 'tsd'],
    ['application/toolbook', 'tbk'],
    ['application/vda', 'vda'],
    ['application/vnd.3gpp.pic-bw-large', 'plb'],
    ['application/vnd.3gpp.pic-bw-small', 'psb'],
    ['application/vnd.3gpp.pic-bw-var', 'pvb'],
    ['application/vnd.3gpp2.tcap', 'tcap'],
    ['application/vnd.3m.post-it-notes', 'pwn'],
    ['application/vnd.accpac.simply.aso', 'aso'],
    ['application/vnd.accpac.simply.imp', 'imp'],
    ['application/vnd.acucobol', 'acu'],
    ['application/vnd.acucorp', 'atc'],
    ['application/vnd.adobe.air-application-installer-package+zip', 'air'],
    ['application/vnd.adobe.fxp', 'fxp'],
    ['application/vnd.adobe.xdp+xml', 'xdp'],
    ['application/vnd.adobe.xfdf', 'xfdf'],
    ['application/vnd.ahead.space', 'ahead'],
    ['application/vnd.airzip.filesecure.azf', 'azf'],
    ['application/vnd.airzip.filesecure.azs', 'azs'],
    ['application/vnd.amazon.ebook', 'azw'],
    ['application/vnd.americandynamics.acc', 'acc'],
    ['application/vnd.amiga.ami', 'ami'],
    ['application/vnd.android.package-archive', 'apk'],
    ['application/vnd.anser-web-certificate-issue-initiation', 'cii'],
    ['application/vnd.anser-web-funds-transfer-initiation', 'fti'],
    ['application/vnd.antix.game-component', 'atx'],
    ['application/vnd.apple.installer+xml', 'mpkg'],
    ['application/vnd.apple.mpegurl', 'm3u8'],
    ['application/vnd.aristanetworks.swi', 'swi'],
    ['application/vnd.audiograph', 'aep'],
    ['application/vnd.blueice.multipass', 'mpm'],
    ['application/vnd.bmi', 'bmi'],
    ['application/vnd.businessobjects', 'rep'],
    ['application/vnd.chemdraw+xml', 'cdxml'],
    ['application/vnd.chipnuts.karaoke-mmd', 'mmd'],
    ['application/vnd.cinderella', 'cdy'],
    ['application/vnd.claymore', 'cla'],
    ['application/vnd.cloanto.rp9', 'rp9'],
    ['application/vnd.clonk.c4group', 'c4g'],
    ['application/vnd.cluetrust.cartomobile-config', 'c11amc'],
    ['application/vnd.cluetrust.cartomobile-config-pkg', 'c11amz'],
    ['application/vnd.commonspace', 'csp'],
    ['application/vnd.contact.cmsg', 'cdbcmsg'],
    ['application/vnd.cosmocaller', 'cmc'],
    ['application/vnd.crick.clicker', 'clkx'],
    ['application/vnd.crick.clicker.keyboard', 'clkk'],
    ['application/vnd.crick.clicker.palette', 'clkp'],
    ['application/vnd.crick.clicker.template', 'clkt'],
    ['application/vnd.crick.clicker.wordbank', 'clkw'],
    ['application/vnd.criticaltools.wbs+xml', 'wbs'],
    ['application/vnd.ctc-posml', 'pml'],
    ['application/vnd.cups-ppd', 'ppd'],
    ['application/vnd.curl.car', 'car'],
    ['application/vnd.curl.pcurl', 'pcurl'],
    ['application/vnd.data-vision.rdz', 'rdz'],
    ['application/vnd.denovo.fcselayout-link', 'fe_launch'],
    ['application/vnd.dna', 'dna'],
    ['application/vnd.dolby.mlp', 'mlp'],
    ['application/vnd.dpgraph', 'dpg'],
    ['application/vnd.dreamfactory', 'dfac'],
    ['application/vnd.dvb.ait', 'ait'],
    ['application/vnd.dvb.service', 'svc'],
    ['application/vnd.dynageo', 'geo'],
    ['application/vnd.ecowin.chart', 'mag'],
    ['application/vnd.enliven', 'nml'],
    ['application/vnd.epson.esf', 'esf'],
    ['application/vnd.epson.msf', 'msf'],
    ['application/vnd.epson.quickanime', 'qam'],
    ['application/vnd.epson.salt', 'slt'],
    ['application/vnd.epson.ssf', 'ssf'],
    ['application/vnd.eszigno3+xml', 'es3'],
    ['application/vnd.ezpix-album', 'ez2'],
    ['application/vnd.ezpix-package', 'ez3'],
    ['application/vnd.fdf', 'fdf'],
    ['application/vnd.fdsn.seed', 'seed'],
    ['application/vnd.flographit', 'gph'],
    ['application/vnd.fluxtime.clip', 'ftc'],
    ['application/vnd.framemaker', 'fm'],
    ['application/vnd.frogans.fnc', 'fnc'],
    ['application/vnd.frogans.ltf', 'ltf'],
    ['application/vnd.fsc.weblaunch', 'fsc'],
    ['application/vnd.fujitsu.oasys', 'oas'],
    ['application/vnd.fujitsu.oasys2', 'oa2'],
    ['application/vnd.fujitsu.oasys3', 'oa3'],
    ['application/vnd.fujitsu.oasysgp', 'fg5'],
    ['application/vnd.fujitsu.oasysprs', 'bh2'],
    ['application/vnd.fujixerox.ddd', 'ddd'],
    ['application/vnd.fujixerox.docuworks', 'xdw'],
    ['application/vnd.fujixerox.docuworks.binder', 'xbd'],
    ['application/vnd.fuzzysheet', 'fzs'],
    ['application/vnd.genomatix.tuxedo', 'txd'],
    ['application/vnd.geogebra.file', 'ggb'],
    ['application/vnd.geogebra.tool', 'ggt'],
    ['application/vnd.geometry-explorer', 'gex'],
    ['application/vnd.geonext', 'gxt'],
    ['application/vnd.geoplan', 'g2w'],
    ['application/vnd.geospace', 'g3w'],
    ['application/vnd.gmx', 'gmx'],
    ['application/vnd.google-earth.kml+xml', 'kml'],
    ['application/vnd.google-earth.kmz', 'kmz'],
    ['application/vnd.grafeq', 'gqf'],
    ['application/vnd.groove-account', 'gac'],
    ['application/vnd.groove-help', 'ghf'],
    ['application/vnd.groove-identity-message', 'gim'],
    ['application/vnd.groove-injector', 'grv'],
    ['application/vnd.groove-tool-message', 'gtm'],
    ['application/vnd.groove-tool-template', 'tpl'],
    ['application/vnd.groove-vcard', 'vcg'],
    ['application/vnd.hal+xml', 'hal'],
    ['application/vnd.handheld-entertainment+xml', 'zmm'],
    ['application/vnd.hbci', 'hbci'],
    ['application/vnd.hhe.lesson-player', 'les'],
    ['application/vnd.hp-hpgl', ['hgl', 'hpg', 'hpgl']],
    ['application/vnd.hp-hpid', 'hpid'],
    ['application/vnd.hp-hps', 'hps'],
    ['application/vnd.hp-jlyt', 'jlt'],
    ['application/vnd.hp-pcl', 'pcl'],
    ['application/vnd.hp-pclxl', 'pclxl'],
    ['application/vnd.hydrostatix.sof-data', 'sfd-hdstx'],
    ['application/vnd.hzn-3d-crossword', 'x3d'],
    ['application/vnd.ibm.minipay', 'mpy'],
    ['application/vnd.ibm.modcap', 'afp'],
    ['application/vnd.ibm.rights-management', 'irm'],
    ['application/vnd.ibm.secure-container', 'sc'],
    ['application/vnd.iccprofile', 'icc'],
    ['application/vnd.igloader', 'igl'],
    ['application/vnd.immervision-ivp', 'ivp'],
    ['application/vnd.immervision-ivu', 'ivu'],
    ['application/vnd.insors.igm', 'igm'],
    ['application/vnd.intercon.formnet', 'xpw'],
    ['application/vnd.intergeo', 'i2g'],
    ['application/vnd.intu.qbo', 'qbo'],
    ['application/vnd.intu.qfx', 'qfx'],
    ['application/vnd.ipunplugged.rcprofile', 'rcprofile'],
    ['application/vnd.irepository.package+xml', 'irp'],
    ['application/vnd.is-xpr', 'xpr'],
    ['application/vnd.isac.fcs', 'fcs'],
    ['application/vnd.jam', 'jam'],
    ['application/vnd.jcp.javame.midlet-rms', 'rms'],
    ['application/vnd.jisp', 'jisp'],
    ['application/vnd.joost.joda-archive', 'joda'],
    ['application/vnd.kahootz', 'ktz'],
    ['application/vnd.kde.karbon', 'karbon'],
    ['application/vnd.kde.kchart', 'chrt'],
    ['application/vnd.kde.kformula', 'kfo'],
    ['application/vnd.kde.kivio', 'flw'],
    ['application/vnd.kde.kontour', 'kon'],
    ['application/vnd.kde.kpresenter', 'kpr'],
    ['application/vnd.kde.kspread', 'ksp'],
    ['application/vnd.kde.kword', 'kwd'],
    ['application/vnd.kenameaapp', 'htke'],
    ['application/vnd.kidspiration', 'kia'],
    ['application/vnd.kinar', 'kne'],
    ['application/vnd.koan', 'skp'],
    ['application/vnd.kodak-descriptor', 'sse'],
    ['application/vnd.las.las+xml', 'lasxml'],
    ['application/vnd.llamagraphics.life-balance.desktop', 'lbd'],
    ['application/vnd.llamagraphics.life-balance.exchange+xml', 'lbe'],
    ['application/vnd.lotus-1-2-3', '123'],
    ['application/vnd.lotus-approach', 'apr'],
    ['application/vnd.lotus-freelance', 'pre'],
    ['application/vnd.lotus-notes', 'nsf'],
    ['application/vnd.lotus-organizer', 'org'],
    ['application/vnd.lotus-screencam', 'scm'],
    ['application/vnd.lotus-wordpro', 'lwp'],
    ['application/vnd.macports.portpkg', 'portpkg'],
    ['application/vnd.mcd', 'mcd'],
    ['application/vnd.medcalcdata', 'mc1'],
    ['application/vnd.mediastation.cdkey', 'cdkey'],
    ['application/vnd.mfer', 'mwf'],
    ['application/vnd.mfmp', 'mfm'],
    ['application/vnd.micrografx.flo', 'flo'],
    ['application/vnd.micrografx.igx', 'igx'],
    ['application/vnd.mif', 'mif'],
    ['application/vnd.mobius.daf', 'daf'],
    ['application/vnd.mobius.dis', 'dis'],
    ['application/vnd.mobius.mbk', 'mbk'],
    ['application/vnd.mobius.mqy', 'mqy'],
    ['application/vnd.mobius.msl', 'msl'],
    ['application/vnd.mobius.plc', 'plc'],
    ['application/vnd.mobius.txf', 'txf'],
    ['application/vnd.mophun.application', 'mpn'],
    ['application/vnd.mophun.certificate', 'mpc'],
    ['application/vnd.mozilla.xul+xml', 'xul'],
    ['application/vnd.ms-artgalry', 'cil'],
    ['application/vnd.ms-cab-compressed', 'cab'],
    ['application/vnd.ms-excel', ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll']],
    ['application/vnd.ms-excel.addin.macroenabled.12', 'xlam'],
    ['application/vnd.ms-excel.sheet.binary.macroenabled.12', 'xlsb'],
    ['application/vnd.ms-excel.sheet.macroenabled.12', 'xlsm'],
    ['application/vnd.ms-excel.template.macroenabled.12', 'xltm'],
    ['application/vnd.ms-fontobject', 'eot'],
    ['application/vnd.ms-htmlhelp', 'chm'],
    ['application/vnd.ms-ims', 'ims'],
    ['application/vnd.ms-lrm', 'lrm'],
    ['application/vnd.ms-officetheme', 'thmx'],
    ['application/vnd.ms-outlook', 'msg'],
    ['application/vnd.ms-pki.certstore', 'sst'],
    ['application/vnd.ms-pki.pko', 'pko'],
    ['application/vnd.ms-pki.seccat', 'cat'],
    ['application/vnd.ms-pki.stl', 'stl'],
    ['application/vnd.ms-pkicertstore', 'sst'],
    ['application/vnd.ms-pkiseccat', 'cat'],
    ['application/vnd.ms-pkistl', 'stl'],
    ['application/vnd.ms-powerpoint', ['ppt', 'pot', 'pps', 'ppa', 'pwz']],
    ['application/vnd.ms-powerpoint.addin.macroenabled.12', 'ppam'],
    ['application/vnd.ms-powerpoint.presentation.macroenabled.12', 'pptm'],
    ['application/vnd.ms-powerpoint.slide.macroenabled.12', 'sldm'],
    ['application/vnd.ms-powerpoint.slideshow.macroenabled.12', 'ppsm'],
    ['application/vnd.ms-powerpoint.template.macroenabled.12', 'potm'],
    ['application/vnd.ms-project', 'mpp'],
    ['application/vnd.ms-word.document.macroenabled.12', 'docm'],
    ['application/vnd.ms-word.template.macroenabled.12', 'dotm'],
    ['application/vnd.ms-works', ['wks', 'wcm', 'wdb', 'wps']],
    ['application/vnd.ms-wpl', 'wpl'],
    ['application/vnd.ms-xpsdocument', 'xps'],
    ['application/vnd.mseq', 'mseq'],
    ['application/vnd.musician', 'mus'],
    ['application/vnd.muvee.style', 'msty'],
    ['application/vnd.neurolanguage.nlu', 'nlu'],
    ['application/vnd.noblenet-directory', 'nnd'],
    ['application/vnd.noblenet-sealer', 'nns'],
    ['application/vnd.noblenet-web', 'nnw'],
    ['application/vnd.nokia.configuration-message', 'ncm'],
    ['application/vnd.nokia.n-gage.data', 'ngdat'],
    ['application/vnd.nokia.n-gage.symbian.install', 'n-gage'],
    ['application/vnd.nokia.radio-preset', 'rpst'],
    ['application/vnd.nokia.radio-presets', 'rpss'],
    ['application/vnd.nokia.ringing-tone', 'rng'],
    ['application/vnd.novadigm.edm', 'edm'],
    ['application/vnd.novadigm.edx', 'edx'],
    ['application/vnd.novadigm.ext', 'ext'],
    ['application/vnd.oasis.opendocument.chart', 'odc'],
    ['application/vnd.oasis.opendocument.chart-template', 'otc'],
    ['application/vnd.oasis.opendocument.database', 'odb'],
    ['application/vnd.oasis.opendocument.formula', 'odf'],
    ['application/vnd.oasis.opendocument.formula-template', 'odft'],
    ['application/vnd.oasis.opendocument.graphics', 'odg'],
    ['application/vnd.oasis.opendocument.graphics-template', 'otg'],
    ['application/vnd.oasis.opendocument.image', 'odi'],
    ['application/vnd.oasis.opendocument.image-template', 'oti'],
    ['application/vnd.oasis.opendocument.presentation', 'odp'],
    ['application/vnd.oasis.opendocument.presentation-template', 'otp'],
    ['application/vnd.oasis.opendocument.spreadsheet', 'ods'],
    ['application/vnd.oasis.opendocument.spreadsheet-template', 'ots'],
    ['application/vnd.oasis.opendocument.text', 'odt'],
    ['application/vnd.oasis.opendocument.text-master', 'odm'],
    ['application/vnd.oasis.opendocument.text-template', 'ott'],
    ['application/vnd.oasis.opendocument.text-web', 'oth'],
    ['application/vnd.olpc-sugar', 'xo'],
    ['application/vnd.oma.dd2+xml', 'dd2'],
    ['application/vnd.openofficeorg.extension', 'oxt'],
    ['application/vnd.openxmlformats-officedocument.presentationml.presentation', 'pptx'],
    ['application/vnd.openxmlformats-officedocument.presentationml.slide', 'sldx'],
    ['application/vnd.openxmlformats-officedocument.presentationml.slideshow', 'ppsx'],
    ['application/vnd.openxmlformats-officedocument.presentationml.template', 'potx'],
    ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'xlsx'],
    ['application/vnd.openxmlformats-officedocument.spreadsheetml.template', 'xltx'],
    ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'docx'],
    ['application/vnd.openxmlformats-officedocument.wordprocessingml.template', 'dotx'],
    ['application/vnd.osgeo.mapguide.package', 'mgp'],
    ['application/vnd.osgi.dp', 'dp'],
    ['application/vnd.palm', 'pdb'],
    ['application/vnd.pawaafile', 'paw'],
    ['application/vnd.pg.format', 'str'],
    ['application/vnd.pg.osasli', 'ei6'],
    ['application/vnd.picsel', 'efif'],
    ['application/vnd.pmi.widget', 'wg'],
    ['application/vnd.pocketlearn', 'plf'],
    ['application/vnd.powerbuilder6', 'pbd'],
    ['application/vnd.previewsystems.box', 'box'],
    ['application/vnd.proteus.magazine', 'mgz'],
    ['application/vnd.publishare-delta-tree', 'qps'],
    ['application/vnd.pvi.ptid1', 'ptid'],
    ['application/vnd.quark.quarkxpress', 'qxd'],
    ['application/vnd.realvnc.bed', 'bed'],
    ['application/vnd.recordare.musicxml', 'mxl'],
    ['application/vnd.recordare.musicxml+xml', 'musicxml'],
    ['application/vnd.rig.cryptonote', 'cryptonote'],
    ['application/vnd.rim.cod', 'cod'],
    ['application/vnd.rn-realmedia', 'rm'],
    ['application/vnd.rn-realplayer', 'rnx'],
    ['application/vnd.route66.link66+xml', 'link66'],
    ['application/vnd.sailingtracker.track', 'st'],
    ['application/vnd.seemail', 'see'],
    ['application/vnd.sema', 'sema'],
    ['application/vnd.semd', 'semd'],
    ['application/vnd.semf', 'semf'],
    ['application/vnd.shana.informed.formdata', 'ifm'],
    ['application/vnd.shana.informed.formtemplate', 'itp'],
    ['application/vnd.shana.informed.interchange', 'iif'],
    ['application/vnd.shana.informed.package', 'ipk'],
    ['application/vnd.simtech-mindmapper', 'twd'],
    ['application/vnd.smaf', 'mmf'],
    ['application/vnd.smart.teacher', 'teacher'],
    ['application/vnd.solent.sdkm+xml', 'sdkm'],
    ['application/vnd.spotfire.dxp', 'dxp'],
    ['application/vnd.spotfire.sfs', 'sfs'],
    ['application/vnd.stardivision.calc', 'sdc'],
    ['application/vnd.stardivision.draw', 'sda'],
    ['application/vnd.stardivision.impress', 'sdd'],
    ['application/vnd.stardivision.math', 'smf'],
    ['application/vnd.stardivision.writer', 'sdw'],
    ['application/vnd.stardivision.writer-global', 'sgl'],
    ['application/vnd.stepmania.stepchart', 'sm'],
    ['application/vnd.sun.xml.calc', 'sxc'],
    ['application/vnd.sun.xml.calc.template', 'stc'],
    ['application/vnd.sun.xml.draw', 'sxd'],
    ['application/vnd.sun.xml.draw.template', 'std'],
    ['application/vnd.sun.xml.impress', 'sxi'],
    ['application/vnd.sun.xml.impress.template', 'sti'],
    ['application/vnd.sun.xml.math', 'sxm'],
    ['application/vnd.sun.xml.writer', 'sxw'],
    ['application/vnd.sun.xml.writer.global', 'sxg'],
    ['application/vnd.sun.xml.writer.template', 'stw'],
    ['application/vnd.sus-calendar', 'sus'],
    ['application/vnd.svd', 'svd'],
    ['application/vnd.symbian.install', 'sis'],
    ['application/vnd.syncml+xml', 'xsm'],
    ['application/vnd.syncml.dm+wbxml', 'bdm'],
    ['application/vnd.syncml.dm+xml', 'xdm'],
    ['application/vnd.tao.intent-module-archive', 'tao'],
    ['application/vnd.tmobile-livetv', 'tmo'],
    ['application/vnd.trid.tpt', 'tpt'],
    ['application/vnd.triscape.mxs', 'mxs'],
    ['application/vnd.trueapp', 'tra'],
    ['application/vnd.ufdl', 'ufd'],
    ['application/vnd.uiq.theme', 'utz'],
    ['application/vnd.umajin', 'umj'],
    ['application/vnd.unity', 'unityweb'],
    ['application/vnd.uoml+xml', 'uoml'],
    ['application/vnd.vcx', 'vcx'],
    ['application/vnd.visio', 'vsd'],
    ['application/vnd.visionary', 'vis'],
    ['application/vnd.vsf', 'vsf'],
    ['application/vnd.wap.wbxml', 'wbxml'],
    ['application/vnd.wap.wmlc', 'wmlc'],
    ['application/vnd.wap.wmlscriptc', 'wmlsc'],
    ['application/vnd.webturbo', 'wtb'],
    ['application/vnd.wolfram.player', 'nbp'],
    ['application/vnd.wordperfect', 'wpd'],
    ['application/vnd.wqd', 'wqd'],
    ['application/vnd.wt.stf', 'stf'],
    ['application/vnd.xara', ['web', 'xar']],
    ['application/vnd.xfdl', 'xfdl'],
    ['application/vnd.yamaha.hv-dic', 'hvd'],
    ['application/vnd.yamaha.hv-script', 'hvs'],
    ['application/vnd.yamaha.hv-voice', 'hvp'],
    ['application/vnd.yamaha.openscoreformat', 'osf'],
    ['application/vnd.yamaha.openscoreformat.osfpvg+xml', 'osfpvg'],
    ['application/vnd.yamaha.smaf-audio', 'saf'],
    ['application/vnd.yamaha.smaf-phrase', 'spf'],
    ['application/vnd.yellowriver-custom-menu', 'cmp'],
    ['application/vnd.zul', 'zir'],
    ['application/vnd.zzazz.deck+xml', 'zaz'],
    ['application/vocaltec-media-desc', 'vmd'],
    ['application/vocaltec-media-file', 'vmf'],
    ['application/voicexml+xml', 'vxml'],
    ['application/widget', 'wgt'],
    ['application/winhlp', 'hlp'],
    ['application/wordperfect', ['wp', 'wp5', 'wp6', 'wpd']],
    ['application/wordperfect6.0', ['w60', 'wp5']],
    ['application/wordperfect6.1', 'w61'],
    ['application/wsdl+xml', 'wsdl'],
    ['application/wspolicy+xml', 'wspolicy'],
    ['application/x-123', 'wk1'],
    ['application/x-7z-compressed', '7z'],
    ['application/x-abiword', 'abw'],
    ['application/x-ace-compressed', 'ace'],
    ['application/x-aim', 'aim'],
    ['application/x-authorware-bin', 'aab'],
    ['application/x-authorware-map', 'aam'],
    ['application/x-authorware-seg', 'aas'],
    ['application/x-bcpio', 'bcpio'],
    ['application/x-binary', 'bin'],
    ['application/x-binhex40', 'hqx'],
    ['application/x-bittorrent', 'torrent'],
    ['application/x-bsh', ['bsh', 'sh', 'shar']],
    ['application/x-bytecode.elisp', 'elc'],
    ['application/x-bytecode.python', 'pyc'],
    ['application/x-bzip', 'bz'],
    ['application/x-bzip2', ['boz', 'bz2']],
    ['application/x-cdf', 'cdf'],
    ['application/x-cdlink', 'vcd'],
    ['application/x-chat', ['cha', 'chat']],
    ['application/x-chess-pgn', 'pgn'],
    ['application/x-cmu-raster', 'ras'],
    ['application/x-cocoa', 'cco'],
    ['application/x-compactpro', 'cpt'],
    ['application/x-compress', 'z'],
    ['application/x-compressed', ['tgz', 'gz', 'z', 'zip']],
    ['application/x-conference', 'nsc'],
    ['application/x-cpio', 'cpio'],
    ['application/x-cpt', 'cpt'],
    ['application/x-csh', 'csh'],
    ['application/x-debian-package', 'deb'],
    ['application/x-deepv', 'deepv'],
    ['application/x-director', ['dir', 'dcr', 'dxr']],
    ['application/x-doom', 'wad'],
    ['application/x-dtbncx+xml', 'ncx'],
    ['application/x-dtbook+xml', 'dtb'],
    ['application/x-dtbresource+xml', 'res'],
    ['application/x-dvi', 'dvi'],
    ['application/x-elc', 'elc'],
    ['application/x-envoy', ['env', 'evy']],
    ['application/x-esrehber', 'es'],
    ['application/x-excel', ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw']],
    ['application/x-font-bdf', 'bdf'],
    ['application/x-font-ghostscript', 'gsf'],
    ['application/x-font-linux-psf', 'psf'],
    ['application/x-font-otf', 'otf'],
    ['application/x-font-pcf', 'pcf'],
    ['application/x-font-snf', 'snf'],
    ['application/x-font-ttf', 'ttf'],
    ['application/x-font-type1', 'pfa'],
    ['application/x-font-woff', 'woff'],
    ['application/x-frame', 'mif'],
    ['application/x-freelance', 'pre'],
    ['application/x-futuresplash', 'spl'],
    ['application/x-gnumeric', 'gnumeric'],
    ['application/x-gsp', 'gsp'],
    ['application/x-gss', 'gss'],
    ['application/x-gtar', 'gtar'],
    ['application/x-gzip', ['gz', 'gzip']],
    ['application/x-hdf', 'hdf'],
    ['application/x-helpfile', ['help', 'hlp']],
    ['application/x-httpd-imap', 'imap'],
    ['application/x-ima', 'ima'],
    ['application/x-internet-signup', ['ins', 'isp']],
    ['application/x-internett-signup', 'ins'],
    ['application/x-inventor', 'iv'],
    ['application/x-ip2', 'ip'],
    ['application/x-iphone', 'iii'],
    ['application/x-java-class', 'class'],
    ['application/x-java-commerce', 'jcm'],
    ['application/x-java-jnlp-file', 'jnlp'],
    ['application/x-javascript', 'js'],
    ['application/x-koan', ['skd', 'skm', 'skp', 'skt']],
    ['application/x-ksh', 'ksh'],
    ['application/x-latex', ['latex', 'ltx']],
    ['application/x-lha', 'lha'],
    ['application/x-lisp', 'lsp'],
    ['application/x-livescreen', 'ivy'],
    ['application/x-lotus', 'wq1'],
    ['application/x-lotusscreencam', 'scm'],
    ['application/x-lzh', 'lzh'],
    ['application/x-lzx', 'lzx'],
    ['application/x-mac-binhex40', 'hqx'],
    ['application/x-macbinary', 'bin'],
    ['application/x-magic-cap-package-1.0', 'mc$'],
    ['application/x-mathcad', 'mcd'],
    ['application/x-meme', 'mm'],
    ['application/x-midi', ['mid', 'midi']],
    ['application/x-mif', 'mif'],
    ['application/x-mix-transfer', 'nix'],
    ['application/x-mobipocket-ebook', 'prc'],
    ['application/x-mplayer2', 'asx'],
    ['application/x-ms-application', 'application'],
    ['application/x-ms-wmd', 'wmd'],
    ['application/x-ms-wmz', 'wmz'],
    ['application/x-ms-xbap', 'xbap'],
    ['application/x-msaccess', 'mdb'],
    ['application/x-msbinder', 'obd'],
    ['application/x-mscardfile', 'crd'],
    ['application/x-msclip', 'clp'],
    ['application/x-msdownload', ['exe', 'dll']],
    ['application/x-msexcel', ['xls', 'xla', 'xlw']],
    ['application/x-msmediaview', ['mvb', 'm13', 'm14']],
    ['application/x-msmetafile', 'wmf'],
    ['application/x-msmoney', 'mny'],
    ['application/x-mspowerpoint', 'ppt'],
    ['application/x-mspublisher', 'pub'],
    ['application/x-msschedule', 'scd'],
    ['application/x-msterminal', 'trm'],
    ['application/x-mswrite', 'wri'],
    ['application/x-navi-animation', 'ani'],
    ['application/x-navidoc', 'nvd'],
    ['application/x-navimap', 'map'],
    ['application/x-navistyle', 'stl'],
    ['application/x-netcdf', ['cdf', 'nc']],
    ['application/x-newton-compatible-pkg', 'pkg'],
    ['application/x-nokia-9000-communicator-add-on-software', 'aos'],
    ['application/x-omc', 'omc'],
    ['application/x-omcdatamaker', 'omcd'],
    ['application/x-omcregerator', 'omcr'],
    ['application/x-pagemaker', ['pm4', 'pm5']],
    ['application/x-pcl', 'pcl'],
    ['application/x-perfmon', ['pma', 'pmc', 'pml', 'pmr', 'pmw']],
    ['application/x-pixclscript', 'plx'],
    ['application/x-pkcs10', 'p10'],
    ['application/x-pkcs12', ['p12', 'pfx']],
    ['application/x-pkcs7-certificates', ['p7b', 'spc']],
    ['application/x-pkcs7-certreqresp', 'p7r'],
    ['application/x-pkcs7-mime', ['p7m', 'p7c']],
    ['application/x-pkcs7-signature', ['p7s', 'p7a']],
    ['application/x-pointplus', 'css'],
    ['application/x-portable-anymap', 'pnm'],
    ['application/x-project', ['mpc', 'mpt', 'mpv', 'mpx']],
    ['application/x-qpro', 'wb1'],
    ['application/x-rar-compressed', 'rar'],
    ['application/x-rtf', 'rtf'],
    ['application/x-sdp', 'sdp'],
    ['application/x-sea', 'sea'],
    ['application/x-seelogo', 'sl'],
    ['application/x-sh', 'sh'],
    ['application/x-shar', ['shar', 'sh']],
    ['application/x-shockwave-flash', 'swf'],
    ['application/x-silverlight-app', 'xap'],
    ['application/x-sit', 'sit'],
    ['application/x-sprite', ['spr', 'sprite']],
    ['application/x-stuffit', 'sit'],
    ['application/x-stuffitx', 'sitx'],
    ['application/x-sv4cpio', 'sv4cpio'],
    ['application/x-sv4crc', 'sv4crc'],
    ['application/x-tar', 'tar'],
    ['application/x-tbook', ['sbk', 'tbk']],
    ['application/x-tcl', 'tcl'],
    ['application/x-tex', 'tex'],
    ['application/x-tex-tfm', 'tfm'],
    ['application/x-texinfo', ['texi', 'texinfo']],
    ['application/x-troff', ['roff', 't', 'tr']],
    ['application/x-troff-man', 'man'],
    ['application/x-troff-me', 'me'],
    ['application/x-troff-ms', 'ms'],
    ['application/x-troff-msvideo', 'avi'],
    ['application/x-ustar', 'ustar'],
    ['application/x-visio', ['vsd', 'vst', 'vsw']],
    ['application/x-vnd.audioexplosion.mzz', 'mzz'],
    ['application/x-vnd.ls-xpix', 'xpix'],
    ['application/x-vrml', 'vrml'],
    ['application/x-wais-source', ['src', 'wsrc']],
    ['application/x-winhelp', 'hlp'],
    ['application/x-wintalk', 'wtk'],
    ['application/x-world', ['wrl', 'svr']],
    ['application/x-wpwin', 'wpd'],
    ['application/x-wri', 'wri'],
    ['application/x-x509-ca-cert', ['cer', 'crt', 'der']],
    ['application/x-x509-user-cert', 'crt'],
    ['application/x-xfig', 'fig'],
    ['application/x-xpinstall', 'xpi'],
    ['application/x-zip-compressed', 'zip'],
    ['application/xcap-diff+xml', 'xdf'],
    ['application/xenc+xml', 'xenc'],
    ['application/xhtml+xml', 'xhtml'],
    ['application/xml', 'xml'],
    ['application/xml-dtd', 'dtd'],
    ['application/xop+xml', 'xop'],
    ['application/xslt+xml', 'xslt'],
    ['application/xspf+xml', 'xspf'],
    ['application/xv+xml', 'mxml'],
    ['application/yang', 'yang'],
    ['application/yin+xml', 'yin'],
    ['application/ynd.ms-pkipko', 'pko'],
    ['application/zip', 'zip'],
    ['audio/adpcm', 'adp'],
    ['audio/aiff', ['aiff', 'aif', 'aifc']],
    ['audio/basic', ['snd', 'au']],
    ['audio/it', 'it'],
    ['audio/make', ['funk', 'my', 'pfunk']],
    ['audio/make.my.funk', 'pfunk'],
    ['audio/mid', ['mid', 'rmi']],
    ['audio/midi', ['midi', 'kar', 'mid']],
    ['audio/mod', 'mod'],
    ['audio/mp4', 'mp4a'],
    ['audio/mpeg', ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg']],
    ['audio/mpeg3', 'mp3'],
    ['audio/nspaudio', ['la', 'lma']],
    ['audio/ogg', 'oga'],
    ['audio/s3m', 's3m'],
    ['audio/tsp-audio', 'tsi'],
    ['audio/tsplayer', 'tsp'],
    ['audio/vnd.dece.audio', 'uva'],
    ['audio/vnd.digital-winds', 'eol'],
    ['audio/vnd.dra', 'dra'],
    ['audio/vnd.dts', 'dts'],
    ['audio/vnd.dts.hd', 'dtshd'],
    ['audio/vnd.lucent.voice', 'lvp'],
    ['audio/vnd.ms-playready.media.pya', 'pya'],
    ['audio/vnd.nuera.ecelp4800', 'ecelp4800'],
    ['audio/vnd.nuera.ecelp7470', 'ecelp7470'],
    ['audio/vnd.nuera.ecelp9600', 'ecelp9600'],
    ['audio/vnd.qcelp', 'qcp'],
    ['audio/vnd.rip', 'rip'],
    ['audio/voc', 'voc'],
    ['audio/voxware', 'vox'],
    ['audio/wav', 'wav'],
    ['audio/webm', 'weba'],
    ['audio/x-aac', 'aac'],
    ['audio/x-adpcm', 'snd'],
    ['audio/x-aiff', ['aiff', 'aif', 'aifc']],
    ['audio/x-au', 'au'],
    ['audio/x-gsm', ['gsd', 'gsm']],
    ['audio/x-jam', 'jam'],
    ['audio/x-liveaudio', 'lam'],
    ['audio/x-mid', ['mid', 'midi']],
    ['audio/x-midi', ['midi', 'mid']],
    ['audio/x-mod', 'mod'],
    ['audio/x-mpeg', 'mp2'],
    ['audio/x-mpeg-3', 'mp3'],
    ['audio/x-mpegurl', 'm3u'],
    ['audio/x-mpequrl', 'm3u'],
    ['audio/x-ms-wax', 'wax'],
    ['audio/x-ms-wma', 'wma'],
    ['audio/x-nspaudio', ['la', 'lma']],
    ['audio/x-pn-realaudio', ['ra', 'ram', 'rm', 'rmm', 'rmp']],
    ['audio/x-pn-realaudio-plugin', ['ra', 'rmp', 'rpm']],
    ['audio/x-psid', 'sid'],
    ['audio/x-realaudio', 'ra'],
    ['audio/x-twinvq', 'vqf'],
    ['audio/x-twinvq-plugin', ['vqe', 'vql']],
    ['audio/x-vnd.audioexplosion.mjuicemediafile', 'mjf'],
    ['audio/x-voc', 'voc'],
    ['audio/x-wav', 'wav'],
    ['audio/xm', 'xm'],
    ['chemical/x-cdx', 'cdx'],
    ['chemical/x-cif', 'cif'],
    ['chemical/x-cmdf', 'cmdf'],
    ['chemical/x-cml', 'cml'],
    ['chemical/x-csml', 'csml'],
    ['chemical/x-pdb', ['pdb', 'xyz']],
    ['chemical/x-xyz', 'xyz'],
    ['drawing/x-dwf', 'dwf'],
    ['i-world/i-vrml', 'ivr'],
    ['image/bmp', ['bmp', 'bm']],
    ['image/cgm', 'cgm'],
    ['image/cis-cod', 'cod'],
    ['image/cmu-raster', ['ras', 'rast']],
    ['image/fif', 'fif'],
    ['image/florian', ['flo', 'turbot']],
    ['image/g3fax', 'g3'],
    ['image/gif', 'gif'],
    ['image/ief', ['ief', 'iefs']],
    ['image/jpeg', ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl']],
    ['image/jutvision', 'jut'],
    ['image/ktx', 'ktx'],
    ['image/naplps', ['nap', 'naplps']],
    ['image/pict', ['pic', 'pict']],
    ['image/pipeg', 'jfif'],
    ['image/pjpeg', ['jfif', 'jpe', 'jpeg', 'jpg']],
    ['image/png', ['png', 'x-png']],
    ['image/prs.btif', 'btif'],
    ['image/svg+xml', 'svg'],
    ['image/tiff', ['tif', 'tiff']],
    ['image/vasa', 'mcf'],
    ['image/vnd.adobe.photoshop', 'psd'],
    ['image/vnd.dece.graphic', 'uvi'],
    ['image/vnd.djvu', 'djvu'],
    ['image/vnd.dvb.subtitle', 'sub'],
    ['image/vnd.dwg', ['dwg', 'dxf', 'svf']],
    ['image/vnd.dxf', 'dxf'],
    ['image/vnd.fastbidsheet', 'fbs'],
    ['image/vnd.fpx', 'fpx'],
    ['image/vnd.fst', 'fst'],
    ['image/vnd.fujixerox.edmics-mmr', 'mmr'],
    ['image/vnd.fujixerox.edmics-rlc', 'rlc'],
    ['image/vnd.ms-modi', 'mdi'],
    ['image/vnd.net-fpx', ['fpx', 'npx']],
    ['image/vnd.rn-realflash', 'rf'],
    ['image/vnd.rn-realpix', 'rp'],
    ['image/vnd.wap.wbmp', 'wbmp'],
    ['image/vnd.xiff', 'xif'],
    ['image/webp', 'webp'],
    ['image/x-cmu-raster', 'ras'],
    ['image/x-cmx', 'cmx'],
    ['image/x-dwg', ['dwg', 'dxf', 'svf']],
    ['image/x-freehand', 'fh'],
    ['image/x-icon', 'ico'],
    ['image/x-jg', 'art'],
    ['image/x-jps', 'jps'],
    ['image/x-niff', ['niff', 'nif']],
    ['image/x-pcx', 'pcx'],
    ['image/x-pict', ['pct', 'pic']],
    ['image/x-portable-anymap', 'pnm'],
    ['image/x-portable-bitmap', 'pbm'],
    ['image/x-portable-graymap', 'pgm'],
    ['image/x-portable-greymap', 'pgm'],
    ['image/x-portable-pixmap', 'ppm'],
    ['image/x-quicktime', ['qif', 'qti', 'qtif']],
    ['image/x-rgb', 'rgb'],
    ['image/x-tiff', ['tif', 'tiff']],
    ['image/x-windows-bmp', 'bmp'],
    ['image/x-xbitmap', 'xbm'],
    ['image/x-xbm', 'xbm'],
    ['image/x-xpixmap', ['xpm', 'pm']],
    ['image/x-xwd', 'xwd'],
    ['image/x-xwindowdump', 'xwd'],
    ['image/xbm', 'xbm'],
    ['image/xpm', 'xpm'],
    ['message/rfc822', ['eml', 'mht', 'mhtml', 'nws', 'mime']],
    ['model/iges', ['iges', 'igs']],
    ['model/mesh', 'msh'],
    ['model/vnd.collada+xml', 'dae'],
    ['model/vnd.dwf', 'dwf'],
    ['model/vnd.gdl', 'gdl'],
    ['model/vnd.gtw', 'gtw'],
    ['model/vnd.mts', 'mts'],
    ['model/vnd.vtu', 'vtu'],
    ['model/vrml', ['vrml', 'wrl', 'wrz']],
    ['model/x-pov', 'pov'],
    ['multipart/x-gzip', 'gzip'],
    ['multipart/x-ustar', 'ustar'],
    ['multipart/x-zip', 'zip'],
    ['music/crescendo', ['mid', 'midi']],
    ['music/x-karaoke', 'kar'],
    ['paleovu/x-pv', 'pvu'],
    ['text/asp', 'asp'],
    ['text/calendar', 'ics'],
    ['text/css', 'css'],
    ['text/csv', 'csv'],
    ['text/ecmascript', 'js'],
    ['text/h323', '323'],
    ['text/html', ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml']],
    ['text/iuls', 'uls'],
    ['text/javascript', 'js'],
    ['text/mcf', 'mcf'],
    ['text/n3', 'n3'],
    ['text/pascal', 'pas'],
    [
        'text/plain',
        [
            'txt',
            'bas',
            'c',
            'h',
            'c++',
            'cc',
            'com',
            'conf',
            'cxx',
            'def',
            'f',
            'f90',
            'for',
            'g',
            'hh',
            'idc',
            'jav',
            'java',
            'list',
            'log',
            'lst',
            'm',
            'mar',
            'pl',
            'sdml',
            'text'
        ]
    ],
    ['text/plain-bas', 'par'],
    ['text/prs.lines.tag', 'dsc'],
    ['text/richtext', ['rtx', 'rt', 'rtf']],
    ['text/scriplet', 'wsc'],
    ['text/scriptlet', 'sct'],
    ['text/sgml', ['sgm', 'sgml']],
    ['text/tab-separated-values', 'tsv'],
    ['text/troff', 't'],
    ['text/turtle', 'ttl'],
    ['text/uri-list', ['uni', 'unis', 'uri', 'uris']],
    ['text/vnd.abc', 'abc'],
    ['text/vnd.curl', 'curl'],
    ['text/vnd.curl.dcurl', 'dcurl'],
    ['text/vnd.curl.mcurl', 'mcurl'],
    ['text/vnd.curl.scurl', 'scurl'],
    ['text/vnd.fly', 'fly'],
    ['text/vnd.fmi.flexstor', 'flx'],
    ['text/vnd.graphviz', 'gv'],
    ['text/vnd.in3d.3dml', '3dml'],
    ['text/vnd.in3d.spot', 'spot'],
    ['text/vnd.rn-realtext', 'rt'],
    ['text/vnd.sun.j2me.app-descriptor', 'jad'],
    ['text/vnd.wap.wml', 'wml'],
    ['text/vnd.wap.wmlscript', 'wmls'],
    ['text/webviewhtml', 'htt'],
    ['text/x-asm', ['asm', 's']],
    ['text/x-audiosoft-intra', 'aip'],
    ['text/x-c', ['c', 'cc', 'cpp']],
    ['text/x-component', 'htc'],
    ['text/x-fortran', ['for', 'f', 'f77', 'f90']],
    ['text/x-h', ['h', 'hh']],
    ['text/x-java-source', ['java', 'jav']],
    ['text/x-java-source,java', 'java'],
    ['text/x-la-asf', 'lsx'],
    ['text/x-m', 'm'],
    ['text/x-pascal', 'p'],
    ['text/x-script', 'hlb'],
    ['text/x-script.csh', 'csh'],
    ['text/x-script.elisp', 'el'],
    ['text/x-script.guile', 'scm'],
    ['text/x-script.ksh', 'ksh'],
    ['text/x-script.lisp', 'lsp'],
    ['text/x-script.perl', 'pl'],
    ['text/x-script.perl-module', 'pm'],
    ['text/x-script.phyton', 'py'],
    ['text/x-script.rexx', 'rexx'],
    ['text/x-script.scheme', 'scm'],
    ['text/x-script.sh', 'sh'],
    ['text/x-script.tcl', 'tcl'],
    ['text/x-script.tcsh', 'tcsh'],
    ['text/x-script.zsh', 'zsh'],
    ['text/x-server-parsed-html', ['shtml', 'ssi']],
    ['text/x-setext', 'etx'],
    ['text/x-sgml', ['sgm', 'sgml']],
    ['text/x-speech', ['spc', 'talk']],
    ['text/x-uil', 'uil'],
    ['text/x-uuencode', ['uu', 'uue']],
    ['text/x-vcalendar', 'vcs'],
    ['text/x-vcard', 'vcf'],
    ['text/xml', 'xml'],
    ['video/3gpp', '3gp'],
    ['video/3gpp2', '3g2'],
    ['video/animaflex', 'afl'],
    ['video/avi', 'avi'],
    ['video/avs-video', 'avs'],
    ['video/dl', 'dl'],
    ['video/fli', 'fli'],
    ['video/gl', 'gl'],
    ['video/h261', 'h261'],
    ['video/h263', 'h263'],
    ['video/h264', 'h264'],
    ['video/jpeg', 'jpgv'],
    ['video/jpm', 'jpm'],
    ['video/mj2', 'mj2'],
    ['video/mp4', 'mp4'],
    ['video/mpeg', ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3']],
    ['video/msvideo', 'avi'],
    ['video/ogg', 'ogv'],
    ['video/quicktime', ['mov', 'qt', 'moov']],
    ['video/vdo', 'vdo'],
    ['video/vivo', ['viv', 'vivo']],
    ['video/vnd.dece.hd', 'uvh'],
    ['video/vnd.dece.mobile', 'uvm'],
    ['video/vnd.dece.pd', 'uvp'],
    ['video/vnd.dece.sd', 'uvs'],
    ['video/vnd.dece.video', 'uvv'],
    ['video/vnd.fvt', 'fvt'],
    ['video/vnd.mpegurl', 'mxu'],
    ['video/vnd.ms-playready.media.pyv', 'pyv'],
    ['video/vnd.rn-realvideo', 'rv'],
    ['video/vnd.uvvu.mp4', 'uvu'],
    ['video/vnd.vivo', ['viv', 'vivo']],
    ['video/vosaic', 'vos'],
    ['video/webm', 'webm'],
    ['video/x-amt-demorun', 'xdr'],
    ['video/x-amt-showrun', 'xsr'],
    ['video/x-atomic3d-feature', 'fmf'],
    ['video/x-dl', 'dl'],
    ['video/x-dv', ['dif', 'dv']],
    ['video/x-f4v', 'f4v'],
    ['video/x-fli', 'fli'],
    ['video/x-flv', 'flv'],
    ['video/x-gl', 'gl'],
    ['video/x-isvideo', 'isu'],
    ['video/x-la-asf', ['lsf', 'lsx']],
    ['video/x-m4v', 'm4v'],
    ['video/x-motion-jpeg', 'mjpg'],
    ['video/x-mpeg', ['mp3', 'mp2']],
    ['video/x-mpeq2a', 'mp2'],
    ['video/x-ms-asf', ['asf', 'asr', 'asx']],
    ['video/x-ms-asf-plugin', 'asx'],
    ['video/x-ms-wm', 'wm'],
    ['video/x-ms-wmv', 'wmv'],
    ['video/x-ms-wmx', 'wmx'],
    ['video/x-ms-wvx', 'wvx'],
    ['video/x-msvideo', 'avi'],
    ['video/x-qtc', 'qtc'],
    ['video/x-scm', 'scm'],
    ['video/x-sgi-movie', ['movie', 'mv']],
    ['windows/metafile', 'wmf'],
    ['www/mime', 'mime'],
    ['x-conference/x-cooltalk', 'ice'],
    ['x-music/x-midi', ['mid', 'midi']],
    ['x-world/x-3dmf', ['3dm', '3dmf', 'qd3', 'qd3d']],
    ['x-world/x-svr', 'svr'],
    ['x-world/x-vrml', ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof']],
    ['x-world/x-vrt', 'vrt'],
    ['xgl/drawing', 'xgz'],
    ['xgl/movie', 'xmz']
]);
const extensions = new Map([
    ['123', 'application/vnd.lotus-1-2-3'],
    ['323', 'text/h323'],
    ['*', 'application/octet-stream'],
    ['3dm', 'x-world/x-3dmf'],
    ['3dmf', 'x-world/x-3dmf'],
    ['3dml', 'text/vnd.in3d.3dml'],
    ['3g2', 'video/3gpp2'],
    ['3gp', 'video/3gpp'],
    ['7z', 'application/x-7z-compressed'],
    ['a', 'application/octet-stream'],
    ['aab', 'application/x-authorware-bin'],
    ['aac', 'audio/x-aac'],
    ['aam', 'application/x-authorware-map'],
    ['aas', 'application/x-authorware-seg'],
    ['abc', 'text/vnd.abc'],
    ['abw', 'application/x-abiword'],
    ['ac', 'application/pkix-attr-cert'],
    ['acc', 'application/vnd.americandynamics.acc'],
    ['ace', 'application/x-ace-compressed'],
    ['acgi', 'text/html'],
    ['acu', 'application/vnd.acucobol'],
    ['acx', 'application/internet-property-stream'],
    ['adp', 'audio/adpcm'],
    ['aep', 'application/vnd.audiograph'],
    ['afl', 'video/animaflex'],
    ['afp', 'application/vnd.ibm.modcap'],
    ['ahead', 'application/vnd.ahead.space'],
    ['ai', 'application/postscript'],
    ['aif', ['audio/aiff', 'audio/x-aiff']],
    ['aifc', ['audio/aiff', 'audio/x-aiff']],
    ['aiff', ['audio/aiff', 'audio/x-aiff']],
    ['aim', 'application/x-aim'],
    ['aip', 'text/x-audiosoft-intra'],
    ['air', 'application/vnd.adobe.air-application-installer-package+zip'],
    ['ait', 'application/vnd.dvb.ait'],
    ['ami', 'application/vnd.amiga.ami'],
    ['ani', 'application/x-navi-animation'],
    ['aos', 'application/x-nokia-9000-communicator-add-on-software'],
    ['apk', 'application/vnd.android.package-archive'],
    ['application', 'application/x-ms-application'],
    ['apr', 'application/vnd.lotus-approach'],
    ['aps', 'application/mime'],
    ['arc', 'application/octet-stream'],
    ['arj', ['application/arj', 'application/octet-stream']],
    ['art', 'image/x-jg'],
    ['asf', 'video/x-ms-asf'],
    ['asm', 'text/x-asm'],
    ['aso', 'application/vnd.accpac.simply.aso'],
    ['asp', 'text/asp'],
    ['asr', 'video/x-ms-asf'],
    ['asx', ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin']],
    ['atc', 'application/vnd.acucorp'],
    ['atomcat', 'application/atomcat+xml'],
    ['atomsvc', 'application/atomsvc+xml'],
    ['atx', 'application/vnd.antix.game-component'],
    ['au', ['audio/basic', 'audio/x-au']],
    ['avi', ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo']],
    ['avs', 'video/avs-video'],
    ['aw', 'application/applixware'],
    ['axs', 'application/olescript'],
    ['azf', 'application/vnd.airzip.filesecure.azf'],
    ['azs', 'application/vnd.airzip.filesecure.azs'],
    ['azw', 'application/vnd.amazon.ebook'],
    ['bas', 'text/plain'],
    ['bcpio', 'application/x-bcpio'],
    ['bdf', 'application/x-font-bdf'],
    ['bdm', 'application/vnd.syncml.dm+wbxml'],
    ['bed', 'application/vnd.realvnc.bed'],
    ['bh2', 'application/vnd.fujitsu.oasysprs'],
    ['bin', ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary']],
    ['bm', 'image/bmp'],
    ['bmi', 'application/vnd.bmi'],
    ['bmp', ['image/bmp', 'image/x-windows-bmp']],
    ['boo', 'application/book'],
    ['book', 'application/book'],
    ['box', 'application/vnd.previewsystems.box'],
    ['boz', 'application/x-bzip2'],
    ['bsh', 'application/x-bsh'],
    ['btif', 'image/prs.btif'],
    ['bz', 'application/x-bzip'],
    ['bz2', 'application/x-bzip2'],
    ['c', ['text/plain', 'text/x-c']],
    ['c++', 'text/plain'],
    ['c11amc', 'application/vnd.cluetrust.cartomobile-config'],
    ['c11amz', 'application/vnd.cluetrust.cartomobile-config-pkg'],
    ['c4g', 'application/vnd.clonk.c4group'],
    ['cab', 'application/vnd.ms-cab-compressed'],
    ['car', 'application/vnd.curl.car'],
    ['cat', ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat']],
    ['cc', ['text/plain', 'text/x-c']],
    ['ccad', 'application/clariscad'],
    ['cco', 'application/x-cocoa'],
    ['ccxml', 'application/ccxml+xml,'],
    ['cdbcmsg', 'application/vnd.contact.cmsg'],
    ['cdf', ['application/cdf', 'application/x-cdf', 'application/x-netcdf']],
    ['cdkey', 'application/vnd.mediastation.cdkey'],
    ['cdmia', 'application/cdmi-capability'],
    ['cdmic', 'application/cdmi-container'],
    ['cdmid', 'application/cdmi-domain'],
    ['cdmio', 'application/cdmi-object'],
    ['cdmiq', 'application/cdmi-queue'],
    ['cdx', 'chemical/x-cdx'],
    ['cdxml', 'application/vnd.chemdraw+xml'],
    ['cdy', 'application/vnd.cinderella'],
    ['cer', ['application/pkix-cert', 'application/x-x509-ca-cert']],
    ['cgm', 'image/cgm'],
    ['cha', 'application/x-chat'],
    ['chat', 'application/x-chat'],
    ['chm', 'application/vnd.ms-htmlhelp'],
    ['chrt', 'application/vnd.kde.kchart'],
    ['cif', 'chemical/x-cif'],
    ['cii', 'application/vnd.anser-web-certificate-issue-initiation'],
    ['cil', 'application/vnd.ms-artgalry'],
    ['cla', 'application/vnd.claymore'],
    ['class', ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class']],
    ['clkk', 'application/vnd.crick.clicker.keyboard'],
    ['clkp', 'application/vnd.crick.clicker.palette'],
    ['clkt', 'application/vnd.crick.clicker.template'],
    ['clkw', 'application/vnd.crick.clicker.wordbank'],
    ['clkx', 'application/vnd.crick.clicker'],
    ['clp', 'application/x-msclip'],
    ['cmc', 'application/vnd.cosmocaller'],
    ['cmdf', 'chemical/x-cmdf'],
    ['cml', 'chemical/x-cml'],
    ['cmp', 'application/vnd.yellowriver-custom-menu'],
    ['cmx', 'image/x-cmx'],
    ['cod', ['image/cis-cod', 'application/vnd.rim.cod']],
    ['com', ['application/octet-stream', 'text/plain']],
    ['conf', 'text/plain'],
    ['cpio', 'application/x-cpio'],
    ['cpp', 'text/x-c'],
    ['cpt', ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt']],
    ['crd', 'application/x-mscardfile'],
    ['crl', ['application/pkix-crl', 'application/pkcs-crl']],
    ['crt', ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert']],
    ['cryptonote', 'application/vnd.rig.cryptonote'],
    ['csh', ['text/x-script.csh', 'application/x-csh']],
    ['csml', 'chemical/x-csml'],
    ['csp', 'application/vnd.commonspace'],
    ['css', ['text/css', 'application/x-pointplus']],
    ['csv', 'text/csv'],
    ['cu', 'application/cu-seeme'],
    ['curl', 'text/vnd.curl'],
    ['cww', 'application/prs.cww'],
    ['cxx', 'text/plain'],
    ['dae', 'model/vnd.collada+xml'],
    ['daf', 'application/vnd.mobius.daf'],
    ['davmount', 'application/davmount+xml'],
    ['dcr', 'application/x-director'],
    ['dcurl', 'text/vnd.curl.dcurl'],
    ['dd2', 'application/vnd.oma.dd2+xml'],
    ['ddd', 'application/vnd.fujixerox.ddd'],
    ['deb', 'application/x-debian-package'],
    ['deepv', 'application/x-deepv'],
    ['def', 'text/plain'],
    ['der', 'application/x-x509-ca-cert'],
    ['dfac', 'application/vnd.dreamfactory'],
    ['dif', 'video/x-dv'],
    ['dir', 'application/x-director'],
    ['dis', 'application/vnd.mobius.dis'],
    ['djvu', 'image/vnd.djvu'],
    ['dl', ['video/dl', 'video/x-dl']],
    ['dll', 'application/x-msdownload'],
    ['dms', 'application/octet-stream'],
    ['dna', 'application/vnd.dna'],
    ['doc', 'application/msword'],
    ['docm', 'application/vnd.ms-word.document.macroenabled.12'],
    ['docx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
    ['dot', 'application/msword'],
    ['dotm', 'application/vnd.ms-word.template.macroenabled.12'],
    ['dotx', 'application/vnd.openxmlformats-officedocument.wordprocessingml.template'],
    ['dp', ['application/commonground', 'application/vnd.osgi.dp']],
    ['dpg', 'application/vnd.dpgraph'],
    ['dra', 'audio/vnd.dra'],
    ['drw', 'application/drafting'],
    ['dsc', 'text/prs.lines.tag'],
    ['dssc', 'application/dssc+der'],
    ['dtb', 'application/x-dtbook+xml'],
    ['dtd', 'application/xml-dtd'],
    ['dts', 'audio/vnd.dts'],
    ['dtshd', 'audio/vnd.dts.hd'],
    ['dump', 'application/octet-stream'],
    ['dv', 'video/x-dv'],
    ['dvi', 'application/x-dvi'],
    ['dwf', ['model/vnd.dwf', 'drawing/x-dwf']],
    ['dwg', ['application/acad', 'image/vnd.dwg', 'image/x-dwg']],
    ['dxf', ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg']],
    ['dxp', 'application/vnd.spotfire.dxp'],
    ['dxr', 'application/x-director'],
    ['ecelp4800', 'audio/vnd.nuera.ecelp4800'],
    ['ecelp7470', 'audio/vnd.nuera.ecelp7470'],
    ['ecelp9600', 'audio/vnd.nuera.ecelp9600'],
    ['edm', 'application/vnd.novadigm.edm'],
    ['edx', 'application/vnd.novadigm.edx'],
    ['efif', 'application/vnd.picsel'],
    ['ei6', 'application/vnd.pg.osasli'],
    ['el', 'text/x-script.elisp'],
    ['elc', ['application/x-elc', 'application/x-bytecode.elisp']],
    ['eml', 'message/rfc822'],
    ['emma', 'application/emma+xml'],
    ['env', 'application/x-envoy'],
    ['eol', 'audio/vnd.digital-winds'],
    ['eot', 'application/vnd.ms-fontobject'],
    ['eps', 'application/postscript'],
    ['epub', 'application/epub+zip'],
    ['es', ['application/ecmascript', 'application/x-esrehber']],
    ['es3', 'application/vnd.eszigno3+xml'],
    ['esf', 'application/vnd.epson.esf'],
    ['etx', 'text/x-setext'],
    ['evy', ['application/envoy', 'application/x-envoy']],
    ['exe', ['application/octet-stream', 'application/x-msdownload']],
    ['exi', 'application/exi'],
    ['ext', 'application/vnd.novadigm.ext'],
    ['ez2', 'application/vnd.ezpix-album'],
    ['ez3', 'application/vnd.ezpix-package'],
    ['f', ['text/plain', 'text/x-fortran']],
    ['f4v', 'video/x-f4v'],
    ['f77', 'text/x-fortran'],
    ['f90', ['text/plain', 'text/x-fortran']],
    ['fbs', 'image/vnd.fastbidsheet'],
    ['fcs', 'application/vnd.isac.fcs'],
    ['fdf', 'application/vnd.fdf'],
    ['fe_launch', 'application/vnd.denovo.fcselayout-link'],
    ['fg5', 'application/vnd.fujitsu.oasysgp'],
    ['fh', 'image/x-freehand'],
    ['fif', ['application/fractals', 'image/fif']],
    ['fig', 'application/x-xfig'],
    ['fli', ['video/fli', 'video/x-fli']],
    ['flo', ['image/florian', 'application/vnd.micrografx.flo']],
    ['flr', 'x-world/x-vrml'],
    ['flv', 'video/x-flv'],
    ['flw', 'application/vnd.kde.kivio'],
    ['flx', 'text/vnd.fmi.flexstor'],
    ['fly', 'text/vnd.fly'],
    ['fm', 'application/vnd.framemaker'],
    ['fmf', 'video/x-atomic3d-feature'],
    ['fnc', 'application/vnd.frogans.fnc'],
    ['for', ['text/plain', 'text/x-fortran']],
    ['fpx', ['image/vnd.fpx', 'image/vnd.net-fpx']],
    ['frl', 'application/freeloader'],
    ['fsc', 'application/vnd.fsc.weblaunch'],
    ['fst', 'image/vnd.fst'],
    ['ftc', 'application/vnd.fluxtime.clip'],
    ['fti', 'application/vnd.anser-web-funds-transfer-initiation'],
    ['funk', 'audio/make'],
    ['fvt', 'video/vnd.fvt'],
    ['fxp', 'application/vnd.adobe.fxp'],
    ['fzs', 'application/vnd.fuzzysheet'],
    ['g', 'text/plain'],
    ['g2w', 'application/vnd.geoplan'],
    ['g3', 'image/g3fax'],
    ['g3w', 'application/vnd.geospace'],
    ['gac', 'application/vnd.groove-account'],
    ['gdl', 'model/vnd.gdl'],
    ['geo', 'application/vnd.dynageo'],
    ['geojson', 'application/geo+json'],
    ['gex', 'application/vnd.geometry-explorer'],
    ['ggb', 'application/vnd.geogebra.file'],
    ['ggt', 'application/vnd.geogebra.tool'],
    ['ghf', 'application/vnd.groove-help'],
    ['gif', 'image/gif'],
    ['gim', 'application/vnd.groove-identity-message'],
    ['gl', ['video/gl', 'video/x-gl']],
    ['gmx', 'application/vnd.gmx'],
    ['gnumeric', 'application/x-gnumeric'],
    ['gph', 'application/vnd.flographit'],
    ['gqf', 'application/vnd.grafeq'],
    ['gram', 'application/srgs'],
    ['grv', 'application/vnd.groove-injector'],
    ['grxml', 'application/srgs+xml'],
    ['gsd', 'audio/x-gsm'],
    ['gsf', 'application/x-font-ghostscript'],
    ['gsm', 'audio/x-gsm'],
    ['gsp', 'application/x-gsp'],
    ['gss', 'application/x-gss'],
    ['gtar', 'application/x-gtar'],
    ['gtm', 'application/vnd.groove-tool-message'],
    ['gtw', 'model/vnd.gtw'],
    ['gv', 'text/vnd.graphviz'],
    ['gxt', 'application/vnd.geonext'],
    ['gz', ['application/x-gzip', 'application/x-compressed']],
    ['gzip', ['multipart/x-gzip', 'application/x-gzip']],
    ['h', ['text/plain', 'text/x-h']],
    ['h261', 'video/h261'],
    ['h263', 'video/h263'],
    ['h264', 'video/h264'],
    ['hal', 'application/vnd.hal+xml'],
    ['hbci', 'application/vnd.hbci'],
    ['hdf', 'application/x-hdf'],
    ['help', 'application/x-helpfile'],
    ['hgl', 'application/vnd.hp-hpgl'],
    ['hh', ['text/plain', 'text/x-h']],
    ['hlb', 'text/x-script'],
    ['hlp', ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp']],
    ['hpg', 'application/vnd.hp-hpgl'],
    ['hpgl', 'application/vnd.hp-hpgl'],
    ['hpid', 'application/vnd.hp-hpid'],
    ['hps', 'application/vnd.hp-hps'],
    [
        'hqx',
        [
            'application/mac-binhex40',
            'application/binhex',
            'application/binhex4',
            'application/mac-binhex',
            'application/x-binhex40',
            'application/x-mac-binhex40'
        ]
    ],
    ['hta', 'application/hta'],
    ['htc', 'text/x-component'],
    ['htke', 'application/vnd.kenameaapp'],
    ['htm', 'text/html'],
    ['html', 'text/html'],
    ['htmls', 'text/html'],
    ['htt', 'text/webviewhtml'],
    ['htx', 'text/html'],
    ['hvd', 'application/vnd.yamaha.hv-dic'],
    ['hvp', 'application/vnd.yamaha.hv-voice'],
    ['hvs', 'application/vnd.yamaha.hv-script'],
    ['i2g', 'application/vnd.intergeo'],
    ['icc', 'application/vnd.iccprofile'],
    ['ice', 'x-conference/x-cooltalk'],
    ['ico', 'image/x-icon'],
    ['ics', 'text/calendar'],
    ['idc', 'text/plain'],
    ['ief', 'image/ief'],
    ['iefs', 'image/ief'],
    ['ifm', 'application/vnd.shana.informed.formdata'],
    ['iges', ['application/iges', 'model/iges']],
    ['igl', 'application/vnd.igloader'],
    ['igm', 'application/vnd.insors.igm'],
    ['igs', ['application/iges', 'model/iges']],
    ['igx', 'application/vnd.micrografx.igx'],
    ['iif', 'application/vnd.shana.informed.interchange'],
    ['iii', 'application/x-iphone'],
    ['ima', 'application/x-ima'],
    ['imap', 'application/x-httpd-imap'],
    ['imp', 'application/vnd.accpac.simply.imp'],
    ['ims', 'application/vnd.ms-ims'],
    ['inf', 'application/inf'],
    ['ins', ['application/x-internet-signup', 'application/x-internett-signup']],
    ['ip', 'application/x-ip2'],
    ['ipfix', 'application/ipfix'],
    ['ipk', 'application/vnd.shana.informed.package'],
    ['irm', 'application/vnd.ibm.rights-management'],
    ['irp', 'application/vnd.irepository.package+xml'],
    ['isp', 'application/x-internet-signup'],
    ['isu', 'video/x-isvideo'],
    ['it', 'audio/it'],
    ['itp', 'application/vnd.shana.informed.formtemplate'],
    ['iv', 'application/x-inventor'],
    ['ivp', 'application/vnd.immervision-ivp'],
    ['ivr', 'i-world/i-vrml'],
    ['ivu', 'application/vnd.immervision-ivu'],
    ['ivy', 'application/x-livescreen'],
    ['jad', 'text/vnd.sun.j2me.app-descriptor'],
    ['jam', ['application/vnd.jam', 'audio/x-jam']],
    ['jar', 'application/java-archive'],
    ['jav', ['text/plain', 'text/x-java-source']],
    ['java', ['text/plain', 'text/x-java-source,java', 'text/x-java-source']],
    ['jcm', 'application/x-java-commerce'],
    ['jfif', ['image/pipeg', 'image/jpeg', 'image/pjpeg']],
    ['jfif-tbnl', 'image/jpeg'],
    ['jisp', 'application/vnd.jisp'],
    ['jlt', 'application/vnd.hp-jlyt'],
    ['jnlp', 'application/x-java-jnlp-file'],
    ['joda', 'application/vnd.joost.joda-archive'],
    ['jpe', ['image/jpeg', 'image/pjpeg']],
    ['jpeg', ['image/jpeg', 'image/pjpeg']],
    ['jpg', ['image/jpeg', 'image/pjpeg']],
    ['jpgv', 'video/jpeg'],
    ['jpm', 'video/jpm'],
    ['jps', 'image/x-jps'],
    ['js', ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript']],
    ['json', 'application/json'],
    ['jut', 'image/jutvision'],
    ['kar', ['audio/midi', 'music/x-karaoke']],
    ['karbon', 'application/vnd.kde.karbon'],
    ['kfo', 'application/vnd.kde.kformula'],
    ['kia', 'application/vnd.kidspiration'],
    ['kml', 'application/vnd.google-earth.kml+xml'],
    ['kmz', 'application/vnd.google-earth.kmz'],
    ['kne', 'application/vnd.kinar'],
    ['kon', 'application/vnd.kde.kontour'],
    ['kpr', 'application/vnd.kde.kpresenter'],
    ['ksh', ['application/x-ksh', 'text/x-script.ksh']],
    ['ksp', 'application/vnd.kde.kspread'],
    ['ktx', 'image/ktx'],
    ['ktz', 'application/vnd.kahootz'],
    ['kwd', 'application/vnd.kde.kword'],
    ['la', ['audio/nspaudio', 'audio/x-nspaudio']],
    ['lam', 'audio/x-liveaudio'],
    ['lasxml', 'application/vnd.las.las+xml'],
    ['latex', 'application/x-latex'],
    ['lbd', 'application/vnd.llamagraphics.life-balance.desktop'],
    ['lbe', 'application/vnd.llamagraphics.life-balance.exchange+xml'],
    ['les', 'application/vnd.hhe.lesson-player'],
    ['lha', ['application/octet-stream', 'application/lha', 'application/x-lha']],
    ['lhx', 'application/octet-stream'],
    ['link66', 'application/vnd.route66.link66+xml'],
    ['list', 'text/plain'],
    ['lma', ['audio/nspaudio', 'audio/x-nspaudio']],
    ['log', 'text/plain'],
    ['lrm', 'application/vnd.ms-lrm'],
    ['lsf', 'video/x-la-asf'],
    ['lsp', ['application/x-lisp', 'text/x-script.lisp']],
    ['lst', 'text/plain'],
    ['lsx', ['video/x-la-asf', 'text/x-la-asf']],
    ['ltf', 'application/vnd.frogans.ltf'],
    ['ltx', 'application/x-latex'],
    ['lvp', 'audio/vnd.lucent.voice'],
    ['lwp', 'application/vnd.lotus-wordpro'],
    ['lzh', ['application/octet-stream', 'application/x-lzh']],
    ['lzx', ['application/lzx', 'application/octet-stream', 'application/x-lzx']],
    ['m', ['text/plain', 'text/x-m']],
    ['m13', 'application/x-msmediaview'],
    ['m14', 'application/x-msmediaview'],
    ['m1v', 'video/mpeg'],
    ['m21', 'application/mp21'],
    ['m2a', 'audio/mpeg'],
    ['m2v', 'video/mpeg'],
    ['m3u', ['audio/x-mpegurl', 'audio/x-mpequrl']],
    ['m3u8', 'application/vnd.apple.mpegurl'],
    ['m4v', 'video/x-m4v'],
    ['ma', 'application/mathematica'],
    ['mads', 'application/mads+xml'],
    ['mag', 'application/vnd.ecowin.chart'],
    ['man', 'application/x-troff-man'],
    ['map', 'application/x-navimap'],
    ['mar', 'text/plain'],
    ['mathml', 'application/mathml+xml'],
    ['mbd', 'application/mbedlet'],
    ['mbk', 'application/vnd.mobius.mbk'],
    ['mbox', 'application/mbox'],
    ['mc$', 'application/x-magic-cap-package-1.0'],
    ['mc1', 'application/vnd.medcalcdata'],
    ['mcd', ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad']],
    ['mcf', ['image/vasa', 'text/mcf']],
    ['mcp', 'application/netmc'],
    ['mcurl', 'text/vnd.curl.mcurl'],
    ['mdb', 'application/x-msaccess'],
    ['mdi', 'image/vnd.ms-modi'],
    ['me', 'application/x-troff-me'],
    ['meta4', 'application/metalink4+xml'],
    ['mets', 'application/mets+xml'],
    ['mfm', 'application/vnd.mfmp'],
    ['mgp', 'application/vnd.osgeo.mapguide.package'],
    ['mgz', 'application/vnd.proteus.magazine'],
    ['mht', 'message/rfc822'],
    ['mhtml', 'message/rfc822'],
    ['mid', ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],
    ['midi', ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid']],
    ['mif', ['application/vnd.mif', 'application/x-mif', 'application/x-frame']],
    ['mime', ['message/rfc822', 'www/mime']],
    ['mj2', 'video/mj2'],
    ['mjf', 'audio/x-vnd.audioexplosion.mjuicemediafile'],
    ['mjpg', 'video/x-motion-jpeg'],
    ['mlp', 'application/vnd.dolby.mlp'],
    ['mm', ['application/base64', 'application/x-meme']],
    ['mmd', 'application/vnd.chipnuts.karaoke-mmd'],
    ['mme', 'application/base64'],
    ['mmf', 'application/vnd.smaf'],
    ['mmr', 'image/vnd.fujixerox.edmics-mmr'],
    ['mny', 'application/x-msmoney'],
    ['mod', ['audio/mod', 'audio/x-mod']],
    ['mods', 'application/mods+xml'],
    ['moov', 'video/quicktime'],
    ['mov', 'video/quicktime'],
    ['movie', 'video/x-sgi-movie'],
    ['mp2', ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a']],
    ['mp3', ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg']],
    ['mp4', ['video/mp4', 'application/mp4']],
    ['mp4a', 'audio/mp4'],
    ['mpa', ['video/mpeg', 'audio/mpeg']],
    ['mpc', ['application/vnd.mophun.certificate', 'application/x-project']],
    ['mpe', 'video/mpeg'],
    ['mpeg', 'video/mpeg'],
    ['mpg', ['video/mpeg', 'audio/mpeg']],
    ['mpga', 'audio/mpeg'],
    ['mpkg', 'application/vnd.apple.installer+xml'],
    ['mpm', 'application/vnd.blueice.multipass'],
    ['mpn', 'application/vnd.mophun.application'],
    ['mpp', 'application/vnd.ms-project'],
    ['mpt', 'application/x-project'],
    ['mpv', 'application/x-project'],
    ['mpv2', 'video/mpeg'],
    ['mpx', 'application/x-project'],
    ['mpy', 'application/vnd.ibm.minipay'],
    ['mqy', 'application/vnd.mobius.mqy'],
    ['mrc', 'application/marc'],
    ['mrcx', 'application/marcxml+xml'],
    ['ms', 'application/x-troff-ms'],
    ['mscml', 'application/mediaservercontrol+xml'],
    ['mseq', 'application/vnd.mseq'],
    ['msf', 'application/vnd.epson.msf'],
    ['msg', 'application/vnd.ms-outlook'],
    ['msh', 'model/mesh'],
    ['msl', 'application/vnd.mobius.msl'],
    ['msty', 'application/vnd.muvee.style'],
    ['mts', 'model/vnd.mts'],
    ['mus', 'application/vnd.musician'],
    ['musicxml', 'application/vnd.recordare.musicxml+xml'],
    ['mv', 'video/x-sgi-movie'],
    ['mvb', 'application/x-msmediaview'],
    ['mwf', 'application/vnd.mfer'],
    ['mxf', 'application/mxf'],
    ['mxl', 'application/vnd.recordare.musicxml'],
    ['mxml', 'application/xv+xml'],
    ['mxs', 'application/vnd.triscape.mxs'],
    ['mxu', 'video/vnd.mpegurl'],
    ['my', 'audio/make'],
    ['mzz', 'application/x-vnd.audioexplosion.mzz'],
    ['n-gage', 'application/vnd.nokia.n-gage.symbian.install'],
    ['n3', 'text/n3'],
    ['nap', 'image/naplps'],
    ['naplps', 'image/naplps'],
    ['nbp', 'application/vnd.wolfram.player'],
    ['nc', 'application/x-netcdf'],
    ['ncm', 'application/vnd.nokia.configuration-message'],
    ['ncx', 'application/x-dtbncx+xml'],
    ['ngdat', 'application/vnd.nokia.n-gage.data'],
    ['nif', 'image/x-niff'],
    ['niff', 'image/x-niff'],
    ['nix', 'application/x-mix-transfer'],
    ['nlu', 'application/vnd.neurolanguage.nlu'],
    ['nml', 'application/vnd.enliven'],
    ['nnd', 'application/vnd.noblenet-directory'],
    ['nns', 'application/vnd.noblenet-sealer'],
    ['nnw', 'application/vnd.noblenet-web'],
    ['npx', 'image/vnd.net-fpx'],
    ['nsc', 'application/x-conference'],
    ['nsf', 'application/vnd.lotus-notes'],
    ['nvd', 'application/x-navidoc'],
    ['nws', 'message/rfc822'],
    ['o', 'application/octet-stream'],
    ['oa2', 'application/vnd.fujitsu.oasys2'],
    ['oa3', 'application/vnd.fujitsu.oasys3'],
    ['oas', 'application/vnd.fujitsu.oasys'],
    ['obd', 'application/x-msbinder'],
    ['oda', 'application/oda'],
    ['odb', 'application/vnd.oasis.opendocument.database'],
    ['odc', 'application/vnd.oasis.opendocument.chart'],
    ['odf', 'application/vnd.oasis.opendocument.formula'],
    ['odft', 'application/vnd.oasis.opendocument.formula-template'],
    ['odg', 'application/vnd.oasis.opendocument.graphics'],
    ['odi', 'application/vnd.oasis.opendocument.image'],
    ['odm', 'application/vnd.oasis.opendocument.text-master'],
    ['odp', 'application/vnd.oasis.opendocument.presentation'],
    ['ods', 'application/vnd.oasis.opendocument.spreadsheet'],
    ['odt', 'application/vnd.oasis.opendocument.text'],
    ['oga', 'audio/ogg'],
    ['ogv', 'video/ogg'],
    ['ogx', 'application/ogg'],
    ['omc', 'application/x-omc'],
    ['omcd', 'application/x-omcdatamaker'],
    ['omcr', 'application/x-omcregerator'],
    ['onetoc', 'application/onenote'],
    ['opf', 'application/oebps-package+xml'],
    ['org', 'application/vnd.lotus-organizer'],
    ['osf', 'application/vnd.yamaha.openscoreformat'],
    ['osfpvg', 'application/vnd.yamaha.openscoreformat.osfpvg+xml'],
    ['otc', 'application/vnd.oasis.opendocument.chart-template'],
    ['otf', 'application/x-font-otf'],
    ['otg', 'application/vnd.oasis.opendocument.graphics-template'],
    ['oth', 'application/vnd.oasis.opendocument.text-web'],
    ['oti', 'application/vnd.oasis.opendocument.image-template'],
    ['otp', 'application/vnd.oasis.opendocument.presentation-template'],
    ['ots', 'application/vnd.oasis.opendocument.spreadsheet-template'],
    ['ott', 'application/vnd.oasis.opendocument.text-template'],
    ['oxt', 'application/vnd.openofficeorg.extension'],
    ['p', 'text/x-pascal'],
    ['p10', ['application/pkcs10', 'application/x-pkcs10']],
    ['p12', ['application/pkcs-12', 'application/x-pkcs12']],
    ['p7a', 'application/x-pkcs7-signature'],
    ['p7b', 'application/x-pkcs7-certificates'],
    ['p7c', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],
    ['p7m', ['application/pkcs7-mime', 'application/x-pkcs7-mime']],
    ['p7r', 'application/x-pkcs7-certreqresp'],
    ['p7s', ['application/pkcs7-signature', 'application/x-pkcs7-signature']],
    ['p8', 'application/pkcs8'],
    ['par', 'text/plain-bas'],
    ['part', 'application/pro_eng'],
    ['pas', 'text/pascal'],
    ['paw', 'application/vnd.pawaafile'],
    ['pbd', 'application/vnd.powerbuilder6'],
    ['pbm', 'image/x-portable-bitmap'],
    ['pcf', 'application/x-font-pcf'],
    ['pcl', ['application/vnd.hp-pcl', 'application/x-pcl']],
    ['pclxl', 'application/vnd.hp-pclxl'],
    ['pct', 'image/x-pict'],
    ['pcurl', 'application/vnd.curl.pcurl'],
    ['pcx', 'image/x-pcx'],
    ['pdb', ['application/vnd.palm', 'chemical/x-pdb']],
    ['pdf', 'application/pdf'],
    ['pfa', 'application/x-font-type1'],
    ['pfr', 'application/font-tdpfr'],
    ['pfunk', ['audio/make', 'audio/make.my.funk']],
    ['pfx', 'application/x-pkcs12'],
    ['pgm', ['image/x-portable-graymap', 'image/x-portable-greymap']],
    ['pgn', 'application/x-chess-pgn'],
    ['pgp', 'application/pgp-signature'],
    ['pic', ['image/pict', 'image/x-pict']],
    ['pict', 'image/pict'],
    ['pkg', 'application/x-newton-compatible-pkg'],
    ['pki', 'application/pkixcmp'],
    ['pkipath', 'application/pkix-pkipath'],
    ['pko', ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko']],
    ['pl', ['text/plain', 'text/x-script.perl']],
    ['plb', 'application/vnd.3gpp.pic-bw-large'],
    ['plc', 'application/vnd.mobius.plc'],
    ['plf', 'application/vnd.pocketlearn'],
    ['pls', 'application/pls+xml'],
    ['plx', 'application/x-pixclscript'],
    ['pm', ['text/x-script.perl-module', 'image/x-xpixmap']],
    ['pm4', 'application/x-pagemaker'],
    ['pm5', 'application/x-pagemaker'],
    ['pma', 'application/x-perfmon'],
    ['pmc', 'application/x-perfmon'],
    ['pml', ['application/vnd.ctc-posml', 'application/x-perfmon']],
    ['pmr', 'application/x-perfmon'],
    ['pmw', 'application/x-perfmon'],
    ['png', 'image/png'],
    ['pnm', ['application/x-portable-anymap', 'image/x-portable-anymap']],
    ['portpkg', 'application/vnd.macports.portpkg'],
    ['pot', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],
    ['potm', 'application/vnd.ms-powerpoint.template.macroenabled.12'],
    ['potx', 'application/vnd.openxmlformats-officedocument.presentationml.template'],
    ['pov', 'model/x-pov'],
    ['ppa', 'application/vnd.ms-powerpoint'],
    ['ppam', 'application/vnd.ms-powerpoint.addin.macroenabled.12'],
    ['ppd', 'application/vnd.cups-ppd'],
    ['ppm', 'image/x-portable-pixmap'],
    ['pps', ['application/vnd.ms-powerpoint', 'application/mspowerpoint']],
    ['ppsm', 'application/vnd.ms-powerpoint.slideshow.macroenabled.12'],
    ['ppsx', 'application/vnd.openxmlformats-officedocument.presentationml.slideshow'],
    ['ppt', ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint']],
    ['pptm', 'application/vnd.ms-powerpoint.presentation.macroenabled.12'],
    ['pptx', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'],
    ['ppz', 'application/mspowerpoint'],
    ['prc', 'application/x-mobipocket-ebook'],
    ['pre', ['application/vnd.lotus-freelance', 'application/x-freelance']],
    ['prf', 'application/pics-rules'],
    ['prt', 'application/pro_eng'],
    ['ps', 'application/postscript'],
    ['psb', 'application/vnd.3gpp.pic-bw-small'],
    ['psd', ['application/octet-stream', 'image/vnd.adobe.photoshop']],
    ['psf', 'application/x-font-linux-psf'],
    ['pskcxml', 'application/pskc+xml'],
    ['ptid', 'application/vnd.pvi.ptid1'],
    ['pub', 'application/x-mspublisher'],
    ['pvb', 'application/vnd.3gpp.pic-bw-var'],
    ['pvu', 'paleovu/x-pv'],
    ['pwn', 'application/vnd.3m.post-it-notes'],
    ['pwz', 'application/vnd.ms-powerpoint'],
    ['py', 'text/x-script.phyton'],
    ['pya', 'audio/vnd.ms-playready.media.pya'],
    ['pyc', 'application/x-bytecode.python'],
    ['pyv', 'video/vnd.ms-playready.media.pyv'],
    ['qam', 'application/vnd.epson.quickanime'],
    ['qbo', 'application/vnd.intu.qbo'],
    ['qcp', 'audio/vnd.qcelp'],
    ['qd3', 'x-world/x-3dmf'],
    ['qd3d', 'x-world/x-3dmf'],
    ['qfx', 'application/vnd.intu.qfx'],
    ['qif', 'image/x-quicktime'],
    ['qps', 'application/vnd.publishare-delta-tree'],
    ['qt', 'video/quicktime'],
    ['qtc', 'video/x-qtc'],
    ['qti', 'image/x-quicktime'],
    ['qtif', 'image/x-quicktime'],
    ['qxd', 'application/vnd.quark.quarkxpress'],
    ['ra', ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin']],
    ['ram', 'audio/x-pn-realaudio'],
    ['rar', 'application/x-rar-compressed'],
    ['ras', ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster']],
    ['rast', 'image/cmu-raster'],
    ['rcprofile', 'application/vnd.ipunplugged.rcprofile'],
    ['rdf', 'application/rdf+xml'],
    ['rdz', 'application/vnd.data-vision.rdz'],
    ['rep', 'application/vnd.businessobjects'],
    ['res', 'application/x-dtbresource+xml'],
    ['rexx', 'text/x-script.rexx'],
    ['rf', 'image/vnd.rn-realflash'],
    ['rgb', 'image/x-rgb'],
    ['rif', 'application/reginfo+xml'],
    ['rip', 'audio/vnd.rip'],
    ['rl', 'application/resource-lists+xml'],
    ['rlc', 'image/vnd.fujixerox.edmics-rlc'],
    ['rld', 'application/resource-lists-diff+xml'],
    ['rm', ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio']],
    ['rmi', 'audio/mid'],
    ['rmm', 'audio/x-pn-realaudio'],
    ['rmp', ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio']],
    ['rms', 'application/vnd.jcp.javame.midlet-rms'],
    ['rnc', 'application/relax-ng-compact-syntax'],
    ['rng', ['application/ringing-tones', 'application/vnd.nokia.ringing-tone']],
    ['rnx', 'application/vnd.rn-realplayer'],
    ['roff', 'application/x-troff'],
    ['rp', 'image/vnd.rn-realpix'],
    ['rp9', 'application/vnd.cloanto.rp9'],
    ['rpm', 'audio/x-pn-realaudio-plugin'],
    ['rpss', 'application/vnd.nokia.radio-presets'],
    ['rpst', 'application/vnd.nokia.radio-preset'],
    ['rq', 'application/sparql-query'],
    ['rs', 'application/rls-services+xml'],
    ['rsd', 'application/rsd+xml'],
    ['rt', ['text/richtext', 'text/vnd.rn-realtext']],
    ['rtf', ['application/rtf', 'text/richtext', 'application/x-rtf']],
    ['rtx', ['text/richtext', 'application/rtf']],
    ['rv', 'video/vnd.rn-realvideo'],
    ['s', 'text/x-asm'],
    ['s3m', 'audio/s3m'],
    ['saf', 'application/vnd.yamaha.smaf-audio'],
    ['saveme', 'application/octet-stream'],
    ['sbk', 'application/x-tbook'],
    ['sbml', 'application/sbml+xml'],
    ['sc', 'application/vnd.ibm.secure-container'],
    ['scd', 'application/x-msschedule'],
    ['scm', ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme']],
    ['scq', 'application/scvp-cv-request'],
    ['scs', 'application/scvp-cv-response'],
    ['sct', 'text/scriptlet'],
    ['scurl', 'text/vnd.curl.scurl'],
    ['sda', 'application/vnd.stardivision.draw'],
    ['sdc', 'application/vnd.stardivision.calc'],
    ['sdd', 'application/vnd.stardivision.impress'],
    ['sdkm', 'application/vnd.solent.sdkm+xml'],
    ['sdml', 'text/plain'],
    ['sdp', ['application/sdp', 'application/x-sdp']],
    ['sdr', 'application/sounder'],
    ['sdw', 'application/vnd.stardivision.writer'],
    ['sea', ['application/sea', 'application/x-sea']],
    ['see', 'application/vnd.seemail'],
    ['seed', 'application/vnd.fdsn.seed'],
    ['sema', 'application/vnd.sema'],
    ['semd', 'application/vnd.semd'],
    ['semf', 'application/vnd.semf'],
    ['ser', 'application/java-serialized-object'],
    ['set', 'application/set'],
    ['setpay', 'application/set-payment-initiation'],
    ['setreg', 'application/set-registration-initiation'],
    ['sfd-hdstx', 'application/vnd.hydrostatix.sof-data'],
    ['sfs', 'application/vnd.spotfire.sfs'],
    ['sgl', 'application/vnd.stardivision.writer-global'],
    ['sgm', ['text/sgml', 'text/x-sgml']],
    ['sgml', ['text/sgml', 'text/x-sgml']],
    ['sh', ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh']],
    ['shar', ['application/x-bsh', 'application/x-shar']],
    ['shf', 'application/shf+xml'],
    ['shtml', ['text/html', 'text/x-server-parsed-html']],
    ['sid', 'audio/x-psid'],
    ['sis', 'application/vnd.symbian.install'],
    ['sit', ['application/x-stuffit', 'application/x-sit']],
    ['sitx', 'application/x-stuffitx'],
    ['skd', 'application/x-koan'],
    ['skm', 'application/x-koan'],
    ['skp', ['application/vnd.koan', 'application/x-koan']],
    ['skt', 'application/x-koan'],
    ['sl', 'application/x-seelogo'],
    ['sldm', 'application/vnd.ms-powerpoint.slide.macroenabled.12'],
    ['sldx', 'application/vnd.openxmlformats-officedocument.presentationml.slide'],
    ['slt', 'application/vnd.epson.salt'],
    ['sm', 'application/vnd.stepmania.stepchart'],
    ['smf', 'application/vnd.stardivision.math'],
    ['smi', ['application/smil', 'application/smil+xml']],
    ['smil', 'application/smil'],
    ['snd', ['audio/basic', 'audio/x-adpcm']],
    ['snf', 'application/x-font-snf'],
    ['sol', 'application/solids'],
    ['spc', ['text/x-speech', 'application/x-pkcs7-certificates']],
    ['spf', 'application/vnd.yamaha.smaf-phrase'],
    ['spl', ['application/futuresplash', 'application/x-futuresplash']],
    ['spot', 'text/vnd.in3d.spot'],
    ['spp', 'application/scvp-vp-response'],
    ['spq', 'application/scvp-vp-request'],
    ['spr', 'application/x-sprite'],
    ['sprite', 'application/x-sprite'],
    ['src', 'application/x-wais-source'],
    ['sru', 'application/sru+xml'],
    ['srx', 'application/sparql-results+xml'],
    ['sse', 'application/vnd.kodak-descriptor'],
    ['ssf', 'application/vnd.epson.ssf'],
    ['ssi', 'text/x-server-parsed-html'],
    ['ssm', 'application/streamingmedia'],
    ['ssml', 'application/ssml+xml'],
    ['sst', ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore']],
    ['st', 'application/vnd.sailingtracker.track'],
    ['stc', 'application/vnd.sun.xml.calc.template'],
    ['std', 'application/vnd.sun.xml.draw.template'],
    ['step', 'application/step'],
    ['stf', 'application/vnd.wt.stf'],
    ['sti', 'application/vnd.sun.xml.impress.template'],
    ['stk', 'application/hyperstudio'],
    ['stl', ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle']],
    ['stm', 'text/html'],
    ['stp', 'application/step'],
    ['str', 'application/vnd.pg.format'],
    ['stw', 'application/vnd.sun.xml.writer.template'],
    ['sub', 'image/vnd.dvb.subtitle'],
    ['sus', 'application/vnd.sus-calendar'],
    ['sv4cpio', 'application/x-sv4cpio'],
    ['sv4crc', 'application/x-sv4crc'],
    ['svc', 'application/vnd.dvb.service'],
    ['svd', 'application/vnd.svd'],
    ['svf', ['image/vnd.dwg', 'image/x-dwg']],
    ['svg', 'image/svg+xml'],
    ['svr', ['x-world/x-svr', 'application/x-world']],
    ['swf', 'application/x-shockwave-flash'],
    ['swi', 'application/vnd.aristanetworks.swi'],
    ['sxc', 'application/vnd.sun.xml.calc'],
    ['sxd', 'application/vnd.sun.xml.draw'],
    ['sxg', 'application/vnd.sun.xml.writer.global'],
    ['sxi', 'application/vnd.sun.xml.impress'],
    ['sxm', 'application/vnd.sun.xml.math'],
    ['sxw', 'application/vnd.sun.xml.writer'],
    ['t', ['text/troff', 'application/x-troff']],
    ['talk', 'text/x-speech'],
    ['tao', 'application/vnd.tao.intent-module-archive'],
    ['tar', 'application/x-tar'],
    ['tbk', ['application/toolbook', 'application/x-tbook']],
    ['tcap', 'application/vnd.3gpp2.tcap'],
    ['tcl', ['text/x-script.tcl', 'application/x-tcl']],
    ['tcsh', 'text/x-script.tcsh'],
    ['teacher', 'application/vnd.smart.teacher'],
    ['tei', 'application/tei+xml'],
    ['tex', 'application/x-tex'],
    ['texi', 'application/x-texinfo'],
    ['texinfo', 'application/x-texinfo'],
    ['text', ['application/plain', 'text/plain']],
    ['tfi', 'application/thraud+xml'],
    ['tfm', 'application/x-tex-tfm'],
    ['tgz', ['application/gnutar', 'application/x-compressed']],
    ['thmx', 'application/vnd.ms-officetheme'],
    ['tif', ['image/tiff', 'image/x-tiff']],
    ['tiff', ['image/tiff', 'image/x-tiff']],
    ['tmo', 'application/vnd.tmobile-livetv'],
    ['torrent', 'application/x-bittorrent'],
    ['tpl', 'application/vnd.groove-tool-template'],
    ['tpt', 'application/vnd.trid.tpt'],
    ['tr', 'application/x-troff'],
    ['tra', 'application/vnd.trueapp'],
    ['trm', 'application/x-msterminal'],
    ['tsd', 'application/timestamped-data'],
    ['tsi', 'audio/tsp-audio'],
    ['tsp', ['application/dsptype', 'audio/tsplayer']],
    ['tsv', 'text/tab-separated-values'],
    ['ttf', 'application/x-font-ttf'],
    ['ttl', 'text/turtle'],
    ['turbot', 'image/florian'],
    ['twd', 'application/vnd.simtech-mindmapper'],
    ['txd', 'application/vnd.genomatix.tuxedo'],
    ['txf', 'application/vnd.mobius.txf'],
    ['txt', 'text/plain'],
    ['ufd', 'application/vnd.ufdl'],
    ['uil', 'text/x-uil'],
    ['uls', 'text/iuls'],
    ['umj', 'application/vnd.umajin'],
    ['uni', 'text/uri-list'],
    ['unis', 'text/uri-list'],
    ['unityweb', 'application/vnd.unity'],
    ['unv', 'application/i-deas'],
    ['uoml', 'application/vnd.uoml+xml'],
    ['uri', 'text/uri-list'],
    ['uris', 'text/uri-list'],
    ['ustar', ['application/x-ustar', 'multipart/x-ustar']],
    ['utz', 'application/vnd.uiq.theme'],
    ['uu', ['application/octet-stream', 'text/x-uuencode']],
    ['uue', 'text/x-uuencode'],
    ['uva', 'audio/vnd.dece.audio'],
    ['uvh', 'video/vnd.dece.hd'],
    ['uvi', 'image/vnd.dece.graphic'],
    ['uvm', 'video/vnd.dece.mobile'],
    ['uvp', 'video/vnd.dece.pd'],
    ['uvs', 'video/vnd.dece.sd'],
    ['uvu', 'video/vnd.uvvu.mp4'],
    ['uvv', 'video/vnd.dece.video'],
    ['vcd', 'application/x-cdlink'],
    ['vcf', 'text/x-vcard'],
    ['vcg', 'application/vnd.groove-vcard'],
    ['vcs', 'text/x-vcalendar'],
    ['vcx', 'application/vnd.vcx'],
    ['vda', 'application/vda'],
    ['vdo', 'video/vdo'],
    ['vew', 'application/groupwise'],
    ['vis', 'application/vnd.visionary'],
    ['viv', ['video/vivo', 'video/vnd.vivo']],
    ['vivo', ['video/vivo', 'video/vnd.vivo']],
    ['vmd', 'application/vocaltec-media-desc'],
    ['vmf', 'application/vocaltec-media-file'],
    ['voc', ['audio/voc', 'audio/x-voc']],
    ['vos', 'video/vosaic'],
    ['vox', 'audio/voxware'],
    ['vqe', 'audio/x-twinvq-plugin'],
    ['vqf', 'audio/x-twinvq'],
    ['vql', 'audio/x-twinvq-plugin'],
    ['vrml', ['model/vrml', 'x-world/x-vrml', 'application/x-vrml']],
    ['vrt', 'x-world/x-vrt'],
    ['vsd', ['application/vnd.visio', 'application/x-visio']],
    ['vsf', 'application/vnd.vsf'],
    ['vst', 'application/x-visio'],
    ['vsw', 'application/x-visio'],
    ['vtu', 'model/vnd.vtu'],
    ['vxml', 'application/voicexml+xml'],
    ['w60', 'application/wordperfect6.0'],
    ['w61', 'application/wordperfect6.1'],
    ['w6w', 'application/msword'],
    ['wad', 'application/x-doom'],
    ['wav', ['audio/wav', 'audio/x-wav']],
    ['wax', 'audio/x-ms-wax'],
    ['wb1', 'application/x-qpro'],
    ['wbmp', 'image/vnd.wap.wbmp'],
    ['wbs', 'application/vnd.criticaltools.wbs+xml'],
    ['wbxml', 'application/vnd.wap.wbxml'],
    ['wcm', 'application/vnd.ms-works'],
    ['wdb', 'application/vnd.ms-works'],
    ['web', 'application/vnd.xara'],
    ['weba', 'audio/webm'],
    ['webm', 'video/webm'],
    ['webp', 'image/webp'],
    ['wg', 'application/vnd.pmi.widget'],
    ['wgt', 'application/widget'],
    ['wiz', 'application/msword'],
    ['wk1', 'application/x-123'],
    ['wks', 'application/vnd.ms-works'],
    ['wm', 'video/x-ms-wm'],
    ['wma', 'audio/x-ms-wma'],
    ['wmd', 'application/x-ms-wmd'],
    ['wmf', ['windows/metafile', 'application/x-msmetafile']],
    ['wml', 'text/vnd.wap.wml'],
    ['wmlc', 'application/vnd.wap.wmlc'],
    ['wmls', 'text/vnd.wap.wmlscript'],
    ['wmlsc', 'application/vnd.wap.wmlscriptc'],
    ['wmv', 'video/x-ms-wmv'],
    ['wmx', 'video/x-ms-wmx'],
    ['wmz', 'application/x-ms-wmz'],
    ['woff', 'application/x-font-woff'],
    ['word', 'application/msword'],
    ['wp', 'application/wordperfect'],
    ['wp5', ['application/wordperfect', 'application/wordperfect6.0']],
    ['wp6', 'application/wordperfect'],
    ['wpd', ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin']],
    ['wpl', 'application/vnd.ms-wpl'],
    ['wps', 'application/vnd.ms-works'],
    ['wq1', 'application/x-lotus'],
    ['wqd', 'application/vnd.wqd'],
    ['wri', ['application/mswrite', 'application/x-wri', 'application/x-mswrite']],
    ['wrl', ['model/vrml', 'x-world/x-vrml', 'application/x-world']],
    ['wrz', ['model/vrml', 'x-world/x-vrml']],
    ['wsc', 'text/scriplet'],
    ['wsdl', 'application/wsdl+xml'],
    ['wspolicy', 'application/wspolicy+xml'],
    ['wsrc', 'application/x-wais-source'],
    ['wtb', 'application/vnd.webturbo'],
    ['wtk', 'application/x-wintalk'],
    ['wvx', 'video/x-ms-wvx'],
    ['x-png', 'image/png'],
    ['x3d', 'application/vnd.hzn-3d-crossword'],
    ['xaf', 'x-world/x-vrml'],
    ['xap', 'application/x-silverlight-app'],
    ['xar', 'application/vnd.xara'],
    ['xbap', 'application/x-ms-xbap'],
    ['xbd', 'application/vnd.fujixerox.docuworks.binder'],
    ['xbm', ['image/xbm', 'image/x-xbm', 'image/x-xbitmap']],
    ['xdf', 'application/xcap-diff+xml'],
    ['xdm', 'application/vnd.syncml.dm+xml'],
    ['xdp', 'application/vnd.adobe.xdp+xml'],
    ['xdr', 'video/x-amt-demorun'],
    ['xdssc', 'application/dssc+xml'],
    ['xdw', 'application/vnd.fujixerox.docuworks'],
    ['xenc', 'application/xenc+xml'],
    ['xer', 'application/patch-ops-error+xml'],
    ['xfdf', 'application/vnd.adobe.xfdf'],
    ['xfdl', 'application/vnd.xfdl'],
    ['xgz', 'xgl/drawing'],
    ['xhtml', 'application/xhtml+xml'],
    ['xif', 'image/vnd.xiff'],
    ['xl', 'application/excel'],
    ['xla', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
    ['xlam', 'application/vnd.ms-excel.addin.macroenabled.12'],
    ['xlb', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],
    ['xlc', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
    ['xld', ['application/excel', 'application/x-excel']],
    ['xlk', ['application/excel', 'application/x-excel']],
    ['xll', ['application/excel', 'application/vnd.ms-excel', 'application/x-excel']],
    ['xlm', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
    ['xls', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
    ['xlsb', 'application/vnd.ms-excel.sheet.binary.macroenabled.12'],
    ['xlsm', 'application/vnd.ms-excel.sheet.macroenabled.12'],
    ['xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
    ['xlt', ['application/vnd.ms-excel', 'application/excel', 'application/x-excel']],
    ['xltm', 'application/vnd.ms-excel.template.macroenabled.12'],
    ['xltx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.template'],
    ['xlv', ['application/excel', 'application/x-excel']],
    ['xlw', ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel']],
    ['xm', 'audio/xm'],
    ['xml', ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml']],
    ['xmz', 'xgl/movie'],
    ['xo', 'application/vnd.olpc-sugar'],
    ['xof', 'x-world/x-vrml'],
    ['xop', 'application/xop+xml'],
    ['xpi', 'application/x-xpinstall'],
    ['xpix', 'application/x-vnd.ls-xpix'],
    ['xpm', ['image/xpm', 'image/x-xpixmap']],
    ['xpr', 'application/vnd.is-xpr'],
    ['xps', 'application/vnd.ms-xpsdocument'],
    ['xpw', 'application/vnd.intercon.formnet'],
    ['xslt', 'application/xslt+xml'],
    ['xsm', 'application/vnd.syncml+xml'],
    ['xspf', 'application/xspf+xml'],
    ['xsr', 'video/x-amt-showrun'],
    ['xul', 'application/vnd.mozilla.xul+xml'],
    ['xwd', ['image/x-xwd', 'image/x-xwindowdump']],
    ['xyz', ['chemical/x-xyz', 'chemical/x-pdb']],
    ['yang', 'application/yang'],
    ['yin', 'application/yin+xml'],
    ['z', ['application/x-compressed', 'application/x-compress']],
    ['zaz', 'application/vnd.zzazz.deck+xml'],
    ['zip', ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed']],
    ['zir', 'application/vnd.zul'],
    ['zmm', 'application/vnd.handheld-entertainment+xml'],
    ['zoo', 'application/octet-stream'],
    ['zsh', 'text/x-script.zsh']
]);

module.exports = {
    detectMimeType(filename) {
        if (!filename) {
            return defaultMimeType;
        }

        let parsed = path.parse(filename);
        let extension = (parsed.ext.substr(1) || parsed.name || '').split('?').shift().trim().toLowerCase();
        let value = defaultMimeType;

        if (extensions.has(extension)) {
            value = extensions.get(extension);
        }

        if (Array.isArray(value)) {
            return value[0];
        }
        return value;
    },

    detectExtension(mimeType) {
        if (!mimeType) {
            return defaultExtension;
        }
        let parts = (mimeType || '').toLowerCase().trim().split('/');
        let rootType = parts.shift().trim();
        let subType = parts.join('/').trim();

        if (mimeTypes.has(rootType + '/' + subType)) {
            let value = mimeTypes.get(rootType + '/' + subType);
            if (Array.isArray(value)) {
                return value[0];
            }
            return value;
        }

        switch (rootType) {
            case 'text':
                return 'txt';
            default:
                return 'bin';
        }
    }
};


/***/ }),

/***/ 758820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-undefined: 0, prefer-spread: 0, no-control-regex: 0 */



const crypto = __webpack_require__(455511);
const fs = __webpack_require__(629021);
const punycode = __webpack_require__(155338);
const PassThrough = (__webpack_require__(927910).PassThrough);
const shared = __webpack_require__(835028);

const mimeFuncs = __webpack_require__(595311);
const qp = __webpack_require__(620964);
const base64 = __webpack_require__(866322);
const addressparser = __webpack_require__(188388);
const nmfetch = __webpack_require__(34843);
const LastNewline = __webpack_require__(161775);

const LeWindows = __webpack_require__(610337);
const LeUnix = __webpack_require__(568012);

/**
 * Creates a new mime tree node. Assumes 'multipart/*' as the content type
 * if it is a branch, anything else counts as leaf. If rootNode is missing from
 * the options, assumes this is the root.
 *
 * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
 * @param {Object} [options] optional options
 * @param {Object} [options.rootNode] root node for this tree
 * @param {Object} [options.parentNode] immediate parent for this node
 * @param {Object} [options.filename] filename for an attachment node
 * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
 * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
 * @param {Function} [options.normalizeHeaderKey] method to normalize header keys for custom caseing
 * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'
 */
class MimeNode {
    constructor(contentType, options) {
        this.nodeCounter = 0;

        options = options || {};

        /**
         * shared part of the unique multipart boundary
         */
        this.baseBoundary = options.baseBoundary || crypto.randomBytes(8).toString('hex');
        this.boundaryPrefix = options.boundaryPrefix || '--_NmP';

        this.disableFileAccess = !!options.disableFileAccess;
        this.disableUrlAccess = !!options.disableUrlAccess;

        this.normalizeHeaderKey = options.normalizeHeaderKey;

        /**
         * If date headers is missing and current node is the root, this value is used instead
         */
        this.date = new Date();

        /**
         * Root node for current mime tree
         */
        this.rootNode = options.rootNode || this;

        /**
         * If true include Bcc in generated headers (if available)
         */
        this.keepBcc = !!options.keepBcc;

        /**
         * If filename is specified but contentType is not (probably an attachment)
         * detect the content type from filename extension
         */
        if (options.filename) {
            /**
             * Filename for this node. Useful with attachments
             */
            this.filename = options.filename;
            if (!contentType) {
                contentType = mimeFuncs.detectMimeType(this.filename.split('.').pop());
            }
        }

        /**
         * Indicates which encoding should be used for header strings: "Q" or "B"
         */
        this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();

        /**
         * Immediate parent for this node (or undefined if not set)
         */
        this.parentNode = options.parentNode;

        /**
         * Hostname for default message-id values
         */
        this.hostname = options.hostname;

        /**
         * If set to 'win' then uses \r\n, if 'linux' then \n. If not set (or `raw` is used) then newlines are kept as is.
         */
        this.newline = options.newline;

        /**
         * An array for possible child nodes
         */
        this.childNodes = [];

        /**
         * Used for generating unique boundaries (prepended to the shared base)
         */
        this._nodeId = ++this.rootNode.nodeCounter;

        /**
         * A list of header values for this node in the form of [{key:'', value:''}]
         */
        this._headers = [];

        /**
         * True if the content only uses ASCII printable characters
         * @type {Boolean}
         */
        this._isPlainText = false;

        /**
         * True if the content is plain text but has longer lines than allowed
         * @type {Boolean}
         */
        this._hasLongLines = false;

        /**
         * If set, use instead this value for envelopes instead of generating one
         * @type {Boolean}
         */
        this._envelope = false;

        /**
         * If set then use this value as the stream content instead of building it
         * @type {String|Buffer|Stream}
         */
        this._raw = false;

        /**
         * Additional transform streams that the message will be piped before
         * exposing by createReadStream
         * @type {Array}
         */
        this._transforms = [];

        /**
         * Additional process functions that the message will be piped through before
         * exposing by createReadStream. These functions are run after transforms
         * @type {Array}
         */
        this._processFuncs = [];

        /**
         * If content type is set (or derived from the filename) add it to headers
         */
        if (contentType) {
            this.setHeader('Content-Type', contentType);
        }
    }

    /////// PUBLIC METHODS

    /**
     * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
     *
     * @param {String} [contentType] Optional content type
     * @param {Object} [options] Optional options object
     * @return {Object} Created node object
     */
    createChild(contentType, options) {
        if (!options && typeof contentType === 'object') {
            options = contentType;
            contentType = undefined;
        }
        let node = new MimeNode(contentType, options);
        this.appendChild(node);
        return node;
    }

    /**
     * Appends an existing node to the mime tree. Removes the node from an existing
     * tree if needed
     *
     * @param {Object} childNode node to be appended
     * @return {Object} Appended node object
     */
    appendChild(childNode) {
        if (childNode.rootNode !== this.rootNode) {
            childNode.rootNode = this.rootNode;
            childNode._nodeId = ++this.rootNode.nodeCounter;
        }

        childNode.parentNode = this;

        this.childNodes.push(childNode);
        return childNode;
    }

    /**
     * Replaces current node with another node
     *
     * @param {Object} node Replacement node
     * @return {Object} Replacement node
     */
    replace(node) {
        if (node === this) {
            return this;
        }

        this.parentNode.childNodes.forEach((childNode, i) => {
            if (childNode === this) {
                node.rootNode = this.rootNode;
                node.parentNode = this.parentNode;
                node._nodeId = this._nodeId;

                this.rootNode = this;
                this.parentNode = undefined;

                node.parentNode.childNodes[i] = node;
            }
        });

        return node;
    }

    /**
     * Removes current node from the mime tree
     *
     * @return {Object} removed node
     */
    remove() {
        if (!this.parentNode) {
            return this;
        }

        for (let i = this.parentNode.childNodes.length - 1; i >= 0; i--) {
            if (this.parentNode.childNodes[i] === this) {
                this.parentNode.childNodes.splice(i, 1);
                this.parentNode = undefined;
                this.rootNode = this;
                return this;
            }
        }
    }

    /**
     * Sets a header value. If the value for selected key exists, it is overwritten.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    setHeader(key, value) {
        let added = false,
            headerValue;

        // Allow setting multiple headers at once
        if (!value && key && typeof key === 'object') {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && 'value' in key) {
                this.setHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach(i => {
                    this.setHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach(i => {
                    this.setHeader(i, key[i]);
                });
            }
            return this;
        }

        key = this._normalizeHeaderKey(key);

        headerValue = {
            key,
            value
        };

        // Check if the value exists and overwrite
        for (let i = 0, len = this._headers.length; i < len; i++) {
            if (this._headers[i].key === key) {
                if (!added) {
                    // replace the first match
                    this._headers[i] = headerValue;
                    added = true;
                } else {
                    // remove following matches
                    this._headers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }

        // match not found, append the value
        if (!added) {
            this._headers.push(headerValue);
        }

        return this;
    }

    /**
     * Adds a header value. If the value for selected key exists, the value is appended
     * as a new field and old one is not touched.
     * You can set multiple values as well by using [{key:'', value:''}] or
     * {key: 'value'} as the first argument.
     *
     * @param {String|Array|Object} key Header key or a list of key value pairs
     * @param {String} value Header value
     * @return {Object} current node
     */
    addHeader(key, value) {
        // Allow setting multiple headers at once
        if (!value && key && typeof key === 'object') {
            // allow {key:'content-type', value: 'text/plain'}
            if (key.key && key.value) {
                this.addHeader(key.key, key.value);
            } else if (Array.isArray(key)) {
                // allow [{key:'content-type', value: 'text/plain'}]
                key.forEach(i => {
                    this.addHeader(i.key, i.value);
                });
            } else {
                // allow {'content-type': 'text/plain'}
                Object.keys(key).forEach(i => {
                    this.addHeader(i, key[i]);
                });
            }
            return this;
        } else if (Array.isArray(value)) {
            value.forEach(val => {
                this.addHeader(key, val);
            });
            return this;
        }

        this._headers.push({
            key: this._normalizeHeaderKey(key),
            value
        });

        return this;
    }

    /**
     * Retrieves the first mathcing value of a selected key
     *
     * @param {String} key Key to search for
     * @retun {String} Value for the key
     */
    getHeader(key) {
        key = this._normalizeHeaderKey(key);
        for (let i = 0, len = this._headers.length; i < len; i++) {
            if (this._headers[i].key === key) {
                return this._headers[i].value;
            }
        }
    }

    /**
     * Sets body content for current node. If the value is a string, charset is added automatically
     * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
     * the charset yourself
     *
     * @param (String|Buffer) content Body content
     * @return {Object} current node
     */
    setContent(content) {
        this.content = content;
        if (typeof this.content.pipe === 'function') {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = err => {
                this.content.removeListener('error', this._contentErrorHandler);
                this.content = err;
            };
            this.content.once('error', this._contentErrorHandler);
        } else if (typeof this.content === 'string') {
            this._isPlainText = mimeFuncs.isPlainText(this.content);
            if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
                // If there are lines longer than 76 symbols/bytes do not use 7bit
                this._hasLongLines = true;
            }
        }
        return this;
    }

    build(callback) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) => {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        let stream = this.createReadStream();
        let buf = [];
        let buflen = 0;
        let returned = false;

        stream.on('readable', () => {
            let chunk;

            while ((chunk = stream.read()) !== null) {
                buf.push(chunk);
                buflen += chunk.length;
            }
        });

        stream.once('error', err => {
            if (returned) {
                return;
            }
            returned = true;

            return callback(err);
        });

        stream.once('end', chunk => {
            if (returned) {
                return;
            }
            returned = true;

            if (chunk && chunk.length) {
                buf.push(chunk);
                buflen += chunk.length;
            }
            return callback(null, Buffer.concat(buf, buflen));
        });

        return promise;
    }

    getTransferEncoding() {
        let transferEncoding = false;
        let contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();

        if (this.content) {
            transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();
            if (!transferEncoding || !['base64', 'quoted-printable'].includes(transferEncoding)) {
                if (/^text\//i.test(contentType)) {
                    // If there are no special symbols, no need to modify the text
                    if (this._isPlainText && !this._hasLongLines) {
                        transferEncoding = '7bit';
                    } else if (typeof this.content === 'string' || this.content instanceof Buffer) {
                        // detect preferred encoding for string value
                        transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';
                    } else {
                        // we can not check content for a stream, so either use preferred encoding or fallback to QP
                        transferEncoding = this.textEncoding === 'B' ? 'base64' : 'quoted-printable';
                    }
                } else if (!/^(multipart|message)\//i.test(contentType)) {
                    transferEncoding = transferEncoding || 'base64';
                }
            }
        }
        return transferEncoding;
    }

    /**
     * Builds the header block for the mime node. Append \r\n\r\n before writing the content
     *
     * @returns {String} Headers
     */
    buildHeaders() {
        let transferEncoding = this.getTransferEncoding();
        let headers = [];

        if (transferEncoding) {
            this.setHeader('Content-Transfer-Encoding', transferEncoding);
        }

        if (this.filename && !this.getHeader('Content-Disposition')) {
            this.setHeader('Content-Disposition', 'attachment');
        }

        // Ensure mandatory header fields
        if (this.rootNode === this) {
            if (!this.getHeader('Date')) {
                this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));
            }

            // ensure that Message-Id is present
            this.messageId();

            if (!this.getHeader('MIME-Version')) {
                this.setHeader('MIME-Version', '1.0');
            }

            // Ensure that Content-Type is the last header for the root node
            for (let i = this._headers.length - 2; i >= 0; i--) {
                let header = this._headers[i];
                if (header.key === 'Content-Type') {
                    this._headers.splice(i, 1);
                    this._headers.push(header);
                }
            }
        }

        this._headers.forEach(header => {
            let key = header.key;
            let value = header.value;
            let structured;
            let param;
            let options = {};
            let formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];

            if (value && typeof value === 'object' && !formattedHeaders.includes(key)) {
                Object.keys(value).forEach(key => {
                    if (key !== 'value') {
                        options[key] = value[key];
                    }
                });
                value = (value.value || '').toString();
                if (!value.trim()) {
                    return;
                }
            }

            if (options.prepared) {
                // header value is
                if (options.foldLines) {
                    headers.push(mimeFuncs.foldLines(key + ': ' + value));
                } else {
                    headers.push(key + ': ' + value);
                }
                return;
            }

            switch (header.key) {
                case 'Content-Disposition':
                    structured = mimeFuncs.parseHeaderValue(value);
                    if (this.filename) {
                        structured.params.filename = this.filename;
                    }
                    value = mimeFuncs.buildHeaderValue(structured);
                    break;

                case 'Content-Type':
                    structured = mimeFuncs.parseHeaderValue(value);

                    this._handleContentType(structured);

                    if (structured.value.match(/^text\/plain\b/) && typeof this.content === 'string' && /[\u0080-\uFFFF]/.test(this.content)) {
                        structured.params.charset = 'utf-8';
                    }

                    value = mimeFuncs.buildHeaderValue(structured);

                    if (this.filename) {
                        // add support for non-compliant clients like QQ webmail
                        // we can't build the value with buildHeaderValue as the value is non standard and
                        // would be converted to parameter continuation encoding that we do not want
                        param = this._encodeWords(this.filename);

                        if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                            // include value in quotes if needed
                            param = '"' + param + '"';
                        }
                        value += '; name=' + param;
                    }
                    break;

                case 'Bcc':
                    if (!this.keepBcc) {
                        // skip BCC values
                        return;
                    }
                    break;
            }

            value = this._encodeHeaderValue(key, value);

            // skip empty lines
            if (!(value || '').toString().trim()) {
                return;
            }

            if (typeof this.normalizeHeaderKey === 'function') {
                let normalized = this.normalizeHeaderKey(key, value);
                if (normalized && typeof normalized === 'string' && normalized.length) {
                    key = normalized;
                }
            }

            headers.push(mimeFuncs.foldLines(key + ': ' + value, 76));
        });

        return headers.join('\r\n');
    }

    /**
     * Streams the rfc2822 message from the current node. If this is a root node,
     * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
     *
     * @return {String} Compiled message
     */
    createReadStream(options) {
        options = options || {};

        let stream = new PassThrough(options);
        let outputStream = stream;
        let transform;

        this.stream(stream, options, err => {
            if (err) {
                outputStream.emit('error', err);
                return;
            }
            stream.end();
        });

        for (let i = 0, len = this._transforms.length; i < len; i++) {
            transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];
            outputStream.once('error', err => {
                transform.emit('error', err);
            });
            outputStream = outputStream.pipe(transform);
        }

        // ensure terminating newline after possible user transforms
        transform = new LastNewline();
        outputStream.once('error', err => {
            transform.emit('error', err);
        });
        outputStream = outputStream.pipe(transform);

        // dkim and stuff
        for (let i = 0, len = this._processFuncs.length; i < len; i++) {
            transform = this._processFuncs[i];
            outputStream = transform(outputStream);
        }

        if (this.newline) {
            const winbreak = ['win', 'windows', 'dos', '\r\n'].includes(this.newline.toString().toLowerCase());
            const newlineTransform = winbreak ? new LeWindows() : new LeUnix();

            const stream = outputStream.pipe(newlineTransform);
            outputStream.on('error', err => stream.emit('error', err));
            return stream;
        }

        return outputStream;
    }

    /**
     * Appends a transform stream object to the transforms list. Final output
     * is passed through this stream before exposing
     *
     * @param {Object} transform Read-Write stream
     */
    transform(transform) {
        this._transforms.push(transform);
    }

    /**
     * Appends a post process function. The functon is run after transforms and
     * uses the following syntax
     *
     *   processFunc(input) -> outputStream
     *
     * @param {Object} processFunc Read-Write stream
     */
    processFunc(processFunc) {
        this._processFuncs.push(processFunc);
    }

    stream(outputStream, options, done) {
        let transferEncoding = this.getTransferEncoding();
        let contentStream;
        let localStream;

        // protect actual callback against multiple triggering
        let returned = false;
        let callback = err => {
            if (returned) {
                return;
            }
            returned = true;
            done(err);
        };

        // for multipart nodes, push child nodes
        // for content nodes end the stream
        let finalize = () => {
            let childId = 0;
            let processChildNode = () => {
                if (childId >= this.childNodes.length) {
                    outputStream.write('\r\n--' + this.boundary + '--\r\n');
                    return callback();
                }
                let child = this.childNodes[childId++];
                outputStream.write((childId > 1 ? '\r\n' : '') + '--' + this.boundary + '\r\n');
                child.stream(outputStream, options, err => {
                    if (err) {
                        return callback(err);
                    }
                    setImmediate(processChildNode);
                });
            };

            if (this.multipart) {
                setImmediate(processChildNode);
            } else {
                return callback();
            }
        };

        // pushes node content
        let sendContent = () => {
            if (this.content) {
                if (Object.prototype.toString.call(this.content) === '[object Error]') {
                    // content is already errored
                    return callback(this.content);
                }

                if (typeof this.content.pipe === 'function') {
                    this.content.removeListener('error', this._contentErrorHandler);
                    this._contentErrorHandler = err => callback(err);
                    this.content.once('error', this._contentErrorHandler);
                }

                let createStream = () => {
                    if (['quoted-printable', 'base64'].includes(transferEncoding)) {
                        contentStream = new (transferEncoding === 'base64' ? base64 : qp).Encoder(options);

                        contentStream.pipe(outputStream, {
                            end: false
                        });
                        contentStream.once('end', finalize);
                        contentStream.once('error', err => callback(err));

                        localStream = this._getStream(this.content);
                        localStream.pipe(contentStream);
                    } else {
                        // anything that is not QP or Base54 passes as-is
                        localStream = this._getStream(this.content);
                        localStream.pipe(outputStream, {
                            end: false
                        });
                        localStream.once('end', finalize);
                    }

                    localStream.once('error', err => callback(err));
                };

                if (this.content._resolve) {
                    let chunks = [];
                    let chunklen = 0;
                    let returned = false;
                    let sourceStream = this._getStream(this.content);
                    sourceStream.on('error', err => {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        callback(err);
                    });
                    sourceStream.on('readable', () => {
                        let chunk;
                        while ((chunk = sourceStream.read()) !== null) {
                            chunks.push(chunk);
                            chunklen += chunk.length;
                        }
                    });
                    sourceStream.on('end', () => {
                        if (returned) {
                            return;
                        }
                        returned = true;
                        this.content._resolve = false;
                        this.content._resolvedValue = Buffer.concat(chunks, chunklen);
                        setImmediate(createStream);
                    });
                } else {
                    setImmediate(createStream);
                }
                return;
            } else {
                return setImmediate(finalize);
            }
        };

        if (this._raw) {
            setImmediate(() => {
                if (Object.prototype.toString.call(this._raw) === '[object Error]') {
                    // content is already errored
                    return callback(this._raw);
                }

                // remove default error handler (if set)
                if (typeof this._raw.pipe === 'function') {
                    this._raw.removeListener('error', this._contentErrorHandler);
                }

                let raw = this._getStream(this._raw);
                raw.pipe(outputStream, {
                    end: false
                });
                raw.on('error', err => outputStream.emit('error', err));
                raw.on('end', finalize);
            });
        } else {
            outputStream.write(this.buildHeaders() + '\r\n\r\n');
            setImmediate(sendContent);
        }
    }

    /**
     * Sets envelope to be used instead of the generated one
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */
    setEnvelope(envelope) {
        let list;

        this._envelope = {
            from: false,
            to: []
        };

        if (envelope.from) {
            list = [];
            this._convertAddresses(this._parseAddresses(envelope.from), list);
            list = list.filter(address => address && address.address);
            if (list.length && list[0]) {
                this._envelope.from = list[0].address;
            }
        }
        ['to', 'cc', 'bcc'].forEach(key => {
            if (envelope[key]) {
                this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
            }
        });

        this._envelope.to = this._envelope.to.map(to => to.address).filter(address => address);

        let standardFields = ['to', 'cc', 'bcc', 'from'];
        Object.keys(envelope).forEach(key => {
            if (!standardFields.includes(key)) {
                this._envelope[key] = envelope[key];
            }
        });

        return this;
    }

    /**
     * Generates and returns an object with parsed address fields
     *
     * @return {Object} Address object
     */
    getAddresses() {
        let addresses = {};

        this._headers.forEach(header => {
            let key = header.key.toLowerCase();
            if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].includes(key)) {
                if (!Array.isArray(addresses[key])) {
                    addresses[key] = [];
                }

                this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
            }
        });

        return addresses;
    }

    /**
     * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
     *
     * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
     */
    getEnvelope() {
        if (this._envelope) {
            return this._envelope;
        }

        let envelope = {
            from: false,
            to: []
        };
        this._headers.forEach(header => {
            let list = [];
            if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].includes(header.key))) {
                this._convertAddresses(this._parseAddresses(header.value), list);
                if (list.length && list[0]) {
                    envelope.from = list[0].address;
                }
            } else if (['To', 'Cc', 'Bcc'].includes(header.key)) {
                this._convertAddresses(this._parseAddresses(header.value), envelope.to);
            }
        });

        envelope.to = envelope.to.map(to => to.address);

        return envelope;
    }

    /**
     * Returns Message-Id value. If it does not exist, then creates one
     *
     * @return {String} Message-Id value
     */
    messageId() {
        let messageId = this.getHeader('Message-ID');
        // You really should define your own Message-Id field!
        if (!messageId) {
            messageId = this._generateMessageId();
            this.setHeader('Message-ID', messageId);
        }
        return messageId;
    }

    /**
     * Sets pregenerated content that will be used as the output of this node
     *
     * @param {String|Buffer|Stream} Raw MIME contents
     */
    setRaw(raw) {
        this._raw = raw;

        if (this._raw && typeof this._raw.pipe === 'function') {
            // pre-stream handler. might be triggered if a stream is set as content
            // and 'error' fires before anything is done with this stream
            this._contentErrorHandler = err => {
                this._raw.removeListener('error', this._contentErrorHandler);
                this._raw = err;
            };
            this._raw.once('error', this._contentErrorHandler);
        }

        return this;
    }

    /////// PRIVATE METHODS

    /**
     * Detects and returns handle to a stream related with the content.
     *
     * @param {Mixed} content Node content
     * @returns {Object} Stream object
     */
    _getStream(content) {
        let contentStream;

        if (content._resolvedValue) {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();

            setImmediate(() => {
                try {
                    contentStream.end(content._resolvedValue);
                } catch (err) {
                    contentStream.emit('error', err);
                }
            });

            return contentStream;
        } else if (typeof content.pipe === 'function') {
            // assume as stream
            return content;
        } else if (content && typeof content.path === 'string' && !content.href) {
            if (this.disableFileAccess) {
                contentStream = new PassThrough();
                setImmediate(() => contentStream.emit('error', new Error('File access rejected for ' + content.path)));
                return contentStream;
            }
            // read file
            return fs.createReadStream(content.path);
        } else if (content && typeof content.href === 'string') {
            if (this.disableUrlAccess) {
                contentStream = new PassThrough();
                setImmediate(() => contentStream.emit('error', new Error('Url access rejected for ' + content.href)));
                return contentStream;
            }
            // fetch URL
            return nmfetch(content.href, { headers: content.httpHeaders });
        } else {
            // pass string or buffer content as a stream
            contentStream = new PassThrough();

            setImmediate(() => {
                try {
                    contentStream.end(content || '');
                } catch (err) {
                    contentStream.emit('error', err);
                }
            });
            return contentStream;
        }
    }

    /**
     * Parses addresses. Takes in a single address or an array or an
     * array of address arrays (eg. To: [[first group], [second group],...])
     *
     * @param {Mixed} addresses Addresses to be parsed
     * @return {Array} An array of address objects
     */
    _parseAddresses(addresses) {
        return [].concat.apply(
            [],
            [].concat(addresses).map(address => {
                // eslint-disable-line prefer-spread
                if (address && address.address) {
                    address.address = this._normalizeAddress(address.address);
                    address.name = address.name || '';
                    return [address];
                }
                return addressparser(address);
            })
        );
    }

    /**
     * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
     *
     * @param {String} key Key to be normalized
     * @return {String} key in Camel-Case form
     */
    _normalizeHeaderKey(key) {
        key = (key || '')
            .toString()
            // no newlines in keys
            .replace(/\r?\n|\r/g, ' ')
            .trim()
            .toLowerCase()
            // use uppercase words, except MIME
            .replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, c => c.toUpperCase())
            // special case
            .replace(/^Content-Features$/i, 'Content-features');

        return key;
    }

    /**
     * Checks if the content type is multipart and defines boundary if needed.
     * Doesn't return anything, modifies object argument instead.
     *
     * @param {Object} structured Parsed header value for 'Content-Type' key
     */
    _handleContentType(structured) {
        this.contentType = structured.value.trim().toLowerCase();

        this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf('/') + 1) : false;

        if (this.multipart) {
            this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
        } else {
            this.boundary = false;
        }
    }

    /**
     * Generates a multipart boundary value
     *
     * @return {String} boundary value
     */
    _generateBoundary() {
        return this.rootNode.boundaryPrefix + '-' + this.rootNode.baseBoundary + '-Part_' + this._nodeId;
    }

    /**
     * Encodes a header value for use in the generated rfc2822 email.
     *
     * @param {String} key Header key
     * @param {String} value Header value
     */
    _encodeHeaderValue(key, value) {
        key = this._normalizeHeaderKey(key);

        switch (key) {
            // Structured headers
            case 'From':
            case 'Sender':
            case 'To':
            case 'Cc':
            case 'Bcc':
            case 'Reply-To':
                return this._convertAddresses(this._parseAddresses(value));

            // values enclosed in <>
            case 'Message-ID':
            case 'In-Reply-To':
            case 'Content-Id':
                value = (value || '').toString().replace(/\r?\n|\r/g, ' ');

                if (value.charAt(0) !== '<') {
                    value = '<' + value;
                }

                if (value.charAt(value.length - 1) !== '>') {
                    value = value + '>';
                }
                return value;

            // space separated list of values enclosed in <>
            case 'References':
                value = [].concat
                    .apply(
                        [],
                        [].concat(value || '').map(elm => {
                            // eslint-disable-line prefer-spread
                            elm = (elm || '')
                                .toString()
                                .replace(/\r?\n|\r/g, ' ')
                                .trim();
                            return elm.replace(/<[^>]*>/g, str => str.replace(/\s/g, '')).split(/\s+/);
                        })
                    )
                    .map(elm => {
                        if (elm.charAt(0) !== '<') {
                            elm = '<' + elm;
                        }
                        if (elm.charAt(elm.length - 1) !== '>') {
                            elm = elm + '>';
                        }
                        return elm;
                    });

                return value.join(' ').trim();

            case 'Date':
                if (Object.prototype.toString.call(value) === '[object Date]') {
                    return value.toUTCString().replace(/GMT/, '+0000');
                }

                value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
                return this._encodeWords(value);

            case 'Content-Type':
            case 'Content-Disposition':
                // if it includes a filename then it is already encoded
                return (value || '').toString().replace(/\r?\n|\r/g, ' ');

            default:
                value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
                // encodeWords only encodes if needed, otherwise the original string is returned
                return this._encodeWords(value);
        }
    }

    /**
     * Rebuilds address object using punycode and other adjustments
     *
     * @param {Array} addresses An array of address objects
     * @param {Array} [uniqueList] An array to be populated with addresses
     * @return {String} address string
     */
    _convertAddresses(addresses, uniqueList) {
        let values = [];

        uniqueList = uniqueList || [];

        [].concat(addresses || []).forEach(address => {
            if (address.address) {
                address.address = this._normalizeAddress(address.address);

                if (!address.name) {
                    values.push(address.address.indexOf(' ') >= 0 ? `<${address.address}>` : `${address.address}`);
                } else if (address.name) {
                    values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
                }

                if (address.address) {
                    if (!uniqueList.filter(a => a.address === address.address).length) {
                        uniqueList.push(address);
                    }
                }
            } else if (address.group) {
                let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim();
                values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
            }
        });

        return values.join(', ');
    }

    /**
     * Normalizes an email address
     *
     * @param {Array} address An array of address objects
     * @return {String} address string
     */
    _normalizeAddress(address) {
        address = (address || '')
            .toString()
            .replace(/[\x00-\x1F<>]+/g, ' ') // remove unallowed characters
            .trim();

        let lastAt = address.lastIndexOf('@');
        if (lastAt < 0) {
            // Bare username
            return address;
        }

        let user = address.substr(0, lastAt);
        let domain = address.substr(lastAt + 1);

        // Usernames are not touched and are kept as is even if these include unicode
        // Domains are punycoded by default
        // 'jõgeva.ee' will be converted to 'xn--jgeva-dua.ee'
        // non-unicode domains are left as is

        let encodedDomain;

        try {
            encodedDomain = punycode.toASCII(domain.toLowerCase());
        } catch (err) {
            // keep as is?
        }

        if (user.indexOf(' ') >= 0) {
            if (user.charAt(0) !== '"') {
                user = '"' + user;
            }
            if (user.substr(-1) !== '"') {
                user = user + '"';
            }
        }

        return `${user}@${encodedDomain}`;
    }

    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeAddressName(name) {
        if (!/^[\w ]*$/.test(name)) {
            if (/^[\x20-\x7e]*$/.test(name)) {
                return '"' + name.replace(/([\\"])/g, '\\$1') + '"';
            } else {
                return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
            }
        }
        return name;
    }

    /**
     * If needed, mime encodes the name part
     *
     * @param {String} name Name part of an address
     * @returns {String} Mime word encoded string if needed
     */
    _encodeWords(value) {
        // set encodeAll parameter to true even though it is against the recommendation of RFC2047,
        // by default only words that include non-ascii should be converted into encoded words
        // but some clients (eg. Zimbra) do not handle it properly and remove surrounding whitespace
        return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }

    /**
     * Detects best mime encoding for a text value
     *
     * @param {String} value Value to check for
     * @return {String} either 'Q' or 'B'
     */
    _getTextEncoding(value) {
        value = (value || '').toString();

        let encoding = this.textEncoding;
        let latinLen;
        let nonLatinLen;

        if (!encoding) {
            // count latin alphabet symbols and 8-bit range symbols + control symbols
            // if there are more latin characters, then use quoted-printable
            // encoding, otherwise use base64
            nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length; // eslint-disable-line no-control-regex
            latinLen = (value.match(/[a-z]/gi) || []).length;
            // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
            encoding = nonLatinLen < latinLen ? 'Q' : 'B';
        }
        return encoding;
    }

    /**
     * Generates a message id
     *
     * @return {String} Random Message-ID value
     */
    _generateMessageId() {
        return (
            '<' +
            [2, 2, 2, 6].reduce(
                // crux to generate UUID-like random strings
                (prev, len) => prev + '-' + crypto.randomBytes(len).toString('hex'),
                crypto.randomBytes(4).toString('hex')
            ) +
            '@' +
            // try to use the domain of the FROM address or fallback to server hostname
            (this.getEnvelope().from || this.hostname || 'localhost').split('@').pop() +
            '>'
        );
    }
}

module.exports = MimeNode;


/***/ }),

/***/ 161775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Transform = (__webpack_require__(927910).Transform);

class LastNewline extends Transform {
    constructor() {
        super();
        this.lastByte = false;
    }

    _transform(chunk, encoding, done) {
        if (chunk.length) {
            this.lastByte = chunk[chunk.length - 1];
        }

        this.push(chunk);
        done();
    }

    _flush(done) {
        if (this.lastByte === 0x0a) {
            return done();
        }
        if (this.lastByte === 0x0d) {
            this.push(Buffer.from('\n'));
            return done();
        }
        this.push(Buffer.from('\r\n'));
        return done();
    }
}

module.exports = LastNewline;


/***/ }),

/***/ 568012:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(927910);
const Transform = stream.Transform;

/**
 * Ensures that only <LF> is used for linebreaks
 *
 * @param {Object} options Stream options
 */
class LeWindows extends Transform {
    constructor(options) {
        super(options);
        // init Transform
        this.options = options || {};
    }

    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;

        for (let i = 0, len = chunk.length; i < len; i++) {
            if (chunk[i] === 0x0d) {
                // \n
                buf = chunk.slice(lastPos, i);
                lastPos = i + 1;
                this.push(buf);
            }
        }
        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }
        done();
    }
}

module.exports = LeWindows;


/***/ }),

/***/ 610337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(927910);
const Transform = stream.Transform;

/**
 * Ensures that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */
class LeWindows extends Transform {
    constructor(options) {
        super(options);
        // init Transform
        this.options = options || {};
        this.lastByte = false;
    }

    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
        let buf;
        let lastPos = 0;

        for (let i = 0, len = chunk.length; i < len; i++) {
            if (chunk[i] === 0x0a) {
                // \n
                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        this.push(buf);
                    }
                    this.push(Buffer.from('\r\n'));
                    lastPos = i + 1;
                }
            }
        }

        if (lastPos && lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            this.push(buf);
        } else if (!lastPos) {
            this.push(chunk);
        }

        this.lastByte = chunk[chunk.length - 1];
        done();
    }
}

module.exports = LeWindows;


/***/ }),

/***/ 841966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;


const Mailer = __webpack_require__(787897);
const shared = __webpack_require__(835028);
const SMTPPool = __webpack_require__(158914);
const SMTPTransport = __webpack_require__(82833);
const SendmailTransport = __webpack_require__(810204);
const StreamTransport = __webpack_require__(417061);
const JSONTransport = __webpack_require__(44719);
const SESTransport = __webpack_require__(382674);
const nmfetch = __webpack_require__(34843);
const packageData = __webpack_require__(227761);

const ETHEREAL_API = (process.env.ETHEREAL_API || 'https://api.nodemailer.com').replace(/\/+$/, '');
const ETHEREAL_WEB = (process.env.ETHEREAL_WEB || 'https://ethereal.email').replace(/\/+$/, '');
const ETHEREAL_API_KEY = (process.env.ETHEREAL_API_KEY || '').replace(/\s*/g, '') || null;
const ETHEREAL_CACHE = ['true', 'yes', 'y', '1'].includes((process.env.ETHEREAL_CACHE || 'yes').toString().trim().toLowerCase());

let testAccount = false;

module.exports.oO = function (transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;

    if (
        // provided transporter is a configuration object, not transporter plugin
        (typeof transporter === 'object' && typeof transporter.send !== 'function') ||
        // provided transporter looks like a connection url
        (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))
    ) {
        if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }

        if (options.pool) {
            transporter = new SMTPPool(options);
        } else if (options.sendmail) {
            transporter = new SendmailTransport(options);
        } else if (options.streamTransport) {
            transporter = new StreamTransport(options);
        } else if (options.jsonTransport) {
            transporter = new JSONTransport(options);
        } else if (options.SES) {
            transporter = new SESTransport(options);
        } else {
            transporter = new SMTPTransport(options);
        }
    }

    mailer = new Mailer(transporter, options, defaults);

    return mailer;
};

__webpack_unused_export__ = function (apiUrl, callback) {
    let promise;

    if (!callback && typeof apiUrl === 'function') {
        callback = apiUrl;
        apiUrl = false;
    }

    if (!callback) {
        promise = new Promise((resolve, reject) => {
            callback = shared.callbackPromise(resolve, reject);
        });
    }

    if (ETHEREAL_CACHE && testAccount) {
        setImmediate(() => callback(null, testAccount));
        return promise;
    }

    apiUrl = apiUrl || ETHEREAL_API;

    let chunks = [];
    let chunklen = 0;

    let requestHeaders = {};
    let requestBody = {
        requestor: packageData.name,
        version: packageData.version
    };

    if (ETHEREAL_API_KEY) {
        requestHeaders.Authorization = 'Bearer ' + ETHEREAL_API_KEY;
    }

    let req = nmfetch(apiUrl + '/user', {
        contentType: 'application/json',
        method: 'POST',
        headers: requestHeaders,
        body: Buffer.from(JSON.stringify(requestBody))
    });

    req.on('readable', () => {
        let chunk;
        while ((chunk = req.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });

    req.once('error', err => callback(err));

    req.once('end', () => {
        let res = Buffer.concat(chunks, chunklen);
        let data;
        let err;
        try {
            data = JSON.parse(res.toString());
        } catch (E) {
            err = E;
        }
        if (err) {
            return callback(err);
        }
        if (data.status !== 'success' || data.error) {
            return callback(new Error(data.error || 'Request failed'));
        }
        delete data.status;
        testAccount = data;
        callback(null, testAccount);
    });

    return promise;
};

__webpack_unused_export__ = function (info) {
    if (!info || !info.response) {
        return false;
    }

    let infoProps = new Map();
    info.response.replace(/\[([^\]]+)\]$/, (m, props) => {
        props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m, key, value) => {
            infoProps.set(key, value);
        });
    });

    if (infoProps.has('STATUS') && infoProps.has('MSGID')) {
        return (testAccount.web || ETHEREAL_WEB) + '/message/' + infoProps.get('MSGID');
    }

    return false;
};


/***/ }),

/***/ 155338:
/***/ ((module) => {

"use strict";
/*

Copied from https://github.com/mathiasbynens/punycode.js/blob/ef3505c8abb5143a00d53ce59077c9f7f4b2ac47/punycode.js

Copyright Mathias Bynens <https://mathiasbynens.be/>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
/* eslint callback-return: 0, no-bitwise: 0, eqeqeq: 0, prefer-arrow-callback: 0, object-shorthand: 0 */



/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7F]/; // Note: U+007F DEL is excluded too.
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
    overflow: 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
    throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
        result[length] = callback(array[length]);
    }
    return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {String} A new string of characters returned by the callback
 * function.
 */
function mapDomain(domain, callback) {
    const parts = domain.split('@');
    let result = '';
    if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        domain = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    domain = domain.replace(regexSeparators, '\x2E');
    const labels = domain.split('.');
    const encoded = map(labels, callback).join('.');
    return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
        const value = string.charCodeAt(counter++);
        if (value >= 0xd800 && value <= 0xdbff && counter < length) {
            // It's a high surrogate, and there is a next character.
            const extra = string.charCodeAt(counter++);
            if ((extra & 0xfc00) == 0xdc00) {
                // Low surrogate.
                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
            } else {
                // It's an unmatched surrogate; only append this code unit, in case the
                // next code unit is the high surrogate of a surrogate pair.
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = codePoints => String.fromCodePoint(...codePoints);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function (codePoint) {
    if (codePoint >= 0x30 && codePoint < 0x3a) {
        return 26 + (codePoint - 0x30);
    }
    if (codePoint >= 0x41 && codePoint < 0x5b) {
        return codePoint - 0x41;
    }
    if (codePoint >= 0x61 && codePoint < 0x7b) {
        return codePoint - 0x61;
    }
    return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function (digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function (delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; /* no initialization */ delta > (baseMinusTMin * tMax) >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
    }
    return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function (input) {
    // Don't use UCS-2.
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;

    // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
        basic = 0;
    }

    for (let j = 0; j < basic; ++j) {
        // if it's not a basic code point
        if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
        }
        output.push(input.charCodeAt(j));
    }

    // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.

    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength /* no final expression */; ) {
        // `index` is the index of the next character to be consumed.
        // Decode a generalized variable-length integer into `delta`,
        // which gets added to `i`. The overflow checking is easier
        // if we increase `i` as we go, then subtract off its starting
        // value at the end to obtain `delta`.
        const oldi = i;
        for (let w = 1, k = base /* no condition */; ; k += base) {
            if (index >= inputLength) {
                error('invalid-input');
            }

            const digit = basicToDigit(input.charCodeAt(index++));

            if (digit >= base) {
                error('invalid-input');
            }
            if (digit > floor((maxInt - i) / w)) {
                error('overflow');
            }

            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (digit < t) {
                break;
            }

            const baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
                error('overflow');
            }

            w *= baseMinusT;
        }

        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);

        // `i` was supposed to wrap around from `out` to `0`,
        // incrementing `n` each time, so we'll fix that now:
        if (floor(i / out) > maxInt - n) {
            error('overflow');
        }

        n += floor(i / out);
        i %= out;

        // Insert `n` at position `i` of the output.
        output.splice(i++, 0, n);
    }

    return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function (input) {
    const output = [];

    // Convert the input in UCS-2 to an array of Unicode code points.
    input = ucs2decode(input);

    // Cache the length.
    const inputLength = input.length;

    // Initialize the state.
    let n = initialN;
    let delta = 0;
    let bias = initialBias;

    // Handle the basic code points.
    for (const currentValue of input) {
        if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
        }
    }

    const basicLength = output.length;
    let handledCPCount = basicLength;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string with a delimiter unless it's empty.
    if (basicLength) {
        output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {
        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        let m = maxInt;
        for (const currentValue of input) {
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (const currentValue of input) {
            if (currentValue < n && ++delta > maxInt) {
                error('overflow');
            }
            if (currentValue === n) {
                // Represent delta as a generalized variable-length integer.
                let q = delta;
                for (let k = base /* no condition */; ; k += base) {
                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = base - t;
                    output.push(stringFromCharCode(digitToBasic(t + (qMinusT % baseMinusT), 0)));
                    q = floor(qMinusT / baseMinusT);
                }

                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }

        ++delta;
        ++n;
    }
    return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function (input) {
    return mapDomain(input, function (string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function (input) {
    return mapDomain(input, function (string) {
        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    version: '2.3.1',
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
    },
    decode: decode,
    encode: encode,
    toASCII: toASCII,
    toUnicode: toUnicode
};

module.exports = punycode;


/***/ }),

/***/ 620964:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Transform = (__webpack_require__(927910).Transform);

/**
 * Encodes a Buffer into a Quoted-Printable encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} Quoted-Printable encoded string
 */
function encode(buffer) {
    if (typeof buffer === 'string') {
        buffer = Buffer.from(buffer, 'utf-8');
    }

    // usable characters that do not need encoding
    let ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [0x09], // <TAB>
        [0x0a], // <LF>
        [0x0d], // <CR>
        [0x20, 0x3c], // <SP>!"#$%&'()*+,-./0123456789:;
        [0x3e, 0x7e] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    let result = '';
    let ord;

    for (let i = 0, len = buffer.length; i < len; i++) {
        ord = buffer[i];
        // if the char is in allowed range, then keep as is, unless it is a WS in the end of a line
        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {
            result += String.fromCharCode(ord);
            continue;
        }
        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();
    }

    return result;
}

/**
 * Adds soft line breaks to a Quoted-Printable string
 *
 * @param {String} str Quoted-Printable encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped Quoted-Printable encoded string
 */
function wrap(str, lineLength) {
    str = (str || '').toString();
    lineLength = lineLength || 76;

    if (str.length <= lineLength) {
        return str;
    }

    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result = '';

    // insert soft linebreaks where needed
    while (pos < len) {
        line = str.substr(pos, lineLength);
        if ((match = line.match(/\r\n/))) {
            line = line.substr(0, match.index + match[0].length);
            result += line;
            pos += line.length;
            continue;
        }

        if (line.substr(-1) === '\n') {
            // nothing to change here
            result += line;
            pos += line.length;
            continue;
        } else if ((match = line.substr(-lineMargin).match(/\n.*?$/))) {
            // truncate to nearest line break
            line = line.substr(0, line.length - (match[0].length - 1));
            result += line;
            pos += line.length;
            continue;
        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
            // truncate to nearest space
            line = line.substr(0, line.length - (match[0].length - 1));
        } else if (line.match(/[=][\da-f]{0,2}$/i)) {
            // push incomplete encoding sequences to the next line
            if ((match = line.match(/[=][\da-f]{0,1}$/i))) {
                line = line.substr(0, line.length - match[0].length);
            }

            // ensure that utf-8 sequences are not split
            while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
                code = parseInt(match[0].substr(1, 2), 16);
                if (code < 128) {
                    break;
                }

                line = line.substr(0, line.length - 3);

                if (code >= 0xc0) {
                    break;
                }
            }
        }

        if (pos + line.length < len && line.substr(-1) !== '\n') {
            if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
                line = line.substr(0, line.length - 3);
            } else if (line.length === lineLength) {
                line = line.substr(0, line.length - 1);
            }
            pos += line.length;
            line += '=\r\n';
        } else {
            pos += line.length;
        }

        result += line;
    }

    return result;
}

/**
 * Helper function to check if a number is inside provided ranges
 *
 * @param {Number} nr Number to check for
 * @param {Array} ranges An Array of allowed values
 * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise
 */
function checkRanges(nr, ranges) {
    for (let i = ranges.length - 1; i >= 0; i--) {
        if (!ranges[i].length) {
            continue;
        }
        if (ranges[i].length === 1 && nr === ranges[i][0]) {
            return true;
        }
        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
            return true;
        }
    }
    return false;
}

/**
 * Creates a transform stream for encoding data to Quoted-Printable encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum length for lines, set to false to disable wrapping
 */
class Encoder extends Transform {
    constructor(options) {
        super();

        // init Transform
        this.options = options || {};

        if (this.options.lineLength !== false) {
            this.options.lineLength = this.options.lineLength || 76;
        }

        this._curLine = '';

        this.inputBytes = 0;
        this.outputBytes = 0;
    }

    _transform(chunk, encoding, done) {
        let qp;

        if (encoding !== 'buffer') {
            chunk = Buffer.from(chunk, encoding);
        }

        if (!chunk || !chunk.length) {
            return done();
        }

        this.inputBytes += chunk.length;

        if (this.options.lineLength) {
            qp = this._curLine + encode(chunk);
            qp = wrap(qp, this.options.lineLength);
            qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
                this._curLine = lastLine;
                return lineBreak;
            });

            if (qp) {
                this.outputBytes += qp.length;
                this.push(qp);
            }
        } else {
            qp = encode(chunk);
            this.outputBytes += qp.length;
            this.push(qp, 'ascii');
        }

        done();
    }

    _flush(done) {
        if (this._curLine) {
            this.outputBytes += this._curLine.length;
            this.push(this._curLine, 'ascii');
        }
        done();
    }
}

// expose to the world
module.exports = {
    encode,
    wrap,
    Encoder
};


/***/ }),

/***/ 810204:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const spawn = (__webpack_require__(579646).spawn);
const packageData = __webpack_require__(227761);
const shared = __webpack_require__(835028);

/**
 * Generates a Transport object for Sendmail
 *
 * Possible options can be the following:
 *
 *  * **path** optional path to sendmail binary
 *  * **newline** either 'windows' or 'unix'
 *  * **args** an array of arguments for the sendmail binary
 *
 * @constructor
 * @param {Object} optional config parameter for Sendmail
 */
class SendmailTransport {
    constructor(options) {
        options = options || {};

        // use a reference to spawn for mocking purposes
        this._spawn = spawn;

        this.options = options || {};

        this.name = 'Sendmail';
        this.version = packageData.version;

        this.path = 'sendmail';
        this.args = false;
        this.winbreak = false;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'sendmail'
        });

        if (options) {
            if (typeof options === 'string') {
                this.path = options;
            } else if (typeof options === 'object') {
                if (options.path) {
                    this.path = options.path;
                }
                if (Array.isArray(options.args)) {
                    this.args = options.args;
                }
                this.winbreak = ['win', 'windows', 'dos', '\r\n'].includes((options.newline || '').toString().toLowerCase());
            }
        }
    }

    /**
     * <p>Compiles a mailcomposer message and forwards it to handler that sends it.</p>
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
        // Sendmail strips this header line by itself
        mail.message.keepBcc = true;

        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();
        let args;
        let sendmail;
        let returned;

        const hasInvalidAddresses = []
            .concat(envelope.from || [])
            .concat(envelope.to || [])
            .some(addr => /^-/.test(addr));
        if (hasInvalidAddresses) {
            return done(new Error('Can not send mail. Invalid envelope addresses.'));
        }

        if (this.args) {
            // force -i to keep single dots
            args = ['-i'].concat(this.args).concat(envelope.to);
        } else {
            args = ['-i'].concat(envelope.from ? ['-f', envelope.from] : []).concat(envelope.to);
        }

        let callback = err => {
            if (returned) {
                // ignore any additional responses, already done
                return;
            }
            returned = true;
            if (typeof done === 'function') {
                if (err) {
                    return done(err);
                } else {
                    return done(null, {
                        envelope: mail.data.envelope || mail.message.getEnvelope(),
                        messageId,
                        response: 'Messages queued for delivery'
                    });
                }
            }
        };

        try {
            sendmail = this._spawn(this.path, args);
        } catch (E) {
            this.logger.error(
                {
                    err: E,
                    tnx: 'spawn',
                    messageId
                },
                'Error occurred while spawning sendmail. %s',
                E.message
            );
            return callback(E);
        }

        if (sendmail) {
            sendmail.on('error', err => {
                this.logger.error(
                    {
                        err,
                        tnx: 'spawn',
                        messageId
                    },
                    'Error occurred when sending message %s. %s',
                    messageId,
                    err.message
                );
                callback(err);
            });

            sendmail.once('exit', code => {
                if (!code) {
                    return callback();
                }
                let err;
                if (code === 127) {
                    err = new Error('Sendmail command not found, process exited with code ' + code);
                } else {
                    err = new Error('Sendmail exited with code ' + code);
                }

                this.logger.error(
                    {
                        err,
                        tnx: 'stdin',
                        messageId
                    },
                    'Error sending message %s to sendmail. %s',
                    messageId,
                    err.message
                );
                callback(err);
            });
            sendmail.once('close', callback);

            sendmail.stdin.on('error', err => {
                this.logger.error(
                    {
                        err,
                        tnx: 'stdin',
                        messageId
                    },
                    'Error occurred when piping message %s to sendmail. %s',
                    messageId,
                    err.message
                );
                callback(err);
            });

            let recipients = [].concat(envelope.to || []);
            if (recipients.length > 3) {
                recipients.push('...and ' + recipients.splice(2).length + ' more');
            }
            this.logger.info(
                {
                    tnx: 'send',
                    messageId
                },
                'Sending message %s to <%s>',
                messageId,
                recipients.join(', ')
            );

            let sourceStream = mail.message.createReadStream();
            sourceStream.once('error', err => {
                this.logger.error(
                    {
                        err,
                        tnx: 'stdin',
                        messageId
                    },
                    'Error occurred when generating message %s. %s',
                    messageId,
                    err.message
                );
                sendmail.kill('SIGINT'); // do not deliver the message
                callback(err);
            });

            sourceStream.pipe(sendmail.stdin);
        } else {
            return callback(new Error('sendmail was not found'));
        }
    }
}

module.exports = SendmailTransport;


/***/ }),

/***/ 382674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(594735);
const packageData = __webpack_require__(227761);
const shared = __webpack_require__(835028);
const LeWindows = __webpack_require__(610337);

/**
 * Generates a Transport object for AWS SES
 *
 * Possible options can be the following:
 *
 *  * **sendingRate** optional Number specifying how many messages per second should be delivered to SES
 *  * **maxConnections** optional Number specifying max number of parallel connections to SES
 *
 * @constructor
 * @param {Object} optional config parameter
 */
class SESTransport extends EventEmitter {
    constructor(options) {
        super();
        options = options || {};

        this.options = options || {};
        this.ses = this.options.SES;

        this.name = 'SESTransport';
        this.version = packageData.version;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'ses-transport'
        });

        // parallel sending connections
        this.maxConnections = Number(this.options.maxConnections) || Infinity;
        this.connections = 0;

        // max messages per second
        this.sendingRate = Number(this.options.sendingRate) || Infinity;
        this.sendingRateTTL = null;
        this.rateInterval = 1000; // milliseconds
        this.rateMessages = [];

        this.pending = [];

        this.idling = true;

        setImmediate(() => {
            if (this.idling) {
                this.emit('idle');
            }
        });
    }

    /**
     * Schedules a sending of a message
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, callback) {
        if (this.connections >= this.maxConnections) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }

        if (!this._checkSendingRate()) {
            this.idling = false;
            return this.pending.push({
                mail,
                callback
            });
        }

        this._send(mail, (...args) => {
            setImmediate(() => callback(...args));
            this._sent();
        });
    }

    _checkRatedQueue() {
        if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
            return;
        }

        if (!this.pending.length) {
            if (!this.idling) {
                this.idling = true;
                this.emit('idle');
            }
            return;
        }

        let next = this.pending.shift();
        this._send(next.mail, (...args) => {
            setImmediate(() => next.callback(...args));
            this._sent();
        });
    }

    _checkSendingRate() {
        clearTimeout(this.sendingRateTTL);

        let now = Date.now();
        let oldest = false;
        // delete older messages
        for (let i = this.rateMessages.length - 1; i >= 0; i--) {
            if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
                oldest = this.rateMessages[i].ts;
            }

            if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
                this.rateMessages.splice(i, 1);
            }
        }

        if (this.rateMessages.length < this.sendingRate) {
            return true;
        }

        let delay = Math.max(oldest + 1001, now + 20);
        this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);

        try {
            this.sendingRateTTL.unref();
        } catch (E) {
            // Ignore. Happens on envs with non-node timer implementation
        }

        return false;
    }

    _sent() {
        this.connections--;
        this._checkRatedQueue();
    }

    /**
     * Returns true if there are free slots in the queue
     */
    isIdle() {
        return this.idling;
    }

    /**
     * Compiles a mailcomposer message and forwards it to SES
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    _send(mail, callback) {
        let statObject = {
            ts: Date.now(),
            pending: true
        };
        this.connections++;
        this.rateMessages.push(statObject);

        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();

        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push('...and ' + recipients.splice(2).length + ' more');
        }
        this.logger.info(
            {
                tnx: 'send',
                messageId
            },
            'Sending message %s to <%s>',
            messageId,
            recipients.join(', ')
        );

        let getRawMessage = next => {
            // do not use Message-ID and Date in DKIM signature
            if (!mail.data._dkim) {
                mail.data._dkim = {};
            }
            if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === 'string') {
                mail.data._dkim.skipFields += ':date:message-id';
            } else {
                mail.data._dkim.skipFields = 'date:message-id';
            }

            let sourceStream = mail.message.createReadStream();
            let stream = sourceStream.pipe(new LeWindows());
            let chunks = [];
            let chunklen = 0;

            stream.on('readable', () => {
                let chunk;
                while ((chunk = stream.read()) !== null) {
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });

            sourceStream.once('error', err => stream.emit('error', err));

            stream.once('error', err => {
                next(err);
            });

            stream.once('end', () => next(null, Buffer.concat(chunks, chunklen)));
        };

        setImmediate(() =>
            getRawMessage((err, raw) => {
                if (err) {
                    this.logger.error(
                        {
                            err,
                            tnx: 'send',
                            messageId
                        },
                        'Failed creating message for %s. %s',
                        messageId,
                        err.message
                    );
                    statObject.pending = false;
                    return callback(err);
                }

                let sesMessage = {
                    RawMessage: {
                        // required
                        Data: raw // required
                    },
                    Source: envelope.from,
                    Destinations: envelope.to
                };

                Object.keys(mail.data.ses || {}).forEach(key => {
                    sesMessage[key] = mail.data.ses[key];
                });

                let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
                let aws = this.ses.aws || {};

                let getRegion = cb => {
                    if (ses.config && typeof ses.config.region === 'function') {
                        // promise
                        return ses.config
                            .region()
                            .then(region => cb(null, region))
                            .catch(err => cb(err));
                    }
                    return cb(null, (ses.config && ses.config.region) || 'us-east-1');
                };

                getRegion((err, region) => {
                    if (err || !region) {
                        region = 'us-east-1';
                    }

                    let sendPromise;
                    if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
                        // v3 API
                        sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
                    } else {
                        // v2 API
                        sendPromise = ses.sendRawEmail(sesMessage).promise();
                    }

                    sendPromise
                        .then(data => {
                            if (region === 'us-east-1') {
                                region = 'email';
                            }

                            statObject.pending = false;
                            callback(null, {
                                envelope: {
                                    from: envelope.from,
                                    to: envelope.to
                                },
                                messageId: '<' + data.MessageId + (!/@/.test(data.MessageId) ? '@' + region + '.amazonses.com' : '') + '>',
                                response: data.MessageId,
                                raw
                            });
                        })
                        .catch(err => {
                            this.logger.error(
                                {
                                    err,
                                    tnx: 'send'
                                },
                                'Send error for %s: %s',
                                messageId,
                                err.message
                            );
                            statObject.pending = false;
                            callback(err);
                        });
                });
            })
        );
    }

    /**
     * Verifies SES configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
        let promise;
        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};

        const sesMessage = {
            RawMessage: {
                // required
                Data: 'From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid'
            },
            Source: 'invalid@invalid',
            Destinations: ['invalid@invalid']
        };

        if (!callback) {
            promise = new Promise((resolve, reject) => {
                callback = shared.callbackPromise(resolve, reject);
            });
        }
        const cb = err => {
            if (err && (err.code || err.Code) !== 'InvalidParameterValue') {
                return callback(err);
            }
            return callback(null, true);
        };

        if (typeof ses.send === 'function' && aws.SendRawEmailCommand) {
            // v3 API
            sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
            ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
        } else {
            // v2 API
            ses.sendRawEmail(sesMessage, cb);
        }

        return promise;
    }
}

module.exports = SESTransport;


/***/ }),

/***/ 835028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-console: 0 */



const urllib = __webpack_require__(379551);
const util = __webpack_require__(328354);
const fs = __webpack_require__(629021);
const nmfetch = __webpack_require__(34843);
const dns = __webpack_require__(714985);
const net = __webpack_require__(491645);
const os = __webpack_require__(321820);

const DNS_TTL = 5 * 60 * 1000;

let networkInterfaces;
try {
    networkInterfaces = os.networkInterfaces();
} catch (err) {
    // fails on some systems
}

module.exports.networkInterfaces = networkInterfaces;

const isFamilySupported = (family, allowInternal) => {
    let networkInterfaces = module.exports.networkInterfaces;
    if (!networkInterfaces) {
        // hope for the best
        return true;
    }

    const familySupported =
        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6
        Object.keys(networkInterfaces)
            .map(key => networkInterfaces[key])
            // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)
            .reduce((acc, val) => acc.concat(val), [])
            .filter(i => !i.internal || allowInternal)
            .filter(i => i.family === 'IPv' + family || i.family === family).length > 0;

    return familySupported;
};

const resolver = (family, hostname, options, callback) => {
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);

    if (!familySupported) {
        return callback(null, []);
    }

    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver['resolve' + family](hostname, (err, addresses) => {
        if (err) {
            switch (err.code) {
                case dns.NODATA:
                case dns.NOTFOUND:
                case dns.NOTIMP:
                case dns.SERVFAIL:
                case dns.CONNREFUSED:
                case dns.REFUSED:
                case 'EAI_AGAIN':
                    return callback(null, []);
            }
            return callback(err);
        }
        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
};

const dnsCache = (module.exports.dnsCache = new Map());

const formatDNSValue = (value, extra) => {
    if (!value) {
        return Object.assign({}, extra || {});
    }

    return Object.assign(
        {
            servername: value.servername,
            host:
                !value.addresses || !value.addresses.length
                    ? null
                    : value.addresses.length === 1
                    ? value.addresses[0]
                    : value.addresses[Math.floor(Math.random() * value.addresses.length)]
        },
        extra || {}
    );
};

module.exports.resolveHostname = (options, callback) => {
    options = options || {};

    if (!options.host && options.servername) {
        options.host = options.servername;
    }

    if (!options.host || net.isIP(options.host)) {
        // nothing to do here
        let value = {
            addresses: [options.host],
            servername: options.servername || false
        };
        return callback(
            null,
            formatDNSValue(value, {
                cached: false
            })
        );
    }

    let cached;
    if (dnsCache.has(options.host)) {
        cached = dnsCache.get(options.host);

        if (!cached.expires || cached.expires >= Date.now()) {
            return callback(
                null,
                formatDNSValue(cached.value, {
                    cached: true
                })
            );
        }
    }

    resolver(4, options.host, options, (err, addresses) => {
        if (err) {
            if (cached) {
                // ignore error, use expired value
                return callback(
                    null,
                    formatDNSValue(cached.value, {
                        cached: true,
                        error: err
                    })
                );
            }
            return callback(err);
        }

        if (addresses && addresses.length) {
            let value = {
                addresses,
                servername: options.servername || options.host
            };

            dnsCache.set(options.host, {
                value,
                expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });

            return callback(
                null,
                formatDNSValue(value, {
                    cached: false
                })
            );
        }

        resolver(6, options.host, options, (err, addresses) => {
            if (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(
                        null,
                        formatDNSValue(cached.value, {
                            cached: true,
                            error: err
                        })
                    );
                }
                return callback(err);
            }

            if (addresses && addresses.length) {
                let value = {
                    addresses,
                    servername: options.servername || options.host
                };

                dnsCache.set(options.host, {
                    value,
                    expires: Date.now() + (options.dnsTtl || DNS_TTL)
                });

                return callback(
                    null,
                    formatDNSValue(value, {
                        cached: false
                    })
                );
            }

            try {
                dns.lookup(options.host, { all: true }, (err, addresses) => {
                    if (err) {
                        if (cached) {
                            // ignore error, use expired value
                            return callback(
                                null,
                                formatDNSValue(cached.value, {
                                    cached: true,
                                    error: err
                                })
                            );
                        }
                        return callback(err);
                    }

                    let address = addresses
                        ? addresses
                              .filter(addr => isFamilySupported(addr.family))
                              .map(addr => addr.address)
                              .shift()
                        : false;

                    if (addresses && addresses.length && !address) {
                        // there are addresses but none can be used
                        console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);
                    }

                    if (!address && cached) {
                        // nothing was found, fallback to cached value
                        return callback(
                            null,
                            formatDNSValue(cached.value, {
                                cached: true
                            })
                        );
                    }

                    let value = {
                        addresses: address ? [address] : [options.host],
                        servername: options.servername || options.host
                    };

                    dnsCache.set(options.host, {
                        value,
                        expires: Date.now() + (options.dnsTtl || DNS_TTL)
                    });

                    return callback(
                        null,
                        formatDNSValue(value, {
                            cached: false
                        })
                    );
                });
            } catch (err) {
                if (cached) {
                    // ignore error, use expired value
                    return callback(
                        null,
                        formatDNSValue(cached.value, {
                            cached: true,
                            error: err
                        })
                    );
                }
                return callback(err);
            }
        });
    });
};
/**
 * Parses connection url to a structured configuration object
 *
 * @param {String} str Connection url
 * @return {Object} Configuration object
 */
module.exports.parseConnectionUrl = str => {
    str = str || '';
    let options = {};

    [urllib.parse(str, true)].forEach(url => {
        let auth;

        switch (url.protocol) {
            case 'smtp:':
                options.secure = false;
                break;
            case 'smtps:':
                options.secure = true;
                break;
            case 'direct:':
                options.direct = true;
                break;
        }

        if (!isNaN(url.port) && Number(url.port)) {
            options.port = Number(url.port);
        }

        if (url.hostname) {
            options.host = url.hostname;
        }

        if (url.auth) {
            auth = url.auth.split(':');

            if (!options.auth) {
                options.auth = {};
            }

            options.auth.user = auth.shift();
            options.auth.pass = auth.join(':');
        }

        Object.keys(url.query || {}).forEach(key => {
            let obj = options;
            let lKey = key;
            let value = url.query[key];

            if (!isNaN(value)) {
                value = Number(value);
            }

            switch (value) {
                case 'true':
                    value = true;
                    break;
                case 'false':
                    value = false;
                    break;
            }

            // tls is nested object
            if (key.indexOf('tls.') === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf('.') >= 0) {
                // ignore nested properties besides tls
                return;
            }

            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });

    return options;
};

module.exports._logFunc = (logger, level, defaults, data, message, ...args) => {
    let entry = {};

    Object.keys(defaults || {}).forEach(key => {
        if (key !== 'level') {
            entry[key] = defaults[key];
        }
    });

    Object.keys(data || {}).forEach(key => {
        if (key !== 'level') {
            entry[key] = data[key];
        }
    });

    logger[level](entry, message, ...args);
};

/**
 * Returns a bunyan-compatible logger interface. Uses either provided logger or
 * creates a default console logger
 *
 * @param {Object} [options] Options object that might include 'logger' value
 * @return {Object} bunyan compatible logger
 */
module.exports.getLogger = (options, defaults) => {
    options = options || {};

    let response = {};
    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];

    if (!options.logger) {
        // use vanity logger
        levels.forEach(level => {
            response[level] = () => false;
        });
        return response;
    }

    let logger = options.logger;

    if (options.logger === true) {
        // create console logger
        logger = createDefaultLogger(levels);
    }

    levels.forEach(level => {
        response[level] = (data, message, ...args) => {
            module.exports._logFunc(logger, level, defaults, data, message, ...args);
        };
    });

    return response;
};

/**
 * Wrapper for creating a callback that either resolves or rejects a promise
 * based on input
 *
 * @param {Function} resolve Function to run if callback is called
 * @param {Function} reject Function to run if callback ends with an error
 */
module.exports.callbackPromise = (resolve, reject) =>
    function () {
        let args = Array.from(arguments);
        let err = args.shift();
        if (err) {
            reject(err);
        } else {
            resolve(...args);
        }
    };

module.exports.parseDataURI = uri => {
    let input = uri;
    let commaPos = input.indexOf(',');
    if (!commaPos) {
        return uri;
    }

    let data = input.substring(commaPos + 1);
    let metaStr = input.substring('data:'.length, commaPos);

    let encoding;

    let metaEntries = metaStr.split(';');
    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry && lastMetaEntry.indexOf('=') < 0) {
        encoding = lastMetaEntry.toLowerCase();
        metaEntries.pop();
    }

    let contentType = metaEntries.shift() || 'application/octet-stream';
    let params = {};
    for (let entry of metaEntries) {
        let sep = entry.indexOf('=');
        if (sep >= 0) {
            let key = entry.substring(0, sep);
            let value = entry.substring(sep + 1);
            params[key] = value;
        }
    }

    switch (encoding) {
        case 'base64':
            data = Buffer.from(data, 'base64');
            break;
        case 'utf8':
            data = Buffer.from(data);
            break;
        default:
            try {
                data = Buffer.from(decodeURIComponent(data));
            } catch (err) {
                data = Buffer.from(data);
            }
            data = Buffer.from(data);
    }

    return { data, encoding, contentType, params };
};

/**
 * Resolves a String or a Buffer value for content value. Useful if the value
 * is a Stream or a file or an URL. If the value is a Stream, overwrites
 * the stream object with the resolved value (you can't stream a value twice).
 *
 * This is useful when you want to create a plugin that needs a content value,
 * for example the `html` or `text` value as a String or a Buffer but not as
 * a file path or an URL.
 *
 * @param {Object} data An object or an Array you want to resolve an element for
 * @param {String|Number} key Property name or an Array index
 * @param {Function} callback Callback function with (err, value)
 */
module.exports.resolveContent = (data, key, callback) => {
    let promise;

    if (!callback) {
        promise = new Promise((resolve, reject) => {
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }

    let content = (data && data[key] && data[key].content) || data[key];
    let contentStream;
    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')
        .toString()
        .toLowerCase()
        .replace(/[-_\s]/g, '');

    if (!content) {
        return callback(null, content);
    }

    if (typeof content === 'object') {
        if (typeof content.pipe === 'function') {
            return resolveStream(content, (err, value) => {
                if (err) {
                    return callback(err);
                }
                // we can't stream twice the same content, so we need
                // to replace the stream object with the streaming result
                if (data[key].content) {
                    data[key].content = value;
                } else {
                    data[key] = value;
                }
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = nmfetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            let parsedDataUri = module.exports.parseDataURI(content.path || content.href);

            if (!parsedDataUri || !parsedDataUri.data) {
                return callback(null, Buffer.from(0));
            }
            return callback(null, parsedDataUri.data);
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }

    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {
        content = Buffer.from(data[key].content, encoding);
    }

    // default action, return as is
    setImmediate(() => callback(null, content));

    return promise;
};

/**
 * Copies properties from source objects to target objects
 */
module.exports.assign = function (/* target, ... sources */) {
    let args = Array.from(arguments);
    let target = args.shift() || {};

    args.forEach(source => {
        Object.keys(source || {}).forEach(key => {
            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // ensure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach(subKey => {
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
};

module.exports.encodeXText = str => {
    // ! 0x21
    // + 0x2B
    // = 0x3D
    // ~ 0x7E
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
        return str;
    }
    let buf = Buffer.from(str);
    let result = '';
    for (let i = 0, len = buf.length; i < len; i++) {
        let c = buf[i];
        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {
            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();
        } else {
            result += String.fromCharCode(c);
        }
    }
    return result;
};

/**
 * Streams a stream value into a Buffer
 *
 * @param {Object} stream Readable stream
 * @param {Function} callback Callback function with (err, value)
 */
function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;

    stream.on('error', err => {
        if (responded) {
            return;
        }

        responded = true;
        callback(err);
    });

    stream.on('readable', () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });

    stream.on('end', () => {
        if (responded) {
            return;
        }
        responded = true;

        let value;

        try {
            value = Buffer.concat(chunks, chunklen);
        } catch (E) {
            return callback(E);
        }
        callback(null, value);
    });
}

/**
 * Generates a bunyan-like logger that prints to console
 *
 * @returns {Object} Bunyan logger instance
 */
function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map();
    levels.forEach(level => {
        if (level.length > levelMaxLen) {
            levelMaxLen = level.length;
        }
    });

    levels.forEach(level => {
        let levelName = level.toUpperCase();
        if (levelName.length < levelMaxLen) {
            levelName += ' '.repeat(levelMaxLen - levelName.length);
        }
        levelNames.set(level, levelName);
    });

    let print = (level, entry, message, ...args) => {
        let prefix = '';
        if (entry) {
            if (entry.tnx === 'server') {
                prefix = 'S: ';
            } else if (entry.tnx === 'client') {
                prefix = 'C: ';
            }

            if (entry.sid) {
                prefix = '[' + entry.sid + '] ' + prefix;
            }

            if (entry.cid) {
                prefix = '[#' + entry.cid + '] ' + prefix;
            }
        }

        message = util.format(message, ...args);
        message.split(/\r?\n/).forEach(line => {
            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);
        });
    };

    let logger = {};
    levels.forEach(level => {
        logger[level] = print.bind(null, level);
    });

    return logger;
}


/***/ }),

/***/ 462951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(927910);
const Transform = stream.Transform;

/**
 * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>
 * Also makes sure that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */
class DataStream extends Transform {
    constructor(options) {
        super(options);
        // init Transform
        this.options = options || {};
        this._curLine = '';

        this.inByteCount = 0;
        this.outByteCount = 0;
        this.lastByte = false;
    }

    /**
     * Escapes dots
     */
    _transform(chunk, encoding, done) {
        let chunks = [];
        let chunklen = 0;
        let i,
            len,
            lastPos = 0;
        let buf;

        if (!chunk || !chunk.length) {
            return done();
        }

        if (typeof chunk === 'string') {
            chunk = Buffer.from(chunk);
        }

        this.inByteCount += chunk.length;

        for (i = 0, len = chunk.length; i < len; i++) {
            if (chunk[i] === 0x2e) {
                // .
                if ((i && chunk[i - 1] === 0x0a) || (!i && (!this.lastByte || this.lastByte === 0x0a))) {
                    buf = chunk.slice(lastPos, i + 1);
                    chunks.push(buf);
                    chunks.push(Buffer.from('.'));
                    chunklen += buf.length + 1;
                    lastPos = i + 1;
                }
            } else if (chunk[i] === 0x0a) {
                // .
                if ((i && chunk[i - 1] !== 0x0d) || (!i && this.lastByte !== 0x0d)) {
                    if (i > lastPos) {
                        buf = chunk.slice(lastPos, i);
                        chunks.push(buf);
                        chunklen += buf.length + 2;
                    } else {
                        chunklen += 2;
                    }
                    chunks.push(Buffer.from('\r\n'));
                    lastPos = i + 1;
                }
            }
        }

        if (chunklen) {
            // add last piece
            if (lastPos < chunk.length) {
                buf = chunk.slice(lastPos);
                chunks.push(buf);
                chunklen += buf.length;
            }

            this.outByteCount += chunklen;
            this.push(Buffer.concat(chunks, chunklen));
        } else {
            this.outByteCount += chunk.length;
            this.push(chunk);
        }

        this.lastByte = chunk[chunk.length - 1];
        done();
    }

    /**
     * Finalizes the stream with a dot on a single line
     */
    _flush(done) {
        let buf;
        if (this.lastByte === 0x0a) {
            buf = Buffer.from('.\r\n');
        } else if (this.lastByte === 0x0d) {
            buf = Buffer.from('\n.\r\n');
        } else {
            buf = Buffer.from('\r\n.\r\n');
        }
        this.outByteCount += buf.length;
        this.push(buf);
        done();
    }
}

module.exports = DataStream;


/***/ }),

/***/ 861103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/**
 * Minimal HTTP/S proxy client
 */

const net = __webpack_require__(491645);
const tls = __webpack_require__(134631);
const urllib = __webpack_require__(379551);

/**
 * Establishes proxied connection to destinationPort
 *
 * httpProxyClient("http://localhost:3128/", 80, "google.com", function(err, socket){
 *     socket.write("GET / HTTP/1.0\r\n\r\n");
 * });
 *
 * @param {String} proxyUrl proxy configuration, etg "http://proxy.host:3128/"
 * @param {Number} destinationPort Port to open in destination host
 * @param {String} destinationHost Destination hostname
 * @param {Function} callback Callback to run with the rocket object once connection is established
 */
function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);

    // create a socket connection to the proxy server
    let options;
    let connect;
    let socket;

    options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === 'https:' ? 443 : 80
    };

    if (proxy.protocol === 'https:') {
        // we can use untrusted proxies as long as we verify actual SMTP certificates
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
    } else {
        connect = net.connect.bind(net);
    }

    // Error harness for initial connection. Once connection is established, the responsibility
    // to handle errors is passed to whoever uses this socket
    let finished = false;
    let tempSocketErr = err => {
        if (finished) {
            return;
        }
        finished = true;
        try {
            socket.destroy();
        } catch (E) {
            // ignore
        }
        callback(err);
    };

    let timeoutErr = () => {
        let err = new Error('Proxy socket timed out');
        err.code = 'ETIMEDOUT';
        tempSocketErr(err);
    };

    socket = connect(options, () => {
        if (finished) {
            return;
        }

        let reqHeaders = {
            Host: destinationHost + ':' + destinationPort,
            Connection: 'close'
        };
        if (proxy.auth) {
            reqHeaders['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');
        }

        socket.write(
            // HTTP method
            'CONNECT ' +
                destinationHost +
                ':' +
                destinationPort +
                ' HTTP/1.1\r\n' +
                // HTTP request headers
                Object.keys(reqHeaders)
                    .map(key => key + ': ' + reqHeaders[key])
                    .join('\r\n') +
                // End request
                '\r\n\r\n'
        );

        let headers = '';
        let onSocketData = chunk => {
            let match;
            let remainder;

            if (finished) {
                return;
            }

            headers += chunk.toString('binary');
            if ((match = headers.match(/\r\n\r\n/))) {
                socket.removeListener('data', onSocketData);

                remainder = headers.substr(match.index + match[0].length);
                headers = headers.substr(0, match.index);
                if (remainder) {
                    socket.unshift(Buffer.from(remainder, 'binary'));
                }

                // proxy connection is now established
                finished = true;

                // check response code
                match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
                if (!match || (match[1] || '').charAt(0) !== '2') {
                    try {
                        socket.destroy();
                    } catch (E) {
                        // ignore
                    }
                    return callback(new Error('Invalid response from proxy' + ((match && ': ' + match[1]) || '')));
                }

                socket.removeListener('error', tempSocketErr);
                socket.removeListener('timeout', timeoutErr);
                socket.setTimeout(0);

                return callback(null, socket);
            }
        };
        socket.on('data', onSocketData);
    });

    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on('timeout', timeoutErr);

    socket.once('error', tempSocketErr);
}

module.exports = httpProxyClient;


/***/ }),

/***/ 573724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const packageInfo = __webpack_require__(227761);
const EventEmitter = (__webpack_require__(594735).EventEmitter);
const net = __webpack_require__(491645);
const tls = __webpack_require__(134631);
const os = __webpack_require__(321820);
const crypto = __webpack_require__(455511);
const DataStream = __webpack_require__(462951);
const PassThrough = (__webpack_require__(927910).PassThrough);
const shared = __webpack_require__(835028);

// default timeout values in ms
const CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established
const SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client
const GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved
const DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname

/**
 * Generates a SMTP connection object
 *
 * Optional options object takes the following possible properties:
 *
 *  * **port** - is the port to connect to (defaults to 587 or 465)
 *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')
 *  * **secure** - use SSL
 *  * **ignoreTLS** - ignore server support for STARTTLS
 *  * **requireTLS** - forces the client to use STARTTLS
 *  * **name** - the name of the client server
 *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
 *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
 *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
 *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
 *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)
 *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
 *  * **logger** - bunyan compatible logger interface
 *  * **debug** - if true pass SMTP traffic to the logger
 *  * **tls** - options for createCredentials
 *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
 *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
 *
 * @constructor
 * @namespace SMTP Client module
 * @param {Object} [options] Option properties
 */
class SMTPConnection extends EventEmitter {
    constructor(options) {
        super(options);

        this.id = crypto.randomBytes(8).toString('base64').replace(/\W/g, '');
        this.stage = 'init';

        this.options = options || {};

        this.secureConnection = !!this.options.secure;
        this.alreadySecured = !!this.options.secured;

        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
        this.host = this.options.host || 'localhost';

        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;

        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;

        if (typeof this.options.secure === 'undefined' && this.port === 465) {
            // if secure option is not set but port is 465, then default to secure
            this.secureConnection = true;
        }

        this.name = this.options.name || this._getHostname();

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'smtp-connection',
            sid: this.id
        });

        this.customAuth = new Map();
        Object.keys(this.options.customAuth || {}).forEach(key => {
            let mapKey = (key || '').toString().trim().toUpperCase();
            if (!mapKey) {
                return;
            }
            this.customAuth.set(mapKey, this.options.customAuth[key]);
        });

        /**
         * Expose version nr, just for the reference
         * @type {String}
         */
        this.version = packageInfo.version;

        /**
         * If true, then the user is authenticated
         * @type {Boolean}
         */
        this.authenticated = false;

        /**
         * If set to true, this instance is no longer active
         * @private
         */
        this.destroyed = false;

        /**
         * Defines if the current connection is secure or not. If not,
         * STARTTLS can be used if available
         * @private
         */
        this.secure = !!this.secureConnection;

        /**
         * Store incomplete messages coming from the server
         * @private
         */
        this._remainder = '';

        /**
         * Unprocessed responses from the server
         * @type {Array}
         */
        this._responseQueue = [];

        this.lastServerResponse = false;

        /**
         * The socket connecting to the server
         * @publick
         */
        this._socket = false;

        /**
         * Lists supported auth mechanisms
         * @private
         */
        this._supportedAuth = [];

        /**
         * Set to true, if EHLO response includes "AUTH".
         * If false then authentication is not tried
         */
        this.allowsAuth = false;

        /**
         * Includes current envelope (from, to)
         * @private
         */
        this._envelope = false;

        /**
         * Lists supported extensions
         * @private
         */
        this._supportedExtensions = [];

        /**
         * Defines the maximum allowed size for a single message
         * @private
         */
        this._maxAllowedSize = 0;

        /**
         * Function queue to run if a data chunk comes from the server
         * @private
         */
        this._responseActions = [];
        this._recipientQueue = [];

        /**
         * Timeout variable for waiting the greeting
         * @private
         */
        this._greetingTimeout = false;

        /**
         * Timeout variable for waiting the connection to start
         * @private
         */
        this._connectionTimeout = false;

        /**
         * If the socket is deemed already closed
         * @private
         */
        this._destroyed = false;

        /**
         * If the socket is already being closed
         * @private
         */
        this._closing = false;

        /**
         * Callbacks for socket's listeners
         */
        this._onSocketData = chunk => this._onData(chunk);
        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');
        this._onSocketClose = () => this._onClose();
        this._onSocketEnd = () => this._onEnd();
        this._onSocketTimeout = () => this._onTimeout();
    }

    /**
     * Creates a connection to a SMTP server and sets up connection
     * listener
     */
    connect(connectCallback) {
        if (typeof connectCallback === 'function') {
            this.once('connect', () => {
                this.logger.debug(
                    {
                        tnx: 'smtp'
                    },
                    'SMTP handshake finished'
                );
                connectCallback();
            });

            const isDestroyedMessage = this._isDestroyedMessage('connect');
            if (isDestroyedMessage) {
                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));
            }
        }

        let opts = {
            port: this.port,
            host: this.host,
            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
            timeout: this.options.dnsTimeout || DNS_TIMEOUT
        };

        if (this.options.localAddress) {
            opts.localAddress = this.options.localAddress;
        }

        let setupConnectionHandlers = () => {
            this._connectionTimeout = setTimeout(() => {
                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');
            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);

            this._socket.on('error', this._onSocketError);
        };

        if (this.options.connection) {
            // connection is already opened
            this._socket = this.options.connection;
            if (this.secureConnection && !this.alreadySecured) {
                setImmediate(() =>
                    this._upgradeConnection(err => {
                        if (err) {
                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');
                            return;
                        }
                        this._onConnect();
                    })
                );
            } else {
                setImmediate(() => this._onConnect());
            }
            return;
        } else if (this.options.socket) {
            // socket object is set up but not yet connected
            this._socket = this.options.socket;
            return shared.resolveHostname(opts, (err, resolved) => {
                if (err) {
                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                }
                this.logger.debug(
                    {
                        tnx: 'dns',
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    'Resolved %s as %s [cache %s]',
                    opts.host,
                    resolved.host,
                    resolved.cached ? 'hit' : 'miss'
                );
                Object.keys(resolved).forEach(key => {
                    if (key.charAt(0) !== '_' && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket.connect(this.port, this.host, () => {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                }
            });
        } else if (this.secureConnection) {
            // connect using tls
            if (this.options.tls) {
                Object.keys(this.options.tls).forEach(key => {
                    opts[key] = this.options.tls[key];
                });
            }

            // ensure servername for SNI
            if (this.servername && !opts.servername) {
                opts.servername = this.servername;
            }

            return shared.resolveHostname(opts, (err, resolved) => {
                if (err) {
                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                }
                this.logger.debug(
                    {
                        tnx: 'dns',
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    'Resolved %s as %s [cache %s]',
                    opts.host,
                    resolved.host,
                    resolved.cached ? 'hit' : 'miss'
                );
                Object.keys(resolved).forEach(key => {
                    if (key.charAt(0) !== '_' && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = tls.connect(opts, () => {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                }
            });
        } else {
            // connect using plaintext
            return shared.resolveHostname(opts, (err, resolved) => {
                if (err) {
                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));
                }
                this.logger.debug(
                    {
                        tnx: 'dns',
                        source: opts.host,
                        resolved: resolved.host,
                        cached: !!resolved.cached
                    },
                    'Resolved %s as %s [cache %s]',
                    opts.host,
                    resolved.host,
                    resolved.cached ? 'hit' : 'miss'
                );
                Object.keys(resolved).forEach(key => {
                    if (key.charAt(0) !== '_' && resolved[key]) {
                        opts[key] = resolved[key];
                    }
                });
                try {
                    this._socket = net.connect(opts, () => {
                        this._socket.setKeepAlive(true);
                        this._onConnect();
                    });
                    setupConnectionHandlers();
                } catch (E) {
                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));
                }
            });
        }
    }

    /**
     * Sends QUIT
     */
    quit() {
        this._sendCommand('QUIT');
        this._responseActions.push(this.close);
    }

    /**
     * Closes the connection to the server
     */
    close() {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);
        this._responseActions = [];

        // allow to run this function only once
        if (this._closing) {
            return;
        }
        this._closing = true;

        let closeMethod = 'end';

        if (this.stage === 'init') {
            // Close the socket immediately when connection timed out
            closeMethod = 'destroy';
        }

        this.logger.debug(
            {
                tnx: 'smtp'
            },
            'Closing connection to the server using "%s"',
            closeMethod
        );

        let socket = (this._socket && this._socket.socket) || this._socket;

        if (socket && !socket.destroyed) {
            try {
                this._socket[closeMethod]();
            } catch (E) {
                // just ignore
            }
        }

        this._destroy();
    }

    /**
     * Authenticate user
     */
    login(authData, callback) {
        const isDestroyedMessage = this._isDestroyedMessage('login');
        if (isDestroyedMessage) {
            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));
        }

        this._auth = authData || {};
        // Select SASL authentication method
        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;

        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
            this._authMethod = 'XOAUTH2';
        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {
            // use first supported
            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();
        }

        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
            if ((this._auth.user && this._auth.pass) || this.customAuth.has(this._authMethod)) {
                this._auth.credentials = {
                    user: this._auth.user,
                    pass: this._auth.pass,
                    options: this._auth.options
                };
            } else {
                return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', 'EAUTH', false, 'API'));
            }
        }

        if (this.customAuth.has(this._authMethod)) {
            let handler = this.customAuth.get(this._authMethod);
            let lastResponse;
            let returned = false;

            let resolve = () => {
                if (returned) {
                    return;
                }
                returned = true;
                this.logger.info(
                    {
                        tnx: 'smtp',
                        username: this._auth.user,
                        action: 'authenticated',
                        method: this._authMethod
                    },
                    'User %s authenticated',
                    JSON.stringify(this._auth.user)
                );
                this.authenticated = true;
                callback(null, true);
            };

            let reject = err => {
                if (returned) {
                    return;
                }
                returned = true;
                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));
            };

            let handlerResponse = handler({
                auth: this._auth,
                method: this._authMethod,

                extensions: [].concat(this._supportedExtensions),
                authMethods: [].concat(this._supportedAuth),
                maxAllowedSize: this._maxAllowedSize || false,

                sendCommand: (cmd, done) => {
                    let promise;

                    if (!done) {
                        promise = new Promise((resolve, reject) => {
                            done = shared.callbackPromise(resolve, reject);
                        });
                    }

                    this._responseActions.push(str => {
                        lastResponse = str;

                        let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
                        let data = {
                            command: cmd,
                            response: str
                        };
                        if (codes) {
                            data.status = Number(codes[1]) || 0;
                            if (codes[2]) {
                                data.code = codes[2];
                            }
                            data.text = str.substr(codes[0].length);
                        } else {
                            data.text = str;
                            data.status = 0; // just in case we need to perform numeric comparisons
                        }
                        done(null, data);
                    });
                    setImmediate(() => this._sendCommand(cmd));

                    return promise;
                },

                resolve,
                reject
            });

            if (handlerResponse && typeof handlerResponse.catch === 'function') {
                // a promise was returned
                handlerResponse.then(resolve).catch(reject);
            }

            return;
        }

        switch (this._authMethod) {
            case 'XOAUTH2':
                this._handleXOauth2Token(false, callback);
                return;
            case 'LOGIN':
                this._responseActions.push(str => {
                    this._actionAUTH_LOGIN_USER(str, callback);
                });
                this._sendCommand('AUTH LOGIN');
                return;
            case 'PLAIN':
                this._responseActions.push(str => {
                    this._actionAUTHComplete(str, callback);
                });
                this._sendCommand(
                    'AUTH PLAIN ' +
                        Buffer.from(
                            //this._auth.user+'\u0000'+
                            '\u0000' + // skip authorization identity as it causes problems with some servers
                                this._auth.credentials.user +
                                '\u0000' +
                                this._auth.credentials.pass,
                            'utf-8'
                        ).toString('base64'),
                    // log entry without passwords
                    'AUTH PLAIN ' +
                        Buffer.from(
                            //this._auth.user+'\u0000'+
                            '\u0000' + // skip authorization identity as it causes problems with some servers
                                this._auth.credentials.user +
                                '\u0000' +
                                '/* secret */',
                            'utf-8'
                        ).toString('base64')
                );
                return;
            case 'CRAM-MD5':
                this._responseActions.push(str => {
                    this._actionAUTH_CRAM_MD5(str, callback);
                });
                this._sendCommand('AUTH CRAM-MD5');
                return;
        }

        return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', 'EAUTH', false, 'API'));
    }

    /**
     * Sends a message
     *
     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
     * @param {Object} message String, Buffer or a Stream
     * @param {Function} callback Callback to return once sending is completed
     */
    send(envelope, message, done) {
        if (!message) {
            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));
        }

        const isDestroyedMessage = this._isDestroyedMessage('send message');
        if (isDestroyedMessage) {
            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));
        }

        // reject larger messages than allowed
        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
            return setImmediate(() => {
                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));
            });
        }

        // ensure that callback is only called once
        let returned = false;
        let callback = function () {
            if (returned) {
                return;
            }
            returned = true;

            done(...arguments);
        };

        if (typeof message.on === 'function') {
            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));
        }

        let startTime = Date.now();
        this._setEnvelope(envelope, (err, info) => {
            if (err) {
                // create passthrough stream to consume to prevent OOM
                let stream = new PassThrough();
                if (typeof message.pipe === 'function') {
                    message.pipe(stream);
                } else {
                    stream.write(message);
                    stream.end();
                }
                
                return callback(err);
            }
            let envelopeTime = Date.now();
            let stream = this._createSendStream((err, str) => {
                if (err) {
                    return callback(err);
                }

                info.envelopeTime = envelopeTime - startTime;
                info.messageTime = Date.now() - envelopeTime;
                info.messageSize = stream.outByteCount;
                info.response = str;

                return callback(null, info);
            });
            if (typeof message.pipe === 'function') {
                message.pipe(stream);
            } else {
                stream.write(message);
                stream.end();
            }
        });
    }

    /**
     * Resets connection state
     *
     * @param {Function} callback Callback to return once connection is reset
     */
    reset(callback) {
        this._sendCommand('RSET');
        this._responseActions.push(str => {
            if (str.charAt(0) !== '2') {
                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));
            }
            this._envelope = false;
            return callback(null, true);
        });
    }

    /**
     * Connection listener that is run when the connection to
     * the server is opened
     *
     * @event
     */
    _onConnect() {
        clearTimeout(this._connectionTimeout);

        this.logger.info(
            {
                tnx: 'network',
                localAddress: this._socket.localAddress,
                localPort: this._socket.localPort,
                remoteAddress: this._socket.remoteAddress,
                remotePort: this._socket.remotePort
            },
            '%s established to %s:%s',
            this.secure ? 'Secure connection' : 'Connection',
            this._socket.remoteAddress,
            this._socket.remotePort
        );

        if (this._destroyed) {
            // Connection was established after we already had canceled it
            this.close();
            return;
        }

        this.stage = 'connected';

        // clear existing listeners for the socket
        this._socket.removeListener('data', this._onSocketData);
        this._socket.removeListener('timeout', this._onSocketTimeout);
        this._socket.removeListener('close', this._onSocketClose);
        this._socket.removeListener('end', this._onSocketEnd);

        this._socket.on('data', this._onSocketData);
        this._socket.once('close', this._onSocketClose);
        this._socket.once('end', this._onSocketEnd);

        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
        this._socket.on('timeout', this._onSocketTimeout);

        this._greetingTimeout = setTimeout(() => {
            // if still waiting for greeting, give up
            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');
            }
        }, this.options.greetingTimeout || GREETING_TIMEOUT);

        this._responseActions.push(this._actionGreeting);

        // we have a 'data' listener set up so resume socket if it was paused
        this._socket.resume();
    }

    /**
     * 'data' listener for data coming from the server
     *
     * @event
     * @param {Buffer} chunk Data chunk coming from the server
     */
    _onData(chunk) {
        if (this._destroyed || !chunk || !chunk.length) {
            return;
        }

        let data = (chunk || '').toString('binary');
        let lines = (this._remainder + data).split(/\r?\n/);
        let lastline;

        this._remainder = lines.pop();

        for (let i = 0, len = lines.length; i < len; i++) {
            if (this._responseQueue.length) {
                lastline = this._responseQueue[this._responseQueue.length - 1];
                if (/^\d+-/.test(lastline.split('\n').pop())) {
                    this._responseQueue[this._responseQueue.length - 1] += '\n' + lines[i];
                    continue;
                }
            }
            this._responseQueue.push(lines[i]);
        }

        if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+-/.test(lastline.split('\n').pop())) {
                return;
            }
        }

        this._processResponse();
    }

    /**
     * 'error' listener for the socket
     *
     * @event
     * @param {Error} err Error object
     * @param {String} type Error name
     */
    _onError(err, type, data, command) {
        clearTimeout(this._connectionTimeout);
        clearTimeout(this._greetingTimeout);

        if (this._destroyed) {
            // just ignore, already closed
            // this might happen when a socket is canceled because of reached timeout
            // but the socket timeout error itself receives only after
            return;
        }

        err = this._formatError(err, type, data, command);

        this.logger.error(data, err.message);

        this.emit('error', err);
        this.close();
    }

    _formatError(message, type, response, command) {
        let err;

        if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
            err = message;
        } else {
            err = new Error(message);
        }

        if (type && type !== 'Error') {
            err.code = type;
        }

        if (response) {
            err.response = response;
            err.message += ': ' + response;
        }

        let responseCode = (typeof response === 'string' && Number((response.match(/^\d+/) || [])[0])) || false;
        if (responseCode) {
            err.responseCode = responseCode;
        }

        if (command) {
            err.command = command;
        }

        return err;
    }

    /**
     * 'close' listener for the socket
     *
     * @event
     */
    _onClose() {
        let serverResponse = false;

        if (this._remainder && this._remainder.trim()) {
            if (this.options.debug || this.options.transactionLog) {
                this.logger.debug(
                    {
                        tnx: 'server'
                    },
                    this._remainder.replace(/\r?\n$/, '')
                );
            }
            this.lastServerResponse = serverResponse = this._remainder.trim();
        }

        this.logger.info(
            {
                tnx: 'network'
            },
            'Connection closed'
        );

        if (this.upgrading && !this._destroyed) {
            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', serverResponse, 'CONN');
        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');
        } else if (/^[45]\d{2}\b/.test(serverResponse)) {
            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');
        }

        this._destroy();
    }

    /**
     * 'end' listener for the socket
     *
     * @event
     */
    _onEnd() {
        if (this._socket && !this._socket.destroyed) {
            this._socket.destroy();
        }
    }

    /**
     * 'timeout' listener for the socket
     *
     * @event
     */
    _onTimeout() {
        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');
    }

    /**
     * Destroys the client, emits 'end'
     */
    _destroy() {
        if (this._destroyed) {
            return;
        }
        this._destroyed = true;
        this.emit('end');
    }

    /**
     * Upgrades the connection to TLS
     *
     * @param {Function} callback Callback function to run when the connection
     *        has been secured
     */
    _upgradeConnection(callback) {
        // do not remove all listeners or it breaks node v0.10 as there's
        // apparently a 'finish' event set that would be cleared as well

        // we can safely keep 'error', 'end', 'close' etc. events
        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards
        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object

        let socketPlain = this._socket;
        let opts = {
            socket: this._socket,
            host: this.host
        };

        Object.keys(this.options.tls || {}).forEach(key => {
            opts[key] = this.options.tls[key];
        });

        // ensure servername for SNI
        if (this.servername && !opts.servername) {
            opts.servername = this.servername;
        }

        this.upgrading = true;
        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch
        try {
            this._socket = tls.connect(opts, () => {
                this.secure = true;
                this.upgrading = false;
                this._socket.on('data', this._onSocketData);

                socketPlain.removeListener('close', this._onSocketClose);
                socketPlain.removeListener('end', this._onSocketEnd);

                return callback(null, true);
            });
        } catch (err) {
            return callback(err);
        }

        this._socket.on('error', this._onSocketError);
        this._socket.once('close', this._onSocketClose);
        this._socket.once('end', this._onSocketEnd);

        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.
        this._socket.on('timeout', this._onSocketTimeout);

        // resume in case the socket was paused
        socketPlain.resume();
    }

    /**
     * Processes queued responses from the server
     *
     * @param {Boolean} force If true, ignores _processing flag
     */
    _processResponse() {
        if (!this._responseQueue.length) {
            return false;
        }

        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());

        if (/^\d+-/.test(str.split('\n').pop())) {
            // keep waiting for the final part of multiline response
            return;
        }

        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug(
                {
                    tnx: 'server'
                },
                str.replace(/\r?\n$/, '')
            );
        }

        if (!str.trim()) {
            // skip unexpected empty lines
            setImmediate(() => this._processResponse());
        }

        let action = this._responseActions.shift();

        if (typeof action === 'function') {
            action.call(this, str);
            setImmediate(() => this._processResponse());
        } else {
            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');
        }
    }

    /**
     * Send a command to the server, append \r\n
     *
     * @param {String} str String to be sent to the server
     * @param {String} logStr Optional string to be used for logging instead of the actual string
     */
    _sendCommand(str, logStr) {
        if (this._destroyed) {
            // Connection already closed, can't send any more data
            return;
        }

        if (this._socket.destroyed) {
            return this.close();
        }

        if (this.options.debug || this.options.transactionLog) {
            this.logger.debug(
                {
                    tnx: 'client'
                },
                (logStr || str || '').toString().replace(/\r?\n$/, '')
            );
        }

        this._socket.write(Buffer.from(str + '\r\n', 'utf-8'));
    }

    /**
     * Initiates a new message by submitting envelope data, starting with
     * MAIL FROM: command
     *
     * @param {Object} envelope Envelope object in the form of
     *        {from:'...', to:['...']}
     *        or
     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
     */
    _setEnvelope(envelope, callback) {
        let args = [];
        let useSmtpUtf8 = false;

        this._envelope = envelope || {};
        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();

        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());

        if (!this._envelope.to.length) {
            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));
        }

        if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));
        }

        // check if the sender address uses only ASCII characters,
        // otherwise require usage of SMTPUTF8 extension
        if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
            useSmtpUtf8 = true;
        }

        for (let i = 0, len = this._envelope.to.length; i < len; i++) {
            if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));
            }

            // check if the recipients addresses use only ASCII characters,
            // otherwise require usage of SMTPUTF8 extension
            if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
                useSmtpUtf8 = true;
            }
        }

        // clone the recipients array for latter manipulation
        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
        this._envelope.rejected = [];
        this._envelope.rejectedErrors = [];
        this._envelope.accepted = [];

        if (this._envelope.dsn) {
            try {
                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
            } catch (err) {
                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));
            }
        }

        this._responseActions.push(str => {
            this._actionMAIL(str, callback);
        });

        // If the server supports SMTPUTF8 and the envelope includes an internationalized
        // email address then append SMTPUTF8 keyword to the MAIL FROM command
        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {
            args.push('SMTPUTF8');
            this._usingSmtpUtf8 = true;
        }

        // If the server supports 8BITMIME and the message might contain non-ascii bytes
        // then append the 8BITMIME keyword to the MAIL FROM command
        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {
            args.push('BODY=8BITMIME');
            this._using8BitMime = true;
        }

        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {
            args.push('SIZE=' + this._envelope.size);
        }

        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the MAIL FROM command
        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {
            if (this._envelope.dsn.ret) {
                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));
            }
            if (this._envelope.dsn.envid) {
                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));
            }
        }

        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));
    }

    _setDsnEnvelope(params) {
        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;
        if (ret) {
            switch (ret) {
                case 'HDRS':
                case 'HEADERS':
                    ret = 'HDRS';
                    break;
                case 'FULL':
                case 'BODY':
                    ret = 'FULL';
                    break;
            }
        }

        if (ret && !['FULL', 'HDRS'].includes(ret)) {
            throw new Error('ret: ' + JSON.stringify(ret));
        }

        let envid = (params.envid || params.id || '').toString() || null;

        let notify = params.notify || null;
        if (notify) {
            if (typeof notify === 'string') {
                notify = notify.split(',');
            }
            notify = notify.map(n => n.trim().toUpperCase());
            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];
            let invaliNotify = notify.filter(n => !validNotify.includes(n));
            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {
                throw new Error('notify: ' + JSON.stringify(notify.join(',')));
            }
            notify = notify.join(',');
        }

        let orcpt = (params.recipient || params.orcpt || '').toString() || null;
        if (orcpt && orcpt.indexOf(';') < 0) {
            orcpt = 'rfc822;' + orcpt;
        }

        return {
            ret,
            envid,
            notify,
            orcpt
        };
    }

    _getDsnRcptToArgs() {
        let args = [];
        // If the server supports DSN and the envelope includes an DSN prop
        // then append DSN params to the RCPT TO command
        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {
            if (this._envelope.dsn.notify) {
                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));
            }
            if (this._envelope.dsn.orcpt) {
                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));
            }
        }
        return args.length ? ' ' + args.join(' ') : '';
    }

    _createSendStream(callback) {
        let dataStream = new DataStream();
        let logStream;

        if (this.options.lmtp) {
            this._envelope.accepted.forEach((recipient, i) => {
                let final = i === this._envelope.accepted.length - 1;
                this._responseActions.push(str => {
                    this._actionLMTPStream(recipient, final, str, callback);
                });
            });
        } else {
            this._responseActions.push(str => {
                this._actionSMTPStream(str, callback);
            });
        }

        dataStream.pipe(this._socket, {
            end: false
        });

        if (this.options.debug) {
            logStream = new PassThrough();
            logStream.on('readable', () => {
                let chunk;
                while ((chunk = logStream.read())) {
                    this.logger.debug(
                        {
                            tnx: 'message'
                        },
                        chunk.toString('binary').replace(/\r?\n$/, '')
                    );
                }
            });
            dataStream.pipe(logStream);
        }

        dataStream.once('end', () => {
            this.logger.info(
                {
                    tnx: 'message',
                    inByteCount: dataStream.inByteCount,
                    outByteCount: dataStream.outByteCount
                },
                '<%s bytes encoded mime message (source size %s bytes)>',
                dataStream.outByteCount,
                dataStream.inByteCount
            );
        });

        return dataStream;
    }

    /** ACTIONS **/

    /**
     * Will be run after the connection is created and the server sends
     * a greeting. If the incoming message starts with 220 initiate
     * SMTP session by sending EHLO command
     *
     * @param {String} str Message from the server
     */
    _actionGreeting(str) {
        clearTimeout(this._greetingTimeout);

        if (str.substr(0, 3) !== '220') {
            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');
            return;
        }

        if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand('LHLO ' + this.name);
        } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand('EHLO ' + this.name);
        }
    }

    /**
     * Handles server response for LHLO command. If it yielded in
     * error, emit 'error', otherwise treat this as an EHLO response
     *
     * @param {String} str Message from the server
     */
    _actionLHLO(str) {
        if (str.charAt(0) !== '2') {
            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');
            return;
        }

        this._actionEHLO(str);
    }

    /**
     * Handles server response for EHLO command. If it yielded in
     * error, try HELO instead, otherwise initiate TLS negotiation
     * if STARTTLS is supported by the server or move into the
     * authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionEHLO(str) {
        let match;

        if (str.substr(0, 3) === '421') {
            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');
            return;
        }

        if (str.charAt(0) !== '2') {
            if (this.options.requireTLS) {
                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');
                return;
            }

            // Try HELO instead
            this._responseActions.push(this._actionHELO);
            this._sendCommand('HELO ' + this.name);
            return;
        }

        this._ehloLines = str
            .split(/\r?\n/)
            .map(line => line.replace(/^\d+[ -]/, '').trim())
            .filter(line => line)
            .slice(1);

        // Detect if the server supports STARTTLS
        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
            this._sendCommand('STARTTLS');
            this._responseActions.push(this._actionSTARTTLS);
            return;
        }

        // Detect if the server supports SMTPUTF8
        if (/[ -]SMTPUTF8\b/im.test(str)) {
            this._supportedExtensions.push('SMTPUTF8');
        }

        // Detect if the server supports DSN
        if (/[ -]DSN\b/im.test(str)) {
            this._supportedExtensions.push('DSN');
        }

        // Detect if the server supports 8BITMIME
        if (/[ -]8BITMIME\b/im.test(str)) {
            this._supportedExtensions.push('8BITMIME');
        }

        // Detect if the server supports PIPELINING
        if (/[ -]PIPELINING\b/im.test(str)) {
            this._supportedExtensions.push('PIPELINING');
        }

        // Detect if the server supports AUTH
        if (/[ -]AUTH\b/i.test(str)) {
            this.allowsAuth = true;
        }

        // Detect if the server supports PLAIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
            this._supportedAuth.push('PLAIN');
        }

        // Detect if the server supports LOGIN auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
            this._supportedAuth.push('LOGIN');
        }

        // Detect if the server supports CRAM-MD5 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
            this._supportedAuth.push('CRAM-MD5');
        }

        // Detect if the server supports XOAUTH2 auth
        if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
            this._supportedAuth.push('XOAUTH2');
        }

        // Detect if the server supports SIZE extensions (and the max allowed size)
        if ((match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im))) {
            this._supportedExtensions.push('SIZE');
            this._maxAllowedSize = Number(match[1]) || 0;
        }

        this.emit('connect');
    }

    /**
     * Handles server response for HELO command. If it yielded in
     * error, emit 'error', otherwise move into the authentication phase.
     *
     * @param {String} str Message from the server
     */
    _actionHELO(str) {
        if (str.charAt(0) !== '2') {
            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');
            return;
        }

        // assume that authentication is enabled (most probably is not though)
        this.allowsAuth = true;

        this.emit('connect');
    }

    /**
     * Handles server response for STARTTLS command. If there's an error
     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
     * succeedes restart the EHLO
     *
     * @param {String} str Message from the server
     */
    _actionSTARTTLS(str) {
        if (str.charAt(0) !== '2') {
            if (this.options.opportunisticTLS) {
                this.logger.info(
                    {
                        tnx: 'smtp'
                    },
                    'Failed STARTTLS upgrade, continuing unencrypted'
                );
                return this.emit('connect');
            }
            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');
            return;
        }

        this._upgradeConnection((err, secured) => {
            if (err) {
                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');
                return;
            }

            this.logger.info(
                {
                    tnx: 'smtp'
                },
                'Connection upgraded with STARTTLS'
            );

            if (secured) {
                // restart session
                if (this.options.lmtp) {
                    this._responseActions.push(this._actionLHLO);
                    this._sendCommand('LHLO ' + this.name);
                } else {
                    this._responseActions.push(this._actionEHLO);
                    this._sendCommand('EHLO ' + this.name);
                }
            } else {
                this.emit('connect');
            }
        });
    }

    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
     * response needs to be base64 encoded username. We do not need
     * exact match but settle with 334 response in general as some
     * hosts invalidly use a longer message than VXNlcm5hbWU6
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_USER(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 VXNlcm5hbWU6'
            callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', 'EAUTH', str, 'AUTH LOGIN'));
            return;
        }

        this._responseActions.push(str => {
            this._actionAUTH_LOGIN_PASS(str, callback);
        });

        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));
    }

    /**
     * Handle the response for AUTH CRAM-MD5 command. We are expecting
     * '334 <challenge string>'. Data to be sent as response needs to be
     * base64 decoded challenge string, MD5 hashed using the password as
     * a HMAC key, prefixed by the username and a space, and finally all
     * base64 encoded again.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5(str, callback) {
        let challengeMatch = str.match(/^334\s+(.+)$/);
        let challengeString = '';

        if (!challengeMatch) {
            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));
        } else {
            challengeString = challengeMatch[1];
        }

        // Decode from base64
        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),
            hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);

        hmacMD5.update(base64decoded);

        let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');

        this._responseActions.push(str => {
            this._actionAUTH_CRAM_MD5_PASS(str, callback);
        });

        this._sendCommand(
            Buffer.from(prepended).toString('base64'),
            // hidden hash for logs
            Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')
        );
    }

    /**
     * Handles the response to CRAM-MD5 authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
        if (!str.match(/^235\s+/)) {
            return callback(this._formatError('Invalid login sequence while waiting for "235"', 'EAUTH', str, 'AUTH CRAM-MD5'));
        }

        this.logger.info(
            {
                tnx: 'smtp',
                username: this._auth.user,
                action: 'authenticated',
                method: this._authMethod
            },
            'User %s authenticated',
            JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback(null, true);
    }

    /**
     * Handle the response for AUTH LOGIN command. We are expecting
     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
     * response needs to be base64 encoded password.
     *
     * @param {String} str Message from the server
     */
    _actionAUTH_LOGIN_PASS(str, callback) {
        if (!/^334[ -]/.test(str)) {
            // expecting '334 UGFzc3dvcmQ6'
            return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', 'EAUTH', str, 'AUTH LOGIN'));
        }

        this._responseActions.push(str => {
            this._actionAUTHComplete(str, callback);
        });

        this._sendCommand(
            Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),
            // Hidden pass for logs
            Buffer.from('/* secret */', 'utf-8').toString('base64')
        );
    }

    /**
     * Handles the response for authentication, if there's no error,
     * the user can be considered logged in. Start waiting for a message to send
     *
     * @param {String} str Message from the server
     */
    _actionAUTHComplete(str, isRetry, callback) {
        if (!callback && typeof isRetry === 'function') {
            callback = isRetry;
            isRetry = false;
        }

        if (str.substr(0, 3) === '334') {
            this._responseActions.push(str => {
                if (isRetry || this._authMethod !== 'XOAUTH2') {
                    this._actionAUTHComplete(str, true, callback);
                } else {
                    // fetch a new OAuth2 access token
                    setImmediate(() => this._handleXOauth2Token(true, callback));
                }
            });
            this._sendCommand('');
            return;
        }

        if (str.charAt(0) !== '2') {
            this.logger.info(
                {
                    tnx: 'smtp',
                    username: this._auth.user,
                    action: 'authfail',
                    method: this._authMethod
                },
                'User %s failed to authenticate',
                JSON.stringify(this._auth.user)
            );
            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));
        }

        this.logger.info(
            {
                tnx: 'smtp',
                username: this._auth.user,
                action: 'authenticated',
                method: this._authMethod
            },
            'User %s authenticated',
            JSON.stringify(this._auth.user)
        );
        this.authenticated = true;
        callback(null, true);
    }

    /**
     * Handle response for a MAIL FROM: command
     *
     * @param {String} str Message from the server
     */
    _actionMAIL(str, callback) {
        let message, curRecipient;
        if (Number(str.charAt(0)) !== 2) {
            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
                message = 'Internationalized mailbox name not allowed';
            } else {
                message = 'Mail command failed';
            }
            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));
        }

        if (!this._envelope.rcptQueue.length) {
            return callback(this._formatError('Can\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));
        } else {
            this._recipientQueue = [];

            if (this._supportedExtensions.includes('PIPELINING')) {
                while (this._envelope.rcptQueue.length) {
                    curRecipient = this._envelope.rcptQueue.shift();
                    this._recipientQueue.push(curRecipient);
                    this._responseActions.push(str => {
                        this._actionRCPT(str, callback);
                    });
                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
                }
            } else {
                curRecipient = this._envelope.rcptQueue.shift();
                this._recipientQueue.push(curRecipient);
                this._responseActions.push(str => {
                    this._actionRCPT(str, callback);
                });
                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
            }
        }
    }

    /**
     * Handle response for a RCPT TO: command
     *
     * @param {String} str Message from the server
     */
    _actionRCPT(str, callback) {
        let message,
            err,
            curRecipient = this._recipientQueue.shift();
        if (Number(str.charAt(0)) !== 2) {
            // this is a soft error
            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
                message = 'Internationalized mailbox name not allowed';
            } else {
                message = 'Recipient command failed';
            }
            this._envelope.rejected.push(curRecipient);
            // store error for the failed recipient
            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');
            err.recipient = curRecipient;
            this._envelope.rejectedErrors.push(err);
        } else {
            this._envelope.accepted.push(curRecipient);
        }

        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
            if (this._envelope.rejected.length < this._envelope.to.length) {
                this._responseActions.push(str => {
                    this._actionDATA(str, callback);
                });
                this._sendCommand('DATA');
            } else {
                err = this._formatError('Can\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');
                err.rejected = this._envelope.rejected;
                err.rejectedErrors = this._envelope.rejectedErrors;
                return callback(err);
            }
        } else if (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push(str => {
                this._actionRCPT(str, callback);
            });
            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());
        }
    }

    /**
     * Handle response for a DATA command
     *
     * @param {String} str Message from the server
     */
    _actionDATA(str, callback) {
        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
        if (!/^[23]/.test(str)) {
            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));
        }

        let response = {
            accepted: this._envelope.accepted,
            rejected: this._envelope.rejected
        };

        if (this._ehloLines && this._ehloLines.length) {
            response.ehlo = this._ehloLines;
        }

        if (this._envelope.rejectedErrors.length) {
            response.rejectedErrors = this._envelope.rejectedErrors;
        }

        callback(null, response);
    }

    /**
     * Handle response for a DATA stream when using SMTP
     * We expect a single response that defines if the sending succeeded or failed
     *
     * @param {String} str Message from the server
     */
    _actionSMTPStream(str, callback) {
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));
        } else {
            // Message sent succesfully
            return callback(null, str);
        }
    }

    /**
     * Handle response for a DATA stream
     * We expect a separate response for every recipient. All recipients can either
     * succeed or fail separately
     *
     * @param {String} recipient The recipient this response applies to
     * @param {Boolean} final Is this the final recipient?
     * @param {String} str Message from the server
     */
    _actionLMTPStream(recipient, final, str, callback) {
        let err;
        if (Number(str.charAt(0)) !== 2) {
            // Message failed
            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');
            err.recipient = recipient;
            this._envelope.rejected.push(recipient);
            this._envelope.rejectedErrors.push(err);
            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {
                if (this._envelope.accepted[i] === recipient) {
                    this._envelope.accepted.splice(i, 1);
                }
            }
        }
        if (final) {
            return callback(null, str);
        }
    }

    _handleXOauth2Token(isRetry, callback) {
        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
            if (err) {
                this.logger.info(
                    {
                        tnx: 'smtp',
                        username: this._auth.user,
                        action: 'authfail',
                        method: this._authMethod
                    },
                    'User %s failed to authenticate',
                    JSON.stringify(this._auth.user)
                );
                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));
            }
            this._responseActions.push(str => {
                this._actionAUTHComplete(str, isRetry, callback);
            });
            this._sendCommand(
                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),
                //  Hidden for logs
                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')
            );
        });
    }

    /**
     *
     * @param {string} command
     * @private
     */
    _isDestroyedMessage(command) {
        if (this._destroyed) {
            return 'Cannot ' + command + ' - smtp connection is already destroyed.';
        }

        if (this._socket) {
            if (this._socket.destroyed) {
                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';
            }

            if (!this._socket.writable) {
                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';
            }
        }
    }

    _getHostname() {
        // defaul hostname is machine hostname or [IP]
        let defaultHostname;
        try {
            defaultHostname = os.hostname() || '';
        } catch (err) {
            // fails on windows 7
            defaultHostname = 'localhost';
        }

        // ignore if not FQDN
        if (!defaultHostname || defaultHostname.indexOf('.') < 0) {
            defaultHostname = '[127.0.0.1]';
        }

        // IP should be enclosed in []
        if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
            defaultHostname = '[' + defaultHostname + ']';
        }

        return defaultHostname;
    }
}

module.exports = SMTPConnection;


/***/ }),

/***/ 158914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(594735);
const PoolResource = __webpack_require__(267863);
const SMTPConnection = __webpack_require__(573724);
const wellKnown = __webpack_require__(867371);
const shared = __webpack_require__(835028);
const packageData = __webpack_require__(227761);

/**
 * Creates a SMTP pool transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options SMTP Connection options
 */
class SMTPPool extends EventEmitter {
    constructor(options) {
        super();

        options = options || {};
        if (typeof options === 'string') {
            options = {
                url: options
            };
        }

        let urlData;
        let service = options.service;

        if (typeof options.getSocket === 'function') {
            this.getSocket = options.getSocket;
        }

        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }

        this.options = shared.assign(
            false, // create new object
            options, // regular options
            urlData, // url options
            service && wellKnown(service) // wellknown options
        );

        this.options.maxConnections = this.options.maxConnections || 5;
        this.options.maxMessages = this.options.maxMessages || 100;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'smtp-pool'
        });

        // temporary object
        let connection = new SMTPConnection(this.options);

        this.name = 'SMTP (pool)';
        this.version = packageData.version + '[client:' + connection.version + ']';

        this._rateLimit = {
            counter: 0,
            timeout: null,
            waiting: [],
            checkpoint: false,
            delta: Number(this.options.rateDelta) || 1000,
            limit: Number(this.options.rateLimit) || 0
        };
        this._closed = false;
        this._queue = [];
        this._connections = [];
        this._connectionCounter = 0;

        this.idling = true;

        setImmediate(() => {
            if (this.idling) {
                this.emit('idle');
            }
        });
    }

    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */
    getSocket(options, callback) {
        // return immediatelly
        return setImmediate(() => callback(null, false));
    }

    /**
     * Queues an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
        if (this._closed) {
            return false;
        }

        this._queue.push({
            mail,
            requeueAttempts: 0,
            callback
        });

        if (this.idling && this._queue.length >= this.options.maxConnections) {
            this.idling = false;
        }

        setImmediate(() => this._processMessages());

        return true;
    }

    /**
     * Closes all connections in the pool. If there is a message being sent, the connection
     * is closed later
     */
    close() {
        let connection;
        let len = this._connections.length;
        this._closed = true;

        // clear rate limit timer if it exists
        clearTimeout(this._rateLimit.timeout);

        if (!len && !this._queue.length) {
            return;
        }

        // remove all available connections
        for (let i = len - 1; i >= 0; i--) {
            if (this._connections[i] && this._connections[i].available) {
                connection = this._connections[i];
                connection.close();
                this.logger.info(
                    {
                        tnx: 'connection',
                        cid: connection.id,
                        action: 'removed'
                    },
                    'Connection #%s removed',
                    connection.id
                );
            }
        }

        if (len && !this._connections.length) {
            this.logger.debug(
                {
                    tnx: 'connection'
                },
                'All connections removed'
            );
        }

        if (!this._queue.length) {
            return;
        }

        // make sure that entire queue would be cleaned
        let invokeCallbacks = () => {
            if (!this._queue.length) {
                this.logger.debug(
                    {
                        tnx: 'connection'
                    },
                    'Pending queue entries cleared'
                );
                return;
            }
            let entry = this._queue.shift();
            if (entry && typeof entry.callback === 'function') {
                try {
                    entry.callback(new Error('Connection pool was closed'));
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: 'callback',
                            cid: connection.id
                        },
                        'Callback error for #%s: %s',
                        connection.id,
                        E.message
                    );
                }
            }
            setImmediate(invokeCallbacks);
        };
        setImmediate(invokeCallbacks);
    }

    /**
     * Check the queue and available connections. If there is a message to be sent and there is
     * an available connection, then use this connection to send the mail
     */
    _processMessages() {
        let connection;
        let i, len;

        // do nothing if already closed
        if (this._closed) {
            return;
        }

        // do nothing if queue is empty
        if (!this._queue.length) {
            if (!this.idling) {
                // no pending jobs
                this.idling = true;
                this.emit('idle');
            }
            return;
        }

        // find first available connection
        for (i = 0, len = this._connections.length; i < len; i++) {
            if (this._connections[i].available) {
                connection = this._connections[i];
                break;
            }
        }

        if (!connection && this._connections.length < this.options.maxConnections) {
            connection = this._createConnection();
        }

        if (!connection) {
            // no more free connection slots available
            this.idling = false;
            return;
        }

        // check if there is free space in the processing queue
        if (!this.idling && this._queue.length < this.options.maxConnections) {
            this.idling = true;
            this.emit('idle');
        }

        let entry = (connection.queueEntry = this._queue.shift());
        entry.messageId = (connection.queueEntry.mail.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');

        connection.available = false;

        this.logger.debug(
            {
                tnx: 'pool',
                cid: connection.id,
                messageId: entry.messageId,
                action: 'assign'
            },
            'Assigned message <%s> to #%s (%s)',
            entry.messageId,
            connection.id,
            connection.messages + 1
        );

        if (this._rateLimit.limit) {
            this._rateLimit.counter++;
            if (!this._rateLimit.checkpoint) {
                this._rateLimit.checkpoint = Date.now();
            }
        }

        connection.send(entry.mail, (err, info) => {
            // only process callback if current handler is not changed
            if (entry === connection.queueEntry) {
                try {
                    entry.callback(err, info);
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: 'callback',
                            cid: connection.id
                        },
                        'Callback error for #%s: %s',
                        connection.id,
                        E.message
                    );
                }
                connection.queueEntry = false;
            }
        });
    }

    /**
     * Creates a new pool resource
     */
    _createConnection() {
        let connection = new PoolResource(this);

        connection.id = ++this._connectionCounter;

        this.logger.info(
            {
                tnx: 'pool',
                cid: connection.id,
                action: 'conection'
            },
            'Created new pool resource #%s',
            connection.id
        );

        // resource comes available
        connection.on('available', () => {
            this.logger.debug(
                {
                    tnx: 'connection',
                    cid: connection.id,
                    action: 'available'
                },
                'Connection #%s became available',
                connection.id
            );

            if (this._closed) {
                // if already closed run close() that will remove this connections from connections list
                this.close();
            } else {
                // check if there's anything else to send
                this._processMessages();
            }
        });

        // resource is terminated with an error
        connection.once('error', err => {
            if (err.code !== 'EMAXLIMIT') {
                this.logger.error(
                    {
                        err,
                        tnx: 'pool',
                        cid: connection.id
                    },
                    'Pool Error for #%s: %s',
                    connection.id,
                    err.message
                );
            } else {
                this.logger.debug(
                    {
                        tnx: 'pool',
                        cid: connection.id,
                        action: 'maxlimit'
                    },
                    'Max messages limit exchausted for #%s',
                    connection.id
                );
            }

            if (connection.queueEntry) {
                try {
                    connection.queueEntry.callback(err);
                } catch (E) {
                    this.logger.error(
                        {
                            err: E,
                            tnx: 'callback',
                            cid: connection.id
                        },
                        'Callback error for #%s: %s',
                        connection.id,
                        E.message
                    );
                }
                connection.queueEntry = false;
            }

            // remove the erroneus connection from connections list
            this._removeConnection(connection);

            this._continueProcessing();
        });

        connection.once('close', () => {
            this.logger.info(
                {
                    tnx: 'connection',
                    cid: connection.id,
                    action: 'closed'
                },
                'Connection #%s was closed',
                connection.id
            );

            this._removeConnection(connection);

            if (connection.queueEntry) {
                // If the connection closed when sending, add the message to the queue again
                // if max number of requeues is not reached yet
                // Note that we must wait a bit.. because the callback of the 'error' handler might be called
                // in the next event loop
                setTimeout(() => {
                    if (connection.queueEntry) {
                        if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                            this._requeueEntryOnConnectionClose(connection);
                        } else {
                            this._failDeliveryOnConnectionClose(connection);
                        }
                    }
                    this._continueProcessing();
                }, 50);
            } else {
                this._continueProcessing();
            }
        });

        this._connections.push(connection);

        return connection;
    }

    _shouldRequeuOnConnectionClose(queueEntry) {
        if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
            return true;
        }

        return queueEntry.requeueAttempts < this.options.maxRequeues;
    }

    _failDeliveryOnConnectionClose(connection) {
        if (connection.queueEntry && connection.queueEntry.callback) {
            try {
                connection.queueEntry.callback(new Error('Reached maximum number of retries after connection was closed'));
            } catch (E) {
                this.logger.error(
                    {
                        err: E,
                        tnx: 'callback',
                        messageId: connection.queueEntry.messageId,
                        cid: connection.id
                    },
                    'Callback error for #%s: %s',
                    connection.id,
                    E.message
                );
            }
            connection.queueEntry = false;
        }
    }

    _requeueEntryOnConnectionClose(connection) {
        connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
        this.logger.debug(
            {
                tnx: 'pool',
                cid: connection.id,
                messageId: connection.queueEntry.messageId,
                action: 'requeue'
            },
            'Re-queued message <%s> for #%s. Attempt: #%s',
            connection.queueEntry.messageId,
            connection.id,
            connection.queueEntry.requeueAttempts
        );
        this._queue.unshift(connection.queueEntry);
        connection.queueEntry = false;
    }

    /**
     * Continue to process message if the pool hasn't closed
     */
    _continueProcessing() {
        if (this._closed) {
            this.close();
        } else {
            setTimeout(() => this._processMessages(), 100);
        }
    }

    /**
     * Remove resource from pool
     *
     * @param {Object} connection The PoolResource to remove
     */
    _removeConnection(connection) {
        let index = this._connections.indexOf(connection);

        if (index !== -1) {
            this._connections.splice(index, 1);
        }
    }

    /**
     * Checks if connections have hit current rate limit and if so, queues the availability callback
     *
     * @param {Function} callback Callback function to run once rate limiter has been cleared
     */
    _checkRateLimit(callback) {
        if (!this._rateLimit.limit) {
            return callback();
        }

        let now = Date.now();

        if (this._rateLimit.counter < this._rateLimit.limit) {
            return callback();
        }

        this._rateLimit.waiting.push(callback);

        if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
            return this._clearRateLimit();
        } else if (!this._rateLimit.timeout) {
            this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
            this._rateLimit.checkpoint = now;
        }
    }

    /**
     * Clears current rate limit limitation and runs paused callback
     */
    _clearRateLimit() {
        clearTimeout(this._rateLimit.timeout);
        this._rateLimit.timeout = null;
        this._rateLimit.counter = 0;
        this._rateLimit.checkpoint = false;

        // resume all paused connections
        while (this._rateLimit.waiting.length) {
            let cb = this._rateLimit.waiting.shift();
            setImmediate(cb);
        }
    }

    /**
     * Returns true if there are free slots in the queue
     */
    isIdle() {
        return this.idling;
    }

    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) => {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        let auth = new PoolResource(this).auth;

        this.getSocket(this.options, (err, socketOptions) => {
            if (err) {
                return callback(err);
            }

            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info(
                    {
                        tnx: 'proxy',
                        remoteAddress: socketOptions.connection.remoteAddress,
                        remotePort: socketOptions.connection.remotePort,
                        destHost: options.host || '',
                        destPort: options.port || '',
                        action: 'connected'
                    },
                    'Using proxied socket from %s:%s to %s:%s',
                    socketOptions.connection.remoteAddress,
                    socketOptions.connection.remotePort,
                    options.host || '',
                    options.port || ''
                );
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach(key => {
                    options[key] = socketOptions[key];
                });
            }

            let connection = new SMTPConnection(options);
            let returned = false;

            connection.once('error', err => {
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });

            connection.once('end', () => {
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error('Connection closed'));
            });

            let finalize = () => {
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };

            connection.connect(() => {
                if (returned) {
                    return;
                }

                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, err => {
                        if (returned) {
                            return;
                        }

                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }

                        finalize();
                    });
                } else if (!auth && connection.allowsAuth && options.forceAuth) {
                    let err = new Error('Authentication info was not provided');
                    err.code = 'NoAuth';

                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });

        return promise;
    }
}

// expose to the world
module.exports = SMTPPool;


/***/ }),

/***/ 267863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const SMTPConnection = __webpack_require__(573724);
const assign = (__webpack_require__(835028).assign);
const XOAuth2 = __webpack_require__(598492);
const EventEmitter = __webpack_require__(594735);

/**
 * Creates an element for the pool
 *
 * @constructor
 * @param {Object} options SMTPPool instance
 */
class PoolResource extends EventEmitter {
    constructor(pool) {
        super();

        this.pool = pool;
        this.options = pool.options;
        this.logger = this.pool.logger;

        if (this.options.auth) {
            switch ((this.options.auth.type || '').toString().toUpperCase()) {
                case 'OAUTH2': {
                    let oauth2 = new XOAuth2(this.options.auth, this.logger);
                    oauth2.provisionCallback = (this.pool.mailer && this.pool.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;
                    this.auth = {
                        type: 'OAUTH2',
                        user: this.options.auth.user,
                        oauth2,
                        method: 'XOAUTH2'
                    };
                    oauth2.on('token', token => this.pool.mailer.emit('token', token));
                    oauth2.on('error', err => this.emit('error', err));
                    break;
                }
                default:
                    if (!this.options.auth.user && !this.options.auth.pass) {
                        break;
                    }
                    this.auth = {
                        type: (this.options.auth.type || '').toString().toUpperCase() || 'LOGIN',
                        user: this.options.auth.user,
                        credentials: {
                            user: this.options.auth.user || '',
                            pass: this.options.auth.pass,
                            options: this.options.auth.options
                        },
                        method: (this.options.auth.method || '').trim().toUpperCase() || this.options.authMethod || false
                    };
            }
        }

        this._connection = false;
        this._connected = false;

        this.messages = 0;
        this.available = true;
    }

    /**
     * Initiates a connection to the SMTP server
     *
     * @param {Function} callback Callback function to run once the connection is established or failed
     */
    connect(callback) {
        this.pool.getSocket(this.options, (err, socketOptions) => {
            if (err) {
                return callback(err);
            }

            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info(
                    {
                        tnx: 'proxy',
                        remoteAddress: socketOptions.connection.remoteAddress,
                        remotePort: socketOptions.connection.remotePort,
                        destHost: options.host || '',
                        destPort: options.port || '',
                        action: 'connected'
                    },
                    'Using proxied socket from %s:%s to %s:%s',
                    socketOptions.connection.remoteAddress,
                    socketOptions.connection.remotePort,
                    options.host || '',
                    options.port || ''
                );

                options = assign(false, options);
                Object.keys(socketOptions).forEach(key => {
                    options[key] = socketOptions[key];
                });
            }

            this.connection = new SMTPConnection(options);

            this.connection.once('error', err => {
                this.emit('error', err);
                if (returned) {
                    return;
                }
                returned = true;
                return callback(err);
            });

            this.connection.once('end', () => {
                this.close();
                if (returned) {
                    return;
                }
                returned = true;

                let timer = setTimeout(() => {
                    if (returned) {
                        return;
                    }
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error('Unexpected socket close');
                    if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = 'ETLS';
                    }
                    callback(err);
                }, 1000);

                try {
                    timer.unref();
                } catch (E) {
                    // Ignore. Happens on envs with non-node timer implementation
                }
            });

            this.connection.connect(() => {
                if (returned) {
                    return;
                }

                if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
                    this.connection.login(this.auth, err => {
                        if (returned) {
                            return;
                        }
                        returned = true;

                        if (err) {
                            this.connection.close();
                            this.emit('error', err);
                            return callback(err);
                        }

                        this._connected = true;
                        callback(null, true);
                    });
                } else {
                    returned = true;
                    this._connected = true;
                    return callback(null, true);
                }
            });
        });
    }

    /**
     * Sends an e-mail to be sent using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
        if (!this._connected) {
            return this.connect(err => {
                if (err) {
                    return callback(err);
                }
                return this.send(mail, callback);
            });
        }

        let envelope = mail.message.getEnvelope();
        let messageId = mail.message.messageId();

        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push('...and ' + recipients.splice(2).length + ' more');
        }
        this.logger.info(
            {
                tnx: 'send',
                messageId,
                cid: this.id
            },
            'Sending message %s using #%s to <%s>',
            messageId,
            this.id,
            recipients.join(', ')
        );

        if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
        }

        this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
            this.messages++;

            if (err) {
                this.connection.close();
                this.emit('error', err);
                return callback(err);
            }

            info.envelope = {
                from: envelope.from,
                to: envelope.to
            };
            info.messageId = messageId;

            setImmediate(() => {
                let err;
                if (this.messages >= this.options.maxMessages) {
                    err = new Error('Resource exhausted');
                    err.code = 'EMAXLIMIT';
                    this.connection.close();
                    this.emit('error', err);
                } else {
                    this.pool._checkRateLimit(() => {
                        this.available = true;
                        this.emit('available');
                    });
                }
            });

            callback(null, info);
        });
    }

    /**
     * Closes the connection
     */
    close() {
        this._connected = false;
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        if (this.connection) {
            this.connection.close();
        }
        this.emit('close');
    }
}

module.exports = PoolResource;


/***/ }),

/***/ 82833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(594735);
const SMTPConnection = __webpack_require__(573724);
const wellKnown = __webpack_require__(867371);
const shared = __webpack_require__(835028);
const XOAuth2 = __webpack_require__(598492);
const packageData = __webpack_require__(227761);

/**
 * Creates a SMTP transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options Connection options
 */
class SMTPTransport extends EventEmitter {
    constructor(options) {
        super();

        options = options || {};

        if (typeof options === 'string') {
            options = {
                url: options
            };
        }

        let urlData;
        let service = options.service;

        if (typeof options.getSocket === 'function') {
            this.getSocket = options.getSocket;
        }

        if (options.url) {
            urlData = shared.parseConnectionUrl(options.url);
            service = service || urlData.service;
        }

        this.options = shared.assign(
            false, // create new object
            options, // regular options
            urlData, // url options
            service && wellKnown(service) // wellknown options
        );

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'smtp-transport'
        });

        // temporary object
        let connection = new SMTPConnection(this.options);

        this.name = 'SMTP';
        this.version = packageData.version + '[client:' + connection.version + ']';

        if (this.options.auth) {
            this.auth = this.getAuth({});
        }
    }

    /**
     * Placeholder function for creating proxy sockets. This method immediatelly returns
     * without a socket
     *
     * @param {Object} options Connection options
     * @param {Function} callback Callback function to run with the socket keys
     */
    getSocket(options, callback) {
        // return immediatelly
        return setImmediate(() => callback(null, false));
    }

    getAuth(authOpts) {
        if (!authOpts) {
            return this.auth;
        }

        let hasAuth = false;
        let authData = {};

        if (this.options.auth && typeof this.options.auth === 'object') {
            Object.keys(this.options.auth).forEach(key => {
                hasAuth = true;
                authData[key] = this.options.auth[key];
            });
        }

        if (authOpts && typeof authOpts === 'object') {
            Object.keys(authOpts).forEach(key => {
                hasAuth = true;
                authData[key] = authOpts[key];
            });
        }

        if (!hasAuth) {
            return false;
        }

        switch ((authData.type || '').toString().toUpperCase()) {
            case 'OAUTH2': {
                if (!authData.service && !authData.user) {
                    return false;
                }
                let oauth2 = new XOAuth2(authData, this.logger);
                oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;
                oauth2.on('token', token => this.mailer.emit('token', token));
                oauth2.on('error', err => this.emit('error', err));
                return {
                    type: 'OAUTH2',
                    user: authData.user,
                    oauth2,
                    method: 'XOAUTH2'
                };
            }
            default:
                return {
                    type: (authData.type || '').toString().toUpperCase() || 'LOGIN',
                    user: authData.user,
                    credentials: {
                        user: authData.user || '',
                        pass: authData.pass,
                        options: authData.options
                    },
                    method: (authData.method || '').trim().toUpperCase() || this.options.authMethod || false
                };
        }
    }

    /**
     * Sends an e-mail using the selected settings
     *
     * @param {Object} mail Mail object
     * @param {Function} callback Callback function
     */
    send(mail, callback) {
        this.getSocket(this.options, (err, socketOptions) => {
            if (err) {
                return callback(err);
            }

            let returned = false;
            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info(
                    {
                        tnx: 'proxy',
                        remoteAddress: socketOptions.connection.remoteAddress,
                        remotePort: socketOptions.connection.remotePort,
                        destHost: options.host || '',
                        destPort: options.port || '',
                        action: 'connected'
                    },
                    'Using proxied socket from %s:%s to %s:%s',
                    socketOptions.connection.remoteAddress,
                    socketOptions.connection.remotePort,
                    options.host || '',
                    options.port || ''
                );

                // only copy options if we need to modify it
                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach(key => {
                    options[key] = socketOptions[key];
                });
            }

            let connection = new SMTPConnection(options);

            connection.once('error', err => {
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });

            connection.once('end', () => {
                if (returned) {
                    return;
                }

                let timer = setTimeout(() => {
                    if (returned) {
                        return;
                    }
                    returned = true;
                    // still have not returned, this means we have an unexpected connection close
                    let err = new Error('Unexpected socket close');
                    if (connection && connection._socket && connection._socket.upgrading) {
                        // starttls connection errors
                        err.code = 'ETLS';
                    }
                    callback(err);
                }, 1000);

                try {
                    timer.unref();
                } catch (E) {
                    // Ignore. Happens on envs with non-node timer implementation
                }
            });

            let sendMessage = () => {
                let envelope = mail.message.getEnvelope();
                let messageId = mail.message.messageId();

                let recipients = [].concat(envelope.to || []);
                if (recipients.length > 3) {
                    recipients.push('...and ' + recipients.splice(2).length + ' more');
                }

                if (mail.data.dsn) {
                    envelope.dsn = mail.data.dsn;
                }

                this.logger.info(
                    {
                        tnx: 'send',
                        messageId
                    },
                    'Sending message %s to <%s>',
                    messageId,
                    recipients.join(', ')
                );

                connection.send(envelope, mail.message.createReadStream(), (err, info) => {
                    returned = true;
                    connection.close();
                    if (err) {
                        this.logger.error(
                            {
                                err,
                                tnx: 'send'
                            },
                            'Send error for %s: %s',
                            messageId,
                            err.message
                        );
                        return callback(err);
                    }
                    info.envelope = {
                        from: envelope.from,
                        to: envelope.to
                    };
                    info.messageId = messageId;
                    try {
                        return callback(null, info);
                    } catch (E) {
                        this.logger.error(
                            {
                                err: E,
                                tnx: 'callback'
                            },
                            'Callback error for %s: %s',
                            messageId,
                            E.message
                        );
                    }
                });
            };

            connection.connect(() => {
                if (returned) {
                    return;
                }

                let auth = this.getAuth(mail.data.auth);

                if (auth && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(auth, err => {
                        if (auth && auth !== this.auth && auth.oauth2) {
                            auth.oauth2.removeAllListeners();
                        }
                        if (returned) {
                            return;
                        }

                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }

                        sendMessage();
                    });
                } else {
                    sendMessage();
                }
            });
        });
    }

    /**
     * Verifies SMTP configuration
     *
     * @param {Function} callback Callback function
     */
    verify(callback) {
        let promise;

        if (!callback) {
            promise = new Promise((resolve, reject) => {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        this.getSocket(this.options, (err, socketOptions) => {
            if (err) {
                return callback(err);
            }

            let options = this.options;
            if (socketOptions && socketOptions.connection) {
                this.logger.info(
                    {
                        tnx: 'proxy',
                        remoteAddress: socketOptions.connection.remoteAddress,
                        remotePort: socketOptions.connection.remotePort,
                        destHost: options.host || '',
                        destPort: options.port || '',
                        action: 'connected'
                    },
                    'Using proxied socket from %s:%s to %s:%s',
                    socketOptions.connection.remoteAddress,
                    socketOptions.connection.remotePort,
                    options.host || '',
                    options.port || ''
                );

                options = shared.assign(false, options);
                Object.keys(socketOptions).forEach(key => {
                    options[key] = socketOptions[key];
                });
            }

            let connection = new SMTPConnection(options);
            let returned = false;

            connection.once('error', err => {
                if (returned) {
                    return;
                }
                returned = true;
                connection.close();
                return callback(err);
            });

            connection.once('end', () => {
                if (returned) {
                    return;
                }
                returned = true;
                return callback(new Error('Connection closed'));
            });

            let finalize = () => {
                if (returned) {
                    return;
                }
                returned = true;
                connection.quit();
                return callback(null, true);
            };

            connection.connect(() => {
                if (returned) {
                    return;
                }

                let authData = this.getAuth({});

                if (authData && (connection.allowsAuth || options.forceAuth)) {
                    connection.login(authData, err => {
                        if (returned) {
                            return;
                        }

                        if (err) {
                            returned = true;
                            connection.close();
                            return callback(err);
                        }

                        finalize();
                    });
                } else if (!authData && connection.allowsAuth && options.forceAuth) {
                    let err = new Error('Authentication info was not provided');
                    err.code = 'NoAuth';

                    returned = true;
                    connection.close();
                    return callback(err);
                } else {
                    finalize();
                }
            });
        });

        return promise;
    }

    /**
     * Releases resources
     */
    close() {
        if (this.auth && this.auth.oauth2) {
            this.auth.oauth2.removeAllListeners();
        }
        this.emit('close');
    }
}

// expose to the world
module.exports = SMTPTransport;


/***/ }),

/***/ 417061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const packageData = __webpack_require__(227761);
const shared = __webpack_require__(835028);

/**
 * Generates a Transport object for streaming
 *
 * Possible options can be the following:
 *
 *  * **buffer** if true, then returns the message as a Buffer object instead of a stream
 *  * **newline** either 'windows' or 'unix'
 *
 * @constructor
 * @param {Object} optional config parameter
 */
class StreamTransport {
    constructor(options) {
        options = options || {};

        this.options = options || {};

        this.name = 'StreamTransport';
        this.version = packageData.version;

        this.logger = shared.getLogger(this.options, {
            component: this.options.component || 'stream-transport'
        });

        this.winbreak = ['win', 'windows', 'dos', '\r\n'].includes((options.newline || '').toString().toLowerCase());
    }

    /**
     * Compiles a mailcomposer message and forwards it to handler that sends it
     *
     * @param {Object} emailMessage MailComposer object
     * @param {Function} callback Callback function to run when the sending is completed
     */
    send(mail, done) {
        // We probably need this in the output
        mail.message.keepBcc = true;

        let envelope = mail.data.envelope || mail.message.getEnvelope();
        let messageId = mail.message.messageId();

        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
            recipients.push('...and ' + recipients.splice(2).length + ' more');
        }
        this.logger.info(
            {
                tnx: 'send',
                messageId
            },
            'Sending message %s to <%s> using %s line breaks',
            messageId,
            recipients.join(', '),
            this.winbreak ? '<CR><LF>' : '<LF>'
        );

        setImmediate(() => {
            let stream;

            try {
                stream = mail.message.createReadStream();
            } catch (E) {
                this.logger.error(
                    {
                        err: E,
                        tnx: 'send',
                        messageId
                    },
                    'Creating send stream failed for %s. %s',
                    messageId,
                    E.message
                );
                return done(E);
            }

            if (!this.options.buffer) {
                stream.once('error', err => {
                    this.logger.error(
                        {
                            err,
                            tnx: 'send',
                            messageId
                        },
                        'Failed creating message for %s. %s',
                        messageId,
                        err.message
                    );
                });
                return done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: stream
                });
            }

            let chunks = [];
            let chunklen = 0;
            stream.on('readable', () => {
                let chunk;
                while ((chunk = stream.read()) !== null) {
                    chunks.push(chunk);
                    chunklen += chunk.length;
                }
            });

            stream.once('error', err => {
                this.logger.error(
                    {
                        err,
                        tnx: 'send',
                        messageId
                    },
                    'Failed creating message for %s. %s',
                    messageId,
                    err.message
                );
                return done(err);
            });

            stream.on('end', () =>
                done(null, {
                    envelope: mail.data.envelope || mail.message.getEnvelope(),
                    messageId,
                    message: Buffer.concat(chunks, chunklen)
                })
            );
        });
    }
}

module.exports = StreamTransport;


/***/ }),

/***/ 867371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const services = __webpack_require__(111406);
const normalized = {};

Object.keys(services).forEach(key => {
    let service = services[key];

    normalized[normalizeKey(key)] = normalizeService(service);

    [].concat(service.aliases || []).forEach(alias => {
        normalized[normalizeKey(alias)] = normalizeService(service);
    });

    [].concat(service.domains || []).forEach(domain => {
        normalized[normalizeKey(domain)] = normalizeService(service);
    });
});

function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, '').toLowerCase();
}

function normalizeService(service) {
    let filter = ['domains', 'aliases'];
    let response = {};

    Object.keys(service).forEach(key => {
        if (filter.indexOf(key) < 0) {
            response[key] = service[key];
        }
    });

    return response;
}

/**
 * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or
 * an email address (like 'test@googlemail.com').
 *
 * @param {String} key [description]
 * @returns {Object} SMTP config or false if not found
 */
module.exports = function (key) {
    key = normalizeKey(key.split('@').pop());
    return normalized[key] || false;
};


/***/ }),

/***/ 598492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Stream = (__webpack_require__(927910).Stream);
const nmfetch = __webpack_require__(34843);
const crypto = __webpack_require__(455511);
const shared = __webpack_require__(835028);

/**
 * XOAUTH2 access_token generator for Gmail.
 * Create client ID for web applications in Google API console to use it.
 * See Offline Access for receiving the needed refreshToken for an user
 * https://developers.google.com/accounts/docs/OAuth2WebServer#offline
 *
 * Usage for generating access tokens with a custom method using provisionCallback:
 * provisionCallback(user, renew, callback)
 *   * user is the username to get the token for
 *   * renew is a boolean that if true indicates that existing token failed and needs to be renewed
 *   * callback is the callback to run with (error, accessToken [, expires])
 *     * accessToken is a string
 *     * expires is an optional expire time in milliseconds
 * If provisionCallback is used, then Nodemailer does not try to attempt generating the token by itself
 *
 * @constructor
 * @param {Object} options Client information for token generation
 * @param {String} options.user User e-mail address
 * @param {String} options.clientId Client ID value
 * @param {String} options.clientSecret Client secret value
 * @param {String} options.refreshToken Refresh token for an user
 * @param {String} options.accessUrl Endpoint for token generation, defaults to 'https://accounts.google.com/o/oauth2/token'
 * @param {String} options.accessToken An existing valid accessToken
 * @param {String} options.privateKey Private key for JSW
 * @param {Number} options.expires Optional Access Token expire time in ms
 * @param {Number} options.timeout Optional TTL for Access Token in seconds
 * @param {Function} options.provisionCallback Function to run when a new access token is required
 */
class XOAuth2 extends Stream {
    constructor(options, logger) {
        super();

        this.options = options || {};

        if (options && options.serviceClient) {
            if (!options.privateKey || !options.user) {
                setImmediate(() => this.emit('error', new Error('Options "privateKey" and "user" are required for service account!')));
                return;
            }

            let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
            this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
        }

        this.logger = shared.getLogger(
            {
                logger
            },
            {
                component: this.options.component || 'OAuth2'
            }
        );

        this.provisionCallback = typeof this.options.provisionCallback === 'function' ? this.options.provisionCallback : false;

        this.options.accessUrl = this.options.accessUrl || 'https://accounts.google.com/o/oauth2/token';
        this.options.customHeaders = this.options.customHeaders || {};
        this.options.customParams = this.options.customParams || {};

        this.accessToken = this.options.accessToken || false;

        if (this.options.expires && Number(this.options.expires)) {
            this.expires = this.options.expires;
        } else {
            let timeout = Math.max(Number(this.options.timeout) || 0, 0);
            this.expires = (timeout && Date.now() + timeout * 1000) || 0;
        }
    }

    /**
     * Returns or generates (if previous has expired) a XOAuth2 token
     *
     * @param {Boolean} renew If false then use cached access token (if available)
     * @param {Function} callback Callback function with error object and token string
     */
    getToken(renew, callback) {
        if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
            return callback(null, this.accessToken);
        }

        let generateCallback = (...args) => {
            if (args[0]) {
                this.logger.error(
                    {
                        err: args[0],
                        tnx: 'OAUTH2',
                        user: this.options.user,
                        action: 'renew'
                    },
                    'Failed generating new Access Token for %s',
                    this.options.user
                );
            } else {
                this.logger.info(
                    {
                        tnx: 'OAUTH2',
                        user: this.options.user,
                        action: 'renew'
                    },
                    'Generated new Access Token for %s',
                    this.options.user
                );
            }
            callback(...args);
        };

        if (this.provisionCallback) {
            this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
                if (!err && accessToken) {
                    this.accessToken = accessToken;
                    this.expires = expires || 0;
                }
                generateCallback(err, accessToken);
            });
        } else {
            this.generateToken(generateCallback);
        }
    }

    /**
     * Updates token values
     *
     * @param {String} accessToken New access token
     * @param {Number} timeout Access token lifetime in seconds
     *
     * Emits 'token': { user: User email-address, accessToken: the new accessToken, timeout: TTL in seconds}
     */
    updateToken(accessToken, timeout) {
        this.accessToken = accessToken;
        timeout = Math.max(Number(timeout) || 0, 0);
        this.expires = (timeout && Date.now() + timeout * 1000) || 0;

        this.emit('token', {
            user: this.options.user,
            accessToken: accessToken || '',
            expires: this.expires
        });
    }

    /**
     * Generates a new XOAuth2 token with the credentials provided at initialization
     *
     * @param {Function} callback Callback function with error object and token string
     */
    generateToken(callback) {
        let urlOptions;
        let loggedUrlOptions;
        if (this.options.serviceClient) {
            // service account - https://developers.google.com/identity/protocols/OAuth2ServiceAccount
            let iat = Math.floor(Date.now() / 1000); // unix time
            let tokenData = {
                iss: this.options.serviceClient,
                scope: this.options.scope || 'https://mail.google.com/',
                sub: this.options.user,
                aud: this.options.accessUrl,
                iat,
                exp: iat + this.options.serviceRequestTimeout
            };
            let token;
            try {
                token = this.jwtSignRS256(tokenData);
            } catch (err) {
                return callback(new Error('Can\x27t generate token. Check your auth options'));
            }

            urlOptions = {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                assertion: token
            };

            loggedUrlOptions = {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                assertion: tokenData
            };
        } else {
            if (!this.options.refreshToken) {
                return callback(new Error('Can\x27t create new access token for user'));
            }

            // web app - https://developers.google.com/identity/protocols/OAuth2WebServer
            urlOptions = {
                client_id: this.options.clientId || '',
                client_secret: this.options.clientSecret || '',
                refresh_token: this.options.refreshToken,
                grant_type: 'refresh_token'
            };

            loggedUrlOptions = {
                client_id: this.options.clientId || '',
                client_secret: (this.options.clientSecret || '').substr(0, 6) + '...',
                refresh_token: (this.options.refreshToken || '').substr(0, 6) + '...',
                grant_type: 'refresh_token'
            };
        }

        Object.keys(this.options.customParams).forEach(key => {
            urlOptions[key] = this.options.customParams[key];
            loggedUrlOptions[key] = this.options.customParams[key];
        });

        this.logger.debug(
            {
                tnx: 'OAUTH2',
                user: this.options.user,
                action: 'generate'
            },
            'Requesting token using: %s',
            JSON.stringify(loggedUrlOptions)
        );

        this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {
            let data;

            if (error) {
                return callback(error);
            }

            try {
                data = JSON.parse(body.toString());
            } catch (E) {
                return callback(E);
            }

            if (!data || typeof data !== 'object') {
                this.logger.debug(
                    {
                        tnx: 'OAUTH2',
                        user: this.options.user,
                        action: 'post'
                    },
                    'Response: %s',
                    (body || '').toString()
                );
                return callback(new Error('Invalid authentication response'));
            }

            let logData = {};
            Object.keys(data).forEach(key => {
                if (key !== 'access_token') {
                    logData[key] = data[key];
                } else {
                    logData[key] = (data[key] || '').toString().substr(0, 6) + '...';
                }
            });

            this.logger.debug(
                {
                    tnx: 'OAUTH2',
                    user: this.options.user,
                    action: 'post'
                },
                'Response: %s',
                JSON.stringify(logData)
            );

            if (data.error) {
                // Error Response : https://tools.ietf.org/html/rfc6749#section-5.2
                let errorMessage = data.error;
                if (data.error_description) {
                    errorMessage += ': ' + data.error_description;
                }
                if (data.error_uri) {
                    errorMessage += ' (' + data.error_uri + ')';
                }
                return callback(new Error(errorMessage));
            }

            if (data.access_token) {
                this.updateToken(data.access_token, data.expires_in);
                return callback(null, this.accessToken);
            }

            return callback(new Error('No access token'));
        });
    }

    /**
     * Converts an access_token and user id into a base64 encoded XOAuth2 token
     *
     * @param {String} [accessToken] Access token string
     * @return {String} Base64 encoded token for IMAP or SMTP login
     */
    buildXOAuth2Token(accessToken) {
        let authData = ['user=' + (this.options.user || ''), 'auth=Bearer ' + (accessToken || this.accessToken), '', ''];
        return Buffer.from(authData.join('\x01'), 'utf-8').toString('base64');
    }

    /**
     * Custom POST request handler.
     * This is only needed to keep paths short in Windows – usually this module
     * is a dependency of a dependency and if it tries to require something
     * like the request module the paths get way too long to handle for Windows.
     * As we do only a simple POST request we do not actually require complicated
     * logic support (no redirects, no nothing) anyway.
     *
     * @param {String} url Url to POST to
     * @param {String|Buffer} payload Payload to POST
     * @param {Function} callback Callback function with (err, buff)
     */
    postRequest(url, payload, params, callback) {
        let returned = false;

        let chunks = [];
        let chunklen = 0;

        let req = nmfetch(url, {
            method: 'post',
            headers: params.customHeaders,
            body: payload,
            allowErrorResponse: true
        });

        req.on('readable', () => {
            let chunk;
            while ((chunk = req.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
            }
        });

        req.once('error', err => {
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        });

        req.once('end', () => {
            if (returned) {
                return;
            }
            returned = true;
            return callback(null, Buffer.concat(chunks, chunklen));
        });
    }

    /**
     * Encodes a buffer or a string into Base64url format
     *
     * @param {Buffer|String} data The data to convert
     * @return {String} The encoded string
     */
    toBase64URL(data) {
        if (typeof data === 'string') {
            data = Buffer.from(data);
        }

        return data
            .toString('base64')
            .replace(/[=]+/g, '') // remove '='s
            .replace(/\+/g, '-') // '+' → '-'
            .replace(/\//g, '_'); // '/' → '_'
    }

    /**
     * Creates a JSON Web Token signed with RS256 (SHA256 + RSA)
     *
     * @param {Object} payload The payload to include in the generated token
     * @return {String} The generated and signed token
     */
    jwtSignRS256(payload) {
        payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map(val => this.toBase64URL(val)).join('.');
        let signature = crypto.createSign('RSA-SHA256').update(payload).sign(this.options.privateKey);
        return payload + '.' + this.toBase64URL(signature);
    }
}

module.exports = XOAuth2;


/***/ }),

/***/ 583593:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ Body)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/body.tsx


var Body = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("body", __spreadProps(__spreadValues({}, props), { ref, style, children }));
  }
);
Body.displayName = "Body";



/***/ }),

/***/ 415765:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/button.tsx


// src/utils/parse-padding.ts
function convertToPx(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = /^([\d.]+)(px|em|rem|%)$/.exec(value);
  if (matches && matches.length === 3) {
    const numValue = parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  } else {
    return 0;
  }
}
function parsePadding({
  padding = "",
  paddingTop,
  paddingRight,
  paddingBottom,
  paddingLeft
}) {
  let pt = 0;
  let pr = 0;
  let pb = 0;
  let pl = 0;
  if (typeof padding === "number") {
    pt = padding;
    pr = padding;
    pb = padding;
    pl = padding;
  } else {
    const values = padding.split(/\s+/);
    switch (values.length) {
      case 1:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[0]);
        pb = convertToPx(values[0]);
        pl = convertToPx(values[0]);
        break;
      case 2:
        pt = convertToPx(values[0]);
        pb = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pl = convertToPx(values[1]);
        break;
      case 3:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pl = convertToPx(values[1]);
        pb = convertToPx(values[2]);
        break;
      case 4:
        pt = convertToPx(values[0]);
        pr = convertToPx(values[1]);
        pb = convertToPx(values[2]);
        pl = convertToPx(values[3]);
        break;
      default:
        break;
    }
  }
  return {
    pt: paddingTop ? convertToPx(paddingTop) : pt,
    pr: paddingRight ? convertToPx(paddingRight) : pr,
    pb: paddingBottom ? convertToPx(paddingBottom) : pb,
    pl: paddingLeft ? convertToPx(paddingLeft) : pl
  };
}

// src/utils/px-to-pt.ts
var pxToPt = (px) => typeof px === "number" && !isNaN(Number(px)) ? px * 3 / 4 : null;

// src/button.tsx

var maxFontWidth = 5;
function computeFontWidthAndSpaceCount(expectedWidth) {
  if (expectedWidth === 0) return [0, 0];
  let smallestSpaceCount = 0;
  const computeRequiredFontWidth = () => {
    if (smallestSpaceCount > 0) {
      return expectedWidth / smallestSpaceCount / 2;
    }
    return Infinity;
  };
  while (computeRequiredFontWidth() > maxFontWidth) {
    smallestSpaceCount++;
  }
  return [computeRequiredFontWidth(), smallestSpaceCount];
}
var Button = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style, target = "_blank" } = _b, props = __objRest(_b, ["children", "style", "target"]);
    var _a2, _b2, _c, _d;
    const { pt, pr, pb, pl } = parsePadding({
      padding: style == null ? void 0 : style.padding,
      paddingLeft: (_a2 = style == null ? void 0 : style.paddingLeft) != null ? _a2 : style == null ? void 0 : style.paddingInline,
      paddingRight: (_b2 = style == null ? void 0 : style.paddingRight) != null ? _b2 : style == null ? void 0 : style.paddingInline,
      paddingTop: (_c = style == null ? void 0 : style.paddingTop) != null ? _c : style == null ? void 0 : style.paddingBlock,
      paddingBottom: (_d = style == null ? void 0 : style.paddingBottom) != null ? _d : style == null ? void 0 : style.paddingBlock
    });
    const y = pt + pb;
    const textRaise = pxToPt(y);
    const [plFontWidth, plSpaceCount] = computeFontWidthAndSpaceCount(pl);
    const [prFontWidth, prSpaceCount] = computeFontWidthAndSpaceCount(pr);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(
      "a",
      __spreadProps(__spreadValues({}, props), {
        ref,
        style: buttonStyle(__spreadProps(__spreadValues({}, style), { pt, pr, pb, pl })),
        target,
        children: [
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                // The `&#8202;` is as close to `1px` of an empty character as we can get, then, we use the `mso-font-width`
                // to scale it according to what padding the developer wants. `mso-font-width` also does not allow for percentages
                // >= 500% so we need to add extra spaces accordingly.
                //
                // See https://github.com/resend/react-email/issues/1512 for why we do not use letter-spacing instead.
                __html: `<!--[if mso]><i style="mso-font-width:${plFontWidth * 100}%;mso-text-raise:${textRaise}" hidden>${"&#8202;".repeat(
                  plSpaceCount
                )}</i><![endif]-->`
              }
            }
          ),
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("span", { style: buttonTextStyle(pb), children }),
          /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
            "span",
            {
              dangerouslySetInnerHTML: {
                __html: `<!--[if mso]><i style="mso-font-width:${prFontWidth * 100}%" hidden>${"&#8202;".repeat(
                  prSpaceCount
                )}&#8203;</i><![endif]-->`
              }
            }
          )
        ]
      })
    );
  }
);
Button.displayName = "Button";
var buttonStyle = (style) => {
  const _a = style || {}, { pt, pr, pb, pl } = _a, rest = __objRest(_a, ["pt", "pr", "pb", "pl"]);
  return __spreadProps(__spreadValues({
    lineHeight: "100%",
    textDecoration: "none",
    display: "inline-block",
    maxWidth: "100%",
    msoPaddingAlt: "0px"
  }, rest), {
    padding: `${pt}px ${pr}px ${pb}px ${pl}px`
  });
};
var buttonTextStyle = (pb) => {
  return {
    maxWidth: "100%",
    display: "inline-block",
    lineHeight: "120%",
    msoPaddingAlt: "0px",
    msoTextRaise: pxToPt(pb || 0)
  };
};



/***/ }),

/***/ 790203:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ Column)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/column.tsx


var Column = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("td", __spreadProps(__spreadValues({}, props), { "data-id": "__react-email-column", ref, style, children }));
  }
);
Column.displayName = "Column";



/***/ }),

/***/ 510956:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   m: () => (/* binding */ Container)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/container.tsx


var Container = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "table",
      __spreadProps(__spreadValues({
        align: "center",
        width: "100%"
      }, props), {
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        ref,
        role: "presentation",
        style: __spreadValues({ maxWidth: "37.5em" }, style),
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tbody", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tr", { style: { width: "100%" }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("td", { children }) }) })
      })
    );
  }
);
Container.displayName = "Container";



/***/ }),

/***/ 361705:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ Heading)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/heading.tsx


// src/utils/spaces.ts
var withMargin = (props) => {
  const nonEmptyStyles = [
    withSpace(props.m, ["margin"]),
    withSpace(props.mx, ["marginLeft", "marginRight"]),
    withSpace(props.my, ["marginTop", "marginBottom"]),
    withSpace(props.mt, ["marginTop"]),
    withSpace(props.mr, ["marginRight"]),
    withSpace(props.mb, ["marginBottom"]),
    withSpace(props.ml, ["marginLeft"])
  ].filter((s) => Object.keys(s).length);
  const mergedStyles = nonEmptyStyles.reduce((acc, style) => {
    return __spreadValues(__spreadValues({}, acc), style);
  }, {});
  return mergedStyles;
};
var withSpace = (value, properties) => {
  return properties.reduce((styles, property) => {
    if (!isNaN(parseFloat(value))) {
      return __spreadProps(__spreadValues({}, styles), { [property]: `${value}px` });
    }
    return styles;
  }, {});
};

// src/heading.tsx

var Heading = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { as: Tag = "h1", children, style, m, mx, my, mt, mr, mb, ml } = _b, props = __objRest(_b, ["as", "children", "style", "m", "mx", "my", "mt", "mr", "mb", "ml"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      Tag,
      __spreadProps(__spreadValues({}, props), {
        ref,
        style: __spreadValues(__spreadValues({}, withMargin({ m, mx, my, mt, mr, mb, ml })), style),
        children
      })
    );
  }
);
Heading.displayName = "Heading";



/***/ }),

/***/ 878371:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hr: () => (/* binding */ Hr)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/hr.tsx


var Hr = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { style } = _b, props = __objRest(_b, ["style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "hr",
      __spreadProps(__spreadValues({}, props), {
        ref,
        style: __spreadValues({
          width: "100%",
          border: "none",
          borderTop: "1px solid #eaeaea"
        }, style)
      })
    );
  }
);
Hr.displayName = "Hr";



/***/ }),

/***/ 655492:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Html)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/html.tsx


var Html = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, lang = "en", dir = "ltr" } = _b, props = __objRest(_b, ["children", "lang", "dir"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("html", __spreadProps(__spreadValues({}, props), { dir, lang, ref, children }));
  }
);
Html.displayName = "Html";



/***/ }),

/***/ 118920:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Img)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/img.tsx


var Img = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { alt, src, width, height, style } = _b, props = __objRest(_b, ["alt", "src", "width", "height", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "img",
      __spreadProps(__spreadValues({}, props), {
        alt,
        height,
        ref,
        src,
        style: __spreadValues({
          display: "block",
          outline: "none",
          border: "none",
          textDecoration: "none"
        }, style),
        width
      })
    );
  }
);
Img.displayName = "Img";



/***/ }),

/***/ 612781:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ Link)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/link.tsx


var Link = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { target = "_blank", style } = _b, props = __objRest(_b, ["target", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "a",
      __spreadProps(__spreadValues({}, props), {
        ref,
        style: __spreadValues({
          color: "#067df7",
          textDecorationLine: "none"
        }, style),
        target,
        children: props.children
      })
    );
  }
);
Link.displayName = "Link";



/***/ }),

/***/ 264632:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  XX: () => (/* binding */ node_render)
});

// UNUSED EXPORTS: plainTextSelectors, renderAsync

;// ../../node_modules/domelementtype/lib/esm/index.js
/** Types of elements found in htmlparser2's DOM */
var esm_ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(esm_ElementType || (esm_ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function esm_isTag(elem) {
    return (elem.type === esm_ElementType.Tag ||
        elem.type === esm_ElementType.Script ||
        elem.type === esm_ElementType.Style);
}
// Exports for backwards compatibility
/** Type for the root element of a document */
const Root = esm_ElementType.Root;
/** Type for Text */
const Text = esm_ElementType.Text;
/** Type for <? ... ?> */
const Directive = esm_ElementType.Directive;
/** Type for <!-- ... --> */
const Comment = esm_ElementType.Comment;
/** Type for <script> tags */
const Script = esm_ElementType.Script;
/** Type for <style> tags */
const Style = esm_ElementType.Style;
/** Type for Any tag */
const Tag = esm_ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
const CDATA = esm_ElementType.CDATA;
/** Type for <!doctype ...> */
const Doctype = esm_ElementType.Doctype;

;// ../../node_modules/domhandler/lib/esm/node.js

/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
class Node {
    constructor() {
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    // Read-write aliases for properties
    /**
     * Same as {@link parent}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get parentNode() {
        return this.parent;
    }
    set parentNode(parent) {
        this.parent = parent;
    }
    /**
     * Same as {@link prev}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get previousSibling() {
        return this.prev;
    }
    set previousSibling(prev) {
        this.prev = prev;
    }
    /**
     * Same as {@link next}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get nextSibling() {
        return this.next;
    }
    set nextSibling(next) {
        this.next = next;
    }
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    cloneNode(recursive = false) {
        return cloneNode(this, recursive);
    }
}
/**
 * A node that contains some data.
 */
class DataNode extends Node {
    /**
     * @param data The content of the data node
     */
    constructor(data) {
        super();
        this.data = data;
    }
    /**
     * Same as {@link data}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get nodeValue() {
        return this.data;
    }
    set nodeValue(data) {
        this.data = data;
    }
}
/**
 * Text within the document.
 */
class node_Text extends DataNode {
    constructor() {
        super(...arguments);
        this.type = esm_ElementType.Text;
    }
    get nodeType() {
        return 3;
    }
}
/**
 * Comments within the document.
 */
class node_Comment extends DataNode {
    constructor() {
        super(...arguments);
        this.type = esm_ElementType.Comment;
    }
    get nodeType() {
        return 8;
    }
}
/**
 * Processing instructions, including doc types.
 */
class ProcessingInstruction extends DataNode {
    constructor(name, data) {
        super(data);
        this.name = name;
        this.type = esm_ElementType.Directive;
    }
    get nodeType() {
        return 1;
    }
}
/**
 * A `Node` that can have children.
 */
class NodeWithChildren extends Node {
    /**
     * @param children Children of the node. Only certain node types can have children.
     */
    constructor(children) {
        super();
        this.children = children;
    }
    // Aliases
    /** First child of the node. */
    get firstChild() {
        var _a;
        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
    }
    /** Last child of the node. */
    get lastChild() {
        return this.children.length > 0
            ? this.children[this.children.length - 1]
            : null;
    }
    /**
     * Same as {@link children}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get childNodes() {
        return this.children;
    }
    set childNodes(children) {
        this.children = children;
    }
}
class node_CDATA extends NodeWithChildren {
    constructor() {
        super(...arguments);
        this.type = esm_ElementType.CDATA;
    }
    get nodeType() {
        return 4;
    }
}
/**
 * The root node of the document.
 */
class Document extends NodeWithChildren {
    constructor() {
        super(...arguments);
        this.type = esm_ElementType.Root;
    }
    get nodeType() {
        return 9;
    }
}
/**
 * An element within the DOM.
 */
class Element extends NodeWithChildren {
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    constructor(name, attribs, children = [], type = name === "script"
        ? esm_ElementType.Script
        : name === "style"
            ? esm_ElementType.Style
            : esm_ElementType.Tag) {
        super(children);
        this.name = name;
        this.attribs = attribs;
        this.type = type;
    }
    get nodeType() {
        return 1;
    }
    // DOM Level 1 aliases
    /**
     * Same as {@link name}.
     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
     */
    get tagName() {
        return this.name;
    }
    set tagName(name) {
        this.name = name;
    }
    get attributes() {
        return Object.keys(this.attribs).map((name) => {
            var _a, _b;
            return ({
                name,
                value: this.attribs[name],
                namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
            });
        });
    }
}
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function node_isTag(node) {
    return esm_isTag(node);
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function node_isCDATA(node) {
    return node.type === esm_ElementType.CDATA;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function node_isText(node) {
    return node.type === esm_ElementType.Text;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function node_isComment(node) {
    return node.type === esm_ElementType.Comment;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === esm_ElementType.Directive;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === esm_ElementType.Root;
}
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function node_hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive = false) {
    let result;
    if (node_isText(node)) {
        result = new node_Text(node.data);
    }
    else if (node_isComment(node)) {
        result = new node_Comment(node.data);
    }
    else if (node_isTag(node)) {
        const children = recursive ? cloneChildren(node.children) : [];
        const clone = new Element(node.name, { ...node.attribs }, children);
        children.forEach((child) => (child.parent = clone));
        if (node.namespace != null) {
            clone.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
        }
        if (node["x-attribsPrefix"]) {
            clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
        }
        result = clone;
    }
    else if (node_isCDATA(node)) {
        const children = recursive ? cloneChildren(node.children) : [];
        const clone = new node_CDATA(children);
        children.forEach((child) => (child.parent = clone));
        result = clone;
    }
    else if (isDocument(node)) {
        const children = recursive ? cloneChildren(node.children) : [];
        const clone = new Document(children);
        children.forEach((child) => (child.parent = clone));
        if (node["x-mode"]) {
            clone["x-mode"] = node["x-mode"];
        }
        result = clone;
    }
    else if (isDirective(node)) {
        const instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error(`Not implemented yet: ${node.type}`);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
function cloneChildren(childs) {
    const children = childs.map((child) => cloneNode(child, true));
    for (let i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}

;// ../../node_modules/domhandler/lib/esm/index.js



// Default options
const defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
class esm_DomHandler {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    constructor(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    onparserinit(parser) {
        this.parser = parser;
    }
    // Resets the handler back to starting state
    onreset() {
        this.dom = [];
        this.root = new Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    }
    // Signals the handler that parsing is done
    onend() {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    }
    onerror(error) {
        this.handleCallback(error);
    }
    onclosetag() {
        this.lastNode = null;
        const elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    }
    onopentag(name, attribs) {
        const type = this.options.xmlMode ? esm_ElementType.Tag : undefined;
        const element = new Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    }
    ontext(data) {
        const { lastNode } = this;
        if (lastNode && lastNode.type === esm_ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            const node = new node_Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    }
    oncomment(data) {
        if (this.lastNode && this.lastNode.type === esm_ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        const node = new node_Comment(data);
        this.addNode(node);
        this.lastNode = node;
    }
    oncommentend() {
        this.lastNode = null;
    }
    oncdatastart() {
        const text = new node_Text("");
        const node = new node_CDATA([text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    }
    oncdataend() {
        this.lastNode = null;
    }
    onprocessinginstruction(name, data) {
        const node = new ProcessingInstruction(name, data);
        this.addNode(node);
    }
    handleCallback(error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    }
    addNode(node) {
        const parent = this.tagStack[this.tagStack.length - 1];
        const previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    }
}
/* harmony default export */ const esm = ((/* unused pure expression or super */ null && (esm_DomHandler)));

;// ../../node_modules/leac/lib/leac.mjs
const e=/\n/g;function n(n){const o=[...n.matchAll(e)].map((e=>e.index||0));o.unshift(-1);const s=t(o,0,o.length);return e=>r(s,e)}function t(e,n,r){if(r-n==1)return{offset:e[n],index:n+1};const o=Math.ceil((n+r)/2),s=t(e,n,o),l=t(e,o,r);return{offset:s.offset,low:s,high:l}}function r(e,n){return function(e){return Object.prototype.hasOwnProperty.call(e,"index")}(e)?{line:e.index,column:n-e.offset}:r(e.high.offset<n?e.high:e.low,n)}function o(e,t="",r={}){const o="string"!=typeof t?t:r,l="string"==typeof t?t:"",c=e.map(s),f=!!o.lineNumbers;return function(e,t=0){const r=f?n(e):()=>({line:0,column:0});let o=t;const s=[];e:for(;o<e.length;){let n=!1;for(const t of c){t.regex.lastIndex=o;const c=t.regex.exec(e);if(c&&c[0].length>0){if(!t.discard){const e=r(o),n="string"==typeof t.replace?c[0].replace(new RegExp(t.regex.source,t.regex.flags),t.replace):c[0];s.push({state:l,name:t.name,text:n,offset:o,len:c[0].length,line:e.line,column:e.column})}if(o=t.regex.lastIndex,n=!0,t.push){const n=t.push(e,o);s.push(...n.tokens),o=n.offset}if(t.pop)break e;break}}if(!n)break}return{tokens:s,offset:o,complete:e.length<=o}}}function s(e,n){return{...e,regex:l(e,n)}}function l(e,n){if(0===e.name.length)throw new Error(`Rule #${n} has empty name, which is not allowed.`);if(function(e){return Object.prototype.hasOwnProperty.call(e,"regex")}(e))return function(e){if(e.global)throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);return e.sticky?e:new RegExp(e.source,e.flags+"y")}(e.regex);if(function(e){return Object.prototype.hasOwnProperty.call(e,"str")}(e)){if(0===e.str.length)throw new Error(`Rule #${n} ("${e.name}") has empty "str" property, which is not allowed.`);return new RegExp(c(e.str),"y")}return new RegExp(c(e.name),"y")}function c(e){return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g,"\\$&")}

;// ../../node_modules/peberminta/lib/core.mjs


function emit(value) {
    return (data, i) => ({
        matched: true,
        position: i,
        value: value
    });
}
function make(
f) {
    return (data, i) => ({
        matched: true,
        position: i,
        value: f(data, i)
    });
}
function action(
f) {
    return (data, i) => {
        f(data, i);
        return {
            matched: true,
            position: i,
            value: null
        };
    };
}
function fail(
data, i) {
    return { matched: false };
}
function error(message) {
    return (data, i) => {
        throw new Error((message instanceof Function) ? message(data, i) : message);
    };
}
function token(
onToken,
onEnd) {
    return (data, i) => {
        let position = i;
        let value = undefined;
        if (i < data.tokens.length) {
            value = onToken(data.tokens[i], data, i);
            if (value !== undefined) {
                position++;
            }
        }
        else {
            onEnd?.(data, i);
        }
        return (value === undefined)
            ? { matched: false }
            : {
                matched: true,
                position: position,
                value: value
            };
    };
}
function any(data, i) {
    return (i < data.tokens.length)
        ? {
            matched: true,
            position: i + 1,
            value: data.tokens[i]
        }
        : { matched: false };
}
function satisfy(
test) {
    return (data, i) => (i < data.tokens.length && test(data.tokens[i], data, i))
        ? {
            matched: true,
            position: i + 1,
            value: data.tokens[i]
        }
        : { matched: false };
}
function mapInner(r, f) {
    return (r.matched) ? ({
        matched: true,
        position: r.position,
        value: f(r.value, r.position)
    }) : r;
}
function mapOuter(r, f) {
    return (r.matched) ? f(r) : r;
}
function map(p, mapper) {
    return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function map1(p,
mapper) {
    return (data, i) => mapOuter(p(data, i), (m) => mapper(m, data, i));
}
function peek(p, f) {
    return (data, i) => {
        const r = p(data, i);
        f(r, data, i);
        return r;
    };
}
function core_option(p, def) {
    return (data, i) => {
        const r = p(data, i);
        return (r.matched)
            ? r
            : {
                matched: true,
                position: i,
                value: def
            };
    };
}
function not(p) {
    return (data, i) => {
        const r = p(data, i);
        return (r.matched)
            ? { matched: false }
            : {
                matched: true,
                position: i,
                value: true
            };
    };
}
function choice(...ps) {
    return (data, i) => {
        for (const p of ps) {
            const result = p(data, i);
            if (result.matched) {
                return result;
            }
        }
        return { matched: false };
    };
}
function otherwise(pa, pb) {
    return (data, i) => {
        const r1 = pa(data, i);
        return (r1.matched)
            ? r1
            : pb(data, i);
    };
}
function longest(...ps) {
    return (data, i) => {
        let match = undefined;
        for (const p of ps) {
            const result = p(data, i);
            if (result.matched && (!match || match.position < result.position)) {
                match = result;
            }
        }
        return match || { matched: false };
    };
}
function takeWhile(p,
test) {
    return (data, i) => {
        const values = [];
        let success = true;
        do {
            const r = p(data, i);
            if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {
                values.push(r.value);
                i = r.position;
            }
            else {
                success = false;
            }
        } while (success);
        return {
            matched: true,
            position: i,
            value: values
        };
    };
}
function takeUntil(p,
test) {
    return takeWhile(p, (value, n, data, i, j) => !test(value, n, data, i, j));
}
function takeWhileP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => pTest(data, i).matched);
}
function takeUntilP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => !pTest(data, i).matched);
}
function many(p) {
    return takeWhile(p, () => true);
}
function many1(p) {
    return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa, pb, join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));
}
function left(pa, pb) {
    return ab(pa, pb, (va) => va);
}
function right(pa, pb) {
    return ab(pa, pb, (va, vb) => vb);
}
function abc(pa, pb, pc, join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));
}
function middle(pa, pb, pc) {
    return abc(pa, pb, pc, (ra, rb) => rb);
}
function core_all(...ps) {
    return (data, i) => {
        const result = [];
        let position = i;
        for (const p of ps) {
            const r1 = p(data, position);
            if (r1.matched) {
                result.push(r1.value);
                position = r1.position;
            }
            else {
                return { matched: false };
            }
        }
        return {
            matched: true,
            position: position,
            value: result
        };
    };
}
function skip(...ps) {
    return map(core_all(...ps), () => null);
}
function flatten(...ps) {
    return flatten1(core_all(...ps));
}
function flatten1(p) {
    return map(p, (vs) => vs.flatMap((v) => v));
}
function sepBy1(pValue, pSep) {
    return ab(pValue, many(right(pSep, pValue)), (head, tail) => [head, ...tail]);
}
function sepBy(pValue, pSep) {
    return otherwise(sepBy1(pValue, pSep), emit([]));
}
function chainReduce(acc,
f) {
    return (data, i) => {
        let loop = true;
        let acc1 = acc;
        let pos = i;
        do {
            const r = f(acc1, data, pos)(data, pos);
            if (r.matched) {
                acc1 = r.value;
                pos = r.position;
            }
            else {
                loop = false;
            }
        } while (loop);
        return {
            matched: true,
            position: pos,
            value: acc1
        };
    };
}
function reduceLeft(acc, p,
reducer) {
    return chainReduce(acc, (acc) => map(p, (v, data, i, j) => reducer(acc, v, data, i, j)));
}
function reduceRight(p, acc,
reducer) {
    return map(many(p), (vs, data, i, j) => vs.reduceRight((acc, v) => reducer(v, acc, data, i, j), acc));
}
function leftAssoc1(pLeft, pOper) {
    return chain(pLeft, (v0) => reduceLeft(v0, pOper, (acc, f) => f(acc)));
}
function rightAssoc1(pOper, pRight) {
    return ab(reduceRight(pOper, (y) => y, (f, acc) => (y) => f(acc(y))), pRight, (f, v) => f(v));
}
function leftAssoc2(pLeft, pOper, pRight) {
    return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function rightAssoc2(pLeft, pOper, pRight) {
    return ab(reduceRight(ab(pLeft, pOper, (x, f) => [x, f]), (y) => y, ([x, f], acc) => (y) => f(x, acc(y))), pRight, (f, v) => f(v));
}
function condition(cond, pTrue, pFalse) {
    return (data, i) => (cond(data, i))
        ? pTrue(data, i)
        : pFalse(data, i);
}
function decide(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => m1.value(data, m1.position));
}
function chain(p,
f) {
    return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}
function ahead(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => ({
        matched: true,
        position: i,
        value: m1.value
    }));
}
function recursive(f) {
    return function (data, i) {
        return f()(data, i);
    };
}
function start(data, i) {
    return (i !== 0)
        ? { matched: false }
        : {
            matched: true,
            position: i,
            value: true
        };
}
function end(data, i) {
    return (i < data.tokens.length)
        ? { matched: false }
        : {
            matched: true,
            position: i,
            value: true
        };
}
function remainingTokensNumber(data, i) {
    return data.tokens.length - i;
}
function parserPosition(data, i, formatToken, contextTokens = 3) {
    const len = data.tokens.length;
    const lowIndex = clamp(0, i - contextTokens, len - contextTokens);
    const highIndex = clamp(contextTokens, i + 1 + contextTokens, len);
    const tokensSlice = data.tokens.slice(lowIndex, highIndex);
    const lines = [];
    const indexWidth = String(highIndex - 1).length + 1;
    if (i < 0) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    if (0 < lowIndex) {
        lines.push('...'.padStart(indexWidth + 6));
    }
    for (let j = 0; j < tokensSlice.length; j++) {
        const index = lowIndex + j;
        lines.push(`${String(index).padStart(indexWidth)} ${(index === i ? '>' : ' ')} ${escapeWhitespace(formatToken(tokensSlice[j]))}`);
    }
    if (highIndex < len) {
        lines.push('...'.padStart(indexWidth + 6));
    }
    if (len <= i) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    return lines.join('\n');
}
function parse(parser, tokens, options, formatToken = JSON.stringify) {
    const data = { tokens: tokens, options: options };
    const result = parser(data, 0);
    if (!result.matched) {
        throw new Error('No match');
    }
    if (result.position < data.tokens.length) {
        throw new Error(`Partial match. Parsing stopped at:\n${parserPosition(data, result.position, formatToken)}`);
    }
    return result.value;
}
function tryParse(parser, tokens, options) {
    const result = parser({ tokens: tokens, options: options }, 0);
    return (result.matched)
        ? result.value
        : undefined;
}
function match(matcher, tokens, options) {
    const result = matcher({ tokens: tokens, options: options }, 0);
    return result.value;
}



;// ../../node_modules/parseley/lib/parseley.mjs



var ast = /*#__PURE__*/Object.freeze({
    __proto__: null
});

const ws = `(?:[ \\t\\r\\n\\f]*)`;
const nl = `(?:\\n|\\r\\n|\\r|\\f)`;
const nonascii = `[^\\x00-\\x7F]`;
const unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`;
const parseley_escape = `(?:\\\\[^\\n\\r\\f0-9a-f])`;
const nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${parseley_escape})`;
const nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${parseley_escape})`;
const parseley_name = `(?:${nmchar}+)`;
const ident = `(?:[-]?${nmstart}${nmchar}*)`;
const string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${parseley_escape})*'`;
const string2 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${parseley_escape})*"`;
const lexSelector = o([
    { name: 'ws', regex: new RegExp(ws) },
    { name: 'hash', regex: new RegExp(`#${parseley_name}`, 'i') },
    { name: 'ident', regex: new RegExp(ident, 'i') },
    { name: 'str1', regex: new RegExp(string1, 'i') },
    { name: 'str2', regex: new RegExp(string2, 'i') },
    { name: '*' },
    { name: '.' },
    { name: ',' },
    { name: '[' },
    { name: ']' },
    { name: '=' },
    { name: '>' },
    { name: '|' },
    { name: '+' },
    { name: '~' },
    { name: '^' },
    { name: '$' },
]);
const lexEscapedString = o([
    { name: 'unicode', regex: new RegExp(unicode, 'i') },
    { name: 'escape', regex: new RegExp(parseley_escape, 'i') },
    { name: 'any', regex: new RegExp('[\\s\\S]', 'i') }
]);
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
    return [a0 + b0, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
    return ss.reduce(sumSpec, [0, 0, 0]);
}
const unicodeEscapedSequence_ = token((t) => t.name === 'unicode' ? String.fromCodePoint(parseInt(t.text.slice(1), 16)) : undefined);
const escapedSequence_ = token((t) => t.name === 'escape' ? t.text.slice(1) : undefined);
const anyChar_ = token((t) => t.name === 'any' ? t.text : undefined);
const escapedString_ = map(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs) => cs.join(''));
function parseley_unescape(escapedString) {
    const lexerResult = lexEscapedString(escapedString);
    const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
    return result.value;
}
function literal(name) {
    return token((t) => t.name === name ? true : undefined);
}
const whitespace_ = token((t) => t.name === 'ws' ? null : undefined);
const optionalWhitespace_ = core_option(whitespace_, null);
function optionallySpaced(parser) {
    return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
const identifier_ = token((t) => t.name === 'ident' ? parseley_unescape(t.text) : undefined);
const hashId_ = token((t) => t.name === 'hash' ? parseley_unescape(t.text.slice(1)) : undefined);
const string_ = token((t) => t.name.startsWith('str') ? parseley_unescape(t.text.slice(1, -1)) : undefined);
const namespace_ = left(core_option(identifier_, ''), literal('|'));
const qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), map(identifier_, (name) => ({ name: name, namespace: null })));
const uniSelector_ = otherwise(ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));
const tagSelector_ = map(qualifiedName_, ({ name, namespace }) => ({
    type: 'tag',
    name: name,
    namespace: namespace,
    specificity: [0, 0, 1]
}));
const classSelector_ = ab(literal('.'), identifier_, (fullstop, name) => ({
    type: 'class',
    name: name,
    specificity: [0, 1, 0]
}));
const idSelector_ = map(hashId_, (name) => ({
    type: 'id',
    name: name,
    specificity: [1, 0, 0]
}));
const attrModifier_ = token((t) => {
    if (t.name === 'ident') {
        if (t.text === 'i' || t.text === 'I') {
            return 'i';
        }
        if (t.text === 's' || t.text === 'S') {
            return 's';
        }
    }
    return undefined;
});
const attrValue_ = otherwise(ab(string_, core_option(right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), ab(identifier_, core_option(right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
const attrMatcher_ = choice(map(literal('='), () => '='), ab(literal('~'), literal('='), () => '~='), ab(literal('|'), literal('='), () => '|='), ab(literal('^'), literal('='), () => '^='), ab(literal('$'), literal('='), () => '$='), ab(literal('*'), literal('='), () => '*='));
const attrPresenceSelector_ = abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({
    type: 'attrPresence',
    name: name,
    namespace: namespace,
    specificity: [0, 1, 0]
}));
const attrValueSelector_ = middle(literal('['), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({
    type: 'attrValue',
    name: name,
    namespace: namespace,
    matcher: matcher,
    value: value,
    modifier: modifier,
    specificity: [0, 1, 0]
})), literal(']'));
const attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
const typeSelector_ = otherwise(uniSelector_, tagSelector_);
const subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
const compoundSelector_ = map(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss) => {
    return {
        type: 'compound',
        list: ss,
        specificity: sumAllSpec(ss.map(s => s.specificity))
    };
});
const combinator_ = choice(map(literal('>'), () => '>'), map(literal('+'), () => '+'), map(literal('~'), () => '~'), ab(literal('|'), literal('|'), () => '||'));
const combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map(whitespace_, () => ' '));
const complexSelector_ = leftAssoc2(compoundSelector_, map(combinatorSeparator_, (c) => (left, right) => ({
    type: 'compound',
    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],
    specificity: sumSpec(left.specificity, right.specificity)
})), compoundSelector_);
const listSelector_ = leftAssoc2(map(complexSelector_, (s) => ({ type: 'list', list: [s] })), map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);
function parse_(parser, str) {
    if (!(typeof str === 'string' || str instanceof String)) {
        throw new Error('Expected a selector string. Actual input is not a string!');
    }
    const lexerResult = lexSelector(str);
    if (!lexerResult.complete) {
        throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` +
            prettyPrintPosition(str, lexerResult.offset));
    }
    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
    if (!result.matched) {
        throw new Error(`No match for "${str}" input!`);
    }
    if (result.position < lexerResult.tokens.length) {
        const token = lexerResult.tokens[result.position];
        throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!\n` +
            prettyPrintPosition(str, token.offset, token.len));
    }
    return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
    return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? '\u2409' : r ? '\u240d' : '\u240a')}\n${''.padEnd(offset)}${'^'.repeat(len)}`;
}
function parseley_parse(str) {
    return parse_(listSelector_, str);
}
function parse1(str) {
    return parse_(complexSelector_, str);
}

function serialize(selector) {
    if (!selector.type) {
        throw new Error('This is not an AST node.');
    }
    switch (selector.type) {
        case 'universal':
            return _serNs(selector.namespace) + '*';
        case 'tag':
            return _serNs(selector.namespace) + _serIdent(selector.name);
        case 'class':
            return '.' + _serIdent(selector.name);
        case 'id':
            return '#' + _serIdent(selector.name);
        case 'attrPresence':
            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
        case 'attrValue':
            return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${(selector.modifier ? selector.modifier : '')}]`;
        case 'combinator':
            return serialize(selector.left) + selector.combinator;
        case 'compound':
            return selector.list.reduce((acc, node) => {
                if (node.type === 'combinator') {
                    return serialize(node) + acc;
                }
                else {
                    return acc + serialize(node);
                }
            }, '');
        case 'list':
            return selector.list.map(serialize).join(',');
    }
}
function _serNs(ns) {
    return (ns || ns === '')
        ? _serIdent(ns) + '|'
        : '';
}
function _codePoint(char) {
    return `\\${char.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
    return str.replace(
    /(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl, ctrl, other) => d1 ? _codePoint(d1) :
        d2 ? '-' + _codePoint(d2.slice(1)) :
            hy ? '\\-' :
                safe ? safe :
                    nl ? '\ufffd' :
                        ctrl ? _codePoint(ctrl) :
                            '\\' + other);
}
function _serStr(str) {
    return str.replace(
    /(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs, nl, ctrl) => dq ? '\\"' :
        bs ? '\\\\' :
            nl ? '\ufffd' :
                _codePoint(ctrl));
}
function normalize(selector) {
    if (!selector.type) {
        throw new Error('This is not an AST node.');
    }
    switch (selector.type) {
        case 'compound': {
            selector.list.forEach(normalize);
            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
            break;
        }
        case 'combinator': {
            normalize(selector.left);
            break;
        }
        case 'list': {
            selector.list.forEach(normalize);
            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);
            break;
        }
    }
    return selector;
}
function _getSelectorPriority(selector) {
    switch (selector.type) {
        case 'universal':
            return [1];
        case 'tag':
            return [1];
        case 'id':
            return [2];
        case 'class':
            return [3, selector.name];
        case 'attrPresence':
            return [4, serialize(selector)];
        case 'attrValue':
            return [5, serialize(selector)];
        case 'combinator':
            return [15, serialize(selector)];
    }
}
function compareSelectors(a, b) {
    return _compareArrays(a.specificity, b.specificity);
}
function compareSpecificity(a, b) {
    return _compareArrays(a, b);
}
function _compareArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
        throw new Error('Arguments must be arrays.');
    }
    const shorter = (a.length < b.length) ? a.length : b.length;
    for (let i = 0; i < shorter; i++) {
        if (a[i] === b[i]) {
            continue;
        }
        return (a[i] < b[i]) ? -1 : 1;
    }
    return a.length - b.length;
}



;// ../../node_modules/selderee/lib/selderee.mjs



var Ast = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var Types = /*#__PURE__*/Object.freeze({
    __proto__: null
});

const treeify = (nodes) => '▽\n' + treeifyArray(nodes, thinLines);
const thinLines = [['├─', '│ '], ['└─', '  ']];
const heavyLines = [['┠─', '┃ '], ['┖─', '  ']];
const doubleLines = [['╟─', '║ '], ['╙─', '  ']];
function treeifyArray(nodes, tpl = heavyLines) {
    return prefixItems(tpl, nodes.map(n => treeifyNode(n)));
}
function treeifyNode(node) {
    switch (node.type) {
        case 'terminal': {
            const vctr = node.valueContainer;
            return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
        }
        case 'tagName':
            return `◻ Tag name\n${treeifyArray(node.variants, doubleLines)}`;
        case 'attrValue':
            return `▣ Attr value: ${node.name}\n${treeifyArray(node.matchers, doubleLines)}`;
        case 'attrPresence':
            return `◨ Attr presence: ${node.name}\n${treeifyArray(node.cont)}`;
        case 'pushElement':
            return `◉ Push element: ${node.combinator}\n${treeifyArray(node.cont, thinLines)}`;
        case 'popElement':
            return `◌ Pop element\n${treeifyArray(node.cont, thinLines)}`;
        case 'variant':
            return `◇ = ${node.value}\n${treeifyArray(node.cont)}`;
        case 'matcher':
            return `◈ ${node.matcher} "${node.value}"${node.modifier || ''}\n${treeifyArray(node.cont)}`;
    }
}
function prefixItems(tpl, items) {
    return items
        .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))
        .join('\n');
}
function prefixItem(tpl, item, tail = true) {
    const tpl1 = tpl[tail ? 1 : 0];
    return tpl1[0] + item.split('\n').join('\n' + tpl1[1]);
}

var TreeifyBuilder = /*#__PURE__*/Object.freeze({
    __proto__: null,
    treeify: treeify
});

class DecisionTree {
    constructor(input) {
        this.branches = weave(toAstTerminalPairs(input));
    }
    build(builder) {
        return builder(this.branches);
    }
}
function toAstTerminalPairs(array) {
    const len = array.length;
    const results = new Array(len);
    for (let i = 0; i < len; i++) {
        const [selectorString, val] = array[i];
        const ast = preprocess(parse1(selectorString));
        results[i] = {
            ast: ast,
            terminal: {
                type: 'terminal',
                valueContainer: { index: i, value: val, specificity: ast.specificity }
            }
        };
    }
    return results;
}
function preprocess(ast) {
    reduceSelectorVariants(ast);
    normalize(ast);
    return ast;
}
function reduceSelectorVariants(ast) {
    const newList = [];
    ast.list.forEach(sel => {
        switch (sel.type) {
            case 'class':
                newList.push({
                    matcher: '~=',
                    modifier: null,
                    name: 'class',
                    namespace: null,
                    specificity: sel.specificity,
                    type: 'attrValue',
                    value: sel.name,
                });
                break;
            case 'id':
                newList.push({
                    matcher: '=',
                    modifier: null,
                    name: 'id',
                    namespace: null,
                    specificity: sel.specificity,
                    type: 'attrValue',
                    value: sel.name,
                });
                break;
            case 'combinator':
                reduceSelectorVariants(sel.left);
                newList.push(sel);
                break;
            case 'universal':
                break;
            default:
                newList.push(sel);
                break;
        }
    });
    ast.list = newList;
}
function weave(items) {
    const branches = [];
    while (items.length) {
        const topKind = findTopKey(items, (sel) => true, getSelectorKind);
        const { matches, nonmatches, empty } = breakByKind(items, topKind);
        items = nonmatches;
        if (matches.length) {
            branches.push(branchOfKind(topKind, matches));
        }
        if (empty.length) {
            branches.push(...terminate(empty));
        }
    }
    return branches;
}
function terminate(items) {
    const results = [];
    for (const item of items) {
        const terminal = item.terminal;
        if (terminal.type === 'terminal') {
            results.push(terminal);
        }
        else {
            const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');
            matches.forEach((node) => results.push(node));
            if (rest.length) {
                terminal.cont = rest;
                results.push(terminal);
            }
        }
    }
    return results;
}
function breakByKind(items, selectedKind) {
    const matches = [];
    const nonmatches = [];
    const empty = [];
    for (const item of items) {
        const simpsels = item.ast.list;
        if (simpsels.length) {
            const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);
            (isMatch ? matches : nonmatches).push(item);
        }
        else {
            empty.push(item);
        }
    }
    return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
    switch (sel.type) {
        case 'attrPresence':
            return `attrPresence ${sel.name}`;
        case 'attrValue':
            return `attrValue ${sel.name}`;
        case 'combinator':
            return `combinator ${sel.combinator}`;
        default:
            return sel.type;
    }
}
function branchOfKind(kind, items) {
    if (kind === 'tag') {
        return tagNameBranch(items);
    }
    if (kind.startsWith('attrValue ')) {
        return attrValueBranch(kind.substring(10), items);
    }
    if (kind.startsWith('attrPresence ')) {
        return attrPresenceBranch(kind.substring(13), items);
    }
    if (kind === 'combinator >') {
        return combinatorBranch('>', items);
    }
    if (kind === 'combinator +') {
        return combinatorBranch('+', items);
    }
    throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
    const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);
    const variants = Object.entries(groups).map(([name, group]) => ({
        type: 'variant',
        value: name,
        cont: weave(group.items)
    }));
    return {
        type: 'tagName',
        variants: variants
    };
}
function attrPresenceBranch(name, items) {
    for (const item of items) {
        spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));
    }
    return {
        type: 'attrPresence',
        name: name,
        cont: weave(items)
    };
}
function attrValueBranch(name, items) {
    const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);
    const matchers = [];
    for (const group of Object.values(groups)) {
        const sel = group.oneSimpleSelector;
        const predicate = getAttrPredicate(sel);
        const continuation = weave(group.items);
        matchers.push({
            type: 'matcher',
            matcher: sel.matcher,
            modifier: sel.modifier,
            value: sel.value,
            predicate: predicate,
            cont: continuation
        });
    }
    return {
        type: 'attrValue',
        name: name,
        matchers: matchers
    };
}
function getAttrPredicate(sel) {
    if (sel.modifier === 'i') {
        const expected = sel.value.toLowerCase();
        switch (sel.matcher) {
            case '=':
                return (actual) => expected === actual.toLowerCase();
            case '~=':
                return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
            case '^=':
                return (actual) => actual.toLowerCase().startsWith(expected);
            case '$=':
                return (actual) => actual.toLowerCase().endsWith(expected);
            case '*=':
                return (actual) => actual.toLowerCase().includes(expected);
            case '|=':
                return (actual) => {
                    const lower = actual.toLowerCase();
                    return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');
                };
        }
    }
    else {
        const expected = sel.value;
        switch (sel.matcher) {
            case '=':
                return (actual) => expected === actual;
            case '~=':
                return (actual) => actual.split(/[ \t]+/).includes(expected);
            case '^=':
                return (actual) => actual.startsWith(expected);
            case '$=':
                return (actual) => actual.endsWith(expected);
            case '*=':
                return (actual) => actual.includes(expected);
            case '|=':
                return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');
        }
    }
}
function combinatorBranch(combinator, items) {
    const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => serialize(x.left));
    const leftItems = [];
    for (const group of Object.values(groups)) {
        const rightCont = weave(group.items);
        const leftAst = group.oneSimpleSelector.left;
        leftItems.push({
            ast: leftAst,
            terminal: { type: 'popElement', cont: rightCont }
        });
    }
    return {
        type: 'pushElement',
        combinator: combinator,
        cont: weave(leftItems)
    };
}
function spliceAndGroup(items, predicate, keyCallback) {
    const groups = {};
    while (items.length) {
        const bestKey = findTopKey(items, predicate, keyCallback);
        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
        const { matches, rest } = partition1(items, hasBestKeyPredicate);
        let oneSimpleSelector = null;
        for (const item of matches) {
            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
            if (!oneSimpleSelector) {
                oneSimpleSelector = splicedNode;
            }
        }
        if (oneSimpleSelector == null) {
            throw new Error('No simple selector is found.');
        }
        groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };
        items = rest;
    }
    return groups;
}
function spliceSimpleSelector(item, predicate) {
    const simpsels = item.ast.list;
    const matches = new Array(simpsels.length);
    let firstIndex = -1;
    for (let i = simpsels.length; i-- > 0;) {
        if (predicate(simpsels[i])) {
            matches[i] = true;
            firstIndex = i;
        }
    }
    if (firstIndex == -1) {
        throw new Error(`Couldn't find the required simple selector.`);
    }
    const result = simpsels[firstIndex];
    item.ast.list = simpsels.filter((sel, i) => !matches[i]);
    return result;
}
function findTopKey(items, predicate, keyCallback) {
    const candidates = {};
    for (const item of items) {
        const candidates1 = {};
        for (const node of item.ast.list.filter(predicate)) {
            candidates1[keyCallback(node)] = true;
        }
        for (const key of Object.keys(candidates1)) {
            if (candidates[key]) {
                candidates[key]++;
            }
            else {
                candidates[key] = 1;
            }
        }
    }
    let topKind = '';
    let topCounter = 0;
    for (const entry of Object.entries(candidates)) {
        if (entry[1] > topCounter) {
            topKind = entry[0];
            topCounter = entry[1];
        }
    }
    return topKind;
}
function partition(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
        if (predicate(x)) {
            matches.push(x);
        }
        else {
            rest.push(x);
        }
    }
    return { matches, rest };
}
function partition1(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
        if (predicate(x)) {
            matches.push(x);
        }
        else {
            rest.push(x);
        }
    }
    return { matches, rest };
}

class Picker {
    constructor(f) {
        this.f = f;
    }
    pickAll(el) {
        return this.f(el);
    }
    pick1(el, preferFirst = false) {
        const results = this.f(el);
        const len = results.length;
        if (len === 0) {
            return null;
        }
        if (len === 1) {
            return results[0].value;
        }
        const comparator = (preferFirst)
            ? comparatorPreferFirst
            : comparatorPreferLast;
        let result = results[0];
        for (let i = 1; i < len; i++) {
            const next = results[i];
            if (comparator(result, next)) {
                result = next;
            }
        }
        return result.value;
    }
}
function comparatorPreferFirst(acc, next) {
    const diff = compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || (diff === 0 && next.index < acc.index);
}
function comparatorPreferLast(acc, next) {
    const diff = compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || (diff === 0 && next.index > acc.index);
}



;// ../../node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs



function hp2Builder(nodes) {
    return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
    const matchers = nodes.map(handleNode);
    return (el, ...tail) => matchers.flatMap(m => m(el, ...tail));
}
function handleNode(node) {
    switch (node.type) {
        case 'terminal': {
            const result = [node.valueContainer];
            return (el, ...tail) => result;
        }
        case 'tagName':
            return handleTagName(node);
        case 'attrValue':
            return handleAttrValueName(node);
        case 'attrPresence':
            return handleAttrPresenceName(node);
        case 'pushElement':
            return handlePushElementNode(node);
        case 'popElement':
            return handlePopElementNode(node);
    }
}
function handleTagName(node) {
    const variants = {};
    for (const variant of node.variants) {
        variants[variant.value] = handleArray(variant.cont);
    }
    return (el, ...tail) => {
        const continuation = variants[el.name];
        return (continuation) ? continuation(el, ...tail) : [];
    };
}
function handleAttrPresenceName(node) {
    const attrName = node.name;
    const continuation = handleArray(node.cont);
    return (el, ...tail) => (Object.prototype.hasOwnProperty.call(el.attribs, attrName))
        ? continuation(el, ...tail)
        : [];
}
function handleAttrValueName(node) {
    const callbacks = [];
    for (const matcher of node.matchers) {
        const predicate = matcher.predicate;
        const continuation = handleArray(matcher.cont);
        callbacks.push((attr, el, ...tail) => (predicate(attr) ? continuation(el, ...tail) : []));
    }
    const attrName = node.name;
    return (el, ...tail) => {
        const attr = el.attribs[attrName];
        return (attr || attr === '')
            ? callbacks.flatMap(cb => cb(attr, el, ...tail))
            : [];
    };
}
function handlePushElementNode(node) {
    const continuation = handleArray(node.cont);
    const leftElementGetter = (node.combinator === '+')
        ? getPrecedingElement
        : getParentElement;
    return (el, ...tail) => {
        const next = leftElementGetter(el);
        if (next === null) {
            return [];
        }
        return continuation(next, el, ...tail);
    };
}
const getPrecedingElement = (el) => {
    const prev = el.prev;
    if (prev === null) {
        return null;
    }
    return (node_isTag(prev)) ? prev : getPrecedingElement(prev);
};
const getParentElement = (el) => {
    const parent = el.parent;
    return (parent && node_isTag(parent)) ? parent : null;
};
function handlePopElementNode(node) {
    const continuation = handleArray(node.cont);
    return (el, next, ...tail) => continuation(next, ...tail);
}



;// ../../node_modules/entities/lib/esm/generated/decode-data-html.js
// Generated using scripts/write-decode-map.ts
/* harmony default export */ const decode_data_html = (new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map((c) => c.charCodeAt(0))));
//# sourceMappingURL=decode-data-html.js.map
;// ../../node_modules/entities/lib/esm/generated/decode-data-xml.js
// Generated using scripts/write-decode-map.ts
/* harmony default export */ const decode_data_xml = (new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map((c) => c.charCodeAt(0))));
//# sourceMappingURL=decode-data-xml.js.map
;// ../../node_modules/entities/lib/esm/decode_codepoint.js
// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
const decodeMap = new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
const fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
    let output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
    var _a;
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
/**
 * Replace the code point if relevant, then convert it to a string.
 *
 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
 * @param codePoint The code point to decode.
 * @returns The decoded code point.
 */
function decodeCodePoint(codePoint) {
    return fromCodePoint(replaceCodePoint(codePoint));
}
//# sourceMappingURL=decode_codepoint.js.map
;// ../../node_modules/entities/lib/esm/decode.js



// Re-export for use by eg. htmlparser2


var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 0b100000;
var BinTrieFlags;
(function (BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
}
function isAsciiAlphaNumeric(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
        isNumber(code));
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var decode_DecodingMode;
(function (DecodingMode) {
    /** Entities in text nodes that can end with any character. */
    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Only allow entities terminated with a semicolon. */
    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    /** Entities in attributes have limitations on ending characters. */
    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(decode_DecodingMode || (decode_DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
class EntityDecoder {
    constructor(
    /** The tree used to decode entities. */
    decodeTree, 
    /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */
    emitCodePoint, 
    /** An object that is used to produce errors. */
    errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        /** The current state of the decoder. */
        this.state = EntityDecoderState.EntityStart;
        /** Characters that were consumed while parsing an entity. */
        this.consumed = 1;
        /**
         * The result of the entity.
         *
         * Either the result index of a numeric entity, or the codepoint of a
         * numeric entity.
         */
        this.result = 0;
        /** The current index in the decode tree. */
        this.treeIndex = 0;
        /** The number of characters that were consumed in excess. */
        this.excess = 1;
        /** The mode in which the decoder is operating. */
        this.decodeMode = decode_DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
        switch (this.state) {
            case EntityDecoderState.EntityStart: {
                if (str.charCodeAt(offset) === CharCodes.NUM) {
                    this.state = EntityDecoderState.NumericStart;
                    this.consumed += 1;
                    return this.stateNumericStart(str, offset + 1);
                }
                this.state = EntityDecoderState.NamedEntity;
                return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
                return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
                return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
                return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
                return this.stateNamedEntity(str, offset);
            }
        }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
        if (offset >= str.length) {
            return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start, end, base) {
        if (start !== end) {
            const digitCount = end - start;
            this.result =
                this.result * Math.pow(base, digitCount) +
                    parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
        }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
        var _a;
        // Ensure we consumed at least one digit.
        if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
        }
        // Figure out if this is a legit end of the entity
        if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
        }
        else if (this.decodeMode === decode_DecodingMode.Strict) {
            return 0;
        }
        this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
        if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
        const { decodeTree } = this;
        let current = decodeTree[this.treeIndex];
        // The mask is the number of bytes of the value, including the current byte.
        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
            const char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
                return this.result === 0 ||
                    // If we are parsing an attribute
                    (this.decodeMode === decode_DecodingMode.Attribute &&
                        // We shouldn't have consumed any characters after the entity,
                        (valueLength === 0 ||
                            // And there should be no invalid characters.
                            isEntityInAttributeInvalidEnd(char)))
                    ? 0
                    : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            // If the branch is a value, store it and continue
            if (valueLength !== 0) {
                // If the entity is terminated by a semicolon, we are done.
                if (char === CharCodes.SEMI) {
                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                if (this.decodeMode !== decode_DecodingMode.Strict) {
                    this.result = this.treeIndex;
                    this.consumed += this.excess;
                    this.excess = 0;
                }
            }
        }
        return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
        var _a;
        const { result, decodeTree } = this;
        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
        const { decodeTree } = this;
        this.emitCodePoint(valueLength === 1
            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
            : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
            // For multi-byte values, we need to emit the second byte.
            this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
        var _a;
        switch (this.state) {
            case EntityDecoderState.NamedEntity: {
                // Emit a named entity if we have one.
                return this.result !== 0 &&
                    (this.decodeMode !== decode_DecodingMode.Attribute ||
                        this.result === this.treeIndex)
                    ? this.emitNotTerminatedNamedEntity()
                    : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
                return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
                return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            case EntityDecoderState.EntityStart: {
                // Return 0 if we have no entity.
                return 0;
            }
        }
    }
}
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));
    return function decodeWithTrie(str, decodeMode) {
        let lastIndex = 0;
        let offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
            ret += str.slice(lastIndex, offset);
            decoder.startEntity(decodeMode);
            const len = decoder.write(str, 
            // Skip the "&"
            offset + 1);
            if (len < 0) {
                lastIndex = offset + decoder.end();
                break;
            }
            lastIndex = offset + len;
            // If `len` is 0, skip the current `&` and continue.
            offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        const result = ret + str.slice(lastIndex);
        // Make sure we don't keep a reference to the final string.
        ret = "";
        return result;
    };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
        const value = char - jumpOffset;
        return value < 0 || value >= branchCount
            ? -1
            : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    let lo = nodeIdx;
    let hi = lo + branchCount - 1;
    while (lo <= hi) {
        const mid = (lo + hi) >>> 1;
        const midVal = decodeTree[mid];
        if (midVal < char) {
            lo = mid + 1;
        }
        else if (midVal > char) {
            hi = mid - 1;
        }
        else {
            return decodeTree[mid + branchCount];
        }
    }
    return -1;
}
const htmlDecoder = getDecoder(decode_data_html);
const xmlDecoder = getDecoder(decode_data_xml);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decode_decodeHTML(str, mode = decode_DecodingMode.Legacy) {
    return htmlDecoder(str, mode);
}
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLAttribute(str) {
    return htmlDecoder(str, decode_DecodingMode.Attribute);
}
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
    return htmlDecoder(str, decode_DecodingMode.Strict);
}
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decode_decodeXML(str) {
    return xmlDecoder(str, decode_DecodingMode.Strict);
}
//# sourceMappingURL=decode.js.map
;// ../../node_modules/html-to-text/node_modules/htmlparser2/lib/esm/Tokenizer.js

var Tokenizer_CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["Tab"] = 9] = "Tab";
    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes[CharCodes["Space"] = 32] = "Space";
    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes[CharCodes["Number"] = 35] = "Number";
    CharCodes[CharCodes["Amp"] = 38] = "Amp";
    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes[CharCodes["Dash"] = 45] = "Dash";
    CharCodes[CharCodes["Slash"] = 47] = "Slash";
    CharCodes[CharCodes["Zero"] = 48] = "Zero";
    CharCodes[CharCodes["Nine"] = 57] = "Nine";
    CharCodes[CharCodes["Semi"] = 59] = "Semi";
    CharCodes[CharCodes["Lt"] = 60] = "Lt";
    CharCodes[CharCodes["Eq"] = 61] = "Eq";
    CharCodes[CharCodes["Gt"] = 62] = "Gt";
    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(Tokenizer_CharCodes || (Tokenizer_CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function (State) {
    State[State["Text"] = 1] = "Text";
    State[State["BeforeTagName"] = 2] = "BeforeTagName";
    State[State["InTagName"] = 3] = "InTagName";
    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State[State["InClosingTagName"] = 6] = "InClosingTagName";
    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    // Attributes
    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State[State["InAttributeName"] = 9] = "InAttributeName";
    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    // Declarations
    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State[State["InDeclaration"] = 16] = "InDeclaration";
    // Processing instructions
    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    // Comments & CDATA
    State[State["BeforeComment"] = 18] = "BeforeComment";
    State[State["CDATASequence"] = 19] = "CDATASequence";
    State[State["InSpecialComment"] = 20] = "InSpecialComment";
    State[State["InCommentLike"] = 21] = "InCommentLike";
    // Special tags
    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State[State["InSpecialTag"] = 24] = "InSpecialTag";
    State[State["BeforeEntity"] = 25] = "BeforeEntity";
    State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State[State["InNamedEntity"] = 27] = "InNamedEntity";
    State[State["InNumericEntity"] = 28] = "InNumericEntity";
    State[State["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
    return (c === Tokenizer_CharCodes.Space ||
        c === Tokenizer_CharCodes.NewLine ||
        c === Tokenizer_CharCodes.Tab ||
        c === Tokenizer_CharCodes.FormFeed ||
        c === Tokenizer_CharCodes.CarriageReturn);
}
function isEndOfTagSection(c) {
    return c === Tokenizer_CharCodes.Slash || c === Tokenizer_CharCodes.Gt || isWhitespace(c);
}
function Tokenizer_isNumber(c) {
    return c >= Tokenizer_CharCodes.Zero && c <= Tokenizer_CharCodes.Nine;
}
function isASCIIAlpha(c) {
    return ((c >= Tokenizer_CharCodes.LowerA && c <= Tokenizer_CharCodes.LowerZ) ||
        (c >= Tokenizer_CharCodes.UpperA && c <= Tokenizer_CharCodes.UpperZ));
}
function isHexDigit(c) {
    return ((c >= Tokenizer_CharCodes.UpperA && c <= Tokenizer_CharCodes.UpperF) ||
        (c >= Tokenizer_CharCodes.LowerA && c <= Tokenizer_CharCodes.LowerF));
}
var QuoteType;
(function (QuoteType) {
    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
    QuoteType[QuoteType["Single"] = 2] = "Single";
    QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
const Sequences = {
    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
};
class Tokenizer {
    constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
        this.cbs = cbs;
        /** The current state the tokenizer is in. */
        this.state = State.Text;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this.index = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = State.Text;
        /** For special parsing behavior inside of script and style tags. */
        this.isSpecial = false;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** The offset of the current buffer. */
        this.offset = 0;
        this.currentSequence = undefined;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        /** For named entities, the index of the value. For numeric entities, the code point. */
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_data_xml : decode_data_html;
    }
    reset() {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = undefined;
        this.running = true;
        this.offset = 0;
    }
    write(chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
    }
    end() {
        if (this.running)
            this.finish();
    }
    pause() {
        this.running = false;
    }
    resume() {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
            this.parse();
        }
    }
    /**
     * The current index within all of the written data.
     */
    getIndex() {
        return this.index;
    }
    /**
     * The start of the current section.
     */
    getSectionStart() {
        return this.sectionStart;
    }
    stateText(c) {
        if (c === Tokenizer_CharCodes.Lt ||
            (!this.decodeEntities && this.fastForwardTo(Tokenizer_CharCodes.Lt))) {
            if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State.BeforeTagName;
            this.sectionStart = this.index;
        }
        else if (this.decodeEntities && c === Tokenizer_CharCodes.Amp) {
            this.state = State.BeforeEntity;
        }
    }
    stateSpecialStartSequence(c) {
        const isEnd = this.sequenceIndex === this.currentSequence.length;
        const isMatch = isEnd
            ? // If we are at the end of the sequence, make sure the tag name has ended
                isEndOfTagSection(c)
            : // Otherwise, do a case-insensitive comparison
                (c | 0x20) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
            this.isSpecial = false;
        }
        else if (!isEnd) {
            this.sequenceIndex++;
            return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
    }
    /** Look for an end tag. For <title> tags, also decode entities. */
    stateInSpecialTag(c) {
        if (this.sequenceIndex === this.currentSequence.length) {
            if (c === Tokenizer_CharCodes.Gt || isWhitespace(c)) {
                const endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                    // Spoof the index so that reported locations match up.
                    const actualIndex = this.index;
                    this.index = endOfText;
                    this.cbs.ontext(this.sectionStart, endOfText);
                    this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2; // Skip over the `</`
                this.stateInClosingTagName(c);
                return; // We are done; skip the rest of the function.
            }
            this.sequenceIndex = 0;
        }
        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
        }
        else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
                // We have to parse entities in <title> tags.
                if (this.decodeEntities && c === Tokenizer_CharCodes.Amp) {
                    this.state = State.BeforeEntity;
                }
            }
            else if (this.fastForwardTo(Tokenizer_CharCodes.Lt)) {
                // Outside of <title> tags, we can fast-forward.
                this.sequenceIndex = 1;
            }
        }
        else {
            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
            this.sequenceIndex = Number(c === Tokenizer_CharCodes.Lt);
        }
    }
    stateCDATASequence(c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
            }
        }
        else {
            this.sequenceIndex = 0;
            this.state = State.InDeclaration;
            this.stateInDeclaration(c); // Reconsume the character
        }
    }
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    fastForwardTo(c) {
        while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
            }
        }
        /*
         * We increment the index at the end of the `parse` loop,
         * so set it to `buffer.length - 1` here.
         *
         * TODO: Refactor `parse` to increment index before calling states.
         */
        this.index = this.buffer.length + this.offset - 1;
        return false;
    }
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    stateInCommentLike(c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, this.index, 2);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
            }
        }
        else if (this.sequenceIndex === 0) {
            // Fast-forward to the first character of the sequence
            if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
            }
        }
        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            // Allow long sequences, eg. --->, ]]]>
            this.sequenceIndex = 0;
        }
    }
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    isTagStartChar(c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    }
    startSpecial(sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
    }
    stateBeforeTagName(c) {
        if (c === Tokenizer_CharCodes.ExclamationMark) {
            this.state = State.BeforeDeclaration;
            this.sectionStart = this.index + 1;
        }
        else if (c === Tokenizer_CharCodes.Questionmark) {
            this.state = State.InProcessingInstruction;
            this.sectionStart = this.index + 1;
        }
        else if (this.isTagStartChar(c)) {
            const lower = c | 0x20;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
            }
            else {
                this.state =
                    !this.xmlMode && lower === Sequences.ScriptEnd[2]
                        ? State.BeforeSpecialS
                        : State.InTagName;
            }
        }
        else if (c === Tokenizer_CharCodes.Slash) {
            this.state = State.BeforeClosingTagName;
        }
        else {
            this.state = State.Text;
            this.stateText(c);
        }
    }
    stateInTagName(c) {
        if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    }
    stateBeforeClosingTagName(c) {
        if (isWhitespace(c)) {
            // Ignore
        }
        else if (c === Tokenizer_CharCodes.Gt) {
            this.state = State.Text;
        }
        else {
            this.state = this.isTagStartChar(c)
                ? State.InClosingTagName
                : State.InSpecialComment;
            this.sectionStart = this.index;
        }
    }
    stateInClosingTagName(c) {
        if (c === Tokenizer_CharCodes.Gt || isWhitespace(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
        }
    }
    stateAfterClosingTagName(c) {
        // Skip everything until ">"
        if (c === Tokenizer_CharCodes.Gt || this.fastForwardTo(Tokenizer_CharCodes.Gt)) {
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
        }
    }
    stateBeforeAttributeName(c) {
        if (c === Tokenizer_CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
            }
            else {
                this.state = State.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
        }
        else if (c === Tokenizer_CharCodes.Slash) {
            this.state = State.InSelfClosingTag;
        }
        else if (!isWhitespace(c)) {
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    }
    stateInSelfClosingTag(c) {
        if (c === Tokenizer_CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false; // Reset special state, in case of self-closing special tags
        }
        else if (!isWhitespace(c)) {
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    }
    stateInAttributeName(c) {
        if (c === Tokenizer_CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterAttributeName;
            this.stateAfterAttributeName(c);
        }
    }
    stateAfterAttributeName(c) {
        if (c === Tokenizer_CharCodes.Eq) {
            this.state = State.BeforeAttributeValue;
        }
        else if (c === Tokenizer_CharCodes.Slash || c === Tokenizer_CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (!isWhitespace(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    }
    stateBeforeAttributeValue(c) {
        if (c === Tokenizer_CharCodes.DoubleQuote) {
            this.state = State.InAttributeValueDq;
            this.sectionStart = this.index + 1;
        }
        else if (c === Tokenizer_CharCodes.SingleQuote) {
            this.state = State.InAttributeValueSq;
            this.sectionStart = this.index + 1;
        }
        else if (!isWhitespace(c)) {
            this.sectionStart = this.index;
            this.state = State.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c); // Reconsume token
        }
    }
    handleInAttributeValue(c, quote) {
        if (c === quote ||
            (!this.decodeEntities && this.fastForwardTo(quote))) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === Tokenizer_CharCodes.DoubleQuote
                ? QuoteType.Double
                : QuoteType.Single, this.index);
            this.state = State.BeforeAttributeName;
        }
        else if (this.decodeEntities && c === Tokenizer_CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    }
    stateInAttributeValueDoubleQuotes(c) {
        this.handleInAttributeValue(c, Tokenizer_CharCodes.DoubleQuote);
    }
    stateInAttributeValueSingleQuotes(c) {
        this.handleInAttributeValue(c, Tokenizer_CharCodes.SingleQuote);
    }
    stateInAttributeValueNoQuotes(c) {
        if (isWhitespace(c) || c === Tokenizer_CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (this.decodeEntities && c === Tokenizer_CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    }
    stateBeforeDeclaration(c) {
        if (c === Tokenizer_CharCodes.OpeningSquareBracket) {
            this.state = State.CDATASequence;
            this.sequenceIndex = 0;
        }
        else {
            this.state =
                c === Tokenizer_CharCodes.Dash
                    ? State.BeforeComment
                    : State.InDeclaration;
        }
    }
    stateInDeclaration(c) {
        if (c === Tokenizer_CharCodes.Gt || this.fastForwardTo(Tokenizer_CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    }
    stateInProcessingInstruction(c) {
        if (c === Tokenizer_CharCodes.Gt || this.fastForwardTo(Tokenizer_CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    }
    stateBeforeComment(c) {
        if (c === Tokenizer_CharCodes.Dash) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            // Allow short comments (eg. <!-->)
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
        }
        else {
            this.state = State.InDeclaration;
        }
    }
    stateInSpecialComment(c) {
        if (c === Tokenizer_CharCodes.Gt || this.fastForwardTo(Tokenizer_CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    }
    stateBeforeSpecialS(c) {
        const lower = c | 0x20;
        if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
        }
        else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
        }
        else {
            this.state = State.InTagName;
            this.stateInTagName(c); // Consume the token again
        }
    }
    stateBeforeEntity(c) {
        // Start excess with 1 to include the '&'
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === Tokenizer_CharCodes.Number) {
            this.state = State.BeforeNumericEntity;
        }
        else if (c === Tokenizer_CharCodes.Amp) {
            // We have two `&` characters in a row. Stay in the current state.
        }
        else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State.InNamedEntity;
            this.stateInNamedEntity(c);
        }
    }
    stateInNamedEntity(c) {
        this.entityExcess += 1;
        this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
        // If the branch is a value, store it and continue
        if (masked) {
            // The mask is the number of bytes of the value, including the current byte.
            const valueLength = (masked >> 14) - 1;
            // If we have a legacy entity while parsing strictly, just skip the number of bytes
            if (!this.allowLegacyEntity() && c !== Tokenizer_CharCodes.Semi) {
                this.trieIndex += valueLength;
            }
            else {
                // Add 1 as we have already incremented the excess
                const entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                // If this is a surrogate pair, consume the next two bytes
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                    this.emitNamedEntity();
                }
            }
        }
    }
    emitNamedEntity() {
        this.state = this.baseState;
        if (this.entityResult === 0) {
            return;
        }
        const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >>
            14;
        switch (valueLength) {
            case 1: {
                this.emitCodePoint(this.entityTrie[this.entityResult] &
                    ~BinTrieFlags.VALUE_LENGTH);
                break;
            }
            case 2: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
            }
            case 3: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
        }
    }
    stateBeforeNumericEntity(c) {
        if ((c | 0x20) === Tokenizer_CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State.InHexEntity;
        }
        else {
            this.state = State.InNumericEntity;
            this.stateInNumericEntity(c);
        }
    }
    emitNumericEntity(strict) {
        const entityStart = this.index - this.entityExcess - 1;
        const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
            // Emit leading data if any
            if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint(replaceCodePoint(this.entityResult));
        }
        this.state = this.baseState;
    }
    stateInNumericEntity(c) {
        if (c === Tokenizer_CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (Tokenizer_isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - Tokenizer_CharCodes.Zero);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    }
    stateInHexEntity(c) {
        if (c === Tokenizer_CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (Tokenizer_isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - Tokenizer_CharCodes.Zero);
            this.entityExcess++;
        }
        else if (isHexDigit(c)) {
            this.entityResult =
                this.entityResult * 16 + ((c | 0x20) - Tokenizer_CharCodes.LowerA + 10);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    }
    allowLegacyEntity() {
        return (!this.xmlMode &&
            (this.baseState === State.Text ||
                this.baseState === State.InSpecialTag));
    }
    /**
     * Remove data that has already been consumed from the buffer.
     */
    cleanup() {
        // If we are inside of text or attributes, emit what we already have.
        if (this.running && this.sectionStart !== this.index) {
            if (this.state === State.Text ||
                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
            else if (this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
        }
    }
    shouldContinue() {
        return this.index < this.buffer.length + this.offset && this.running;
    }
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    parse() {
        while (this.shouldContinue()) {
            const c = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
                case State.Text: {
                    this.stateText(c);
                    break;
                }
                case State.SpecialStartSequence: {
                    this.stateSpecialStartSequence(c);
                    break;
                }
                case State.InSpecialTag: {
                    this.stateInSpecialTag(c);
                    break;
                }
                case State.CDATASequence: {
                    this.stateCDATASequence(c);
                    break;
                }
                case State.InAttributeValueDq: {
                    this.stateInAttributeValueDoubleQuotes(c);
                    break;
                }
                case State.InAttributeName: {
                    this.stateInAttributeName(c);
                    break;
                }
                case State.InCommentLike: {
                    this.stateInCommentLike(c);
                    break;
                }
                case State.InSpecialComment: {
                    this.stateInSpecialComment(c);
                    break;
                }
                case State.BeforeAttributeName: {
                    this.stateBeforeAttributeName(c);
                    break;
                }
                case State.InTagName: {
                    this.stateInTagName(c);
                    break;
                }
                case State.InClosingTagName: {
                    this.stateInClosingTagName(c);
                    break;
                }
                case State.BeforeTagName: {
                    this.stateBeforeTagName(c);
                    break;
                }
                case State.AfterAttributeName: {
                    this.stateAfterAttributeName(c);
                    break;
                }
                case State.InAttributeValueSq: {
                    this.stateInAttributeValueSingleQuotes(c);
                    break;
                }
                case State.BeforeAttributeValue: {
                    this.stateBeforeAttributeValue(c);
                    break;
                }
                case State.BeforeClosingTagName: {
                    this.stateBeforeClosingTagName(c);
                    break;
                }
                case State.AfterClosingTagName: {
                    this.stateAfterClosingTagName(c);
                    break;
                }
                case State.BeforeSpecialS: {
                    this.stateBeforeSpecialS(c);
                    break;
                }
                case State.InAttributeValueNq: {
                    this.stateInAttributeValueNoQuotes(c);
                    break;
                }
                case State.InSelfClosingTag: {
                    this.stateInSelfClosingTag(c);
                    break;
                }
                case State.InDeclaration: {
                    this.stateInDeclaration(c);
                    break;
                }
                case State.BeforeDeclaration: {
                    this.stateBeforeDeclaration(c);
                    break;
                }
                case State.BeforeComment: {
                    this.stateBeforeComment(c);
                    break;
                }
                case State.InProcessingInstruction: {
                    this.stateInProcessingInstruction(c);
                    break;
                }
                case State.InNamedEntity: {
                    this.stateInNamedEntity(c);
                    break;
                }
                case State.BeforeEntity: {
                    this.stateBeforeEntity(c);
                    break;
                }
                case State.InHexEntity: {
                    this.stateInHexEntity(c);
                    break;
                }
                case State.InNumericEntity: {
                    this.stateInNumericEntity(c);
                    break;
                }
                default: {
                    // `this._state === State.BeforeNumericEntity`
                    this.stateBeforeNumericEntity(c);
                }
            }
            this.index++;
        }
        this.cleanup();
    }
    finish() {
        if (this.state === State.InNamedEntity) {
            this.emitNamedEntity();
        }
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this.index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    }
    /** Handle any trailing data. */
    handleTrailingData() {
        const endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
            }
            else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
        }
        else if (this.state === State.InNumericEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InHexEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InTagName ||
            this.state === State.BeforeAttributeName ||
            this.state === State.BeforeAttributeValue ||
            this.state === State.AfterAttributeName ||
            this.state === State.InAttributeName ||
            this.state === State.InAttributeValueSq ||
            this.state === State.InAttributeValueDq ||
            this.state === State.InAttributeValueNq ||
            this.state === State.InClosingTagName) {
            /*
             * If we are currently in an opening or closing tag, us not calling the
             * respective callback signals that the tag should be ignored.
             */
        }
        else {
            this.cbs.ontext(this.sectionStart, endIndex);
        }
    }
    emitPartial(start, endIndex) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
        }
        else {
            this.cbs.ontext(start, endIndex);
        }
    }
    emitCodePoint(cp) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribentity(cp);
        }
        else {
            this.cbs.ontextentity(cp);
        }
    }
}
//# sourceMappingURL=Tokenizer.js.map
;// ../../node_modules/html-to-text/node_modules/htmlparser2/lib/esm/Parser.js


const formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
const pTag = new Set(["p"]);
const tableSectionTags = new Set(["thead", "tbody"]);
const ddtTags = new Set(["dd", "dt"]);
const rtpTags = new Set(["rt", "rp"]);
const openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags],
]);
const voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
const foreignContextElements = new Set(["math", "svg"]);
const htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title",
]);
const reNameEnd = /\s|\//;
class Parser_Parser {
    constructor(cbs, options = {}) {
        var _a, _b, _c, _d, _e;
        this.options = options;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = 0;
        /**
         * Store the start index of the current open tag,
         * so we can update the start index for attributes.
         */
        this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        /** The index of the last written buffer. Used when resuming after a `pause()`. */
        this.writeIndex = 0;
        /** Indicates whether the parser has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    // Tokenizer event handlers
    /** @internal */
    ontext(start, endIndex) {
        var _a, _b;
        const data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
    }
    /** @internal */
    ontextentity(cp) {
        var _a, _b;
        /*
         * Entities can be emitted on the character, or directly after.
         * We use the section start here to get accurate indices.
         */
        const index = this.tokenizer.getSectionStart();
        this.endIndex = index - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));
        this.startIndex = index;
    }
    isVoidElement(name) {
        return !this.options.xmlMode && voidElements.has(name);
    }
    /** @internal */
    onopentagname(start, endIndex) {
        this.endIndex = endIndex;
        let name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.emitOpenTag(name);
    }
    emitOpenTag(name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
            while (this.stack.length > 0 &&
                impliesClose.has(this.stack[this.stack.length - 1])) {
                const element = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
            }
        }
        if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    }
    endOpenTag(isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
    }
    /** @internal */
    onopentagend(endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    onclosetag(start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        let name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
            const pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    let count = this.stack.length - pos;
                    while (count--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop(), count !== 0);
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (!this.options.xmlMode && name === "p") {
                // Implicit open before close
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
            }
        }
        else if (!this.options.xmlMode && name === "br") {
            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    onselfclosingtag(endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        else {
            // Ignore the fact that the tag is self-closing.
            this.onopentagend(endIndex);
        }
    }
    closeCurrentTag(isOpenImplied) {
        var _a, _b;
        const name = this.tagname;
        this.endOpenTag(isOpenImplied);
        // Self-closing tags will be on the top of the stack
        if (this.stack[this.stack.length - 1] === name) {
            // If the opening tag isn't implied, the closing tag has to be implied.
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
        }
    }
    /** @internal */
    onattribname(start, endIndex) {
        this.startIndex = start;
        const name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames
            ? name.toLowerCase()
            : name;
    }
    /** @internal */
    onattribdata(start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
    }
    /** @internal */
    onattribentity(cp) {
        this.attribvalue += fromCodePoint(cp);
    }
    /** @internal */
    onattribend(quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double
            ? '"'
            : quote === QuoteType.Single
                ? "'"
                : quote === QuoteType.NoValue
                    ? undefined
                    : null);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
    }
    getInstructionName(value) {
        const index = value.search(reNameEnd);
        let name = index < 0 ? value : value.substr(0, index);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    }
    /** @internal */
    ondeclaration(start, endIndex) {
        this.endIndex = endIndex;
        const value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            const name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    onprocessinginstruction(start, endIndex) {
        this.endIndex = endIndex;
        const value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            const name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    oncomment(start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    oncdata(start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        const value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    }
    /** @internal */
    onend() {
        var _a, _b;
        if (this.cbs.onclosetag) {
            // Set the end index for all remaining tags
            this.endIndex = this.startIndex;
            for (let index = this.stack.length; index > 0; this.cbs.onclosetag(this.stack[--index], true))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    reset() {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
    }
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    parseComplete(data) {
        this.reset();
        this.end(data);
    }
    getSlice(start, end) {
        while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
        }
        let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return slice;
    }
    shiftBuffer() {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
    }
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    write(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
        }
    }
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    end(chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
        }
        if (chunk)
            this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
    }
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    pause() {
        this.tokenizer.pause();
    }
    /**
     * Resumes parsing after `pause` was called.
     */
    resume() {
        this.tokenizer.resume();
        while (this.tokenizer.running &&
            this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended)
            this.tokenizer.end();
    }
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    parseChunk(chunk) {
        this.write(chunk);
    }
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    done(chunk) {
        this.end(chunk);
    }
}
//# sourceMappingURL=Parser.js.map
;// ../../node_modules/entities/lib/esm/generated/encode-html.js
// Generated using scripts/write-encode-map.ts
function restoreDiff(arr) {
    for (let i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
}
// prettier-ignore
/* harmony default export */ const encode_html = (new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])));
//# sourceMappingURL=encode-html.js.map
;// ../../node_modules/entities/lib/esm/escape.js
const escape_xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"],
]);
// For compatibility with node < 4, we wrap `codePointAt`
const escape_getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? (str, index) => str.codePointAt(index)
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800
            ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                c.charCodeAt(index + 1) -
                0xdc00 +
                0x10000
            : c.charCodeAt(index);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function escape_encodeXML(str) {
    let ret = "";
    let lastIdx = 0;
    let match;
    while ((match = escape_xmlReplacer.exec(str)) !== null) {
        const i = match.index;
        const char = str.charCodeAt(i);
        const next = xmlCodeMap.get(char);
        if (next !== undefined) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
        }
        else {
            ret += `${str.substring(lastIdx, i)}&#x${escape_getCodePoint(str, i).toString(16)};`;
            // Increase by 1 if we have a surrogate pair
            lastIdx = escape_xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
        }
    }
    return ret + str.substr(lastIdx);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
const escape_escape = (/* unused pure expression or super */ null && (escape_encodeXML));
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */
function getEscaper(regex, map) {
    return function escape(data) {
        let match;
        let lastIdx = 0;
        let result = "";
        while ((match = regex.exec(data))) {
            if (lastIdx !== match.index) {
                result += data.substring(lastIdx, match.index);
            }
            // We know that this character will be in the map.
            result += map.get(match[0].charCodeAt(0));
            // Every match will be of length 1
            lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
    };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
const escape_escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escape_escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"],
]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
const escape_escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"],
]));
//# sourceMappingURL=escape.js.map
;// ../../node_modules/entities/lib/esm/encode.js


const htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encode_encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
}
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encode_encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(xmlReplacer, data);
}
function encodeHTMLTrieRe(regExp, str) {
    let ret = "";
    let lastIdx = 0;
    let match;
    while ((match = regExp.exec(str)) !== null) {
        const i = match.index;
        ret += str.substring(lastIdx, i);
        const char = str.charCodeAt(i);
        let next = htmlTrie.get(char);
        if (typeof next === "object") {
            // We are in a branch. Try to match the next char.
            if (i + 1 < str.length) {
                const nextChar = str.charCodeAt(i + 1);
                const value = typeof next.n === "number"
                    ? next.n === nextChar
                        ? next.o
                        : undefined
                    : next.n.get(nextChar);
                if (value !== undefined) {
                    ret += value;
                    lastIdx = regExp.lastIndex += 1;
                    continue;
                }
            }
            next = next.v;
        }
        // We might have a tree node without a value; skip and use a numeric entity.
        if (next !== undefined) {
            ret += next;
            lastIdx = i + 1;
        }
        else {
            const cp = getCodePoint(str, i);
            ret += `&#x${cp.toString(16)};`;
            // Increase by 1 if we have a surrogate pair
            lastIdx = regExp.lastIndex += Number(cp !== char);
        }
    }
    return ret + str.substr(lastIdx);
}
//# sourceMappingURL=encode.js.map
;// ../../node_modules/entities/lib/esm/index.js



/** The level of entities to support. */
var EntityLevel;
(function (EntityLevel) {
    /** Support only XML entities. */
    EntityLevel[EntityLevel["XML"] = 0] = "XML";
    /** Support HTML entities, which are a superset of XML entities. */
    EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function (EncodingMode) {
    /**
     * The output is UTF-8 encoded. Only characters that need escaping within
     * XML will be escaped.
     */
    EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
    /**
     * The output consists only of ASCII characters. Characters that need
     * escaping within HTML, and characters that aren't ASCII characters will
     * be escaped.
     */
    EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
    /**
     * Encode all characters that have an equivalent entity, as well as all
     * characters that are not ASCII characters.
     */
    EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
    /**
     * Encode all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
    /**
     * Encode all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */
function decode(data, options = EntityLevel.XML) {
    const level = typeof options === "number" ? options : options.level;
    if (level === EntityLevel.HTML) {
        const mode = typeof options === "object" ? options.mode : undefined;
        return decodeHTML(data, mode);
    }
    return decodeXML(data);
}
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */
function decodeStrict(data, options = EntityLevel.XML) {
    var _a;
    const opts = typeof options === "number" ? { level: options } : options;
    (_a = opts.mode) !== null && _a !== void 0 ? _a : (opts.mode = DecodingMode.Strict);
    return decode(data, opts);
}
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */
function encode(data, options = EntityLevel.XML) {
    const opts = typeof options === "number" ? { level: options } : options;
    // Mode `UTF8` just escapes XML entities
    if (opts.mode === EncodingMode.UTF8)
        return escapeUTF8(data);
    if (opts.mode === EncodingMode.Attribute)
        return escapeAttribute(data);
    if (opts.mode === EncodingMode.Text)
        return escapeText(data);
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
            return encodeNonAsciiHTML(data);
        }
        return encodeHTML(data);
    }
    // ASCII and Extensive are equivalent
    return encodeXML(data);
}



//# sourceMappingURL=index.js.map
;// ../../node_modules/dom-serializer/lib/esm/foreignNames.js
const elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
].map((val) => [val.toLowerCase(), val]));
const attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
].map((val) => [val.toLowerCase(), val]));

;// ../../node_modules/dom-serializer/lib/esm/index.js
/*
 * Module dependencies
 */


/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */

const unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    var _a;
    if (!attributes)
        return;
    const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
        ? replaceQuotes
        : opts.xmlMode || opts.encodeEntities !== "utf8"
            ? escape_encodeXML
            : escape_escapeAttribute;
    return Object.keys(attributes)
        .map((key) => {
        var _a, _b;
        const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return `${key}="${encode(value)}"`;
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
const singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options = {}) {
    const nodes = "length" in node ? node : [node];
    let output = "";
    for (let i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
/* harmony default export */ const lib_esm = ((/* unused pure expression or super */ null && (render)));
function renderNode(node, options) {
    switch (node.type) {
        case Root:
            return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case Doctype:
        case Directive:
            return renderDirective(node);
        case Comment:
            return renderComment(node);
        case CDATA:
            return renderCdata(node);
        case Script:
        case Style:
        case Tag:
            return renderTag(node, options);
        case Text:
            return renderText(node, options);
    }
}
const foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
const foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = { ...opts, xmlMode: false };
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = { ...opts, xmlMode: "foreign" };
    }
    let tag = `<${elem.name}`;
    const attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += ` ${attribs}`;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += `</${elem.name}>`;
        }
    }
    return tag;
}
function renderDirective(elem) {
    return `<${elem.data}>`;
}
function renderText(elem, opts) {
    var _a;
    let data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data =
            opts.xmlMode || opts.encodeEntities !== "utf8"
                ? escape_encodeXML(data)
                : escape_escapeText(data);
    }
    return data;
}
function renderCdata(elem) {
    return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
    return `<!--${elem.data}-->`;
}

;// ../../node_modules/domutils/lib/esm/stringify.js



/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return renderHTML(node, options);
}
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return hasChildren(node)
        ? node.children.map((node) => getOuterHTML(node, options)).join("")
        : "";
}
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if (isTag(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if (isCDATA(node))
        return getText(node.children);
    if (isText(node))
        return node.data;
    return "";
}
/**
 * Get a node's text content. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function stringify_textContent(node) {
    if (Array.isArray(node))
        return node.map(stringify_textContent).join("");
    if (hasChildren(node) && !isComment(node)) {
        return stringify_textContent(node.children);
    }
    if (isText(node))
        return node.data;
    return "";
}
/**
 * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
        return innerText(node.children);
    }
    if (isText(node))
        return node.data;
    return "";
}
//# sourceMappingURL=stringify.js.map
;// ../../node_modules/domutils/lib/esm/traversal.js

/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    return hasChildren(elem) ? elem.children : [];
}
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node, or `null` if `elem` is a root node.
 */
function getParent(elem) {
    return elem.parent || null;
}
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings, including `elem`.
 */
function getSiblings(elem) {
    const parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    const siblings = [elem];
    let { prev, next } = elem;
    while (prev != null) {
        siblings.unshift(prev);
        ({ prev } = prev);
    }
    while (next != null) {
        siblings.push(next);
        ({ next } = next);
    }
    return siblings;
}
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag, or `null` if there is no next
 * sibling.
 */
function nextElementSibling(elem) {
    let { next } = elem;
    while (next !== null && !isTag(next))
        ({ next } = next);
    return next;
}
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag, or `null` if there is no
 * previous sibling.
 */
function prevElementSibling(elem) {
    let { prev } = elem;
    while (prev !== null && !isTag(prev))
        ({ prev } = prev);
    return prev;
}
//# sourceMappingURL=traversal.js.map
;// ../../node_modules/domutils/lib/esm/querying.js

/**
 * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function querying_filter(test, node, recurse = true, limit = Infinity) {
    return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
/**
 * Search an array of nodes and their children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    const result = [];
    /** Stack of the arrays we are looking at. */
    const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
    /** Stack of the indices within the arrays. */
    const indexStack = [0];
    for (;;) {
        // First, check if the current array has any more elements to look at.
        if (indexStack[0] >= nodeStack[0].length) {
            // If we have no more arrays to look at, we are done.
            if (indexStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            // Loop back to the start to continue with the next array.
            continue;
        }
        const elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                return result;
        }
        if (recurse && hasChildren(elem) && elem.children.length > 0) {
            /*
             * Add the children to the stack. We are depth-first, so this is
             * the next array we look at.
             */
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
/**
 * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Node or array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first node that passes `test`.
 */
function querying_findOne(test, nodes, recurse = true) {
    const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
    for (let i = 0; i < searchedNodes.length; i++) {
        const node = searchedNodes[i];
        if (isTag(node) && test(node)) {
            return node;
        }
        if (recurse && hasChildren(node) && node.children.length > 0) {
            const found = querying_findOne(test, node.children, true);
            if (found)
                return found;
        }
    }
    return null;
}
/**
 * Checks if a tree of nodes contains at least one node passing a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne(test, nodes) {
    return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => (isTag(node) && test(node)) ||
        (hasChildren(node) && existsOne(test, node.children)));
}
/**
 * Search an array of nodes and their children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    const result = [];
    const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
    const indexStack = [0];
    for (;;) {
        if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
                return result;
            }
            // Otherwise, remove the current array from the stack.
            nodeStack.shift();
            indexStack.shift();
            // Loop back to the start to continue with the next array.
            continue;
        }
        const elem = nodeStack[0][indexStack[0]++];
        if (isTag(elem) && test(elem))
            result.push(elem);
        if (hasChildren(elem) && elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
        }
    }
}
//# sourceMappingURL=querying.js.map
;// ../../node_modules/domutils/lib/esm/legacy.js


/**
 * A map of functions to check nodes against.
 */
const Checks = {
    tag_name(name) {
        if (typeof name === "function") {
            return (elem) => node_isTag(elem) && name(elem.name);
        }
        else if (name === "*") {
            return node_isTag;
        }
        return (elem) => node_isTag(elem) && elem.name === name;
    },
    tag_type(type) {
        if (typeof type === "function") {
            return (elem) => type(elem.type);
        }
        return (elem) => elem.type === type;
    },
    tag_contains(data) {
        if (typeof data === "function") {
            return (elem) => node_isText(elem) && data(elem.data);
        }
        return (elem) => node_isText(elem) && elem.data === data;
    },
};
/**
 * Returns a function to check whether a node has an attribute with a particular
 * value.
 *
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return (elem) => isTag(elem) && value(elem.attribs[attrib]);
    }
    return (elem) => isTag(elem) && elem.attribs[attrib] === value;
}
/**
 * Returns a function that returns `true` if either of the input functions
 * returns `true` for a node.
 *
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return (elem) => a(elem) || b(elem);
}
/**
 * Returns a function that executes all checks in `options` and returns `true`
 * if any of them match a node.
 *
 * @param options An object describing nodes to look for.
 * @returns A function that executes all checks in `options` and returns `true`
 *   if any of them match a node.
 */
function compileTest(options) {
    const funcs = Object.keys(options).map((key) => {
        const value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * Checks whether a node matches the description in `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    const test = compileTest(options);
    return test ? test(node) : true;
}
/**
 * Returns all nodes that match `options`.
 *
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit = Infinity) {
    const test = compileTest(options);
    return test ? filter(test, nodes, recurse, limit) : [];
}
/**
 * Returns the node with the supplied ID.
 *
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse = true) {
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return findOne(getAttribCheck("id", id), nodes, recurse);
}
/**
 * Returns all nodes with the supplied `tagName`.
 *
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function legacy_getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
    return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
/**
 * Returns all nodes with the supplied `className`.
 *
 * @category Legacy Query Functions
 * @param className Class name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `className`.
 */
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
    return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
/**
 * Returns all nodes with the supplied `type`.
 *
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
    return filter(Checks["tag_type"](type), nodes, recurse, limit);
}
//# sourceMappingURL=legacy.js.map
;// ../../node_modules/domutils/lib/esm/helpers.js

/**
 * Given an array of nodes, remove any member that is contained by another
 * member.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't contained by other nodes.
 */
function removeSubsets(nodes) {
    let idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        const node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */
var DocumentPosition;
(function (DocumentPosition) {
    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document,
 * returning a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    const aParents = [];
    const bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = hasChildren(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    const maxIdx = Math.min(aParents.length, bParents.length);
    let idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
    }
    const sharedParent = aParents[idx - 1];
    const siblings = sharedParent.children;
    const aSibling = aParents[idx];
    const bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
}
/**
 * Sort an array of nodes based on their relative position in the document,
 * removing any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
    nodes.sort((a, b) => {
        const relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
            return -1;
        }
        else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
//# sourceMappingURL=helpers.js.map
;// ../../node_modules/domutils/lib/esm/feeds.js


/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function feeds_getFeed(doc) {
    const feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    const childs = feedRoot.children;
    const feed = {
        type: "atom",
        items: getElementsByTagName("entry", childs).map((item) => {
            var _a;
            const { children } = item;
            const entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            const href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
            if (href) {
                entry.link = href;
            }
            const description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            const pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    const updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    const feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: getElementsByTagName("item", feedRoot.children).map((item) => {
            const { children } = item;
            const entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            const pubDate = fetch("pubDate", children) || fetch("dc:date", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    const updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
const MEDIA_KEYS_STRING = (/* unused pure expression or super */ null && (["url", "type", "lang"]));
const MEDIA_KEYS_INT = (/* unused pure expression or super */ null && ([
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
]));
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return getElementsByTagName("media:content", where).map((elem) => {
        const { attribs } = elem;
        const media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"],
        };
        for (const attrib of MEDIA_KEYS_STRING) {
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (const attrib of MEDIA_KEYS_INT) {
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs["expression"]) {
            media.expression = attribs["expression"];
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return getElementsByTagName(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse = false) {
    return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse = false) {
    const val = fetch(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
//# sourceMappingURL=feeds.js.map
;// ../../node_modules/domutils/lib/esm/index.js







/** @deprecated Use these methods from `domhandler` directly. */

//# sourceMappingURL=index.js.map
;// ../../node_modules/html-to-text/node_modules/htmlparser2/lib/esm/index.js




// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    const handler = new esm_DomHandler(undefined, options);
    new Parser_Parser(handler, options).end(data);
    return handler.root;
}
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param callback A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(callback, options, elementCallback) {
    const handler = new DomHandler(callback, options, elementCallback);
    return new Parser(handler, options);
}

/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */



const parseFeedDefaultOptions = { xmlMode: true };
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options = parseFeedDefaultOptions) {
    return getFeed(parseDOM(feed, options));
}

//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ../../node_modules/deepmerge/dist/cjs.js
var cjs = __webpack_require__(238505);
;// ../../node_modules/html-to-text/lib/html-to-text.mjs






/**
 * Make a recursive function that will only run to a given depth
 * and switches to an alternative function at that depth. \
 * No limitation if `n` is `undefined` (Just wraps `f` in that case).
 *
 * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.
 * @param   { Function }           f   Function that accepts recursive callback as the first argument.
 * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.
 * @returns { Function }
 */
function limitedDepthRecursive (n, f, g = () => undefined) {
  if (n === undefined) {
    const f1 = function (...args) { return f(f1, ...args); };
    return f1;
  }
  if (n >= 0) {
    return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };
  }
  return g;
}

/**
 * Return the same string or a substring with
 * the given character occurrences removed from each side.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */
function trimCharacter (str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) { ++start; }
  while (end > start && str[end - 1] === char) { --end; }
  return (start > 0 || end < str.length)
    ? str.substring(start, end)
    : str;
}

/**
 * Return the same string or a substring with
 * the given character occurrences removed from the end only.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */
function trimCharacterEnd (str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) { --end; }
  return (end < str.length)
    ? str.substring(0, end)
    : str;
}

/**
 * Return a new string will all characters replaced with unicode escape sequences.
 * This extreme kind of escaping can used to be safely compose regular expressions.
 *
 * @param { string } str A string to escape.
 * @returns { string } A string of unicode escape sequences.
 */
function unicodeEscape (str) {
  return str.replace(/[\s\S]/g, c => '\\u' + c.charCodeAt().toString(16).padStart(4, '0'));
}

/**
 * Deduplicate an array by a given key callback.
 * Item properties are merged recursively and with the preference for last defined values.
 * Of items with the same key, merged item takes the place of the last item,
 * others are omitted.
 *
 * @param { any[] } items An array to deduplicate.
 * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.
 * @returns { any[] }
 */
function mergeDuplicatesPreferLast (items, getKey) {
  const map = new Map();
  for (let i = items.length; i-- > 0;) {
    const item = items[i];
    const key = getKey(item);
    map.set(
      key,
      (map.has(key))
        ? cjs(item, map.get(key), { arrayMerge: overwriteMerge$1 })
        : item
    );
  }
  return [...map.values()].reverse();
}

const overwriteMerge$1 = (acc, src, options) => [...src];

/**
 * Get a nested property from an object.
 *
 * @param   { object }   obj  The object to query for the value.
 * @param   { string[] } path The path to the property.
 * @returns { any }
 */
function get (obj, path) {
  for (const key of path) {
    if (!obj) { return undefined; }
    obj = obj[key];
  }
  return obj;
}

/**
 * Convert a number into alphabetic sequence representation (Sequence without zeroes).
 *
 * For example: `a, ..., z, aa, ..., zz, aaa, ...`.
 *
 * @param   { number } num              Number to convert. Must be >= 1.
 * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.
 * @param   { number } [base = 26]      Number of characters in the sequence.
 * @returns { string }
 */
function numberToLetterSequence (num, baseChar = 'a', base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = (num / base) >> 0; // quick `floor`
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits
    .reverse()
    .map(n => String.fromCharCode(baseCode + n))
    .join('');
}

const I = ['I', 'X', 'C', 'M'];
const V = ['V', 'L', 'D'];

/**
 * Convert a number to it's Roman representation. No large numbers extension.
 *
 * @param   { number } num Number to convert. `0 < num <= 3999`.
 * @returns { string }
 */
function numberToRoman (num) {
  return [...(num) + '']
    .map(n => +n)
    .reverse()
    .map((v, i) => ((v % 5 < 4)
      ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)
      : I[i] + (v < 5 ? V[i] : I[i + 1])))
    .reverse()
    .join('');
}

/**
 * Helps to build text from words.
 */
class InlineTextBuilder {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor (options, maxLineLength = undefined) {
    /** @type { string[][] } */
    this.lines = [];
    /** @type { string[] }   */
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];
    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;

    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }

  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord (word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget

      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;

    } else { // Does not fit - try to split the word

      // The word is moved to a new line - prefer to wrap between words.
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) { this.startNewLine(); }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }

    }
  }

  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord () {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }

  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord (word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);
    }
  }

  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine (n = 1) {
    this.lines.push(this.nextLineWords);
    if (n > 1) {
      this.lines.push(...Array.from({ length: n - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }

  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty () {
    return this.lines.length === 0
        && this.nextLineWords.length === 0;
  }

  clear () {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }

  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString () {
    return [...this.lines, this.nextLineWords]
      .map(words => words.join(' '))
      .join('\n');
  }

  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord (word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {

      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);

      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);

      if (splitIndex > -1) { // Found a character to split on

        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));

      } else { // Not found a character to split on

        idx++;
        if (idx < this.wrapCharacters.length) { // There is next character to try

          word = firstLine + remainingChars;

        } else { // No more characters to try

          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;

        }

      }

    }
    parts.push(word); // Add remaining part to array
    return parts;
  }
}

/* eslint-disable max-classes-per-file */


class StackItem {
  constructor (next = null) { this.next = next; }

  getRoot () { return (this.next) ? this.next : this; }
}

class BlockStackItem extends StackItem {
  constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = '';
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor (
    options,
    next = null,
    {
      interRowLineBreaks = 1,
      leadingLineBreaks = 2,
      maxLineLength = undefined,
      maxPrefixLength = 0,
      prefixAlign = 'left',
    } = {}
  ) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor (
    options,
    next = null,
    {
      leadingLineBreaks = 1,
      maxLineLength = undefined,
      prefix = '',
    } = {}
  ) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor (next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor (next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor (options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = '';
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor (next = null, transform) {
    super(next);
    this.transform = transform;
  }
}

function charactersToCodes (str) {
  return [...str]
    .map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))
    .join('');
}

/**
 * Helps to handle HTML whitespaces.
 *
 * @class WhitespaceProcessor
 */
class WhitespaceProcessor {

  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor (options) {
    this.whitespaceChars = (options.preserveNewlines)
      ? options.whitespaceCharacters.replace(/\n/g, '')
      : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, 'g');
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, 'g');

    if (options.preserveNewlines) {

      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');

      /**
       * Shrink whitespaces and wrap text, add to the builder.
       *
       * @param { string }                  text              Input text.
       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.
       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.
       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.
       */
      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
        if (!text) { return; }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === '\n') {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === '\n') {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));
        // No need to stash a space in case last added item was a new line,
        // but that won't affect anything later anyway.
      };

    } else {

      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');

      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
        if (!text) { return; }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);
      };

    }
  }

  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral (text, inlineTextBuilder, noWrap = true) {
    if (!text) { return; }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === '\n') {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === '\n') {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);
  }

  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace (text) {
    return this.leadingWhitespaceRe.test(text);
  }

  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace (text) {
    return this.trailingWhitespaceRe.test(text);
  }

  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords (text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }

  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords (text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === '\n') {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }

}

/**
 * Helps to build text from inline and block elements.
 *
 * @class BlockTextBuilder
 */
class BlockTextBuilder {

  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor (options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    /** @type { StackItem } */
    this._stackItem = new BlockStackItem(options);
    /** @type { TransformerStackItem } */
    this._wordTransformer = undefined;
  }

  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform (wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }

  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform () {
    if (!this._wordTransformer) { return undefined; }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }

  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap () {
    this._stackItem.isNoWrap = true;
  }

  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap () {
    this._stackItem.isNoWrap = false;
  }

  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer () {
    const wt = (this._wordTransformer)
      ? ((str) => applyTransformer(str, this._wordTransformer))
      : undefined;
    const ce = this.options.encodeCharacters;
    return (wt)
      ? ((ce) ? (str) => ce(wt(str)) : wt)
      : ce;
  }

  _popStackItem () {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }

  /**
   * Add a line break into currently built block.
   */
  addLineBreak () {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += '\n';
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }

  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity () {
    if (
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    ) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }

  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline (str, { noWordTransform = false } = {}) {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }

    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }

    if (
      str.length === 0 || // empty string
      (
        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
        !this.whitespaceProcessor.testContainsWords(str) // no words to add
      )
    ) { return; }

    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        // keep stashedLineBreaks unchanged
        return;
      }
    }

    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      (noWordTransform) ? undefined : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks
  }

  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral (str) {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }

    if (str.length === 0) { return; }

    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }

    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }

  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) { this._stackItem.isPre = true; }
  }

  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = (blockTransform) ? blockTransform(html_to_text_getText(block)) : html_to_text_getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }

  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks: interRowLineBreaks,
      leadingLineBreaks: leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength: maxPrefixLength,
      prefixAlign: prefixAlign
    });
  }

  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem ({ prefix = '' } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error('Can\'t add a list item to something that is not a list! Check the formatter.');
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix: prefix,
      maxLineLength: maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }

  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem () {
    const listItem = this._popStackItem();
    const list = listItem.next;

    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = '\n' + ' '.repeat(prefixLength);
    const prefix = (list.prefixAlign === 'right')
      ? listItem.prefix.padStart(prefixLength)
      : listItem.prefix.padEnd(prefixLength);
    const text = prefix + html_to_text_getText(listItem).replace(/\n/g, spacing);

    addText(
      list,
      text,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }

  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList ({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = html_to_text_getText(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }

  /**
   * Start building a table.
   */
  openTable () {
    this._stackItem = new TableStackItem(this._stackItem);
  }

  /**
   * Start building a table row.
   */
  openTableRow () {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error('Can\'t add a table row to something that is not a table! Check the formatter.');
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }

  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell ({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error('Can\'t add a table cell to something that is not a table row! Check the formatter.');
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }

  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(html_to_text_getText(cell), '\n');
    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });
  }

  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow () {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }

  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }

  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString () {
    return html_to_text_getText(this._stackItem.getRoot());
    // There should only be the root item if everything is closed properly.
  }

}

function html_to_text_getText (stackItem) {
  if (!(
    stackItem instanceof BlockStackItem
    || stackItem instanceof ListItemStackItem
    || stackItem instanceof TableCellStackItem
  )) {
    throw new Error('Only blocks, list items and table cells can be requested for text contents.');
  }
  return (stackItem.inlineTextBuilder.isEmpty())
    ? stackItem.rawText
    : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}

function addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(
    stackItem instanceof BlockStackItem
    || stackItem instanceof ListItemStackItem
    || stackItem instanceof TableCellStackItem
  )) {
    throw new Error('Only blocks, list items and table cells can contain text.');
  }
  const parentText = html_to_text_getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + '\n'.repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}

/**
 * @param { string } str A string to transform.
 * @param { TransformerStackItem } transformer A transformer item (with possible continuation).
 * @returns { string }
 */
function applyTransformer (str, transformer) {
  return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);
}

/**
 * Compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */
function compile$1 (options = {}) {
  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      'Following selectors have no specified format: ' +
      selectorsWithoutFormat.map(s => `\`${s.selector}\``).join(', ')
    );
  }
  const picker = new DecisionTree(
    options.selectors.map(s => [s.selector, s])
  ).build(hp2Builder);

  if (typeof options.encodeCharacters !== 'function') {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }

  const baseSelectorsPicker = new DecisionTree(
    options.baseElements.selectors.map((s, i) => [s, i + 1])
  ).build(hp2Builder);
  function findBaseElements (dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }

  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk,
    function (dom, builder) {
      builder.addInline(options.limits.ellipsis || '');
    }
  );

  return function (html, metadata = undefined) {
    return process(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}


/**
 * Convert given HTML according to preprocessed options.
 *
 * @param { string } html HTML content to convert.
 * @param { any } metadata Optional metadata for HTML document, for use in formatters.
 * @param { Options } options HtmlToText options (preprocessed).
 * @param { import('selderee').Picker<DomNode, TagDefinition> } picker
 * Tag definition picker for DOM nodes processing.
 * @param { (dom: DomNode[]) => DomNode[] } findBaseElements
 * Function to extract elements from HTML DOM
 * that will only be present in the output text.
 * @param { RecursiveCallback } walk Recursive callback.
 * @returns { string }
 */
function process (html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(
      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html = html.substring(0, maxInputLength);
  }

  const document = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}


function findBases (dom, options, baseSelectorsPicker) {
  const results = [];

  function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    for (const elem of dom) {
      if (elem.type !== 'tag') {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }

  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk
  );
  limitedWalk(dom);

  if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return (options.baseElements.returnDomByDefault && results.length === 0)
    ? dom
    : results.map(x => x.element);
}

/**
 * Function to walk through DOM nodes and accumulate their string representations.
 *
 * @param   { RecursiveCallback } walk    Recursive callback.
 * @param   { DomNode[] }         [dom]   Nodes array to process.
 * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.
 * @private
 */
function recursiveWalk (walk, dom, builder) {
  if (!dom) { return; }

  const options = builder.options;

  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: 'text'
    });
  }

  for (const elem of dom) {
    switch (elem.type) {
      case 'text': {
        builder.addInline(elem.data);
        break;
      }
      case 'tag': {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }

  return;
}

/**
 * @param { Object<string,string | false> } dict
 * A dictionary where keys are characters to replace
 * and values are replacement strings.
 *
 * First code point from dict keys is used.
 * Compound emojis with ZWJ are not supported (not until Node 16).
 *
 * @returns { ((str: string) => string) | undefined }
 */
function makeReplacerFromDict (dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return undefined;
  }
  /** @type { [string, string][] } */
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(
    entries
      .map(([c]) => `(${unicodeEscape([...c][0])})`)
      .join('|'),
    'g'
  );
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];
  return (str) => str.replace(regex, replacer);
}

/**
 * Dummy formatter that discards the input and does nothing.
 *
 * @type { FormatCallback }
 */
function formatSkip (elem, walk, builder, formatOptions) {
  /* do nothing */
}

/**
 * Insert the given string literal inline instead of a tag.
 *
 * @type { FormatCallback }
 */
function formatInlineString (elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || '');
}

/**
 * Insert a block with the given string literal instead of a tag.
 *
 * @type { FormatCallback }
 */
function formatBlockString (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || '');
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process an inline-level element.
 *
 * @type { FormatCallback }
 */
function formatInline (elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}

/**
 * Process a block-level container.
 *
 * @type { FormatCallback }
 */
function formatBlock$1 (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

function renderOpenTag (elem) {
  const attrs = (elem.attribs && elem.attribs.length)
    ? ' ' + Object.entries(elem.attribs)
      .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/"/g, '&quot;')}`))
      .join(' ')
    : '';
  return `<${elem.name}${attrs}>`;
}

function renderCloseTag (elem) {
  return `</${elem.name}>`;
}

/**
 * Render an element as inline HTML tag, walk through it's children.
 *
 * @type { FormatCallback }
 */
function formatInlineTag (elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}

/**
 * Render an element as HTML block bag, walk through it's children.
 *
 * @type { FormatCallback }
 */
function formatBlockTag (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Render an element with all it's children as inline HTML.
 *
 * @type { FormatCallback }
 */
function formatInlineHtml (elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}

/**
 * Render an element with all it's children as HTML block.
 *
 * @type { FormatCallback }
 */
function formatBlockHtml (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Render inline element wrapped with given strings.
 *
 * @type { FormatCallback }
 */
function formatInlineSurround (elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || '');
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || '');
}

var genericFormatters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});

function getRow (matrix, j) {
  if (!matrix[j]) { matrix[j] = []; }
  return matrix[j];
}

function findFirstVacantIndex (row, x = 0) {
  while (row[x]) { x++; }
  return x;
}

function transposeInPlace (matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0; j < i; j++) {
      const rowJ = getRow(matrix, j);
      if (rowI[j] || rowJ[i]) {
        const temp = rowI[j];
        rowI[j] = rowJ[i];
        rowJ[i] = temp;
      }
    }
  }
}

function putCellIntoLayout (cell, layout, baseRow, baseCol) {
  for (let r = 0; r < cell.rowspan; r++) {
    const layoutRow = getRow(layout, baseRow + r);
    for (let c = 0; c < cell.colspan; c++) {
      layoutRow[baseCol + c] = cell;
    }
  }
}

function getOrInitOffset (offsets, index) {
  if (offsets[index] === undefined) {
    offsets[index] = (index === 0) ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}

function updateOffset (offsets, base, span, value) {
  offsets[base + span] = Math.max(
    getOrInitOffset(offsets, base + span),
    getOrInitOffset(offsets, base) + value
  );
}

/**
 * Render a table into a string.
 * Cells can contain multiline text and span across multiple rows and columns.
 *
 * Modifies cells to add lines array.
 *
 * @param { TablePrinterCell[][] } tableRows Table to render.
 * @param { number } rowSpacing Number of spaces between columns.
 * @param { number } colSpacing Number of empty lines between rows.
 * @returns { string }
 */
function tableToString (tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  // Fill the layout table and row offsets row-by-row.
  for (let j = 0; j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split('\n');
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;
  }

  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);

  const outputLines = [];
  const colOffsets = [0];
  // Fill column offsets and output lines column-by-column.
  for (let x = 0; x < colNumber; x++) {
    let y = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x].length);
    while (y < rowsInThisColumn) {
      cell = layout[x][y];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j = 0; j < cell.lines.length; j++) {
            const line = cell.lines[j];
            const lineOffset = rowOffsets[y] + j;
            outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;
            cellWidth = (line.length > cellWidth) ? line.length : cellWidth;
          }
          updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y];
        outputLines[lineOffset] = (outputLines[lineOffset] || '');
        y++;
      }
    }
  }

  return outputLines.join('\n');
}

/**
 * Process a line-break.
 *
 * @type { FormatCallback }
 */
function formatLineBreak (elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}

/**
 * Process a `wbr` tag (word break opportunity).
 *
 * @type { FormatCallback }
 */
function formatWbr (elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}

/**
 * Process a horizontal line.
 *
 * @type { FormatCallback }
 */
function formatHorizontalLine (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a paragraph.
 *
 * @type { FormatCallback }
 */
function formatParagraph (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a preformatted content.
 *
 * @type { FormatCallback }
 */
function formatPre (elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a heading.
 *
 * @type { FormatCallback }
 */
function formatHeading (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform(str => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a blockquote.
 *
 * @type { FormatCallback }
 */
function formatBlockquote (elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\n') : str)
      .split('\n')
      .map(line => '> ' + line)
      .join('\n')
  });
}

function withBrackets (str, brackets) {
  if (!brackets) { return str; }

  const lbr = (typeof brackets[0] === 'string')
    ? brackets[0]
    : '[';
  const rbr = (typeof brackets[1] === 'string')
    ? brackets[1]
    : ']';
  return lbr + str + rbr;
}

function pathRewrite (path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = (typeof rewriter === 'function')
    ? rewriter(path, metadata, elem)
    : path;
  return (modifiedPath[0] === '/' && baseUrl)
    ? trimCharacterEnd(baseUrl, '/') + modifiedPath
    : modifiedPath;
}

/**
 * Process an image.
 *
 * @type { FormatCallback }
 */
function formatImage (elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = (attribs.alt)
    ? attribs.alt
    : '';
  const src = (!attribs.src)
    ? ''
    : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = (!src)
    ? alt
    : (!alt)
      ? withBrackets(src, formatOptions.linkBrackets)
      : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);

  builder.addInline(text, { noWordTransform: true });
}

// a img baseUrl
// a img pathRewrite
// a img linkBrackets

// a     ignoreHref: false
//            ignoreText ?
// a     noAnchorUrl: true
//            can be replaced with selector
// a     hideLinkHrefIfSameAsText: false
//            how to compare, what to show (text, href, normalized) ?
// a     mailto protocol removed without options

// a     protocols: mailto, tel, ...
//            can be matched with selector?

// anchors, protocols - only if no pathRewrite fn is provided

// normalize-url ?

// a
// a[href^="#"] - format:skip by default
// a[href^="mailto:"] - ?

/**
 * Process an anchor.
 *
 * @type { FormatCallback }
 */
function formatAnchor (elem, walk, builder, formatOptions) {
  function getHref () {
    if (formatOptions.ignoreHref) { return ''; }
    if (!elem.attribs || !elem.attribs.href) { return ''; }
    let href = elem.attribs.href.replace(/^mailto:/, '');
    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }
    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = '';
    builder.pushWordTransform(
      str => {
        if (str) { text += str; }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();

    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(
        (!text)
          ? href
          : ' ' + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}

/**
 * @param { DomNode }           elem               List items with their prefixes.
 * @param { RecursiveCallback } walk               Recursive callback to process child nodes.
 * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.
 * @param { FormatOptions }     formatOptions      Options specific to a formatter.
 * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.
 */
function formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ['parent', 'name']) === 'li';

  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,
  // so the dumb length comparison is the most robust way to get the correct value.
  let maxPrefixLength = 0;
  const listItems = (elem.children || [])
    // it might be more accurate to check only for html spaces here, but no significant benefit
    .filter(child => child.type !== 'text' || !/^\s*$/.test(child.data))
    .map(function (child) {
      if (child.name !== 'li') {
        return { node: child, prefix: '' };
      }
      const prefix = (isNestedList)
        ? nextPrefixCallback().trimStart()
        : nextPrefixCallback();
      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }
      return { node: child, prefix: prefix };
    });
  if (!listItems.length) { return; }

  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),
    maxPrefixLength: maxPrefixLength,
    prefixAlign: 'left'
  });

  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix: prefix });
    walk([node], builder);
    builder.closeListItem();
  }

  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });
}

/**
 * Process an unordered list.
 *
 * @type { FormatCallback }
 */
function formatUnorderedList (elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || ' * ';
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}

/**
 * Process an ordered list.
 *
 * @type { FormatCallback }
 */
function formatOrderedList (elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || '1');
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}

/**
 * Return a function that can be used to generate index markers of a specified format.
 *
 * @param   { string } [olType='1'] Marker type.
 * @returns { (i: number) => string }
 */
function getOrderedListIndexFunction (olType = '1') {
  switch (olType) {
    case 'a': return (i) => numberToLetterSequence(i, 'a');
    case 'A': return (i) => numberToLetterSequence(i, 'A');
    case 'i': return (i) => numberToRoman(i).toLowerCase();
    case 'I': return (i) => numberToRoman(i);
    case '1':
    default: return (i) => (i).toString();
  }
}

/**
 * Given a list of class and ID selectors (prefixed with '.' and '#'),
 * return them as separate lists of names without prefixes.
 *
 * @param { string[] } selectors Class and ID selectors (`[".class", "#id"]` etc).
 * @returns { { classes: string[], ids: string[] } }
 */
function splitClassesAndIds (selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith('.')) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith('#')) {
      ids.push(selector.substring(1));
    }
  }
  return { classes: classes, ids: ids };
}

function isDataTable (attr, tables) {
  if (tables === true) { return true; }
  if (!attr) { return false; }

  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr['class'] || '').split(' ');
  const attrIds = (attr['id'] || '').split(' ');

  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));
}

/**
 * Process a table (either as a container or as a data table, depending on options).
 *
 * @type { FormatCallback }
 */
function formatTable (elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables)
    ? formatDataTable(elem, walk, builder, formatOptions)
    : formatBlock(elem, walk, builder, formatOptions);
}

function formatBlock (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}

/**
 * Process a data table.
 *
 * @type { FormatCallback }
 */
function formatDataTable (elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });

  function formatCell (cellNode) {
    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;
    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });
  }

  function walkTable (elem) {
    if (elem.type !== 'tag') { return; }

    const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)
      ? (cellNode) => {
        builder.pushWordTransform(str => str.toUpperCase());
        formatCell(cellNode);
        builder.popWordTransform();
      }
      : formatCell;

    switch (elem.name) {
      case 'thead':
      case 'tbody':
      case 'tfoot':
      case 'center':
        elem.children.forEach(walkTable);
        return;

      case 'tr': {
        builder.openTableRow();
        for (const childOfTr of elem.children) {
          if (childOfTr.type !== 'tag') { continue; }
          switch (childOfTr.name) {
            case 'th': {
              formatHeaderCell(childOfTr);
              break;
            }
            case 'td': {
              formatCell(childOfTr);
              break;
            }
              // do nothing
          }
        }
        builder.closeTableRow();
        break;
      }
        // do nothing
    }
  }
}

var textFormatters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});

/**
 * Default options.
 *
 * @constant
 * @type { Options }
 * @default
 * @private
 */
const DEFAULT_OPTIONS = {
  baseElements: {
    selectors: [ 'body' ],
    orderBy: 'selectors', // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: '...',
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: (1 << 24) // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: '*', format: 'inline' },
    {
      selector: 'a',
      format: 'anchor',
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ['[', ']'],
        noAnchorUrl: true
      }
    },
    { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'blockquote',
      format: 'blockquote',
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: 'br', format: 'lineBreak' },
    { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'hr',
      format: 'horizontalLine',
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: 'img',
      format: 'image',
      options: { baseUrl: null, linkBrackets: ['[', ']'] }
    },
    { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'ol',
      format: 'orderedList',
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'table',
      format: 'table',
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: 'ul',
      format: 'unorderedList',
      options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: 'wbr', format: 'wbr' },
  ],
  tables: [], // deprecated
  whitespaceCharacters: ' \t\r\n\f\u200b',
  wordwrap: 80
};

const concatMerge = (acc, src, options) => [...acc, ...src];
const overwriteMerge = (acc, src, options) => [...src];
const selectorsMerge = (acc, src, options) => (
  (acc.some(s => typeof s === 'object'))
    ? concatMerge(acc, src) // selectors
    : overwriteMerge(acc, src) // baseElements.selectors
);

/**
 * Preprocess options, compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options.
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */
function compile (options = {}) {
  options = cjs(
    DEFAULT_OPTIONS,
    options,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)
    }
  );
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));

  handleDeprecatedOptions(options);

  return compile$1(options);
}

/**
 * Convert given HTML content to plain text string.
 *
 * @param   { string }  html           HTML content to convert.
 * @param   { Options } [options = {}] HtmlToText options.
 * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.
 * @returns { string }                 Plain text string.
 * @static
 *
 * @example
 * const { convert } = require('html-to-text');
 * const text = convert('<h1>Hello World</h1>', {
 *   wordwrap: 130
 * });
 * console.log(text); // HELLO WORLD
 */
function convert (html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
}

/**
 * Map previously existing and now deprecated options to the new options layout.
 * This is a subject for cleanup in major releases.
 *
 * @param { Options } options HtmlToText options.
 */
function handleDeprecatedOptions (options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || '*' })
    );
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));
  }

  function set (obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }

  if (options['baseElement']) {
    const baseElement = options['baseElement'];
    set(
      options,
      ['baseElements', 'selectors'],
      (Array.isArray(baseElement) ? baseElement : [baseElement])
    );
  }
  if (options['returnDomByDefault'] !== undefined) {
    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);
  }

  for (const definition of options.selectors) {
    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {
      set(definition, ['options', 'linkBrackets'], false);
    }
  }
}



// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js
var react = __webpack_require__(922728);
;// ../../node_modules/@react-email/render/node_modules/prettier/standalone.mjs
var yu=Object.create;var He=Object.defineProperty;var Au=Object.getOwnPropertyDescriptor;var Bu=Object.getOwnPropertyNames;var wu=Object.getPrototypeOf,xu=Object.prototype.hasOwnProperty;var sr=e=>{throw TypeError(e)};var _u=(e,t)=>()=>(e&&(t=e(e=0)),t);var At=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),We=(e,t)=>{for(var r in t)He(e,r,{get:t[r],enumerable:!0})},ar=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of Bu(t))!xu.call(e,o)&&o!==r&&He(e,o,{get:()=>t[o],enumerable:!(n=Au(t,o))||n.enumerable});return e};var Me=(e,t,r)=>(r=e!=null?yu(wu(e)):{},ar(t||!e||!e.__esModule?He(r,"default",{value:e,enumerable:!0}):r,e)),vu=e=>ar(He({},"__esModule",{value:!0}),e);var bu=(e,t,r)=>t.has(e)||sr("Cannot "+r);var Dr=(e,t,r)=>t.has(e)?sr("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r);var pe=(e,t,r)=>(bu(e,t,"access private method"),r);var it=At((ia,sn)=>{"use strict";var on=new Proxy(String,{get:()=>on});sn.exports=on});var Tn={};We(Tn,{default:()=>_o,shouldHighlight:()=>xo});var xo,_o,kn=_u(()=>{xo=()=>!1,_o=String});var Pn=At((bD,Xt)=>{var g=String,Ln=function(){return{isColorSupported:!1,reset:g,bold:g,dim:g,italic:g,underline:g,inverse:g,hidden:g,strikethrough:g,black:g,red:g,green:g,yellow:g,blue:g,magenta:g,cyan:g,white:g,gray:g,bgBlack:g,bgRed:g,bgGreen:g,bgYellow:g,bgBlue:g,bgMagenta:g,bgCyan:g,bgWhite:g}};Xt.exports=Ln();Xt.exports.createColors=Ln});var $n=At(Ct=>{"use strict";Object.defineProperty(Ct,"__esModule",{value:!0});Ct.codeFrameColumns=Mn;Ct.default=To;var In=(kn(),vu(Tn)),Hn=vo(Pn(),!0);function Wn(e){if(typeof WeakMap!="function")return null;var t=new WeakMap,r=new WeakMap;return(Wn=function(n){return n?r:t})(e)}function vo(e,t){if(!t&&e&&e.__esModule)return e;if(e===null||typeof e!="object"&&typeof e!="function")return{default:e};var r=Wn(t);if(r&&r.has(e))return r.get(e);var n={__proto__:null},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(u!=="default"&&{}.hasOwnProperty.call(e,u)){var i=o?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,r&&r.set(e,n),n}var bo=Hn.default,Rn=(e,t)=>r=>e(t(r)),Zt;function Oo(e){if(e){var t;return(t=Zt)!=null||(Zt=(0,Hn.createColors)(!0)),Zt}return bo}var Yn=!1;function So(e){return{gutter:e.gray,marker:Rn(e.red,e.bold),message:Rn(e.red,e.bold)}}var jn=/\r\n|[\n\r\u2028\u2029]/;function No(e,t,r){let n=Object.assign({column:0,line:-1},e.start),o=Object.assign({},n,e.end),{linesAbove:u=2,linesBelow:i=3}=r||{},s=n.line,a=n.column,D=o.line,l=o.column,d=Math.max(s-(u+1),0),f=Math.min(t.length,D+i);s===-1&&(d=0),D===-1&&(f=t.length);let p=D-s,c={};if(p)for(let F=0;F<=p;F++){let m=F+s;if(!a)c[m]=!0;else if(F===0){let E=t[m-1].length;c[m]=[a,E-a+1]}else if(F===p)c[m]=[0,l];else{let E=t[m-F].length;c[m]=[0,E]}}else a===l?a?c[s]=[a,0]:c[s]=!0:c[s]=[a,l-a];return{start:d,end:f,markerLines:c}}function Mn(e,t,r={}){let n=(r.highlightCode||r.forceColor)&&(0,In.shouldHighlight)(r),o=Oo(r.forceColor),u=So(o),i=(F,m)=>n?F(m):m,s=e.split(jn),{start:a,end:D,markerLines:l}=No(t,s,r),d=t.start&&typeof t.start.column=="number",f=String(D).length,c=(n?(0,In.default)(e,r):e).split(jn,D).slice(a,D).map((F,m)=>{let E=a+1+m,w=` ${` ${E}`.slice(-f)} |`,h=l[E],C=!l[E+1];if(h){let k="";if(Array.isArray(h)){let v=F.slice(0,Math.max(h[0]-1,0)).replace(/[^\t]/g," "),$=h[1]||1;k=[`
 `,i(u.gutter,w.replace(/\d/g," "))," ",v,i(u.marker,"^").repeat($)].join(""),C&&r.message&&(k+=" "+i(u.message,r.message))}return[i(u.marker,">"),i(u.gutter,w),F.length>0?` ${F}`:"",k].join("")}else return` ${i(u.gutter,w)}${F.length>0?` ${F}`:""}`}).join(`
`);return r.message&&!d&&(c=`${" ".repeat(f+1)}${r.message}
${c}`),n?o.reset(c):c}function To(e,t,r,n={}){if(!Yn){Yn=!0;let u="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";{let i=new Error(u);i.name="DeprecationWarning",console.warn(new Error(u))}}return r=Math.max(r,0),Mn(e,{start:{column:r,line:t}},n)}});var ir={};We(ir,{__debug:()=>di,check:()=>fi,doc:()=>nr,format:()=>gu,formatWithCursor:()=>Cu,getSupportInfo:()=>pi,util:()=>or,version:()=>fu});var Ou=(e,t,r,n)=>{if(!(e&&t==null))return t.replaceAll?t.replaceAll(r,n):r.global?t.replace(r,n):t.split(r).join(n)},ne=Ou;function Z(){}Z.prototype={diff:function(t,r){var n,o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},u=o.callback;typeof o=="function"&&(u=o,o={}),this.options=o;var i=this;function s(h){return u?(setTimeout(function(){u(void 0,h)},0),!0):h}t=this.castInput(t),r=this.castInput(r),t=this.removeEmpty(this.tokenize(t)),r=this.removeEmpty(this.tokenize(r));var a=r.length,D=t.length,l=1,d=a+D;o.maxEditLength&&(d=Math.min(d,o.maxEditLength));var f=(n=o.timeout)!==null&&n!==void 0?n:1/0,p=Date.now()+f,c=[{oldPos:-1,lastComponent:void 0}],F=this.extractCommon(c[0],r,t,0);if(c[0].oldPos+1>=D&&F+1>=a)return s([{value:this.join(r),count:r.length}]);var m=-1/0,E=1/0;function A(){for(var h=Math.max(m,-l);h<=Math.min(E,l);h+=2){var C=void 0,k=c[h-1],v=c[h+1];k&&(c[h-1]=void 0);var $=!1;if(v){var ye=v.oldPos-h;$=v&&0<=ye&&ye<a}var yt=k&&k.oldPos+1<D;if(!$&&!yt){c[h]=void 0;continue}if(!yt||$&&k.oldPos+1<v.oldPos?C=i.addToPath(v,!0,void 0,0):C=i.addToPath(k,void 0,!0,1),F=i.extractCommon(C,r,t,h),C.oldPos+1>=D&&F+1>=a)return s(Su(i,C.lastComponent,r,t,i.useLongestToken));c[h]=C,C.oldPos+1>=D&&(E=Math.min(E,h-1)),F+1>=a&&(m=Math.max(m,h+1))}l++}if(u)(function h(){setTimeout(function(){if(l>d||Date.now()>p)return u();A()||h()},0)})();else for(;l<=d&&Date.now()<=p;){var w=A();if(w)return w}},addToPath:function(t,r,n,o){var u=t.lastComponent;return u&&u.added===r&&u.removed===n?{oldPos:t.oldPos+o,lastComponent:{count:u.count+1,added:r,removed:n,previousComponent:u.previousComponent}}:{oldPos:t.oldPos+o,lastComponent:{count:1,added:r,removed:n,previousComponent:u}}},extractCommon:function(t,r,n,o){for(var u=r.length,i=n.length,s=t.oldPos,a=s-o,D=0;a+1<u&&s+1<i&&this.equals(r[a+1],n[s+1]);)a++,s++,D++;return D&&(t.lastComponent={count:D,previousComponent:t.lastComponent}),t.oldPos=s,a},equals:function(t,r){return this.options.comparator?this.options.comparator(t,r):t===r||this.options.ignoreCase&&t.toLowerCase()===r.toLowerCase()},removeEmpty:function(t){for(var r=[],n=0;n<t.length;n++)t[n]&&r.push(t[n]);return r},castInput:function(t){return t},tokenize:function(t){return t.split("")},join:function(t){return t.join("")}};function Su(e,t,r,n,o){for(var u=[],i;t;)u.push(t),i=t.previousComponent,delete t.previousComponent,t=i;u.reverse();for(var s=0,a=u.length,D=0,l=0;s<a;s++){var d=u[s];if(d.removed){if(d.value=e.join(n.slice(l,l+d.count)),l+=d.count,s&&u[s-1].added){var p=u[s-1];u[s-1]=u[s],u[s]=p}}else{if(!d.added&&o){var f=r.slice(D,D+d.count);f=f.map(function(F,m){var E=n[l+m];return E.length>F.length?E:F}),d.value=e.join(f)}else d.value=e.join(r.slice(D,D+d.count));D+=d.count,d.added||(l+=d.count)}}var c=u[a-1];return a>1&&typeof c.value=="string"&&(c.added||c.removed)&&e.equals("",c.value)&&(u[a-2].value+=c.value,u.pop()),u}var hi=new Z;var lr=/^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,cr=/\S/,fr=new Z;fr.equals=function(e,t){return this.options.ignoreCase&&(e=e.toLowerCase(),t=t.toLowerCase()),e===t||this.options.ignoreWhitespace&&!cr.test(e)&&!cr.test(t)};fr.tokenize=function(e){for(var t=e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/),r=0;r<t.length-1;r++)!t[r+1]&&t[r+2]&&lr.test(t[r])&&lr.test(t[r+2])&&(t[r]+=t[r+2],t.splice(r+1,2),r--);return t};var pr=new Z;pr.tokenize=function(e){this.options.stripTrailingCr&&(e=e.replace(/\r\n/g,`
`));var t=[],r=e.split(/(\n|\r\n)/);r[r.length-1]||r.pop();for(var n=0;n<r.length;n++){var o=r[n];n%2&&!this.options.newlineIsToken?t[t.length-1]+=o:(this.options.ignoreWhitespace&&(o=o.trim()),t.push(o))}return t};var Nu=new Z;Nu.tokenize=function(e){return e.split(/(\S.+?[.!?])(?=\s+|$)/)};var Tu=new Z;Tu.tokenize=function(e){return e.split(/([{}:;,]|\s+)/)};function $e(e){"@babel/helpers - typeof";return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?$e=function(t){return typeof t}:$e=function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$e(e)}var ku=Object.prototype.toString,Ae=new Z;Ae.useLongestToken=!0;Ae.tokenize=pr.tokenize;Ae.castInput=function(e){var t=this.options,r=t.undefinedReplacement,n=t.stringifyReplacer,o=n===void 0?function(u,i){return typeof i>"u"?r:i}:n;return typeof e=="string"?e:JSON.stringify(Bt(e,null,null,o),o,"  ")};Ae.equals=function(e,t){return Z.prototype.equals.call(Ae,e.replace(/,([\r\n])/g,"$1"),t.replace(/,([\r\n])/g,"$1"))};function Bt(e,t,r,n,o){t=t||[],r=r||[],n&&(e=n(o,e));var u;for(u=0;u<t.length;u+=1)if(t[u]===e)return r[u];var i;if(ku.call(e)==="[object Array]"){for(t.push(e),i=new Array(e.length),r.push(i),u=0;u<e.length;u+=1)i[u]=Bt(e[u],t,r,n,o);return t.pop(),r.pop(),i}if(e&&e.toJSON&&(e=e.toJSON()),$e(e)==="object"&&e!==null){t.push(e),i={},r.push(i);var s=[],a;for(a in e)e.hasOwnProperty(a)&&s.push(a);for(s.sort(),u=0;u<s.length;u+=1)a=s[u],i[a]=Bt(e[a],t,r,n,a);t.pop(),r.pop()}else i=e;return i}var Ve=new Z;Ve.tokenize=function(e){return e.slice()};Ve.join=Ve.removeEmpty=function(e){return e};function dr(e,t,r){return Ve.diff(e,t,r)}function Fr(e){let t=e.indexOf("\r");return t>=0?e.charAt(t+1)===`
`?"crlf":"cr":"lf"}function Be(e){switch(e){case"cr":return"\r";case"crlf":return`\r
`;default:return`
`}}function wt(e,t){let r;switch(t){case`
`:r=/\n/gu;break;case"\r":r=/\r/gu;break;case`\r
`:r=/\r\n/gu;break;default:throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`)}let n=e.match(r);return n?n.length:0}function mr(e){return ne(!1,e,/\r\n?/gu,`
`)}var U="string",W="array",z="cursor",L="indent",P="align",standalone_I="trim",x="group",S="fill",_="if-break",R="indent-if-break",Y="line-suffix",j="line-suffix-boundary",B="line",N="label",b="break-parent",Ue=new Set([z,L,P,standalone_I,x,S,_,R,Y,j,B,N,b]);function Lu(e){if(typeof e=="string")return U;if(Array.isArray(e))return W;if(!e)return;let{type:t}=e;if(Ue.has(t))return t}var G=Lu;var Pu=e=>new Intl.ListFormat("en-US",{type:"disjunction"}).format(e);function Iu(e){let t=e===null?"null":typeof e;if(t!=="string"&&t!=="object")return`Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;if(G(e))throw new Error("doc is valid.");let r=Object.prototype.toString.call(e);if(r!=="[object Object]")return`Unexpected doc '${r}'.`;let n=Pu([...Ue].map(o=>`'${o}'`));return`Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`}var xt=class extends Error{name="InvalidDocError";constructor(t){super(Iu(t)),this.doc=t}},Q=xt;var Er={};function Ru(e,t,r,n){let o=[e];for(;o.length>0;){let u=o.pop();if(u===Er){r(o.pop());continue}r&&o.push(u,Er);let i=G(u);if(!i)throw new Q(u);if((t==null?void 0:t(u))!==!1)switch(i){case W:case S:{let s=i===W?u:u.parts;for(let a=s.length,D=a-1;D>=0;--D)o.push(s[D]);break}case _:o.push(u.flatContents,u.breakContents);break;case x:if(n&&u.expandedStates)for(let s=u.expandedStates.length,a=s-1;a>=0;--a)o.push(u.expandedStates[a]);else o.push(u.contents);break;case P:case L:case R:case N:case Y:o.push(u.contents);break;case U:case z:case standalone_I:case j:case B:case b:break;default:throw new Q(u)}}}var we=Ru;var hr=()=>{},K=hr,ze=hr;function De(e){return K(e),{type:L,contents:e}}function ae(e,t){return K(t),{type:P,contents:t,n:e}}function _t(e,t={}){return K(e),ze(t.expandedStates,!0),{type:x,id:t.id,contents:e,break:!!t.shouldBreak,expandedStates:t.expandedStates}}function Cr(e){return ae(Number.NEGATIVE_INFINITY,e)}function gr(e){return ae({type:"root"},e)}function yr(e){return ae(-1,e)}function Ar(e,t){return _t(e[0],{...t,expandedStates:e})}function Ge(e){return ze(e),{type:S,parts:e}}function Br(e,t="",r={}){return K(e),t!==""&&K(t),{type:_,breakContents:e,flatContents:t,groupId:r.groupId}}function wr(e,t){return K(e),{type:R,contents:e,groupId:t.groupId,negate:t.negate}}function xe(e){return K(e),{type:Y,contents:e}}var xr={type:j},de={type:b},_r={type:standalone_I},_e={type:B,hard:!0},vt={type:B,hard:!0,literal:!0},Ke={type:B},vr={type:B,soft:!0},q=[_e,de],qe=[vt,de],ve={type:z};function be(e,t){K(e),ze(t);let r=[];for(let n=0;n<t.length;n++)n!==0&&r.push(e),r.push(t[n]);return r}function Je(e,t,r){K(e);let n=e;if(t>0){for(let o=0;o<Math.floor(t/r);++o)n=De(n);n=ae(t%r,n),n=ae(Number.NEGATIVE_INFINITY,n)}return n}function br(e,t){return K(t),e?{type:N,label:e,contents:t}:t}function ee(e){var t;if(!e)return"";if(Array.isArray(e)){let r=[];for(let n of e)if(Array.isArray(n))r.push(...ee(n));else{let o=ee(n);o!==""&&r.push(o)}return r}return e.type===_?{...e,breakContents:ee(e.breakContents),flatContents:ee(e.flatContents)}:e.type===x?{...e,contents:ee(e.contents),expandedStates:(t=e.expandedStates)==null?void 0:t.map(ee)}:e.type===S?{type:"fill",parts:e.parts.map(ee)}:e.contents?{...e,contents:ee(e.contents)}:e}function Or(e){let t=Object.create(null),r=new Set;return n(ee(e));function n(u,i,s){var a,D;if(typeof u=="string")return JSON.stringify(u);if(Array.isArray(u)){let l=u.map(n).filter(Boolean);return l.length===1?l[0]:`[${l.join(", ")}]`}if(u.type===B){let l=((a=s==null?void 0:s[i+1])==null?void 0:a.type)===b;return u.literal?l?"literalline":"literallineWithoutBreakParent":u.hard?l?"hardline":"hardlineWithoutBreakParent":u.soft?"softline":"line"}if(u.type===b)return((D=s==null?void 0:s[i-1])==null?void 0:D.type)===B&&s[i-1].hard?void 0:"breakParent";if(u.type===standalone_I)return"trim";if(u.type===L)return"indent("+n(u.contents)+")";if(u.type===P)return u.n===Number.NEGATIVE_INFINITY?"dedentToRoot("+n(u.contents)+")":u.n<0?"dedent("+n(u.contents)+")":u.n.type==="root"?"markAsRoot("+n(u.contents)+")":"align("+JSON.stringify(u.n)+", "+n(u.contents)+")";if(u.type===_)return"ifBreak("+n(u.breakContents)+(u.flatContents?", "+n(u.flatContents):"")+(u.groupId?(u.flatContents?"":', ""')+`, { groupId: ${o(u.groupId)} }`:"")+")";if(u.type===R){let l=[];u.negate&&l.push("negate: true"),u.groupId&&l.push(`groupId: ${o(u.groupId)}`);let d=l.length>0?`, { ${l.join(", ")} }`:"";return`indentIfBreak(${n(u.contents)}${d})`}if(u.type===x){let l=[];u.break&&u.break!=="propagated"&&l.push("shouldBreak: true"),u.id&&l.push(`id: ${o(u.id)}`);let d=l.length>0?`, { ${l.join(", ")} }`:"";return u.expandedStates?`conditionalGroup([${u.expandedStates.map(f=>n(f)).join(",")}]${d})`:`group(${n(u.contents)}${d})`}if(u.type===S)return`fill([${u.parts.map(l=>n(l)).join(", ")}])`;if(u.type===Y)return"lineSuffix("+n(u.contents)+")";if(u.type===j)return"lineSuffixBoundary";if(u.type===N)return`label(${JSON.stringify(u.label)}, ${n(u.contents)})`;throw new Error("Unknown doc type "+u.type)}function o(u){if(typeof u!="symbol")return JSON.stringify(String(u));if(u in t)return t[u];let i=u.description||"symbol";for(let s=0;;s++){let a=i+(s>0?` #${s}`:"");if(!r.has(a))return r.add(a),t[u]=`Symbol.for(${JSON.stringify(a)})`}}}var Yu=(e,t,r)=>{if(!(e&&t==null))return Array.isArray(t)||typeof t=="string"?t[r<0?t.length+r:r]:t.at(r)},y=Yu;var Sr=()=>/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;function Nr(e){return e===12288||e>=65281&&e<=65376||e>=65504&&e<=65510}function Tr(e){return e>=4352&&e<=4447||e===8986||e===8987||e===9001||e===9002||e>=9193&&e<=9196||e===9200||e===9203||e===9725||e===9726||e===9748||e===9749||e>=9800&&e<=9811||e===9855||e===9875||e===9889||e===9898||e===9899||e===9917||e===9918||e===9924||e===9925||e===9934||e===9940||e===9962||e===9970||e===9971||e===9973||e===9978||e===9981||e===9989||e===9994||e===9995||e===10024||e===10060||e===10062||e>=10067&&e<=10069||e===10071||e>=10133&&e<=10135||e===10160||e===10175||e===11035||e===11036||e===11088||e===11093||e>=11904&&e<=11929||e>=11931&&e<=12019||e>=12032&&e<=12245||e>=12272&&e<=12287||e>=12289&&e<=12350||e>=12353&&e<=12438||e>=12441&&e<=12543||e>=12549&&e<=12591||e>=12593&&e<=12686||e>=12688&&e<=12771||e>=12783&&e<=12830||e>=12832&&e<=12871||e>=12880&&e<=19903||e>=19968&&e<=42124||e>=42128&&e<=42182||e>=43360&&e<=43388||e>=44032&&e<=55203||e>=63744&&e<=64255||e>=65040&&e<=65049||e>=65072&&e<=65106||e>=65108&&e<=65126||e>=65128&&e<=65131||e>=94176&&e<=94180||e===94192||e===94193||e>=94208&&e<=100343||e>=100352&&e<=101589||e>=101632&&e<=101640||e>=110576&&e<=110579||e>=110581&&e<=110587||e===110589||e===110590||e>=110592&&e<=110882||e===110898||e>=110928&&e<=110930||e===110933||e>=110948&&e<=110951||e>=110960&&e<=111355||e===126980||e===127183||e===127374||e>=127377&&e<=127386||e>=127488&&e<=127490||e>=127504&&e<=127547||e>=127552&&e<=127560||e===127568||e===127569||e>=127584&&e<=127589||e>=127744&&e<=127776||e>=127789&&e<=127797||e>=127799&&e<=127868||e>=127870&&e<=127891||e>=127904&&e<=127946||e>=127951&&e<=127955||e>=127968&&e<=127984||e===127988||e>=127992&&e<=128062||e===128064||e>=128066&&e<=128252||e>=128255&&e<=128317||e>=128331&&e<=128334||e>=128336&&e<=128359||e===128378||e===128405||e===128406||e===128420||e>=128507&&e<=128591||e>=128640&&e<=128709||e===128716||e>=128720&&e<=128722||e>=128725&&e<=128727||e>=128732&&e<=128735||e===128747||e===128748||e>=128756&&e<=128764||e>=128992&&e<=129003||e===129008||e>=129292&&e<=129338||e>=129340&&e<=129349||e>=129351&&e<=129535||e>=129648&&e<=129660||e>=129664&&e<=129672||e>=129680&&e<=129725||e>=129727&&e<=129733||e>=129742&&e<=129755||e>=129760&&e<=129768||e>=129776&&e<=129784||e>=131072&&e<=196605||e>=196608&&e<=262141}var kr=e=>!(Nr(e)||Tr(e));var ju=/[^\x20-\x7F]/u;function Hu(e){if(!e)return 0;if(!ju.test(e))return e.length;e=e.replace(Sr(),"  ");let t=0;for(let r of e){let n=r.codePointAt(0);n<=31||n>=127&&n<=159||n>=768&&n<=879||(t+=kr(n)?1:2)}return t}var Oe=Hu;function Ne(e,t){if(typeof e=="string")return t(e);let r=new Map;return n(e);function n(u){if(r.has(u))return r.get(u);let i=o(u);return r.set(u,i),i}function o(u){switch(G(u)){case W:return t(u.map(n));case S:return t({...u,parts:u.parts.map(n)});case _:return t({...u,breakContents:n(u.breakContents),flatContents:n(u.flatContents)});case x:{let{expandedStates:i,contents:s}=u;return i?(i=i.map(n),s=i[0]):s=n(s),t({...u,contents:s,expandedStates:i})}case P:case L:case R:case N:case Y:return t({...u,contents:n(u.contents)});case U:case z:case standalone_I:case j:case B:case b:return t(u);default:throw new Q(u)}}}function Xe(e,t,r){let n=r,o=!1;function u(i){if(o)return!1;let s=t(i);s!==void 0&&(o=!0,n=s)}return we(e,u),n}function Wu(e){if(e.type===x&&e.break||e.type===B&&e.hard||e.type===b)return!0}function Ir(e){return Xe(e,Wu,!1)}function Lr(e){if(e.length>0){let t=y(!1,e,-1);!t.expandedStates&&!t.break&&(t.break="propagated")}return null}function Rr(e){let t=new Set,r=[];function n(u){if(u.type===b&&Lr(r),u.type===x){if(r.push(u),t.has(u))return!1;t.add(u)}}function o(u){u.type===x&&r.pop().break&&Lr(r)}we(e,n,o,!0)}function Mu(e){return e.type===B&&!e.hard?e.soft?"":" ":e.type===_?e.flatContents:e}function Yr(e){return Ne(e,Mu)}function Pr(e){for(e=[...e];e.length>=2&&y(!1,e,-2).type===B&&y(!1,e,-1).type===b;)e.length-=2;if(e.length>0){let t=Se(y(!1,e,-1));e[e.length-1]=t}return e}function Se(e){switch(G(e)){case L:case R:case x:case Y:case N:{let t=Se(e.contents);return{...e,contents:t}}case _:return{...e,breakContents:Se(e.breakContents),flatContents:Se(e.flatContents)};case S:return{...e,parts:Pr(e.parts)};case W:return Pr(e);case U:return e.replace(/[\n\r]*$/u,"");case P:case z:case standalone_I:case j:case B:case b:break;default:throw new Q(e)}return e}function Ze(e){return Se(Vu(e))}function $u(e){switch(G(e)){case S:if(e.parts.every(t=>t===""))return"";break;case x:if(!e.contents&&!e.id&&!e.break&&!e.expandedStates)return"";if(e.contents.type===x&&e.contents.id===e.id&&e.contents.break===e.break&&e.contents.expandedStates===e.expandedStates)return e.contents;break;case P:case L:case R:case Y:if(!e.contents)return"";break;case _:if(!e.flatContents&&!e.breakContents)return"";break;case W:{let t=[];for(let r of e){if(!r)continue;let[n,...o]=Array.isArray(r)?r:[r];typeof n=="string"&&typeof y(!1,t,-1)=="string"?t[t.length-1]+=n:t.push(n),t.push(...o)}return t.length===0?"":t.length===1?t[0]:t}case U:case z:case standalone_I:case j:case B:case N:case b:break;default:throw new Q(e)}return e}function Vu(e){return Ne(e,t=>$u(t))}function jr(e,t=qe){return Ne(e,r=>typeof r=="string"?be(t,r.split(`
`)):r)}function Uu(e){if(e.type===B)return!0}function Hr(e){return Xe(e,Uu,!1)}function Qe(e,t){return e.type===N?{...e,contents:t(e.contents)}:t(e)}var H=Symbol("MODE_BREAK"),J=Symbol("MODE_FLAT"),Te=Symbol("cursor");function Wr(){return{value:"",length:0,queue:[]}}function zu(e,t){return bt(e,{type:"indent"},t)}function Gu(e,t,r){return t===Number.NEGATIVE_INFINITY?e.root||Wr():t<0?bt(e,{type:"dedent"},r):t?t.type==="root"?{...e,root:e}:bt(e,{type:typeof t=="string"?"stringAlign":"numberAlign",n:t},r):e}function bt(e,t,r){let n=t.type==="dedent"?e.queue.slice(0,-1):[...e.queue,t],o="",u=0,i=0,s=0;for(let c of n)switch(c.type){case"indent":l(),r.useTabs?a(1):D(r.tabWidth);break;case"stringAlign":l(),o+=c.n,u+=c.n.length;break;case"numberAlign":i+=1,s+=c.n;break;default:throw new Error(`Unexpected type '${c.type}'`)}return f(),{...e,value:o,length:u,queue:n};function a(c){o+="	".repeat(c),u+=r.tabWidth*c}function D(c){o+=" ".repeat(c),u+=c}function l(){r.useTabs?d():f()}function d(){i>0&&a(i),p()}function f(){s>0&&D(s),p()}function p(){i=0,s=0}}function Ot(e){let t=0,r=0,n=e.length;e:for(;n--;){let o=e[n];if(o===Te){r++;continue}for(let u=o.length-1;u>=0;u--){let i=o[u];if(i===" "||i==="	")t++;else{e[n]=o.slice(0,u+1);break e}}}if(t>0||r>0)for(e.length=n+1;r-- >0;)e.push(Te);return t}function et(e,t,r,n,o,u){if(r===Number.POSITIVE_INFINITY)return!0;let i=t.length,s=[e],a=[];for(;r>=0;){if(s.length===0){if(i===0)return!0;s.push(t[--i]);continue}let{mode:D,doc:l}=s.pop(),d=G(l);switch(d){case U:a.push(l),r-=Oe(l);break;case W:case S:{let f=d===W?l:l.parts;for(let p=f.length-1;p>=0;p--)s.push({mode:D,doc:f[p]});break}case L:case P:case R:case N:s.push({mode:D,doc:l.contents});break;case standalone_I:r+=Ot(a);break;case x:{if(u&&l.break)return!1;let f=l.break?H:D,p=l.expandedStates&&f===H?y(!1,l.expandedStates,-1):l.contents;s.push({mode:f,doc:p});break}case _:{let p=(l.groupId?o[l.groupId]||J:D)===H?l.breakContents:l.flatContents;p&&s.push({mode:D,doc:p});break}case B:if(D===H||l.hard)return!0;l.soft||(a.push(" "),r--);break;case Y:n=!0;break;case j:if(n)return!1;break}}return!1}function Fe(e,t){let r={},n=t.printWidth,o=Be(t.endOfLine),u=0,i=[{ind:Wr(),mode:H,doc:e}],s=[],a=!1,D=[],l=0;for(Rr(e);i.length>0;){let{ind:f,mode:p,doc:c}=i.pop();switch(G(c)){case U:{let F=o!==`
`?ne(!1,c,`
`,o):c;s.push(F),i.length>0&&(u+=Oe(F));break}case W:for(let F=c.length-1;F>=0;F--)i.push({ind:f,mode:p,doc:c[F]});break;case z:if(l>=2)throw new Error("There are too many 'cursor' in doc.");s.push(Te),l++;break;case L:i.push({ind:zu(f,t),mode:p,doc:c.contents});break;case P:i.push({ind:Gu(f,c.n,t),mode:p,doc:c.contents});break;case standalone_I:u-=Ot(s);break;case x:switch(p){case J:if(!a){i.push({ind:f,mode:c.break?H:J,doc:c.contents});break}case H:{a=!1;let F={ind:f,mode:J,doc:c.contents},m=n-u,E=D.length>0;if(!c.break&&et(F,i,m,E,r))i.push(F);else if(c.expandedStates){let A=y(!1,c.expandedStates,-1);if(c.break){i.push({ind:f,mode:H,doc:A});break}else for(let w=1;w<c.expandedStates.length+1;w++)if(w>=c.expandedStates.length){i.push({ind:f,mode:H,doc:A});break}else{let h=c.expandedStates[w],C={ind:f,mode:J,doc:h};if(et(C,i,m,E,r)){i.push(C);break}}}else i.push({ind:f,mode:H,doc:c.contents});break}}c.id&&(r[c.id]=y(!1,i,-1).mode);break;case S:{let F=n-u,{parts:m}=c;if(m.length===0)break;let[E,A]=m,w={ind:f,mode:J,doc:E},h={ind:f,mode:H,doc:E},C=et(w,[],F,D.length>0,r,!0);if(m.length===1){C?i.push(w):i.push(h);break}let k={ind:f,mode:J,doc:A},v={ind:f,mode:H,doc:A};if(m.length===2){C?i.push(k,w):i.push(v,h);break}m.splice(0,2);let $={ind:f,mode:p,doc:Ge(m)},ye=m[0];et({ind:f,mode:J,doc:[E,A,ye]},[],F,D.length>0,r,!0)?i.push($,k,w):C?i.push($,v,w):i.push($,v,h);break}case _:case R:{let F=c.groupId?r[c.groupId]:p;if(F===H){let m=c.type===_?c.breakContents:c.negate?c.contents:De(c.contents);m&&i.push({ind:f,mode:p,doc:m})}if(F===J){let m=c.type===_?c.flatContents:c.negate?De(c.contents):c.contents;m&&i.push({ind:f,mode:p,doc:m})}break}case Y:D.push({ind:f,mode:p,doc:c.contents});break;case j:D.length>0&&i.push({ind:f,mode:p,doc:_e});break;case B:switch(p){case J:if(c.hard)a=!0;else{c.soft||(s.push(" "),u+=1);break}case H:if(D.length>0){i.push({ind:f,mode:p,doc:c},...D.reverse()),D.length=0;break}c.literal?f.root?(s.push(o,f.root.value),u=f.root.length):(s.push(o),u=0):(u-=Ot(s),s.push(o+f.value),u=f.length);break}break;case N:i.push({ind:f,mode:p,doc:c.contents});break;case b:break;default:throw new Q(c)}i.length===0&&D.length>0&&(i.push(...D.reverse()),D.length=0)}let d=s.indexOf(Te);if(d!==-1){let f=s.indexOf(Te,d+1),p=s.slice(0,d).join(""),c=s.slice(d+1,f).join(""),F=s.slice(f+1).join("");return{formatted:p+c+F,cursorNodeStart:p.length,cursorNodeText:c}}return{formatted:s.join("")}}function Ku(e,t,r=0){let n=0;for(let o=r;o<e.length;++o)e[o]==="	"?n=n+t-n%t:n++;return n}var me=Ku;var te,Nt,tt,St=class{constructor(t){Dr(this,te);this.stack=[t]}get key(){let{stack:t,siblings:r}=this;return y(!1,t,r===null?-2:-4)??null}get index(){return this.siblings===null?null:y(!1,this.stack,-2)}get node(){return y(!1,this.stack,-1)}get parent(){return this.getNode(1)}get grandparent(){return this.getNode(2)}get isInArray(){return this.siblings!==null}get siblings(){let{stack:t}=this,r=y(!1,t,-3);return Array.isArray(r)?r:null}get next(){let{siblings:t}=this;return t===null?null:t[this.index+1]}get previous(){let{siblings:t}=this;return t===null?null:t[this.index-1]}get isFirst(){return this.index===0}get isLast(){let{siblings:t,index:r}=this;return t!==null&&r===t.length-1}get isRoot(){return this.stack.length===1}get root(){return this.stack[0]}get ancestors(){return[...pe(this,te,tt).call(this)]}getName(){let{stack:t}=this,{length:r}=t;return r>1?y(!1,t,-2):null}getValue(){return y(!1,this.stack,-1)}getNode(t=0){let r=pe(this,te,Nt).call(this,t);return r===-1?null:this.stack[r]}getParentNode(t=0){return this.getNode(t+1)}call(t,...r){let{stack:n}=this,{length:o}=n,u=y(!1,n,-1);for(let i of r)u=u[i],n.push(i,u);try{return t(this)}finally{n.length=o}}callParent(t,r=0){let n=pe(this,te,Nt).call(this,r+1),o=this.stack.splice(n+1);try{return t(this)}finally{this.stack.push(...o)}}each(t,...r){let{stack:n}=this,{length:o}=n,u=y(!1,n,-1);for(let i of r)u=u[i],n.push(i,u);try{for(let i=0;i<u.length;++i)n.push(i,u[i]),t(this,i,u),n.length-=2}finally{n.length=o}}map(t,...r){let n=[];return this.each((o,u,i)=>{n[u]=t(o,u,i)},...r),n}match(...t){let r=this.stack.length-1,n=null,o=this.stack[r--];for(let u of t){if(o===void 0)return!1;let i=null;if(typeof n=="number"&&(i=n,n=this.stack[r--],o=this.stack[r--]),u&&!u(o,n,i))return!1;n=this.stack[r--],o=this.stack[r--]}return!0}findAncestor(t){for(let r of pe(this,te,tt).call(this))if(t(r))return r}hasAncestor(t){for(let r of pe(this,te,tt).call(this))if(t(r))return!0;return!1}};te=new WeakSet,Nt=function(t){let{stack:r}=this;for(let n=r.length-1;n>=0;n-=2)if(!Array.isArray(r[n])&&--t<0)return n;return-1},tt=function*(){let{stack:t}=this;for(let r=t.length-3;r>=0;r-=2){let n=t[r];Array.isArray(n)||(yield n)}};var Mr=St;var $r=new Proxy(()=>{},{get:()=>$r}),ke=$r;function qu(e){return e!==null&&typeof e=="object"}var Vr=qu;function*Tt(e,t){let{getVisitorKeys:r,filter:n=()=>!0}=t,o=u=>Vr(u)&&n(u);for(let u of r(e)){let i=e[u];if(Array.isArray(i))for(let s of i)o(s)&&(yield s);else o(i)&&(yield i)}}function*Ur(e,t){let r=[e];for(let n=0;n<r.length;n++){let o=r[n];for(let u of Tt(o,t))yield u,r.push(u)}}function Ee(e){return(t,r,n)=>{let o=!!(n!=null&&n.backwards);if(r===!1)return!1;let{length:u}=t,i=r;for(;i>=0&&i<u;){let s=t.charAt(i);if(e instanceof RegExp){if(!e.test(s))return i}else if(!e.includes(s))return i;o?i--:i++}return i===-1||i===u?i:!1}}var zr=Ee(/\s/u),T=Ee(" 	"),rt=Ee(",; 	"),nt=Ee(/[^\n\r]/u);function Ju(e,t,r){let n=!!(r!=null&&r.backwards);if(t===!1)return!1;let o=e.charAt(t);if(n){if(e.charAt(t-1)==="\r"&&o===`
`)return t-2;if(o===`
`||o==="\r"||o==="\u2028"||o==="\u2029")return t-1}else{if(o==="\r"&&e.charAt(t+1)===`
`)return t+2;if(o===`
`||o==="\r"||o==="\u2028"||o==="\u2029")return t+1}return t}var M=Ju;function Xu(e,t,r={}){let n=T(e,r.backwards?t-1:t,r),o=M(e,n,r);return n!==o}var standalone_V=Xu;function Zu(e){return Array.isArray(e)&&e.length>0}var kt=Zu;var Gr=new Set(["tokens","comments","parent","enclosingNode","precedingNode","followingNode"]),Qu=e=>Object.keys(e).filter(t=>!Gr.has(t));function eo(e){return e?t=>e(t,Gr):Qu}var X=eo;function to(e){let t=e.type||e.kind||"(unknown type)",r=String(e.name||e.id&&(typeof e.id=="object"?e.id.name:e.id)||e.key&&(typeof e.key=="object"?e.key.name:e.key)||e.value&&(typeof e.value=="object"?"":String(e.value))||e.operator||"");return r.length>20&&(r=r.slice(0,19)+"\u2026"),t+(r?" "+r:"")}function Lt(e,t){(e.comments??(e.comments=[])).push(t),t.printed=!1,t.nodeDescription=to(e)}function ue(e,t){t.leading=!0,t.trailing=!1,Lt(e,t)}function re(e,t,r){t.leading=!1,t.trailing=!1,r&&(t.marker=r),Lt(e,t)}function oe(e,t){t.leading=!1,t.trailing=!0,Lt(e,t)}var Pt=new WeakMap;function ut(e,t){if(Pt.has(e))return Pt.get(e);let{printer:{getCommentChildNodes:r,canAttachComment:n,getVisitorKeys:o},locStart:u,locEnd:i}=t;if(!n)return[];let s=((r==null?void 0:r(e,t))??[...Tt(e,{getVisitorKeys:X(o)})]).flatMap(a=>n(a)?[a]:ut(a,t));return s.sort((a,D)=>u(a)-u(D)||i(a)-i(D)),Pt.set(e,s),s}function qr(e,t,r,n){let{locStart:o,locEnd:u}=r,i=o(t),s=u(t),a=ut(e,r),D,l,d=0,f=a.length;for(;d<f;){let p=d+f>>1,c=a[p],F=o(c),m=u(c);if(F<=i&&s<=m)return qr(c,t,r,c);if(m<=i){D=c,d=p+1;continue}if(s<=F){l=c,f=p;continue}throw new Error("Comment location overlaps with node location")}if((n==null?void 0:n.type)==="TemplateLiteral"){let{quasis:p}=n,c=Rt(p,t,r);D&&Rt(p,D,r)!==c&&(D=null),l&&Rt(p,l,r)!==c&&(l=null)}return{enclosingNode:n,precedingNode:D,followingNode:l}}var It=()=>!1;function Jr(e,t){let{comments:r}=e;if(delete e.comments,!kt(r)||!t.printer.canAttachComment)return;let n=[],{locStart:o,locEnd:u,printer:{experimentalFeatures:{avoidAstMutation:i=!1}={},handleComments:s={}},originalText:a}=t,{ownLine:D=It,endOfLine:l=It,remaining:d=It}=s,f=r.map((p,c)=>({...qr(e,p,t),comment:p,text:a,options:t,ast:e,isLastComment:r.length-1===c}));for(let[p,c]of f.entries()){let{comment:F,precedingNode:m,enclosingNode:E,followingNode:A,text:w,options:h,ast:C,isLastComment:k}=c;if(h.parser==="json"||h.parser==="json5"||h.parser==="jsonc"||h.parser==="__js_expression"||h.parser==="__ts_expression"||h.parser==="__vue_expression"||h.parser==="__vue_ts_expression"){if(o(F)-o(C)<=0){ue(C,F);continue}if(u(F)-u(C)>=0){oe(C,F);continue}}let v;if(i?v=[c]:(F.enclosingNode=E,F.precedingNode=m,F.followingNode=A,v=[F,w,h,C,k]),ro(w,h,f,p))F.placement="ownLine",D(...v)||(A?ue(A,F):m?oe(m,F):E?re(E,F):re(C,F));else if(no(w,h,f,p))F.placement="endOfLine",l(...v)||(m?oe(m,F):A?ue(A,F):E?re(E,F):re(C,F));else if(F.placement="remaining",!d(...v))if(m&&A){let $=n.length;$>0&&n[$-1].followingNode!==A&&Kr(n,h),n.push(c)}else m?oe(m,F):A?ue(A,F):E?re(E,F):re(C,F)}if(Kr(n,t),!i)for(let p of r)delete p.precedingNode,delete p.enclosingNode,delete p.followingNode}var Xr=e=>!/[\S\n\u2028\u2029]/u.test(e);function ro(e,t,r,n){let{comment:o,precedingNode:u}=r[n],{locStart:i,locEnd:s}=t,a=i(o);if(u)for(let D=n-1;D>=0;D--){let{comment:l,precedingNode:d}=r[D];if(d!==u||!Xr(e.slice(s(l),a)))break;a=i(l)}return standalone_V(e,a,{backwards:!0})}function no(e,t,r,n){let{comment:o,followingNode:u}=r[n],{locStart:i,locEnd:s}=t,a=s(o);if(u)for(let D=n+1;D<r.length;D++){let{comment:l,followingNode:d}=r[D];if(d!==u||!Xr(e.slice(a,i(l))))break;a=s(l)}return standalone_V(e,a)}function Kr(e,t){var s,a;let r=e.length;if(r===0)return;let{precedingNode:n,followingNode:o}=e[0],u=t.locStart(o),i;for(i=r;i>0;--i){let{comment:D,precedingNode:l,followingNode:d}=e[i-1];ke.strictEqual(l,n),ke.strictEqual(d,o);let f=t.originalText.slice(t.locEnd(D),u);if(((a=(s=t.printer).isGap)==null?void 0:a.call(s,f,t))??/^[\s(]*$/u.test(f))u=t.locStart(D);else break}for(let[D,{comment:l}]of e.entries())D<i?oe(n,l):ue(o,l);for(let D of[n,o])D.comments&&D.comments.length>1&&D.comments.sort((l,d)=>t.locStart(l)-t.locStart(d));e.length=0}function Rt(e,t,r){let n=r.locStart(t)-1;for(let o=1;o<e.length;++o)if(n<r.locStart(e[o]))return o-1;return 0}function uo(e,t){let r=t-1;r=T(e,r,{backwards:!0}),r=M(e,r,{backwards:!0}),r=T(e,r,{backwards:!0});let n=M(e,r,{backwards:!0});return r!==n}var Le=uo;function Zr(e,t){let r=e.node;return r.printed=!0,t.printer.printComment(e,t)}function oo(e,t){var l;let r=e.node,n=[Zr(e,t)],{printer:o,originalText:u,locStart:i,locEnd:s}=t;if((l=o.isBlockComment)==null?void 0:l.call(o,r)){let d=standalone_V(u,s(r))?standalone_V(u,i(r),{backwards:!0})?q:Ke:" ";n.push(d)}else n.push(q);let D=M(u,T(u,s(r)));return D!==!1&&standalone_V(u,D)&&n.push(q),n}function io(e,t,r){var D;let n=e.node,o=Zr(e,t),{printer:u,originalText:i,locStart:s}=t,a=(D=u.isBlockComment)==null?void 0:D.call(u,n);if(r!=null&&r.hasLineSuffix&&!(r!=null&&r.isBlock)||standalone_V(i,s(n),{backwards:!0})){let l=Le(i,s(n));return{doc:xe([q,l?q:"",o]),isBlock:a,hasLineSuffix:!0}}return!a||r!=null&&r.hasLineSuffix?{doc:[xe([" ",o]),de],isBlock:a,hasLineSuffix:!0}:{doc:[" ",o],isBlock:a,hasLineSuffix:!1}}function so(e,t){let r=e.node;if(!r)return{};let n=t[Symbol.for("printedComments")];if((r.comments||[]).filter(a=>!n.has(a)).length===0)return{leading:"",trailing:""};let u=[],i=[],s;return e.each(()=>{let a=e.node;if(n!=null&&n.has(a))return;let{leading:D,trailing:l}=a;D?u.push(oo(e,t)):l&&(s=io(e,t,s),i.push(s.doc))},"comments"),{leading:u,trailing:i}}function Qr(e,t,r){let{leading:n,trailing:o}=so(e,r);return!n&&!o?t:Qe(t,u=>[n,u,o])}function en(e){let{[Symbol.for("comments")]:t,[Symbol.for("printedComments")]:r}=e;for(let n of t){if(!n.printed&&!r.has(n))throw new Error('Comment "'+n.value.trim()+'" was not printed. Please report this error!');delete n.printed}}function ao(e){return()=>{}}var tn=ao;var Pe=class extends Error{name="ConfigError"},Ie=class extends Error{name="UndefinedParserError"};var rn={cursorOffset:{category:"Special",type:"int",default:-1,range:{start:-1,end:1/0,step:1},description:"Print (to stderr) where a cursor at the given position would move to after formatting.",cliCategory:"Editor"},endOfLine:{category:"Global",type:"choice",default:"lf",description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:`Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)`}]},filepath:{category:"Special",type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:"Other",cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{category:"Special",type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:"Other"},parser:{category:"Global",type:"choice",default:void 0,description:"Which parser to use.",exception:e=>typeof e=="string"||typeof e=="function",choices:[{value:"flow",description:"Flow"},{value:"babel",description:"JavaScript"},{value:"babel-flow",description:"Flow"},{value:"babel-ts",description:"TypeScript"},{value:"typescript",description:"TypeScript"},{value:"acorn",description:"JavaScript"},{value:"espree",description:"JavaScript"},{value:"meriyah",description:"JavaScript"},{value:"css",description:"CSS"},{value:"less",description:"Less"},{value:"scss",description:"SCSS"},{value:"json",description:"JSON"},{value:"json5",description:"JSON5"},{value:"jsonc",description:"JSON with Comments"},{value:"json-stringify",description:"JSON.stringify"},{value:"graphql",description:"GraphQL"},{value:"markdown",description:"Markdown"},{value:"mdx",description:"MDX"},{value:"vue",description:"Vue"},{value:"yaml",description:"YAML"},{value:"glimmer",description:"Ember / Handlebars"},{value:"html",description:"HTML"},{value:"angular",description:"Angular"},{value:"lwc",description:"Lightning Web Components"}]},plugins:{type:"path",array:!0,default:[{value:[]}],category:"Global",description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:e=>typeof e=="string"||typeof e=="object",cliName:"plugin",cliCategory:"Config"},printWidth:{category:"Global",type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:1/0,step:1}},rangeEnd:{category:"Special",type:"int",default:1/0,range:{start:0,end:1/0,step:1},description:`Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`,cliCategory:"Editor"},rangeStart:{category:"Special",type:"int",default:0,range:{start:0,end:1/0,step:1},description:`Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`,cliCategory:"Editor"},requirePragma:{category:"Special",type:"boolean",default:!1,description:`Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`,cliCategory:"Other"},tabWidth:{type:"int",category:"Global",default:2,description:"Number of spaces per indentation level.",range:{start:0,end:1/0,step:1}},useTabs:{category:"Global",type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{category:"Global",type:"choice",default:"auto",description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};function ot({plugins:e=[],showDeprecated:t=!1}={}){let r=e.flatMap(o=>o.languages??[]),n=[];for(let o of lo(Object.assign({},...e.map(({options:u})=>u),rn)))!t&&o.deprecated||(Array.isArray(o.choices)&&(t||(o.choices=o.choices.filter(u=>!u.deprecated)),o.name==="parser"&&(o.choices=[...o.choices,...Do(o.choices,r,e)])),o.pluginDefaults=Object.fromEntries(e.filter(u=>{var i;return((i=u.defaultOptions)==null?void 0:i[o.name])!==void 0}).map(u=>[u.name,u.defaultOptions[o.name]])),n.push(o));return{languages:r,options:n}}function*Do(e,t,r){let n=new Set(e.map(o=>o.value));for(let o of t)if(o.parsers){for(let u of o.parsers)if(!n.has(u)){n.add(u);let i=r.find(a=>a.parsers&&Object.prototype.hasOwnProperty.call(a.parsers,u)),s=o.name;i!=null&&i.name&&(s+=` (plugin: ${i.name})`),yield{value:u,description:s}}}}function lo(e){let t=[];for(let[r,n]of Object.entries(e)){let o={name:r,...n};Array.isArray(o.default)&&(o.default=y(!1,o.default,-1).value),t.push(o)}return t}var co=e=>String(e).split(/[/\\]/u).pop();function nn(e,t){if(!t)return;let r=co(t).toLowerCase();return e.find(({filenames:n})=>n==null?void 0:n.some(o=>o.toLowerCase()===r))??e.find(({extensions:n})=>n==null?void 0:n.some(o=>r.endsWith(o)))}function fo(e,t){if(t)return e.find(({name:r})=>r.toLowerCase()===t)??e.find(({aliases:r})=>r==null?void 0:r.includes(t))??e.find(({extensions:r})=>r==null?void 0:r.includes(`.${t}`))}function po(e,t){let r=e.plugins.flatMap(o=>o.languages??[]),n=fo(r,t.language)??nn(r,t.physicalFile)??nn(r,t.file)??(t.physicalFile,void 0);return n==null?void 0:n.parsers[0]}var un=po;var ie={key:e=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e)?e:JSON.stringify(e),value(e){if(e===null||typeof e!="object")return JSON.stringify(e);if(Array.isArray(e))return`[${e.map(r=>ie.value(r)).join(", ")}]`;let t=Object.keys(e);return t.length===0?"{}":`{ ${t.map(r=>`${ie.key(r)}: ${ie.value(e[r])}`).join(", ")} }`},pair:({key:e,value:t})=>ie.value({[e]:t})};var Yt=Me(it(),1),an=(e,t,{descriptor:r})=>{let n=[`${Yt.default.yellow(typeof e=="string"?r.key(e):r.pair(e))} is deprecated`];return t&&n.push(`we now treat it as ${Yt.default.blue(typeof t=="string"?r.key(t):r.pair(t))}`),n.join("; ")+"."};var le=Me(it(),1);var st=Symbol.for("vnopts.VALUE_NOT_EXIST"),he=Symbol.for("vnopts.VALUE_UNCHANGED");var Dn=" ".repeat(2),cn=(e,t,r)=>{let{text:n,list:o}=r.normalizeExpectedResult(r.schemas[e].expected(r)),u=[];return n&&u.push(ln(e,t,n,r.descriptor)),o&&u.push([ln(e,t,o.title,r.descriptor)].concat(o.values.map(i=>fn(i,r.loggerPrintWidth))).join(`
`)),pn(u,r.loggerPrintWidth)};function ln(e,t,r,n){return[`Invalid ${le.default.red(n.key(e))} value.`,`Expected ${le.default.blue(r)},`,`but received ${t===st?le.default.gray("nothing"):le.default.red(n.value(t))}.`].join(" ")}function fn({text:e,list:t},r){let n=[];return e&&n.push(`- ${le.default.blue(e)}`),t&&n.push([`- ${le.default.blue(t.title)}:`].concat(t.values.map(o=>fn(o,r-Dn.length).replace(/^|\n/g,`$&${Dn}`))).join(`
`)),pn(n,r)}function pn(e,t){if(e.length===1)return e[0];let[r,n]=e,[o,u]=e.map(i=>i.split(`
`,1)[0].length);return o>t&&o>u?n:r}var Wt=Me(it(),1);var jt=[],dn=[];function Ht(e,t){if(e===t)return 0;let r=e;e.length>t.length&&(e=t,t=r);let n=e.length,o=t.length;for(;n>0&&e.charCodeAt(~-n)===t.charCodeAt(~-o);)n--,o--;let u=0;for(;u<n&&e.charCodeAt(u)===t.charCodeAt(u);)u++;if(n-=u,o-=u,n===0)return o;let i,s,a,D,l=0,d=0;for(;l<n;)dn[l]=e.charCodeAt(u+l),jt[l]=++l;for(;d<o;)for(i=t.charCodeAt(u+d),a=d++,s=d,l=0;l<n;l++)D=i===dn[l]?a:a+1,a=jt[l],s=jt[l]=a>s?D>s?s+1:D:D>a?a+1:D;return s}var at=(e,t,{descriptor:r,logger:n,schemas:o})=>{let u=[`Ignored unknown option ${Wt.default.yellow(r.pair({key:e,value:t}))}.`],i=Object.keys(o).sort().find(s=>Ht(e,s)<3);i&&u.push(`Did you mean ${Wt.default.blue(r.key(i))}?`),n.warn(u.join(" "))};var Fo=["default","expected","validate","deprecated","forward","redirect","overlap","preprocess","postprocess"];function mo(e,t){let r=new e(t),n=Object.create(r);for(let o of Fo)o in t&&(n[o]=Eo(t[o],r,O.prototype[o].length));return n}var O=class{static create(t){return mo(this,t)}constructor(t){this.name=t.name}default(t){}expected(t){return"nothing"}validate(t,r){return!1}deprecated(t,r){return!1}forward(t,r){}redirect(t,r){}overlap(t,r,n){return t}preprocess(t,r){return t}postprocess(t,r){return he}};function Eo(e,t,r){return typeof e=="function"?(...n)=>e(...n.slice(0,r-1),t,...n.slice(r-1)):()=>e}var Dt=class extends O{constructor(t){super(t),this._sourceName=t.sourceName}expected(t){return t.schemas[this._sourceName].expected(t)}validate(t,r){return r.schemas[this._sourceName].validate(t,r)}redirect(t,r){return this._sourceName}};var lt=class extends O{expected(){return"anything"}validate(){return!0}};var ct=class extends O{constructor({valueSchema:t,name:r=t.name,...n}){super({...n,name:r}),this._valueSchema=t}expected(t){let{text:r,list:n}=t.normalizeExpectedResult(this._valueSchema.expected(t));return{text:r&&`an array of ${r}`,list:n&&{title:"an array of the following values",values:[{list:n}]}}}validate(t,r){if(!Array.isArray(t))return!1;let n=[];for(let o of t){let u=r.normalizeValidateResult(this._valueSchema.validate(o,r),o);u!==!0&&n.push(u.value)}return n.length===0?!0:{value:n}}deprecated(t,r){let n=[];for(let o of t){let u=r.normalizeDeprecatedResult(this._valueSchema.deprecated(o,r),o);u!==!1&&n.push(...u.map(({value:i})=>({value:[i]})))}return n}forward(t,r){let n=[];for(let o of t){let u=r.normalizeForwardResult(this._valueSchema.forward(o,r),o);n.push(...u.map(Fn))}return n}redirect(t,r){let n=[],o=[];for(let u of t){let i=r.normalizeRedirectResult(this._valueSchema.redirect(u,r),u);"remain"in i&&n.push(i.remain),o.push(...i.redirect.map(Fn))}return n.length===0?{redirect:o}:{redirect:o,remain:n}}overlap(t,r){return t.concat(r)}};function Fn({from:e,to:t}){return{from:[e],to:t}}var ft=class extends O{expected(){return"true or false"}validate(t){return typeof t=="boolean"}};function En(e,t){let r=Object.create(null);for(let n of e){let o=n[t];if(r[o])throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);r[o]=n}return r}function hn(e,t){let r=new Map;for(let n of e){let o=n[t];if(r.has(o))throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);r.set(o,n)}return r}function Cn(){let e=Object.create(null);return t=>{let r=JSON.stringify(t);return e[r]?!0:(e[r]=!0,!1)}}function gn(e,t){let r=[],n=[];for(let o of e)t(o)?r.push(o):n.push(o);return[r,n]}function yn(e){return e===Math.floor(e)}function An(e,t){if(e===t)return 0;let r=typeof e,n=typeof t,o=["undefined","object","boolean","number","string"];return r!==n?o.indexOf(r)-o.indexOf(n):r!=="string"?Number(e)-Number(t):e.localeCompare(t)}function Bn(e){return(...t)=>{let r=e(...t);return typeof r=="string"?new Error(r):r}}function Mt(e){return e===void 0?{}:e}function $t(e){if(typeof e=="string")return{text:e};let{text:t,list:r}=e;return ho((t||r)!==void 0,"Unexpected `expected` result, there should be at least one field."),r?{text:t,list:{title:r.title,values:r.values.map($t)}}:{text:t}}function Vt(e,t){return e===!0?!0:e===!1?{value:t}:e}function Ut(e,t,r=!1){return e===!1?!1:e===!0?r?!0:[{value:t}]:"value"in e?[e]:e.length===0?!1:e}function mn(e,t){return typeof e=="string"||"key"in e?{from:t,to:e}:"from"in e?{from:e.from,to:e.to}:{from:t,to:e.to}}function pt(e,t){return e===void 0?[]:Array.isArray(e)?e.map(r=>mn(r,t)):[mn(e,t)]}function zt(e,t){let r=pt(typeof e=="object"&&"redirect"in e?e.redirect:e,t);return r.length===0?{remain:t,redirect:r}:typeof e=="object"&&"remain"in e?{remain:e.remain,redirect:r}:{redirect:r}}function ho(e,t){if(!e)throw new Error(t)}var dt=class extends O{constructor(t){super(t),this._choices=hn(t.choices.map(r=>r&&typeof r=="object"?r:{value:r}),"value")}expected({descriptor:t}){let r=Array.from(this._choices.keys()).map(i=>this._choices.get(i)).filter(({hidden:i})=>!i).map(i=>i.value).sort(An).map(t.value),n=r.slice(0,-2),o=r.slice(-2);return{text:n.concat(o.join(" or ")).join(", "),list:{title:"one of the following values",values:r}}}validate(t){return this._choices.has(t)}deprecated(t){let r=this._choices.get(t);return r&&r.deprecated?{value:t}:!1}forward(t){let r=this._choices.get(t);return r?r.forward:void 0}redirect(t){let r=this._choices.get(t);return r?r.redirect:void 0}};var Ft=class extends O{expected(){return"a number"}validate(t,r){return typeof t=="number"}};var mt=class extends Ft{expected(){return"an integer"}validate(t,r){return r.normalizeValidateResult(super.validate(t,r),t)===!0&&yn(t)}};var Re=class extends O{expected(){return"a string"}validate(t){return typeof t=="string"}};var wn=ie,xn=at,_n=cn,vn=an;var Et=class{constructor(t,r){let{logger:n=console,loggerPrintWidth:o=80,descriptor:u=wn,unknown:i=xn,invalid:s=_n,deprecated:a=vn,missing:D=()=>!1,required:l=()=>!1,preprocess:d=p=>p,postprocess:f=()=>he}=r||{};this._utils={descriptor:u,logger:n||{warn:()=>{}},loggerPrintWidth:o,schemas:En(t,"name"),normalizeDefaultResult:Mt,normalizeExpectedResult:$t,normalizeDeprecatedResult:Ut,normalizeForwardResult:pt,normalizeRedirectResult:zt,normalizeValidateResult:Vt},this._unknownHandler=i,this._invalidHandler=Bn(s),this._deprecatedHandler=a,this._identifyMissing=(p,c)=>!(p in c)||D(p,c),this._identifyRequired=l,this._preprocess=d,this._postprocess=f,this.cleanHistory()}cleanHistory(){this._hasDeprecationWarned=Cn()}normalize(t){let r={},o=[this._preprocess(t,this._utils)],u=()=>{for(;o.length!==0;){let i=o.shift(),s=this._applyNormalization(i,r);o.push(...s)}};u();for(let i of Object.keys(this._utils.schemas)){let s=this._utils.schemas[i];if(!(i in r)){let a=Mt(s.default(this._utils));"value"in a&&o.push({[i]:a.value})}}u();for(let i of Object.keys(this._utils.schemas)){if(!(i in r))continue;let s=this._utils.schemas[i],a=r[i],D=s.postprocess(a,this._utils);D!==he&&(this._applyValidation(D,i,s),r[i]=D)}return this._applyPostprocess(r),this._applyRequiredCheck(r),r}_applyNormalization(t,r){let n=[],{knownKeys:o,unknownKeys:u}=this._partitionOptionKeys(t);for(let i of o){let s=this._utils.schemas[i],a=s.preprocess(t[i],this._utils);this._applyValidation(a,i,s);let D=({from:p,to:c})=>{n.push(typeof c=="string"?{[c]:p}:{[c.key]:c.value})},l=({value:p,redirectTo:c})=>{let F=Ut(s.deprecated(p,this._utils),a,!0);if(F!==!1)if(F===!0)this._hasDeprecationWarned(i)||this._utils.logger.warn(this._deprecatedHandler(i,c,this._utils));else for(let{value:m}of F){let E={key:i,value:m};if(!this._hasDeprecationWarned(E)){let A=typeof c=="string"?{key:c,value:m}:c;this._utils.logger.warn(this._deprecatedHandler(E,A,this._utils))}}};pt(s.forward(a,this._utils),a).forEach(D);let f=zt(s.redirect(a,this._utils),a);if(f.redirect.forEach(D),"remain"in f){let p=f.remain;r[i]=i in r?s.overlap(r[i],p,this._utils):p,l({value:p})}for(let{from:p,to:c}of f.redirect)l({value:p,redirectTo:c})}for(let i of u){let s=t[i];this._applyUnknownHandler(i,s,r,(a,D)=>{n.push({[a]:D})})}return n}_applyRequiredCheck(t){for(let r of Object.keys(this._utils.schemas))if(this._identifyMissing(r,t)&&this._identifyRequired(r))throw this._invalidHandler(r,st,this._utils)}_partitionOptionKeys(t){let[r,n]=gn(Object.keys(t).filter(o=>!this._identifyMissing(o,t)),o=>o in this._utils.schemas);return{knownKeys:r,unknownKeys:n}}_applyValidation(t,r,n){let o=Vt(n.validate(t,this._utils),t);if(o!==!0)throw this._invalidHandler(r,o.value,this._utils)}_applyUnknownHandler(t,r,n,o){let u=this._unknownHandler(t,r,this._utils);if(u)for(let i of Object.keys(u)){if(this._identifyMissing(i,u))continue;let s=u[i];i in this._utils.schemas?o(i,s):n[i]=s}}_applyPostprocess(t){let r=this._postprocess(t,this._utils);if(r!==he){if(r.delete)for(let n of r.delete)delete t[n];if(r.override){let{knownKeys:n,unknownKeys:o}=this._partitionOptionKeys(r.override);for(let u of n){let i=r.override[u];this._applyValidation(i,u,this._utils.schemas[u]),t[u]=i}for(let u of o){let i=r.override[u];this._applyUnknownHandler(u,i,t,(s,a)=>{let D=this._utils.schemas[s];this._applyValidation(a,s,D),t[s]=a})}}}}};var Gt;function go(e,t,{logger:r=!1,isCLI:n=!1,passThrough:o=!1,FlagSchema:u,descriptor:i}={}){if(n){if(!u)throw new Error("'FlagSchema' option is required.");if(!i)throw new Error("'descriptor' option is required.")}else i=ie;let s=o?Array.isArray(o)?(f,p)=>o.includes(f)?{[f]:p}:void 0:(f,p)=>({[f]:p}):(f,p,c)=>{let{_:F,...m}=c.schemas;return at(f,p,{...c,schemas:m})},a=yo(t,{isCLI:n,FlagSchema:u}),D=new Et(a,{logger:r,unknown:s,descriptor:i}),l=r!==!1;l&&Gt&&(D._hasDeprecationWarned=Gt);let d=D.normalize(e);return l&&(Gt=D._hasDeprecationWarned),d}function yo(e,{isCLI:t,FlagSchema:r}){let n=[];t&&n.push(lt.create({name:"_"}));for(let o of e)n.push(Ao(o,{isCLI:t,optionInfos:e,FlagSchema:r})),o.alias&&t&&n.push(Dt.create({name:o.alias,sourceName:o.name}));return n}function Ao(e,{isCLI:t,optionInfos:r,FlagSchema:n}){let{name:o}=e,u={name:o},i,s={};switch(e.type){case"int":i=mt,t&&(u.preprocess=Number);break;case"string":i=Re;break;case"choice":i=dt,u.choices=e.choices.map(a=>a!=null&&a.redirect?{...a,redirect:{to:{key:e.name,value:a.redirect}}}:a);break;case"boolean":i=ft;break;case"flag":i=n,u.flags=r.flatMap(a=>[a.alias,a.description&&a.name,a.oppositeDescription&&`no-${a.name}`].filter(Boolean));break;case"path":i=Re;break;default:throw new Error(`Unexpected type ${e.type}`)}if(e.exception?u.validate=(a,D,l)=>e.exception(a)||D.validate(a,l):u.validate=(a,D,l)=>a===void 0||D.validate(a,l),e.redirect&&(s.redirect=a=>a?{to:typeof e.redirect=="string"?e.redirect:{key:e.redirect.option,value:e.redirect.value}}:void 0),e.deprecated&&(s.deprecated=!0),t&&!e.array){let a=u.preprocess||(D=>D);u.preprocess=(D,l,d)=>l.preprocess(a(Array.isArray(D)?y(!1,D,-1):D),d)}return e.array?ct.create({...t?{preprocess:a=>Array.isArray(a)?a:[a]}:{},...s,valueSchema:i.create(u)}):i.create({...u,...s})}var bn=go;var Bo=(e,t,r)=>{if(!(e&&t==null)){if(t.findLast)return t.findLast(r);for(let n=t.length-1;n>=0;n--){let o=t[n];if(r(o,n,t))return o}}},Kt=Bo;function qt(e,t){if(!t)throw new Error("parserName is required.");let r=Kt(!1,e,o=>o.parsers&&Object.prototype.hasOwnProperty.call(o.parsers,t));if(r)return r;let n=`Couldn't resolve parser "${t}".`;throw n+=" Plugins must be explicitly added to the standalone bundle.",new Pe(n)}function On(e,t){if(!t)throw new Error("astFormat is required.");let r=Kt(!1,e,o=>o.printers&&Object.prototype.hasOwnProperty.call(o.printers,t));if(r)return r;let n=`Couldn't find plugin for AST format "${t}".`;throw n+=" Plugins must be explicitly added to the standalone bundle.",new Pe(n)}function ht({plugins:e,parser:t}){let r=qt(e,t);return Jt(r,t)}function Jt(e,t){let r=e.parsers[t];return typeof r=="function"?r():r}function Sn(e,t){let r=e.printers[t];return typeof r=="function"?r():r}var Nn={astFormat:"estree",printer:{},originalText:void 0,locStart:null,locEnd:null};async function wo(e,t={}){var d;let r={...e};if(!r.parser)if(r.filepath){if(r.parser=un(r,{physicalFile:r.filepath}),!r.parser)throw new Ie(`No parser could be inferred for file "${r.filepath}".`)}else throw new Ie("No parser and no file path given, couldn't infer a parser.");let n=ot({plugins:e.plugins,showDeprecated:!0}).options,o={...Nn,...Object.fromEntries(n.filter(f=>f.default!==void 0).map(f=>[f.name,f.default]))},u=qt(r.plugins,r.parser),i=await Jt(u,r.parser);r.astFormat=i.astFormat,r.locEnd=i.locEnd,r.locStart=i.locStart;let s=(d=u.printers)!=null&&d[i.astFormat]?u:On(r.plugins,i.astFormat),a=await Sn(s,i.astFormat);r.printer=a;let D=s.defaultOptions?Object.fromEntries(Object.entries(s.defaultOptions).filter(([,f])=>f!==void 0)):{},l={...o,...D};for(let[f,p]of Object.entries(l))(r[f]===null||r[f]===void 0)&&(r[f]=p);return r.parser==="json"&&(r.trailingComma="none"),bn(r,n,{passThrough:Object.keys(Nn),...t})}var se=wo;var Vn=Me($n(),1);async function ko(e,t){let r=await ht(t),n=r.preprocess?r.preprocess(e,t):e;t.originalText=n;let o;try{o=await r.parse(n,t,t)}catch(u){Lo(u,e)}return{text:n,ast:o}}function Lo(e,t){let{loc:r}=e;if(r){let n=(0,Vn.codeFrameColumns)(t,r,{highlightCode:!0});throw e.message+=`
`+n,e.codeFrame=n,e}throw e}var ce=ko;async function Un(e,t,r,n,o){let{embeddedLanguageFormatting:u,printer:{embed:i,hasPrettierIgnore:s=()=>!1,getVisitorKeys:a}}=r;if(!i||u!=="auto")return;if(i.length>2)throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");let D=X(i.getVisitorKeys??a),l=[];p();let d=e.stack;for(let{print:c,node:F,pathStack:m}of l)try{e.stack=m;let E=await c(f,t,e,r);E&&o.set(F,E)}catch(E){if(globalThis.PRETTIER_DEBUG)throw E}e.stack=d;function f(c,F){return Po(c,F,r,n)}function p(){let{node:c}=e;if(c===null||typeof c!="object"||s(e))return;for(let m of D(c))Array.isArray(c[m])?e.each(p,m):e.call(p,m);let F=i(e,r);if(F){if(typeof F=="function"){l.push({print:F,node:c,pathStack:[...e.stack]});return}o.set(c,F)}}}async function Po(e,t,r,n){let o=await se({...r,...t,parentParser:r.parser,originalText:e},{passThrough:!0}),{ast:u}=await ce(e,o),i=await n(u,o);return Ze(i)}function Io(e,t){let{originalText:r,[Symbol.for("comments")]:n,locStart:o,locEnd:u,[Symbol.for("printedComments")]:i}=t,{node:s}=e,a=o(s),D=u(s);for(let l of n)o(l)>=a&&u(l)<=D&&i.add(l);return r.slice(a,D)}var zn=Io;async function Ye(e,t){({ast:e}=await Qt(e,t));let r=new Map,n=new Mr(e),o=tn(t),u=new Map;await Un(n,s,t,Ye,u);let i=await Gn(n,t,s,void 0,u);return en(t),i;function s(D,l){return D===void 0||D===n?a(l):Array.isArray(D)?n.call(()=>a(l),...D):n.call(()=>a(l),D)}function a(D){o(n);let l=n.node;if(l==null)return"";let d=l&&typeof l=="object"&&D===void 0;if(d&&r.has(l))return r.get(l);let f=Gn(n,t,s,D,u);return d&&r.set(l,f),f}}function Gn(e,t,r,n,o){var a;let{node:u}=e,{printer:i}=t,s;return(a=i.hasPrettierIgnore)!=null&&a.call(i,e)?s=zn(e,t):o.has(u)?s=o.get(u):s=i.print(e,t,r,n),u===t.cursorNode&&(s=Qe(s,D=>[ve,D,ve])),i.printComment&&(!i.willPrintOwnComments||!i.willPrintOwnComments(e,t))&&(s=Qr(e,s,t)),s}async function Qt(e,t){let r=e.comments??[];t[Symbol.for("comments")]=r,t[Symbol.for("tokens")]=e.tokens??[],t[Symbol.for("printedComments")]=new Set,Jr(e,t);let{printer:{preprocess:n}}=t;return e=n?await n(e,t):e,{ast:e,comments:r}}function Ro(e,t){let{cursorOffset:r,locStart:n,locEnd:o}=t,u=X(t.printer.getVisitorKeys),i=a=>n(a)<=r&&o(a)>=r,s=e;for(let a of Ur(e,{getVisitorKeys:u,filter:i}))s=a;return s}var Kn=Ro;function Yo(e,t){let{printer:{massageAstNode:r,getVisitorKeys:n}}=t;if(!r)return e;let o=X(n),u=r.ignoredProperties??new Set;return i(e);function i(s,a){if(!(s!==null&&typeof s=="object"))return s;if(Array.isArray(s))return s.map(f=>i(f,a)).filter(Boolean);let D={},l=new Set(o(s));for(let f in s)!Object.prototype.hasOwnProperty.call(s,f)||u.has(f)||(l.has(f)?D[f]=i(s[f],s):D[f]=s[f]);let d=r(s,D,a);if(d!==null)return d??D}}var qn=Yo;var jo=(e,t,r)=>{if(!(e&&t==null)){if(t.findLastIndex)return t.findLastIndex(r);for(let n=t.length-1;n>=0;n--){let o=t[n];if(r(o,n,t))return n}return-1}},Jn=jo;var Ho=({parser:e})=>e==="json"||e==="json5"||e==="jsonc"||e==="json-stringify";function Wo(e,t){let r=[e.node,...e.parentNodes],n=new Set([t.node,...t.parentNodes]);return r.find(o=>Qn.has(o.type)&&n.has(o))}function Xn(e){let t=Jn(!1,e,r=>r.type!=="Program"&&r.type!=="File");return t===-1?e:e.slice(0,t+1)}function Mo(e,t,{locStart:r,locEnd:n}){let o=e.node,u=t.node;if(o===u)return{startNode:o,endNode:u};let i=r(e.node);for(let a of Xn(t.parentNodes))if(r(a)>=i)u=a;else break;let s=n(t.node);for(let a of Xn(e.parentNodes)){if(n(a)<=s)o=a;else break;if(o===u)break}return{startNode:o,endNode:u}}function er(e,t,r,n,o=[],u){let{locStart:i,locEnd:s}=r,a=i(e),D=s(e);if(!(t>D||t<a||u==="rangeEnd"&&t===a||u==="rangeStart"&&t===D)){for(let l of ut(e,r)){let d=er(l,t,r,n,[e,...o],u);if(d)return d}if(!n||n(e,o[0]))return{node:e,parentNodes:o}}}function $o(e,t){return t!=="DeclareExportDeclaration"&&e!=="TypeParameterDeclaration"&&(e==="Directive"||e==="TypeAlias"||e==="TSExportAssignment"||e.startsWith("Declare")||e.startsWith("TSDeclare")||e.endsWith("Statement")||e.endsWith("Declaration"))}var Qn=new Set(["JsonRoot","ObjectExpression","ArrayExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","UnaryExpression","TemplateLiteral"]),Vo=new Set(["OperationDefinition","FragmentDefinition","VariableDefinition","TypeExtensionDefinition","ObjectTypeDefinition","FieldDefinition","DirectiveDefinition","EnumTypeDefinition","EnumValueDefinition","InputValueDefinition","InputObjectTypeDefinition","SchemaDefinition","OperationTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","ScalarTypeDefinition"]);function Zn(e,t,r){if(!t)return!1;switch(e.parser){case"flow":case"babel":case"babel-flow":case"babel-ts":case"typescript":case"acorn":case"espree":case"meriyah":case"__babel_estree":return $o(t.type,r==null?void 0:r.type);case"json":case"json5":case"jsonc":case"json-stringify":return Qn.has(t.type);case"graphql":return Vo.has(t.kind);case"vue":return t.tag!=="root"}return!1}function eu(e,t,r){let{rangeStart:n,rangeEnd:o,locStart:u,locEnd:i}=t;ke.ok(o>n);let s=e.slice(n,o).search(/\S/u),a=s===-1;if(!a)for(n+=s;o>n&&!/\S/u.test(e[o-1]);--o);let D=er(r,n,t,(p,c)=>Zn(t,p,c),[],"rangeStart"),l=a?D:er(r,o,t,p=>Zn(t,p),[],"rangeEnd");if(!D||!l)return{rangeStart:0,rangeEnd:0};let d,f;if(Ho(t)){let p=Wo(D,l);d=p,f=p}else({startNode:d,endNode:f}=Mo(D,l,t));return{rangeStart:Math.min(u(d),u(f)),rangeEnd:Math.max(i(d),i(f))}}var uu="\uFEFF",tu=Symbol("cursor");async function ou(e,t,r=0){if(!e||e.trim().length===0)return{formatted:"",cursorOffset:-1,comments:[]};let{ast:n,text:o}=await ce(e,t);t.cursorOffset>=0&&(t.cursorNode=Kn(n,t));let u=await Ye(n,t,r);r>0&&(u=Je([q,u],r,t.tabWidth));let i=Fe(u,t);if(r>0){let a=i.formatted.trim();i.cursorNodeStart!==void 0&&(i.cursorNodeStart-=i.formatted.indexOf(a)),i.formatted=a+Be(t.endOfLine)}let s=t[Symbol.for("comments")];if(t.cursorOffset>=0){let a,D,l,d,f;if(t.cursorNode&&i.cursorNodeText?(a=t.locStart(t.cursorNode),D=o.slice(a,t.locEnd(t.cursorNode)),l=t.cursorOffset-a,d=i.cursorNodeStart,f=i.cursorNodeText):(a=0,D=o,l=t.cursorOffset,d=0,f=i.formatted),D===f)return{formatted:i.formatted,cursorOffset:d+l,comments:s};let p=D.split("");p.splice(l,0,tu);let c=f.split(""),F=dr(p,c),m=d;for(let E of F)if(E.removed){if(E.value.includes(tu))break}else m+=E.count;return{formatted:i.formatted,cursorOffset:m,comments:s}}return{formatted:i.formatted,cursorOffset:-1,comments:s}}async function Uo(e,t){let{ast:r,text:n}=await ce(e,t),{rangeStart:o,rangeEnd:u}=eu(n,t,r),i=n.slice(o,u),s=Math.min(o,n.lastIndexOf(`
`,o)+1),a=n.slice(s,o).match(/^\s*/u)[0],D=me(a,t.tabWidth),l=await ou(i,{...t,rangeStart:0,rangeEnd:Number.POSITIVE_INFINITY,cursorOffset:t.cursorOffset>o&&t.cursorOffset<=u?t.cursorOffset-o:-1,endOfLine:"lf"},D),d=l.formatted.trimEnd(),{cursorOffset:f}=t;f>u?f+=d.length-i.length:l.cursorOffset>=0&&(f=l.cursorOffset+o);let p=n.slice(0,o)+d+n.slice(u);if(t.endOfLine!=="lf"){let c=Be(t.endOfLine);f>=0&&c===`\r
`&&(f+=wt(p.slice(0,f),`
`)),p=ne(!1,p,`
`,c)}return{formatted:p,cursorOffset:f,comments:l.comments}}function tr(e,t,r){return typeof t!="number"||Number.isNaN(t)||t<0||t>e.length?r:t}function ru(e,t){let{cursorOffset:r,rangeStart:n,rangeEnd:o}=t;return r=tr(e,r,-1),n=tr(e,n,0),o=tr(e,o,e.length),{...t,cursorOffset:r,rangeStart:n,rangeEnd:o}}function iu(e,t){let{cursorOffset:r,rangeStart:n,rangeEnd:o,endOfLine:u}=ru(e,t),i=e.charAt(0)===uu;if(i&&(e=e.slice(1),r--,n--,o--),u==="auto"&&(u=Fr(e)),e.includes("\r")){let s=a=>wt(e.slice(0,Math.max(a,0)),`\r
`);r-=s(r),n-=s(n),o-=s(o),e=mr(e)}return{hasBOM:i,text:e,options:ru(e,{...t,cursorOffset:r,rangeStart:n,rangeEnd:o,endOfLine:u})}}async function nu(e,t){let r=await ht(t);return!r.hasPragma||r.hasPragma(e)}async function rr(e,t){let{hasBOM:r,text:n,options:o}=iu(e,await se(t));if(o.rangeStart>=o.rangeEnd&&n!==""||o.requirePragma&&!await nu(n,o))return{formatted:e,cursorOffset:t.cursorOffset,comments:[]};let u;return o.rangeStart>0||o.rangeEnd<n.length?u=await Uo(n,o):(!o.requirePragma&&o.insertPragma&&o.printer.insertPragma&&!await nu(n,o)&&(n=o.printer.insertPragma(n)),u=await ou(n,o)),r&&(u.formatted=uu+u.formatted,u.cursorOffset>=0&&u.cursorOffset++),u}async function su(e,t,r){let{text:n,options:o}=iu(e,await se(t)),u=await ce(n,o);return r&&(r.preprocessForPrint&&(u.ast=await Qt(u.ast,o)),r.massage&&(u.ast=qn(u.ast,o))),u}async function au(e,t){t=await se(t);let r=await Ye(e,t);return Fe(r,t)}async function Du(e,t){let r=Or(e),{formatted:n}=await rr(r,{...t,parser:"__js_expression"});return n}async function lu(e,t){t=await se(t);let{ast:r}=await ce(e,t);return Ye(r,t)}async function cu(e,t){return Fe(e,await se(t))}var nr={};We(nr,{builders:()=>Go,printer:()=>Ko,utils:()=>qo});var Go={join:be,line:Ke,softline:vr,hardline:q,literalline:qe,group:_t,conditionalGroup:Ar,fill:Ge,lineSuffix:xe,lineSuffixBoundary:xr,cursor:ve,breakParent:de,ifBreak:Br,trim:_r,indent:De,indentIfBreak:wr,align:ae,addAlignmentToDoc:Je,markAsRoot:gr,dedentToRoot:Cr,dedent:yr,hardlineWithoutBreakParent:_e,literallineWithoutBreakParent:vt,label:br,concat:e=>e},Ko={printDocToString:Fe},qo={willBreak:Ir,traverseDoc:we,findInDoc:Xe,mapDoc:Ne,removeLines:Yr,stripTrailingHardline:Ze,replaceEndOfLine:jr,canBreak:Hr};var fu="3.3.3";var or={};We(or,{addDanglingComment:()=>re,addLeadingComment:()=>ue,addTrailingComment:()=>oe,getAlignmentSize:()=>me,getIndentSize:()=>pu,getMaxContinuousCount:()=>du,getNextNonSpaceNonCommentCharacter:()=>Fu,getNextNonSpaceNonCommentCharacterIndex:()=>si,getStringWidth:()=>Oe,hasNewline:()=>standalone_V,hasNewlineInRange:()=>mu,hasSpaces:()=>Eu,isNextLineEmpty:()=>ci,isNextLineEmptyAfterIndex:()=>gt,isPreviousLineEmpty:()=>Di,makeString:()=>hu,skip:()=>Ee,skipEverythingButNewLine:()=>nt,skipInlineComment:()=>Ce,skipNewline:()=>M,skipSpaces:()=>T,skipToLineEnd:()=>rt,skipTrailingComment:()=>ge,skipWhitespace:()=>zr});function Jo(e,t){if(t===!1)return!1;if(e.charAt(t)==="/"&&e.charAt(t+1)==="*"){for(let r=t+2;r<e.length;++r)if(e.charAt(r)==="*"&&e.charAt(r+1)==="/")return r+2}return t}var Ce=Jo;function Xo(e,t){return t===!1?!1:e.charAt(t)==="/"&&e.charAt(t+1)==="/"?nt(e,t):t}var ge=Xo;function Zo(e,t){let r=null,n=t;for(;n!==r;)r=n,n=T(e,n),n=Ce(e,n),n=ge(e,n),n=M(e,n);return n}var je=Zo;function Qo(e,t){let r=null,n=t;for(;n!==r;)r=n,n=rt(e,n),n=Ce(e,n),n=T(e,n);return n=ge(e,n),n=M(e,n),n!==!1&&standalone_V(e,n)}var gt=Qo;function ei(e,t){let r=e.lastIndexOf(`
`);return r===-1?0:me(e.slice(r+1).match(/^[\t ]*/u)[0],t)}var pu=ei;function ur(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}function ti(e,t){let r=e.match(new RegExp(`(${ur(t)})+`,"gu"));return r===null?0:r.reduce((n,o)=>Math.max(n,o.length/t.length),0)}var du=ti;function ri(e,t){let r=je(e,t);return r===!1?"":e.charAt(r)}var Fu=ri;function ni(e,t,r){for(let n=t;n<r;++n)if(e.charAt(n)===`
`)return!0;return!1}var mu=ni;function ui(e,t,r={}){return T(e,r.backwards?t-1:t,r)!==t}var Eu=ui;function oi(e,t,r){let n=t==='"'?"'":'"',u=ne(!1,e,/\\(.)|(["'])/gsu,(i,s,a)=>s===n?s:a===t?"\\"+a:a||(r&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s)?s:"\\"+s));return t+u+t}var hu=oi;function ii(e,t,r){return je(e,r(t))}function si(e,t){return arguments.length===2||typeof t=="number"?je(e,t):ii(...arguments)}function ai(e,t,r){return Le(e,r(t))}function Di(e,t){return arguments.length===2||typeof t=="number"?Le(e,t):ai(...arguments)}function li(e,t,r){return gt(e,r(t))}function ci(e,t){return arguments.length===2||typeof t=="number"?gt(e,t):li(...arguments)}function fe(e,t=1){return async(...r)=>{let n=r[t]??{},o=n.plugins??[];return r[t]={...n,plugins:Array.isArray(o)?o:Object.values(o)},e(...r)}}var Cu=fe(rr);async function gu(e,t){let{formatted:r}=await Cu(e,{...t,cursorOffset:-1});return r}async function fi(e,t){return await gu(e,t)===e}var pi=fe(ot,0),di={parse:fe(su),formatAST:fe(au),formatDoc:fe(Du),printToDoc:fe(lu),printDocToString:fe(cu)};var fc=(/* unused pure expression or super */ null && (ir));

;// ../../node_modules/@react-email/render/node_modules/prettier/plugins/html.mjs
var html_ni=Object.defineProperty;var html_Xr=t=>{throw TypeError(t)};var html_Jr=(t,e)=>{for(var r in e)html_ni(t,r,{get:e[r],enumerable:!0})};var html_Zr=(t,e,r)=>e.has(t)||html_Xr("Cannot "+r);var html_Q=(t,e,r)=>(html_Zr(t,e,"read from private field"),r?r.call(t):e.get(t)),html_en=(t,e,r)=>e.has(t)?html_Xr("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,r),html_tn=(t,e,r,n)=>(html_Zr(t,e,"write to private field"),n?n.call(t,r):e.set(t,r),r);var html_Yr={};html_Jr(html_Yr,{languages:()=>Ds,options:()=>ys,parsers:()=>html_Gr,printers:()=>html_$o});var html_si=(t,e,r,n)=>{if(!(t&&e==null))return e.replaceAll?e.replaceAll(r,n):r.global?e.replace(r,n):e.split(r).join(n)},w=html_si;var html_ke="string",html_Be="array",html_Le="cursor",html_ce="indent",html_pe="align",html_Fe="trim",html_te="group",html_he="fill",html_me="if-break",html_fe="indent-if-break",html_Ne="line-suffix",html_Pe="line-suffix-boundary",html_Y="line",html_Ie="label",html_de="break-parent",html_St=new Set([html_Le,html_ce,html_pe,html_Fe,html_te,html_he,html_me,html_fe,html_Ne,html_Pe,html_Y,html_Ie,html_de]);function html_ii(t){if(typeof t=="string")return html_ke;if(Array.isArray(t))return html_Be;if(!t)return;let{type:e}=t;if(html_St.has(e))return e}var html_Re=html_ii;var html_ai=t=>new Intl.ListFormat("en-US",{type:"disjunction"}).format(t);function html_oi(t){let e=t===null?"null":typeof t;if(e!=="string"&&e!=="object")return`Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;if(html_Re(t))throw new Error("doc is valid.");let r=Object.prototype.toString.call(t);if(r!=="[object Object]")return`Unexpected doc '${r}'.`;let n=html_ai([...html_St].map(s=>`'${s}'`));return`Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`}var html_lr=class extends Error{name="InvalidDocError";constructor(e){super(html_oi(e)),this.doc=e}},html_t=html_lr;var html_rn=()=>{},html_re=html_rn,html_Et=html_rn;function k(t){return html_re(t),{type:html_ce,contents:t}}function html_nn(t,e){return html_re(e),{type:html_pe,contents:e,n:t}}function html_(t,e={}){return html_re(t),html_Et(e.expandedStates,!0),{type:html_te,id:e.id,contents:t,break:!!e.shouldBreak,expandedStates:e.expandedStates}}function sn(t){return html_nn(Number.NEGATIVE_INFINITY,t)}function html_an(t){return html_nn({type:"root"},t)}function html_At(t){return html_Et(t),{type:html_he,parts:t}}function html_ge(t,e="",r={}){return html_re(t),e!==""&&html_re(e),{type:html_me,breakContents:t,flatContents:e,groupId:r.groupId}}function on(t,e){return html_re(t),{type:html_fe,contents:t,groupId:e.groupId,negate:e.negate}}var html_ne={type:html_de};var html_ui={type:html_Y,hard:!0},html_li={type:html_Y,hard:!0,literal:!0},E={type:html_Y},v={type:html_Y,soft:!0},html_S=[html_ui,html_ne],html_un=[html_li,html_ne];function html_q(t,e){html_re(t),html_Et(e);let r=[];for(let n=0;n<e.length;n++)n!==0&&r.push(t),r.push(e[n]);return r}var html_ci=(t,e,r)=>{if(!(t&&e==null))return Array.isArray(e)||typeof e=="string"?e[r<0?e.length+r:r]:e.at(r)},html_X=html_ci;function html_Dt(t,e){if(typeof t=="string")return e(t);let r=new Map;return n(t);function n(i){if(r.has(i))return r.get(i);let a=s(i);return r.set(i,a),a}function s(i){switch(html_Re(i)){case html_Be:return e(i.map(n));case html_he:return e({...i,parts:i.parts.map(n)});case html_me:return e({...i,breakContents:n(i.breakContents),flatContents:n(i.flatContents)});case html_te:{let{expandedStates:a,contents:o}=i;return a?(a=a.map(n),o=a[0]):o=n(o),e({...i,contents:o,expandedStates:a})}case html_pe:case html_ce:case html_fe:case html_Ie:case html_Ne:return e({...i,contents:n(i.contents)});case html_ke:case html_Le:case html_Fe:case html_Pe:case html_Y:case html_de:return e(i);default:throw new html_t(i)}}}function html_pi(t){switch(html_Re(t)){case html_he:if(t.parts.every(e=>e===""))return"";break;case html_te:if(!t.contents&&!t.id&&!t.break&&!t.expandedStates)return"";if(t.contents.type===html_te&&t.contents.id===t.id&&t.contents.break===t.break&&t.contents.expandedStates===t.expandedStates)return t.contents;break;case html_pe:case html_ce:case html_fe:case html_Ne:if(!t.contents)return"";break;case html_me:if(!t.flatContents&&!t.breakContents)return"";break;case html_Be:{let e=[];for(let r of t){if(!r)continue;let[n,...s]=Array.isArray(r)?r:[r];typeof n=="string"&&typeof html_X(!1,e,-1)=="string"?e[e.length-1]+=n:e.push(n),e.push(...s)}return e.length===0?"":e.length===1?e[0]:e}case html_ke:case html_Le:case html_Fe:case html_Pe:case html_Y:case html_Ie:case html_de:break;default:throw new html_t(t)}return t}function html_ln(t){return html_Dt(t,e=>html_pi(e))}function html_B(t,e=html_un){return html_Dt(t,r=>typeof r=="string"?html_q(e,r.split(`
`)):r)}var html_vt="'",html_cn='"';function html_hi(t,e){let r=e===!0||e===html_vt?html_vt:html_cn,n=r===html_vt?html_cn:html_vt,s=0,i=0;for(let a of t)a===r?s++:a===n&&i++;return s>i?n:r}var html_pn=html_hi;function html_cr(t){if(typeof t!="string")throw new TypeError("Expected a string");return t.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var html_H,html_pr=class{constructor(e){html_en(this,html_H);html_tn(this,html_H,new Set(e))}getLeadingWhitespaceCount(e){let r=html_Q(this,html_H),n=0;for(let s=0;s<e.length&&r.has(e.charAt(s));s++)n++;return n}getTrailingWhitespaceCount(e){let r=html_Q(this,html_H),n=0;for(let s=e.length-1;s>=0&&r.has(e.charAt(s));s--)n++;return n}getLeadingWhitespace(e){let r=this.getLeadingWhitespaceCount(e);return e.slice(0,r)}getTrailingWhitespace(e){let r=this.getTrailingWhitespaceCount(e);return e.slice(e.length-r)}hasLeadingWhitespace(e){return html_Q(this,html_H).has(e.charAt(0))}hasTrailingWhitespace(e){return html_Q(this,html_H).has(html_X(!1,e,-1))}trimStart(e){let r=this.getLeadingWhitespaceCount(e);return e.slice(r)}trimEnd(e){let r=this.getTrailingWhitespaceCount(e);return e.slice(0,e.length-r)}trim(e){return this.trimEnd(this.trimStart(e))}split(e,r=!1){let n=`[${html_cr([...html_Q(this,html_H)].join(""))}]+`,s=new RegExp(r?`(${n})`:n,"u");return e.split(s)}hasWhitespaceCharacter(e){let r=html_Q(this,html_H);return Array.prototype.some.call(e,n=>r.has(n))}hasNonWhitespaceCharacter(e){let r=html_Q(this,html_H);return Array.prototype.some.call(e,n=>!r.has(n))}isWhitespaceOnly(e){let r=html_Q(this,html_H);return Array.prototype.every.call(e,n=>r.has(n))}};html_H=new WeakMap;var html_hn=html_pr;var mi=["	",`
`,"\f","\r"," "],html_fi=new html_hn(mi),html_N=html_fi;var html_hr=class extends Error{name="UnexpectedNodeError";constructor(e,r,n="type"){super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`),this.node=e}},html_mn=html_hr;function html_di(t){return(t==null?void 0:t.type)==="front-matter"}var html_$e=html_di;var gi=new Set(["sourceSpan","startSourceSpan","endSourceSpan","nameSpan","valueSpan","keySpan","tagDefinition","tokens","valueTokens","switchValueSourceSpan","expSourceSpan","valueSourceSpan"]),Ci=new Set(["if","else if","for","switch","case"]);function html_fn(t,e){var r;if(t.type==="text"||t.type==="comment"||html_$e(t)||t.type==="yaml"||t.type==="toml")return null;if(t.type==="attribute"&&delete e.value,t.type==="docType"&&delete e.value,t.type==="angularControlFlowBlock"&&((r=t.parameters)!=null&&r.children))for(let n of e.parameters.children)Ci.has(t.name)?delete n.expression:n.expression=n.expression.trim();t.type==="angularIcuExpression"&&(e.switchValue=t.switchValue.trim()),t.type==="angularLetDeclarationInitializer"&&delete e.value}html_fn.ignoredProperties=gi;var html_dn=html_fn;async function Si(t,e){if(t.language==="yaml"){let r=t.value.trim(),n=r?await e(r,{parser:"yaml"}):"";return html_an([t.startDelimiter,t.explicitLanguage,html_S,n,n?html_S:"",t.endDelimiter])}}var html_gn=Si;function html_Ce(t,e=!0){return[k([v,t]),e?v:""]}function html_j(t,e){let r=t.type==="NGRoot"?t.node.type==="NGMicrosyntax"&&t.node.body.length===1&&t.node.body[0].type==="NGMicrosyntaxExpression"?t.node.body[0].expression:t.node:t.type==="JsExpressionRoot"?t.node:t;return r&&(r.type==="ObjectExpression"||r.type==="ArrayExpression"||(e.parser==="__vue_expression"||e.parser==="__vue_ts_expression")&&(r.type==="TemplateLiteral"||r.type==="StringLiteral"))}async function html_T(t,e,r,n){r={__isInHtmlAttribute:!0,__embeddedInHtml:!0,...r};let s=!0;n&&(r.__onHtmlBindingRoot=(a,o)=>{s=n(a,o)});let i=await e(t,r,e);return s?html_(i):html_Ce(i)}function _i(t,e,r,n){let{node:s}=r,i=n.originalText.slice(s.sourceSpan.start.offset,s.sourceSpan.end.offset);return/^\s*$/u.test(i)?"":html_T(i,t,{parser:"__ng_directive",__isInHtmlAttribute:!1},html_j)}var html_Cn=_i;var Ei=t=>String(t).split(/[/\\]/u).pop();function html_Sn(t,e){if(!e)return;let r=Ei(e).toLowerCase();return t.find(({filenames:n})=>n==null?void 0:n.some(s=>s.toLowerCase()===r))??t.find(({extensions:n})=>n==null?void 0:n.some(s=>r.endsWith(s)))}function Ai(t,e){if(e)return t.find(({name:r})=>r.toLowerCase()===e)??t.find(({aliases:r})=>r==null?void 0:r.includes(e))??t.find(({extensions:r})=>r==null?void 0:r.includes(`.${e}`))}function html_Di(t,e){let r=t.plugins.flatMap(s=>s.languages??[]),n=Ai(r,e.language)??html_Sn(r,e.physicalFile)??html_Sn(r,e.file)??(e.physicalFile,void 0);return n==null?void 0:n.parsers[0]}var html_Oe=html_Di;var html_n="inline",html_En={area:"none",base:"none",basefont:"none",datalist:"none",head:"none",link:"none",meta:"none",noembed:"none",noframes:"none",param:"block",rp:"none",script:"block",style:"none",template:"inline",title:"none",html:"block",body:"block",address:"block",blockquote:"block",center:"block",dialog:"block",div:"block",figure:"block",figcaption:"block",footer:"block",form:"block",header:"block",hr:"block",legend:"block",listing:"block",main:"block",p:"block",plaintext:"block",pre:"block",search:"block",xmp:"block",slot:"contents",ruby:"ruby",rt:"ruby-text",article:"block",aside:"block",h1:"block",h2:"block",h3:"block",h4:"block",h5:"block",h6:"block",hgroup:"block",nav:"block",section:"block",dir:"block",dd:"block",dl:"block",dt:"block",menu:"block",ol:"block",ul:"block",li:"list-item",table:"table",caption:"table-caption",colgroup:"table-column-group",col:"table-column",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",tr:"table-row",td:"table-cell",th:"table-cell",input:"inline-block",button:"inline-block",fieldset:"block",marquee:"inline-block",source:"block",track:"block",details:"block",summary:"block",meter:"inline-block",progress:"inline-block",object:"inline-block",video:"inline-block",audio:"inline-block",select:"inline-block",option:"block",optgroup:"block"},html_An="normal",html_Dn={listing:"pre",plaintext:"pre",pre:"pre",xmp:"pre",nobr:"nowrap",table:"initial",textarea:"pre-wrap"};function vi(t){return t.type==="element"&&!t.hasExplicitNamespace&&!["html","svg"].includes(t.namespace)}var html_Se=vi;var yi=t=>w(!1,t,/^[\t\f\r ]*\n/gu,""),html_mr=t=>yi(html_N.trimEnd(t)),html_vn=t=>{let e=t,r=html_N.getLeadingWhitespace(e);r&&(e=e.slice(r.length));let n=html_N.getTrailingWhitespace(e);return n&&(e=e.slice(0,-n.length)),{leadingWhitespace:r,trailingWhitespace:n,text:e}};function yt(t,e){return!!(t.type==="ieConditionalComment"&&t.lastChild&&!t.lastChild.isSelfClosing&&!t.lastChild.endSourceSpan||t.type==="ieConditionalComment"&&!t.complete||html_e(t)&&t.children.some(r=>r.type!=="text"&&r.type!=="interpolation")||html_Tt(t,e)&&!html_U(t)&&t.type!=="interpolation")}function html_Ee(t){return t.type==="attribute"||!t.parent||!t.prev?!1:wi(t.prev)}function wi(t){return t.type==="comment"&&t.value.trim()==="prettier-ignore"}function $(t){return t.type==="text"||t.type==="comment"}function html_U(t){return t.type==="element"&&(t.fullName==="script"||t.fullName==="style"||t.fullName==="svg:style"||t.fullName==="svg:script"||html_Se(t)&&(t.name==="script"||t.name==="style"))}function html_yn(t){return t.children&&!html_U(t)}function html_wn(t){return html_U(t)||t.type==="interpolation"||html_fr(t)}function html_fr(t){return Rn(t).startsWith("pre")}function html_bn(t,e){var s,i;let r=n();if(r&&!t.prev&&((i=(s=t.parent)==null?void 0:s.tagDefinition)!=null&&i.ignoreFirstLf))return t.type==="interpolation";return r;function n(){return html_$e(t)||t.type==="angularControlFlowBlock"?!1:(t.type==="text"||t.type==="interpolation")&&t.prev&&(t.prev.type==="text"||t.prev.type==="interpolation")?!0:!t.parent||t.parent.cssDisplay==="none"?!1:html_e(t.parent)?!0:!(!t.prev&&(t.parent.type==="root"||html_e(t)&&t.parent||html_U(t.parent)||html_Je(t.parent,e)||!Li(t.parent.cssDisplay))||t.prev&&!Pi(t.prev.cssDisplay))}}function html_Tn(t,e){return html_$e(t)||t.type==="angularControlFlowBlock"?!1:(t.type==="text"||t.type==="interpolation")&&t.next&&(t.next.type==="text"||t.next.type==="interpolation")?!0:!t.parent||t.parent.cssDisplay==="none"?!1:html_e(t.parent)?!0:!(!t.next&&(t.parent.type==="root"||html_e(t)&&t.parent||html_U(t.parent)||html_Je(t.parent,e)||!Fi(t.parent.cssDisplay))||t.next&&!Ni(t.next.cssDisplay))}function html_xn(t){return Ii(t.cssDisplay)&&!html_U(t)}function html_Qe(t){return html_$e(t)||t.next&&t.sourceSpan.end&&t.sourceSpan.end.line+1<t.next.sourceSpan.start.line}function html_kn(t){return html_dr(t)||t.type==="element"&&t.children.length>0&&(["body","script","style"].includes(t.name)||t.children.some(e=>Ti(e)))||t.firstChild&&t.firstChild===t.lastChild&&t.firstChild.type!=="text"&&Ln(t.firstChild)&&(!t.lastChild.isTrailingSpaceSensitive||html_Fn(t.lastChild))}function html_dr(t){return t.type==="element"&&t.children.length>0&&(["html","head","ul","ol","select"].includes(t.name)||t.cssDisplay.startsWith("table")&&t.cssDisplay!=="table-cell")}function html_wt(t){return html_Nn(t)||t.prev&&bi(t.prev)||html_Bn(t)}function bi(t){return html_Nn(t)||t.type==="element"&&t.fullName==="br"||html_Bn(t)}function html_Bn(t){return Ln(t)&&html_Fn(t)}function Ln(t){return t.hasLeadingSpaces&&(t.prev?t.prev.sourceSpan.end.line<t.sourceSpan.start.line:t.parent.type==="root"||t.parent.startSourceSpan.end.line<t.sourceSpan.start.line)}function html_Fn(t){return t.hasTrailingSpaces&&(t.next?t.next.sourceSpan.start.line>t.sourceSpan.end.line:t.parent.type==="root"||t.parent.endSourceSpan&&t.parent.endSourceSpan.start.line>t.sourceSpan.end.line)}function html_Nn(t){switch(t.type){case"ieConditionalComment":case"comment":case"directive":return!0;case"element":return["script","select"].includes(t.name)}return!1}function html_bt(t){return t.lastChild?html_bt(t.lastChild):t}function Ti(t){var e;return(e=t.children)==null?void 0:e.some(r=>r.type!=="text")}function html_Pn(t){if(t)switch(t){case"module":case"text/javascript":case"text/babel":case"application/javascript":return"babel";case"application/x-typescript":return"typescript";case"text/markdown":return"markdown";case"text/html":return"html";case"text/x-handlebars-template":return"glimmer";default:if(t.endsWith("json")||t.endsWith("importmap")||t==="speculationrules")return"json"}}function xi(t,e){let{name:r,attrMap:n}=t;if(r!=="script"||Object.prototype.hasOwnProperty.call(n,"src"))return;let{type:s,lang:i}=t.attrMap;return!i&&!s?"babel":html_Oe(e,{language:i})??html_Pn(s)}function ki(t,e){if(!html_Tt(t,e))return;let{attrMap:r}=t;if(Object.prototype.hasOwnProperty.call(r,"src"))return;let{type:n,lang:s}=r;return html_Oe(e,{language:s})??html_Pn(n)}function Bi(t,e){if(t.name!=="style")return;let{lang:r}=t.attrMap;return r?html_Oe(e,{language:r}):"css"}function html_gr(t,e){return xi(t,e)??Bi(t,e)??ki(t,e)}function html_Xe(t){return t==="block"||t==="list-item"||t.startsWith("table")}function Li(t){return!html_Xe(t)&&t!=="inline-block"}function Fi(t){return!html_Xe(t)&&t!=="inline-block"}function Ni(t){return!html_Xe(t)}function Pi(t){return!html_Xe(t)}function Ii(t){return!html_Xe(t)&&t!=="inline-block"}function html_e(t){return Rn(t).startsWith("pre")}function Ri(t,e){let r=t;for(;r;){if(e(r))return!0;r=r.parent}return!1}function In(t,e){var n;if(html_Ae(t,e))return"block";if(((n=t.prev)==null?void 0:n.type)==="comment"){let s=t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);if(s)return s[1]}let r=!1;if(t.type==="element"&&t.namespace==="svg")if(Ri(t,s=>s.fullName==="svg:foreignObject"))r=!0;else return t.name==="svg"?"inline-block":"block";switch(e.htmlWhitespaceSensitivity){case"strict":return"inline";case"ignore":return"block";default:return t.type==="element"&&(!t.namespace||r||html_Se(t))&&html_En[t.name]||html_n}}function Rn(t){return t.type==="element"&&(!t.namespace||html_Se(t))&&html_Dn[t.name]||html_An}function $i(t){let e=Number.POSITIVE_INFINITY;for(let r of t.split(`
`)){if(r.length===0)continue;let n=html_N.getLeadingWhitespaceCount(r);if(n===0)return 0;r.length!==n&&n<e&&(e=n)}return e===Number.POSITIVE_INFINITY?0:e}function html_Cr(t,e=$i(t)){return e===0?t:t.split(`
`).map(r=>r.slice(e)).join(`
`)}function html_Sr(t){return w(!1,w(!1,t,"&apos;","'"),"&quot;",'"')}function html_P(t){return html_Sr(t.value)}var Oi=new Set(["template","style","script"]);function html_Je(t,e){return html_Ae(t,e)&&!Oi.has(t.fullName)}function html_Ae(t,e){return e.parser==="vue"&&t.type==="element"&&t.parent.type==="root"&&t.fullName.toLowerCase()!=="html"}function html_Tt(t,e){return html_Ae(t,e)&&(html_Je(t,e)||t.attrMap.lang&&t.attrMap.lang!=="html")}function html_$n(t){let e=t.fullName;return e.charAt(0)==="#"||e==="slot-scope"||e==="v-slot"||e.startsWith("v-slot:")}function html_On(t,e){let r=t.parent;if(!html_Ae(r,e))return!1;let n=r.fullName,s=t.fullName;return n==="script"&&s==="setup"||n==="style"&&s==="vars"}function html_xt(t,e=t.value){return t.parent.isWhitespaceSensitive?t.parent.isIndentationSensitive?html_B(e):html_B(html_Cr(html_mr(e)),html_S):html_q(E,html_N.split(e))}function html_kt(t,e){return html_Ae(t,e)&&t.name==="script"}var html_r=/\{\{(.+?)\}\}/su;async function Mn(t,e){let r=[];for(let[n,s]of t.split(html_r).entries())if(n%2===0)r.push(html_B(s));else try{r.push(html_(["{{",k([E,await html_T(s,e,{parser:"__ng_interpolation",__isInHtmlInterpolation:!0})]),E,"}}"]))}catch{r.push("{{",html_B(s),"}}")}return r}function html_Er({parser:t}){return(e,r,n)=>html_T(html_P(n.node),e,{parser:t},html_j)}var Mi=html_Er({parser:"__ng_action"}),qi=html_Er({parser:"__ng_binding"}),Hi=html_Er({parser:"__ng_directive"});function Vi(t,e){if(e.parser!=="angular")return;let{node:r}=t,n=r.fullName;if(n.startsWith("(")&&n.endsWith(")")||n.startsWith("on-"))return Mi;if(n.startsWith("[")&&n.endsWith("]")||/^bind(?:on)?-/u.test(n)||/^ng-(?:if|show|hide|class|style)$/u.test(n))return qi;if(n.startsWith("*"))return Hi;let s=html_P(r);if(/^i18n(?:-.+)?$/u.test(n))return()=>html_Ce(html_At(html_xt(r,s.trim())),!s.includes("@@"));if(html_r.test(s))return i=>Mn(s,i)}var html_qn=Vi;function Ui(t,e){let{node:r}=t,n=html_P(r);if(r.fullName==="class"&&!e.parentParser&&!n.includes("{{"))return()=>n.trim().split(/\s+/u).join(" ")}var Hn=Ui;function html_Vn(t){return t==="	"||t===`
`||t==="\f"||t==="\r"||t===" "}var Wi=/^[ \t\n\r\u000c]+/,zi=/^[, \t\n\r\u000c]+/,Gi=/^[^ \t\n\r\u000c]+/,Yi=/[,]+$/,html_Un=/^\d+$/,ji=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;function Ki(t){let e=t.length,r,n,s,i,a,o=0,u;function p(C){let A,D=C.exec(t.substring(o));if(D)return[A]=D,o+=A.length,A}let l=[];for(;;){if(p(zi),o>=e){if(l.length===0)throw new Error("Must contain one or more image candidate strings.");return l}u=o,r=p(Gi),n=[],r.slice(-1)===","?(r=r.replace(Yi,""),d()):f()}function f(){for(p(Wi),s="",i="in descriptor";;){if(a=t.charAt(o),i==="in descriptor")if(html_Vn(a))s&&(n.push(s),s="",i="after descriptor");else if(a===","){o+=1,s&&n.push(s),d();return}else if(a==="(")s+=a,i="in parens";else if(a===""){s&&n.push(s),d();return}else s+=a;else if(i==="in parens")if(a===")")s+=a,i="in descriptor";else if(a===""){n.push(s),d();return}else s+=a;else if(i==="after descriptor"&&!html_Vn(a))if(a===""){d();return}else i="in descriptor",o-=1;o+=1}}function d(){let C=!1,A,D,R,F,c={},g,y,M,x,V;for(F=0;F<n.length;F++)g=n[F],y=g[g.length-1],M=g.substring(0,g.length-1),x=parseInt(M,10),V=parseFloat(M),html_Un.test(M)&&y==="w"?((A||D)&&(C=!0),x===0?C=!0:A=x):ji.test(M)&&y==="x"?((A||D||R)&&(C=!0),V<0?C=!0:D=V):html_Un.test(M)&&y==="h"?((R||D)&&(C=!0),x===0?C=!0:R=x):C=!0;if(!C)c.source={value:r,startOffset:u},A&&(c.width={value:A}),D&&(c.density={value:D}),R&&(c.height={value:R}),l.push(c);else throw new Error(`Invalid srcset descriptor found in "${t}" at "${g}".`)}}var Wn=Ki;function Qi(t){if(t.node.fullName==="srcset"&&(t.parent.fullName==="img"||t.parent.fullName==="source"))return()=>Ji(html_P(t.node))}var html_zn={width:"w",height:"h",density:"x"},Xi=Object.keys(html_zn);function Ji(t){let e=Wn(t),r=Xi.filter(l=>e.some(f=>Object.prototype.hasOwnProperty.call(f,l)));if(r.length>1)throw new Error("Mixed descriptor in srcset is not supported");let[n]=r,s=html_zn[n],i=e.map(l=>l.source.value),a=Math.max(...i.map(l=>l.length)),o=e.map(l=>l[n]?String(l[n].value):""),u=o.map(l=>{let f=l.indexOf(".");return f===-1?l.length:f}),p=Math.max(...u);return html_Ce(html_q([",",E],i.map((l,f)=>{let d=[l],C=o[f];if(C){let A=a-l.length+1,D=p-u[f],R=" ".repeat(A+D);d.push(html_ge(R," "),C+s)}return d})))}var html_Gn=Qi;function Yn(t,e){let{node:r}=t,n=html_P(t.node).trim();if(r.fullName==="style"&&!e.parentParser&&!n.includes("{{"))return async s=>html_Ce(await s(n,{parser:"css",__isHTMLStyleAttribute:!0}))}var html_Ar=new WeakMap;function Zi(t,e){let{root:r}=t;return html_Ar.has(r)||html_Ar.set(r,r.children.some(n=>html_kt(n,e)&&["ts","typescript"].includes(n.attrMap.lang))),html_Ar.get(r)}var html_Me=Zi;function jn(t,e,r){let{node:n}=r,s=html_P(n);return html_T(`type T<${s}> = any`,t,{parser:"babel-ts",__isEmbeddedTypescriptGenericParameters:!0},html_j)}function html_Kn(t,e,{parseWithTs:r}){return html_T(`function _(${t}) {}`,e,{parser:r?"babel-ts":"babel",__isVueBindings:!0})}function html_Qn(t){let e=/^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/u,r=/^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*'\]|\["[^"]*"\]|\[\d+\]|\[[$_a-z][\w$]*\])*$/iu,n=t.trim();return e.test(n)||r.test(n)}async function html_Xn(t,e,r,n){let s=html_P(r.node),{left:i,operator:a,right:o}=ea(s),u=html_Me(r,n);return[html_(await html_T(`function _(${i}) {}`,t,{parser:u?"babel-ts":"babel",__isVueForBindingLeft:!0}))," ",a," ",await html_T(o,t,{parser:u?"__ts_expression":"__js_expression"})]}function ea(t){let e=/(.*?)\s+(in|of)\s+(.*)/su,r=/,([^,\]}]*)(?:,([^,\]}]*))?$/u,n=/^\(|\)$/gu,s=t.match(e);if(!s)return;let i={};if(i.for=s[3].trim(),!i.for)return;let a=w(!1,s[1].trim(),n,""),o=a.match(r);o?(i.alias=a.replace(r,""),i.iterator1=o[1].trim(),o[2]&&(i.iterator2=o[2].trim())):i.alias=a;let u=[i.alias,i.iterator1,i.iterator2];if(!u.some((p,l)=>!p&&(l===0||u.slice(l+1).some(Boolean))))return{left:u.filter(Boolean).join(","),operator:s[2],right:i.for}}function ta(t,e){if(e.parser!=="vue")return;let{node:r}=t,n=r.fullName;if(n==="v-for")return html_Xn;if(n==="generic"&&html_kt(r.parent,e))return jn;let s=html_P(r),i=html_Me(t,e);if(html_$n(r)||html_On(r,e))return a=>html_Kn(s,a,{parseWithTs:i});if(n.startsWith("@")||n.startsWith("v-on:"))return a=>ra(s,a,{parseWithTs:i});if(n.startsWith(":")||n.startsWith("v-bind:"))return a=>na(s,a,{parseWithTs:i});if(n.startsWith("v-"))return a=>html_Jn(s,a,{parseWithTs:i})}function ra(t,e,{parseWithTs:r}){return html_Qn(t)?html_Jn(t,e,{parseWithTs:r}):html_T(t,e,{parser:r?"__vue_ts_event_binding":"__vue_event_binding"},html_j)}function na(t,e,{parseWithTs:r}){return html_T(t,e,{parser:r?"__vue_ts_expression":"__vue_expression"},html_j)}function html_Jn(t,e,{parseWithTs:r}){return html_T(t,e,{parser:r?"__ts_expression":"__js_expression"},html_j)}var html_Zn=ta;function sa(t,e){let{node:r}=t;if(r.value){if(/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset,r.valueSpan.end.offset))||e.parser==="lwc"&&r.value.startsWith("{")&&r.value.endsWith("}"))return[r.rawName,"=",r.value];for(let n of[html_Gn,Yn,Hn,html_Zn,html_qn]){let s=n(t,e);if(s)return ia(s)}}}function ia(t){return async(e,r,n,s)=>{let i=await t(e,r,n,s);if(i)return i=html_Dt(i,a=>typeof a=="string"?w(!1,a,'"',"&quot;"):a),[n.node.rawName,'="',html_(i),'"']}}var es=sa;var ts=new Proxy(()=>{},{get:()=>ts}),html_Dr=ts;function aa(t){return Array.isArray(t)&&t.length>0}var html_qe=aa;function html_se(t){return t.sourceSpan.start.offset}function html_ie(t){return t.sourceSpan.end.offset}function html_Ze(t,e){return[t.isSelfClosing?"":oa(t,e),html_De(t,e)]}function oa(t,e){return t.lastChild&&html_we(t.lastChild)?"":[ua(t,e),html_Bt(t,e)]}function html_De(t,e){return(t.next?html_K(t.next):ye(t.parent))?"":[html_ve(t,e),html_W(t,e)]}function ua(t,e){return ye(t)?html_ve(t.lastChild,e):""}function html_W(t,e){return html_we(t)?html_Bt(t.parent,e):html_et(t)?html_Lt(t.next):""}function html_Bt(t,e){if(html_Dr(!t.isSelfClosing),rs(t,e))return"";switch(t.type){case"ieConditionalComment":return"<!";case"element":if(t.hasHtmComponentClosingTag)return"<//";default:return`</${t.rawName}`}}function html_ve(t,e){if(rs(t,e))return"";switch(t.type){case"ieConditionalComment":case"ieConditionalEndComment":return"[endif]-->";case"ieConditionalStartComment":return"]><!-->";case"interpolation":return"}}";case"angularIcuExpression":return"}";case"element":if(t.isSelfClosing)return"/>";default:return">"}}function rs(t,e){return!t.isSelfClosing&&!t.endSourceSpan&&(html_Ee(t)||yt(t.parent,e))}function html_K(t){return t.prev&&t.prev.type!=="docType"&&t.type!=="angularControlFlowBlock"&&!$(t.prev)&&t.isLeadingSpaceSensitive&&!t.hasLeadingSpaces}function ye(t){var e;return((e=t.lastChild)==null?void 0:e.isTrailingSpaceSensitive)&&!t.lastChild.hasTrailingSpaces&&!$(html_bt(t.lastChild))&&!html_e(t)}function html_we(t){return!t.next&&!t.hasTrailingSpaces&&t.isTrailingSpaceSensitive&&$(html_bt(t))}function html_et(t){return t.next&&!$(t.next)&&$(t)&&t.isTrailingSpaceSensitive&&!t.hasTrailingSpaces}function la(t){let e=t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);return e?e[1]?e[1].split(/\s+/u):!0:!1}function html_tt(t){return!t.prev&&t.isLeadingSpaceSensitive&&!t.hasLeadingSpaces}function ca(t,e,r){var f;let{node:n}=t;if(!html_qe(n.attrs))return n.isSelfClosing?" ":"";let s=((f=n.prev)==null?void 0:f.type)==="comment"&&la(n.prev.value),i=typeof s=="boolean"?()=>s:Array.isArray(s)?d=>s.includes(d.rawName):()=>!1,a=t.map(({node:d})=>i(d)?html_B(e.originalText.slice(html_se(d),html_ie(d))):r(),"attrs"),o=n.type==="element"&&n.fullName==="script"&&n.attrs.length===1&&n.attrs[0].fullName==="src"&&n.children.length===0,p=e.singleAttributePerLine&&n.attrs.length>1&&!html_Ae(n,e)?html_S:E,l=[k([o?" ":E,html_q(p,a)])];return n.firstChild&&html_tt(n.firstChild)||n.isSelfClosing&&ye(n.parent)||o?l.push(n.isSelfClosing?" ":""):l.push(e.bracketSameLine?n.isSelfClosing?" ":"":n.isSelfClosing?E:v),l}function pa(t){return t.firstChild&&html_tt(t.firstChild)?"":html_Ft(t)}function html_rt(t,e,r){let{node:n}=t;return[html_be(n,e),ca(t,e,r),n.isSelfClosing?"":pa(n)]}function html_be(t,e){return t.prev&&html_et(t.prev)?"":[html_z(t,e),html_Lt(t)]}function html_z(t,e){return html_tt(t)?html_Ft(t.parent):html_K(t)?html_ve(t.prev,e):""}function html_Lt(t){switch(t.type){case"ieConditionalComment":case"ieConditionalStartComment":return`<!--[if ${t.condition}`;case"ieConditionalEndComment":return"<!--<!";case"interpolation":return"{{";case"docType":return t.value==="html"?"<!doctype":"<!DOCTYPE";case"angularIcuExpression":return"{";case"element":if(t.condition)return`<!--[if ${t.condition}]><!--><${t.rawName}`;default:return`<${t.rawName}`}}function html_Ft(t){switch(html_Dr(!t.isSelfClosing),t.type){case"ieConditionalComment":return"]>";case"element":if(t.condition)return"><!--<![endif]-->";default:return">"}}function ha(t,e){if(!t.endSourceSpan)return"";let r=t.startSourceSpan.end.offset;t.firstChild&&html_tt(t.firstChild)&&(r-=html_Ft(t).length);let n=t.endSourceSpan.start.offset;return t.lastChild&&html_we(t.lastChild)?n+=html_Bt(t,e).length:ye(t)&&(n-=html_ve(t.lastChild,e).length),e.originalText.slice(r,n)}var html_Nt=ha;var ma=new Set(["if","else if","for","switch","case"]);function fa(t,e){let{node:r}=t;switch(r.type){case"element":if(html_U(r)||r.type==="interpolation")return;if(!r.isSelfClosing&&html_Tt(r,e)){let n=html_gr(r,e);return n?async(s,i)=>{let a=html_Nt(r,e),o=/^\s*$/u.test(a),u="";return o||(u=await s(html_mr(a),{parser:n,__embeddedInHtml:!0}),o=u===""),[html_z(r,e),html_(html_rt(t,e,i)),o?"":html_S,u,o?"":html_S,html_Ze(r,e),html_W(r,e)]}:void 0}break;case"text":if(html_U(r.parent)){let n=html_gr(r.parent,e);if(n)return async s=>{let i=n==="markdown"?html_Cr(r.value.replace(/^[^\S\n]*\n/u,"")):r.value,a={parser:n,__embeddedInHtml:!0};if(e.parser==="html"&&n==="babel"){let o="script",{attrMap:u}=r.parent;u&&(u.type==="module"||u.type==="text/babel"&&u["data-type"]==="module")&&(o="module"),a.__babelSourceType=o}return[html_ne,html_z(r,e),await s(i,a),html_W(r,e)]}}else if(r.parent.type==="interpolation")return async n=>{let s={__isInHtmlInterpolation:!0,__embeddedInHtml:!0};return e.parser==="angular"?s.parser="__ng_interpolation":e.parser==="vue"?s.parser=html_Me(t,e)?"__vue_ts_expression":"__vue_expression":s.parser="__js_expression",[k([E,await n(r.value,s)]),r.parent.next&&html_K(r.parent.next)?" ":E]};break;case"attribute":return es(t,e);case"front-matter":return n=>html_gn(r,n);case"angularControlFlowBlockParameters":return ma.has(t.parent.name)?html_Cn:void 0;case"angularLetDeclarationInitializer":return n=>html_T(r.value,n,{parser:"__ng_binding",__isInHtmlAttribute:!1})}}var ns=fa;var html_nt=null;function html_st(t){if(html_nt!==null&&typeof html_nt.property){let e=html_nt;return html_nt=html_st.prototype=null,e}return html_nt=html_st.prototype=t??Object.create(null),new html_st}var da=10;for(let t=0;t<=da;t++)html_st();function html_vr(t){return html_st(t)}function ga(t,e="type"){html_vr(t);function r(n){let s=n[e],i=t[s];if(!Array.isArray(i))throw Object.assign(new Error(`Missing visitor keys for '${s}'.`),{node:n});return i}return r}var ss=ga;var Ca={"front-matter":[],root:["children"],element:["attrs","children"],ieConditionalComment:["children"],ieConditionalStartComment:[],ieConditionalEndComment:[],interpolation:["children"],text:["children"],docType:[],comment:[],attribute:[],cdata:[],angularControlFlowBlock:["children","parameters"],angularControlFlowBlockParameters:["children"],angularControlFlowBlockParameter:[],angularLetDeclaration:["init"],angularLetDeclarationInitializer:[],angularIcuExpression:["cases"],angularIcuCase:["expression"]},is=Ca;var Sa=ss(is),as=Sa;function os(t){return/^\s*<!--\s*@(?:format|prettier)\s*-->/u.test(t)}function us(t){return`<!-- @format -->

`+t}var ls=new Map([["if",new Set(["else if","else"])],["else if",new Set(["else if","else"])],["for",new Set(["empty"])],["defer",new Set(["placeholder","error","loading"])],["placeholder",new Set(["placeholder","error","loading"])],["error",new Set(["placeholder","error","loading"])],["loading",new Set(["placeholder","error","loading"])]]);function cs(t){let e=html_ie(t);return t.type==="element"&&!t.endSourceSpan&&html_qe(t.children)?Math.max(e,cs(html_X(!1,t.children,-1))):e}function html_it(t,e,r){let n=t.node;if(html_Ee(n)){let s=cs(n);return[html_z(n,e),html_B(html_N.trimEnd(e.originalText.slice(html_se(n)+(n.prev&&html_et(n.prev)?html_Lt(n).length:0),s-(n.next&&html_K(n.next)?html_ve(n,e).length:0)))),html_W(n,e)]}return r()}function html_Pt(t,e){return $(t)&&$(e)?t.isTrailingSpaceSensitive?t.hasTrailingSpaces?html_wt(e)?html_S:E:"":html_wt(e)?html_S:v:html_et(t)&&(html_Ee(e)||e.firstChild||e.isSelfClosing||e.type==="element"&&e.attrs.length>0)||t.type==="element"&&t.isSelfClosing&&html_K(e)?"":!e.isLeadingSpaceSensitive||html_wt(e)||html_K(e)&&t.lastChild&&html_we(t.lastChild)&&t.lastChild.lastChild&&html_we(t.lastChild.lastChild)?html_S:e.hasLeadingSpaces?E:v}function html_He(t,e,r){let{node:n}=t;if(html_dr(n))return[html_ne,...t.map(i=>{let a=i.node,o=a.prev?html_Pt(a.prev,a):"";return[o?[o,html_Qe(a.prev)?html_S:""]:"",html_it(i,e,r)]},"children")];let s=n.children.map(()=>Symbol(""));return t.map((i,a)=>{let o=i.node;if($(o)){if(o.prev&&$(o.prev)){let A=html_Pt(o.prev,o);if(A)return html_Qe(o.prev)?[html_S,html_S,html_it(i,e,r)]:[A,html_it(i,e,r)]}return html_it(i,e,r)}let u=[],p=[],l=[],f=[],d=o.prev?html_Pt(o.prev,o):"",C=o.next?html_Pt(o,o.next):"";return d&&(html_Qe(o.prev)?u.push(html_S,html_S):d===html_S?u.push(html_S):$(o.prev)?p.push(d):p.push(html_ge("",v,{groupId:s[a-1]}))),C&&(html_Qe(o)?$(o.next)&&f.push(html_S,html_S):C===html_S?$(o.next)&&f.push(html_S):l.push(C)),[...u,html_([...p,html_([html_it(i,e,r),...l],{id:s[a]})]),...f]},"children")}function ps(t,e,r){let{node:n}=t,s=[];html_a(t)&&s.push("} "),s.push("@",n.name),n.parameters&&s.push(" (",html_(r("parameters")),")"),s.push(" {");let i=hs(n);return n.children.length>0?(n.firstChild.hasLeadingSpaces=!0,n.lastChild.hasTrailingSpaces=!0,s.push(k([html_S,html_He(t,e,r)])),i&&s.push(html_S,"}")):i&&s.push("}"),html_(s,{shouldBreak:!0})}function hs(t){var e,r;return!(((e=t.next)==null?void 0:e.type)==="angularControlFlowBlock"&&((r=ls.get(t.name))!=null&&r.has(t.next.name)))}function html_a(t){let{previous:e}=t;return(e==null?void 0:e.type)==="angularControlFlowBlock"&&!html_Ee(e)&&!hs(e)}function ms(t,e,r){return[k([v,html_q([";",E],t.map(r,"children"))]),v]}function fs(t,e,r){let{node:n}=t;return[html_be(n,e),html_([n.switchValue.trim(),", ",n.clause,n.cases.length>0?[",",k([E,html_q(E,t.map(r,"cases"))])]:"",v]),html_De(n,e)]}function ds(t,e,r){let{node:n}=t;return[n.value," {",html_([k([v,t.map(({node:s})=>s.type==="text"&&!html_N.trim(s.value)?"":r(),"expression")]),v]),"}"]}function gs(t,e,r){let{node:n}=t;if(yt(n,e))return[html_z(n,e),html_(html_rt(t,e,r)),html_B(html_Nt(n,e)),...html_Ze(n,e),html_W(n,e)];let s=n.children.length===1&&(n.firstChild.type==="interpolation"||n.firstChild.type==="angularIcuExpression")&&n.firstChild.isLeadingSpaceSensitive&&!n.firstChild.hasLeadingSpaces&&n.lastChild.isTrailingSpaceSensitive&&!n.lastChild.hasTrailingSpaces,i=Symbol("element-attr-group-id"),a=l=>html_([html_(html_rt(t,e,r),{id:i}),l,html_Ze(n,e)]),o=l=>s?on(l,{groupId:i}):(html_U(n)||html_Je(n,e))&&n.parent.type==="root"&&e.parser==="vue"&&!e.vueIndentScriptAndStyle?l:k(l),u=()=>s?html_ge(v,"",{groupId:i}):n.firstChild.hasLeadingSpaces&&n.firstChild.isLeadingSpaceSensitive?E:n.firstChild.type==="text"&&n.isWhitespaceSensitive&&n.isIndentationSensitive?sn(v):v,p=()=>(n.next?html_K(n.next):ye(n.parent))?n.lastChild.hasTrailingSpaces&&n.lastChild.isTrailingSpaceSensitive?" ":"":s?html_ge(v,"",{groupId:i}):n.lastChild.hasTrailingSpaces&&n.lastChild.isTrailingSpaceSensitive?E:(n.lastChild.type==="comment"||n.lastChild.type==="text"&&n.isWhitespaceSensitive&&n.isIndentationSensitive)&&new RegExp(`\\n[\\t ]{${e.tabWidth*(t.ancestors.length-1)}}$`,"u").test(n.lastChild.value)?"":v;return n.children.length===0?a(n.hasDanglingSpaces&&n.isDanglingSpaceSensitive?E:""):a([html_kn(n)?html_ne:"",o([u(),html_He(t,e,r)]),p()])}function html_at(t){return t>=9&&t<=32||t==160}function html_It(t){return 48<=t&&t<=57}function html_ot(t){return t>=97&&t<=122||t>=65&&t<=90}function Cs(t){return t>=97&&t<=102||t>=65&&t<=70||html_It(t)}function html_Rt(t){return t===10||t===13}function html_yr(t){return 48<=t&&t<=55}function html_$t(t){return t===39||t===34||t===96}var Ea=/-+([a-z0-9])/g;function _s(t){return t.replace(Ea,(...e)=>e[1].toUpperCase())}var html_ae=class t{constructor(e,r,n,s){this.file=e,this.offset=r,this.line=n,this.col=s}toString(){return this.offset!=null?`${this.file.url}@${this.line}:${this.col}`:this.file.url}moveBy(e){let r=this.file.content,n=r.length,s=this.offset,i=this.line,a=this.col;for(;s>0&&e<0;)if(s--,e++,r.charCodeAt(s)==10){i--;let u=r.substring(0,s-1).lastIndexOf(String.fromCharCode(10));a=u>0?s-u:s}else a--;for(;s<n&&e>0;){let o=r.charCodeAt(s);s++,e--,o==10?(i++,a=0):a++}return new t(this.file,s,i,a)}getContext(e,r){let n=this.file.content,s=this.offset;if(s!=null){s>n.length-1&&(s=n.length-1);let i=s,a=0,o=0;for(;a<e&&s>0&&(s--,a++,!(n[s]==`
`&&++o==r)););for(a=0,o=0;a<e&&i<n.length-1&&(i++,a++,!(n[i]==`
`&&++o==r)););return{before:n.substring(s,this.offset),after:n.substring(this.offset,i+1)}}return null}},html_Te=class{constructor(e,r){this.content=e,this.url=r}},h=class{constructor(e,r,n=e,s=null){this.start=e,this.end=r,this.fullStart=n,this.details=s}toString(){return this.start.file.content.substring(this.start.offset,this.end.offset)}},html_Ot;(function(t){t[t.WARNING=0]="WARNING",t[t.ERROR=1]="ERROR"})(html_Ot||(html_Ot={}));var html_Ue=class{constructor(e,r,n=html_Ot.ERROR){this.span=e,this.msg=r,this.level=n}contextualMessage(){let e=this.span.start.getContext(100,3);return e?`${this.msg} ("${e.before}[${html_Ot[this.level]} ->]${e.after}")`:this.msg}toString(){let e=this.span.details?`, ${this.span.details}`:"";return`${this.contextualMessage()}: ${this.span.start}${e}`}};var Aa=[va,ya,ba,xa,ka,Fa,Ba,La,Na,Ta];function Da(t,e){for(let r of Aa)r(t,e);return t}function va(t){t.walk(e=>{if(e.type==="element"&&e.tagDefinition.ignoreFirstLf&&e.children.length>0&&e.children[0].type==="text"&&e.children[0].value[0]===`
`){let r=e.children[0];r.value.length===1?e.removeChild(r):r.value=r.value.slice(1)}})}function ya(t){let e=r=>{var n,s;return r.type==="element"&&((n=r.prev)==null?void 0:n.type)==="ieConditionalStartComment"&&r.prev.sourceSpan.end.offset===r.startSourceSpan.start.offset&&((s=r.firstChild)==null?void 0:s.type)==="ieConditionalEndComment"&&r.firstChild.sourceSpan.start.offset===r.startSourceSpan.end.offset};t.walk(r=>{if(r.children)for(let n=0;n<r.children.length;n++){let s=r.children[n];if(!e(s))continue;let i=s.prev,a=s.firstChild;r.removeChild(i),n--;let o=new h(i.sourceSpan.start,a.sourceSpan.end),u=new h(o.start,s.sourceSpan.end);s.condition=i.condition,s.sourceSpan=u,s.startSourceSpan=o,s.removeChild(a)}})}function wa(t,e,r){t.walk(n=>{if(n.children)for(let s=0;s<n.children.length;s++){let i=n.children[s];if(i.type!=="text"&&!e(i))continue;i.type!=="text"&&(i.type="text",i.value=r(i));let a=i.prev;!a||a.type!=="text"||(a.value+=i.value,a.sourceSpan=new h(a.sourceSpan.start,i.sourceSpan.end),n.removeChild(i),s--)}})}function ba(t){return wa(t,e=>e.type==="cdata",e=>`<![CDATA[${e.value}]]>`)}function Ta(t){let e=r=>{var n,s;return r.type==="element"&&r.attrs.length===0&&r.children.length===1&&r.firstChild.type==="text"&&!html_N.hasWhitespaceCharacter(r.children[0].value)&&!r.firstChild.hasLeadingSpaces&&!r.firstChild.hasTrailingSpaces&&r.isLeadingSpaceSensitive&&!r.hasLeadingSpaces&&r.isTrailingSpaceSensitive&&!r.hasTrailingSpaces&&((n=r.prev)==null?void 0:n.type)==="text"&&((s=r.next)==null?void 0:s.type)==="text"};t.walk(r=>{if(r.children)for(let n=0;n<r.children.length;n++){let s=r.children[n];if(!e(s))continue;let i=s.prev,a=s.next;i.value+=`<${s.rawName}>`+s.firstChild.value+`</${s.rawName}>`+a.value,i.sourceSpan=new h(i.sourceSpan.start,a.sourceSpan.end),i.isTrailingSpaceSensitive=a.isTrailingSpaceSensitive,i.hasTrailingSpaces=a.hasTrailingSpaces,r.removeChild(s),n--,r.removeChild(a)}})}function xa(t,e){if(e.parser==="html")return;let r=/\{\{(.+?)\}\}/su;t.walk(n=>{if(html_yn(n))for(let s of n.children){if(s.type!=="text")continue;let i=s.sourceSpan.start,a=null,o=s.value.split(r);for(let u=0;u<o.length;u++,i=a){let p=o[u];if(u%2===0){a=i.moveBy(p.length),p.length>0&&n.insertChildBefore(s,{type:"text",value:p,sourceSpan:new h(i,a)});continue}a=i.moveBy(p.length+4),n.insertChildBefore(s,{type:"interpolation",sourceSpan:new h(i,a),children:p.length===0?[]:[{type:"text",value:p,sourceSpan:new h(i.moveBy(2),a.moveBy(-2))}]})}n.removeChild(s)}})}function ka(t){t.walk(e=>{if(!e.children)return;if(e.children.length===0||e.children.length===1&&e.children[0].type==="text"&&html_N.trim(e.children[0].value).length===0){e.hasDanglingSpaces=e.children.length>0,e.children=[];return}let r=html_wn(e),n=html_fr(e);if(!r)for(let s=0;s<e.children.length;s++){let i=e.children[s];if(i.type!=="text")continue;let{leadingWhitespace:a,text:o,trailingWhitespace:u}=html_vn(i.value),p=i.prev,l=i.next;o?(i.value=o,i.sourceSpan=new h(i.sourceSpan.start.moveBy(a.length),i.sourceSpan.end.moveBy(-u.length)),a&&(p&&(p.hasTrailingSpaces=!0),i.hasLeadingSpaces=!0),u&&(i.hasTrailingSpaces=!0,l&&(l.hasLeadingSpaces=!0))):(e.removeChild(i),s--,(a||u)&&(p&&(p.hasTrailingSpaces=!0),l&&(l.hasLeadingSpaces=!0)))}e.isWhitespaceSensitive=r,e.isIndentationSensitive=n})}function Ba(t){t.walk(e=>{e.isSelfClosing=!e.children||e.type==="element"&&(e.tagDefinition.isVoid||e.endSourceSpan&&e.startSourceSpan.start===e.endSourceSpan.start&&e.startSourceSpan.end===e.endSourceSpan.end)})}function La(t,e){t.walk(r=>{r.type==="element"&&(r.hasHtmComponentClosingTag=r.endSourceSpan&&/^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset,r.endSourceSpan.end.offset)))})}function Fa(t,e){t.walk(r=>{r.cssDisplay=In(r,e)})}function Na(t,e){t.walk(r=>{let{children:n}=r;if(n){if(n.length===0){r.isDanglingSpaceSensitive=html_xn(r);return}for(let s of n)s.isLeadingSpaceSensitive=html_bn(s,e),s.isTrailingSpaceSensitive=html_Tn(s,e);for(let s=0;s<n.length;s++){let i=n[s];i.isLeadingSpaceSensitive=(s===0||i.prev.isTrailingSpaceSensitive)&&i.isLeadingSpaceSensitive,i.isTrailingSpaceSensitive=(s===n.length-1||i.next.isLeadingSpaceSensitive)&&i.isTrailingSpaceSensitive}}})}var Es=Da;function Pa(t,e,r){let{node:n}=t;switch(n.type){case"front-matter":return html_B(n.raw);case"root":return e.__onHtmlRoot&&e.__onHtmlRoot(n),[html_(html_He(t,e,r)),html_S];case"element":case"ieConditionalComment":return gs(t,e,r);case"angularControlFlowBlock":return ps(t,e,r);case"angularControlFlowBlockParameters":return ms(t,e,r);case"angularControlFlowBlockParameter":return html_N.trim(n.expression);case"angularLetDeclaration":return html_(["@let ",html_([n.id," =",html_(k([E,r("init")]))]),";"]);case"angularLetDeclarationInitializer":return n.value;case"angularIcuExpression":return fs(t,e,r);case"angularIcuCase":return ds(t,e,r);case"ieConditionalStartComment":case"ieConditionalEndComment":return[html_be(n),html_De(n)];case"interpolation":return[html_be(n,e),...t.map(r,"children"),html_De(n,e)];case"text":{if(n.parent.type==="interpolation"){let i=/\n[^\S\n]*$/u,a=i.test(n.value),o=a?n.value.replace(i,""):n.value;return[html_B(o),a?html_S:""]}let s=html_ln([html_z(n,e),...html_xt(n),html_W(n,e)]);return Array.isArray(s)?html_At(s):s}case"docType":return[html_([html_be(n,e)," ",w(!1,n.value.replace(/^html\b/iu,"html"),/\s+/gu," ")]),html_De(n,e)];case"comment":return[html_z(n,e),html_B(e.originalText.slice(html_se(n),html_ie(n))),html_W(n,e)];case"attribute":{if(n.value===null)return n.rawName;let s=html_Sr(n.value),i=html_pn(s,'"');return[n.rawName,"=",i,html_B(i==='"'?w(!1,s,'"',"&quot;"):w(!1,s,"'","&apos;")),i]}case"cdata":default:throw new html_mn(n,"HTML")}}var Ia={preprocess:Es,print:Pa,insertPragma:us,massageAstNode:html_dn,embed:ns,getVisitorKeys:as},As=Ia;var Ds=[{linguistLanguageId:146,name:"Angular",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[".component.html"],parsers:["angular"],vscodeLanguageIds:["html"],filenames:[]},{linguistLanguageId:146,name:"HTML",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[".html",".hta",".htm",".html.hl",".inc",".xht",".xhtml",".mjml"],parsers:["html"],vscodeLanguageIds:["html"]},{linguistLanguageId:146,name:"Lightning Web Components",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[],parsers:["lwc"],vscodeLanguageIds:["html"],filenames:[]},{linguistLanguageId:391,name:"Vue",type:"markup",color:"#41b883",extensions:[".vue"],tmScope:"text.html.vue",aceMode:"html",parsers:["vue"],vscodeLanguageIds:["vue"]}];var html_wr={bracketSpacing:{category:"Common",type:"boolean",default:!0,description:"Print spaces between brackets.",oppositeDescription:"Do not print spaces between brackets."},singleQuote:{category:"Common",type:"boolean",default:!1,description:"Use single quotes instead of double quotes."},proseWrap:{category:"Common",type:"choice",default:"preserve",description:"How to wrap prose.",choices:[{value:"always",description:"Wrap prose if it exceeds the print width."},{value:"never",description:"Do not wrap prose."},{value:"preserve",description:"Wrap prose as-is."}]},bracketSameLine:{category:"Common",type:"boolean",default:!1,description:"Put > of opening tags on the last line instead of on a new line."},singleAttributePerLine:{category:"Common",type:"boolean",default:!1,description:"Enforce single attribute per line in HTML, Vue and JSX."}};var vs="HTML",Ra={bracketSameLine:html_wr.bracketSameLine,htmlWhitespaceSensitivity:{category:vs,type:"choice",default:"css",description:"How to handle whitespaces in HTML.",choices:[{value:"css",description:"Respect the default value of CSS display property."},{value:"strict",description:"Whitespaces are considered sensitive."},{value:"ignore",description:"Whitespaces are considered insensitive."}]},singleAttributePerLine:html_wr.singleAttributePerLine,vueIndentScriptAndStyle:{category:vs,type:"boolean",default:!1,description:"Indent script and style tags in Vue files."}},ys=Ra;var html_Gr={};html_Jr(html_Gr,{angular:()=>html_Po,html:()=>No,lwc:()=>html_Ro,vue:()=>html_Io});var _p=(/* unused pure expression or super */ null && (new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`,"g")));var html_ws;(function(t){t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom"})(html_ws||(html_ws={}));var bs;(function(t){t[t.OnPush=0]="OnPush",t[t.Default=1]="Default"})(bs||(bs={}));var Ts;(function(t){t[t.None=0]="None",t[t.SignalBased=1]="SignalBased",t[t.HasDecoratorInputTransform=2]="HasDecoratorInputTransform"})(Ts||(Ts={}));var html_br={name:"custom-elements"},html_Tr={name:"no-errors-schema"};var html_J;(function(t){t[t.NONE=0]="NONE",t[t.HTML=1]="HTML",t[t.STYLE=2]="STYLE",t[t.SCRIPT=3]="SCRIPT",t[t.URL=4]="URL",t[t.RESOURCE_URL=5]="RESOURCE_URL"})(html_J||(html_J={}));var xs;(function(t){t[t.Error=0]="Error",t[t.Warning=1]="Warning",t[t.Ignore=2]="Ignore"})(xs||(xs={}));var html_I;(function(t){t[t.RAW_TEXT=0]="RAW_TEXT",t[t.ESCAPABLE_RAW_TEXT=1]="ESCAPABLE_RAW_TEXT",t[t.PARSABLE_DATA=2]="PARSABLE_DATA"})(html_I||(html_I={}));function html_ut(t,e=!0){if(t[0]!=":")return[null,t];let r=t.indexOf(":",1);if(r===-1){if(e)throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);return[null,t]}return[t.slice(1,r),t.slice(r+1)]}function html_xr(t){return html_ut(t)[1]==="ng-container"}function html_kr(t){return html_ut(t)[1]==="ng-content"}function html_We(t){return t===null?null:html_ut(t)[0]}function html_ze(t,e){return t?`:${t}:${e}`:e}var html_qt;function html_Br(){return html_qt||(html_qt={},html_Mt(html_J.HTML,["iframe|srcdoc","*|innerHTML","*|outerHTML"]),html_Mt(html_J.STYLE,["*|style"]),html_Mt(html_J.URL,["*|formAction","area|href","area|ping","audio|src","a|href","a|ping","blockquote|cite","body|background","del|cite","form|action","img|src","input|src","ins|cite","q|cite","source|src","track|src","video|poster","video|src"]),html_Mt(html_J.RESOURCE_URL,["applet|code","applet|codebase","base|href","embed|src","frame|src","head|profile","html|manifest","iframe|src","link|href","media|src","object|codebase","object|data","script|src"])),html_qt}function html_Mt(t,e){for(let r of e)html_qt[r.toLowerCase()]=t}var html_Ht=class{};var $a="boolean",Oa="number",Ma="string",qa="object",Ha=["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored","[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy","abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy","media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume",":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex",":svg:graphics^:svg:|",":svg:animation^:svg:|*begin,*end,*repeat",":svg:geometry^:svg:|",":svg:componentTransferFunction^:svg:|",":svg:gradient^:svg:|",":svg:textContent^:svg:graphics|",":svg:textPositioning^:svg:textContent|","a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username","area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username","audio^media|","br^[HTMLElement]|clear","base^[HTMLElement]|href,target","body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink","button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value","canvas^[HTMLElement]|#height,#width","content^[HTMLElement]|select","dl^[HTMLElement]|!compact","data^[HTMLElement]|value","datalist^[HTMLElement]|","details^[HTMLElement]|!open","dialog^[HTMLElement]|!open,returnValue","dir^[HTMLElement]|!compact","div^[HTMLElement]|align","embed^[HTMLElement]|align,height,name,src,type,width","fieldset^[HTMLElement]|!disabled,name","font^[HTMLElement]|color,face,size","form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target","frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src","frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows","hr^[HTMLElement]|align,color,!noShade,size,width","head^[HTMLElement]|","h1,h2,h3,h4,h5,h6^[HTMLElement]|align","html^[HTMLElement]|version","iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width","img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width","input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width","li^[HTMLElement]|type,#value","label^[HTMLElement]|htmlFor","legend^[HTMLElement]|align","link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type","map^[HTMLElement]|name","marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width","menu^[HTMLElement]|!compact","meta^[HTMLElement]|content,httpEquiv,media,name,scheme","meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value","ins,del^[HTMLElement]|cite,dateTime","ol^[HTMLElement]|!compact,!reversed,#start,type","object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width","optgroup^[HTMLElement]|!disabled,label","option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value","output^[HTMLElement]|defaultValue,%htmlFor,name,value","p^[HTMLElement]|align","param^[HTMLElement]|name,type,value,valueType","picture^[HTMLElement]|","pre^[HTMLElement]|#width","progress^[HTMLElement]|#max,#value","q,blockquote,cite^[HTMLElement]|","script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type","select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value","slot^[HTMLElement]|name","source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width","span^[HTMLElement]|","style^[HTMLElement]|!disabled,media,type","caption^[HTMLElement]|align","th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width","col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width","table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width","tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign","tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign","template^[HTMLElement]|","textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap","time^[HTMLElement]|dateTime","title^[HTMLElement]|text","track^[HTMLElement]|!default,kind,label,src,srclang","ul^[HTMLElement]|!compact,type","unknown^[HTMLElement]|","video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width",":svg:a^:svg:graphics|",":svg:animate^:svg:animation|",":svg:animateMotion^:svg:animation|",":svg:animateTransform^:svg:animation|",":svg:circle^:svg:geometry|",":svg:clipPath^:svg:graphics|",":svg:defs^:svg:graphics|",":svg:desc^:svg:|",":svg:discard^:svg:|",":svg:ellipse^:svg:geometry|",":svg:feBlend^:svg:|",":svg:feColorMatrix^:svg:|",":svg:feComponentTransfer^:svg:|",":svg:feComposite^:svg:|",":svg:feConvolveMatrix^:svg:|",":svg:feDiffuseLighting^:svg:|",":svg:feDisplacementMap^:svg:|",":svg:feDistantLight^:svg:|",":svg:feDropShadow^:svg:|",":svg:feFlood^:svg:|",":svg:feFuncA^:svg:componentTransferFunction|",":svg:feFuncB^:svg:componentTransferFunction|",":svg:feFuncG^:svg:componentTransferFunction|",":svg:feFuncR^:svg:componentTransferFunction|",":svg:feGaussianBlur^:svg:|",":svg:feImage^:svg:|",":svg:feMerge^:svg:|",":svg:feMergeNode^:svg:|",":svg:feMorphology^:svg:|",":svg:feOffset^:svg:|",":svg:fePointLight^:svg:|",":svg:feSpecularLighting^:svg:|",":svg:feSpotLight^:svg:|",":svg:feTile^:svg:|",":svg:feTurbulence^:svg:|",":svg:filter^:svg:|",":svg:foreignObject^:svg:graphics|",":svg:g^:svg:graphics|",":svg:image^:svg:graphics|decoding",":svg:line^:svg:geometry|",":svg:linearGradient^:svg:gradient|",":svg:mpath^:svg:|",":svg:marker^:svg:|",":svg:mask^:svg:|",":svg:metadata^:svg:|",":svg:path^:svg:geometry|",":svg:pattern^:svg:|",":svg:polygon^:svg:geometry|",":svg:polyline^:svg:geometry|",":svg:radialGradient^:svg:gradient|",":svg:rect^:svg:geometry|",":svg:svg^:svg:graphics|#currentScale,#zoomAndPan",":svg:script^:svg:|type",":svg:set^:svg:animation|",":svg:stop^:svg:|",":svg:style^:svg:|!disabled,media,title,type",":svg:switch^:svg:graphics|",":svg:symbol^:svg:|",":svg:tspan^:svg:textPositioning|",":svg:text^:svg:textPositioning|",":svg:textPath^:svg:textContent|",":svg:title^:svg:|",":svg:use^:svg:graphics|",":svg:view^:svg:|#zoomAndPan","data^[HTMLElement]|value","keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name","menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default","summary^[HTMLElement]|","time^[HTMLElement]|dateTime",":svg:cursor^:svg:|",":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex",":math:math^:math:|",":math:maction^:math:|",":math:menclose^:math:|",":math:merror^:math:|",":math:mfenced^:math:|",":math:mfrac^:math:|",":math:mi^:math:|",":math:mmultiscripts^:math:|",":math:mn^:math:|",":math:mo^:math:|",":math:mover^:math:|",":math:mpadded^:math:|",":math:mphantom^:math:|",":math:mroot^:math:|",":math:mrow^:math:|",":math:ms^:math:|",":math:mspace^:math:|",":math:msqrt^:math:|",":math:mstyle^:math:|",":math:msub^:math:|",":math:msubsup^:math:|",":math:msup^:math:|",":math:mtable^:math:|",":math:mtd^:math:|",":math:mtext^:math:|",":math:mtr^:math:|",":math:munder^:math:|",":math:munderover^:math:|",":math:semantics^:math:|"],ks=new Map(Object.entries({class:"className",for:"htmlFor",formaction:"formAction",innerHtml:"innerHTML",readonly:"readOnly",tabindex:"tabIndex"})),Va=Array.from(ks).reduce((t,[e,r])=>(t.set(e,r),t),new Map),html_Vt=class extends html_Ht{constructor(){super(),this._schema=new Map,this._eventSchema=new Map,Ha.forEach(e=>{let r=new Map,n=new Set,[s,i]=e.split("|"),a=i.split(","),[o,u]=s.split("^");o.split(",").forEach(l=>{this._schema.set(l.toLowerCase(),r),this._eventSchema.set(l.toLowerCase(),n)});let p=u&&this._schema.get(u.toLowerCase());if(p){for(let[l,f]of p)r.set(l,f);for(let l of this._eventSchema.get(u.toLowerCase()))n.add(l)}a.forEach(l=>{if(l.length>0)switch(l[0]){case"*":n.add(l.substring(1));break;case"!":r.set(l.substring(1),$a);break;case"#":r.set(l.substring(1),Oa);break;case"%":r.set(l.substring(1),qa);break;default:r.set(l,Ma)}})})}hasProperty(e,r,n){if(n.some(i=>i.name===html_Tr.name))return!0;if(e.indexOf("-")>-1){if(html_xr(e)||html_kr(e))return!1;if(n.some(i=>i.name===html_br.name))return!0}return(this._schema.get(e.toLowerCase())||this._schema.get("unknown")).has(r)}hasElement(e,r){return r.some(n=>n.name===html_Tr.name)||e.indexOf("-")>-1&&(html_xr(e)||html_kr(e)||r.some(n=>n.name===html_br.name))?!0:this._schema.has(e.toLowerCase())}securityContext(e,r,n){n&&(r=this.getMappedPropName(r)),e=e.toLowerCase(),r=r.toLowerCase();let s=html_Br()[e+"|"+r];return s||(s=html_Br()["*|"+r],s||html_J.NONE)}getMappedPropName(e){return ks.get(e)??e}getDefaultComponentElementName(){return"ng-component"}validateProperty(e){return e.toLowerCase().startsWith("on")?{error:!0,msg:`Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.`}:{error:!1}}validateAttribute(e){return e.toLowerCase().startsWith("on")?{error:!0,msg:`Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...`}:{error:!1}}allKnownElementNames(){return Array.from(this._schema.keys())}allKnownAttributesOfElement(e){let r=this._schema.get(e.toLowerCase())||this._schema.get("unknown");return Array.from(r.keys()).map(n=>Va.get(n)??n)}allKnownEventsOfElement(e){return Array.from(this._eventSchema.get(e.toLowerCase())??[])}normalizeAnimationStyleProperty(e){return _s(e)}normalizeAnimationStyleValue(e,r,n){let s="",i=n.toString().trim(),a=null;if(Ua(e)&&n!==0&&n!=="0")if(typeof n=="number")s="px";else{let o=n.match(/^[+-]?[\d\.]+([a-z]*)$/);o&&o[1].length==0&&(a=`Please provide a CSS unit value for ${r}:${n}`)}return{error:a,value:i+s}}};function Ua(t){switch(t){case"width":case"height":case"minWidth":case"minHeight":case"maxWidth":case"maxHeight":case"left":case"top":case"bottom":case"right":case"fontSize":case"outlineWidth":case"outlineOffset":case"paddingTop":case"paddingLeft":case"paddingBottom":case"paddingRight":case"marginTop":case"marginLeft":case"marginBottom":case"marginRight":case"borderRadius":case"borderWidth":case"borderTopWidth":case"borderLeftWidth":case"borderRightWidth":case"borderBottomWidth":case"textIndent":return!0;default:return!1}}var m=class{constructor({closedByChildren:e,implicitNamespacePrefix:r,contentType:n=html_I.PARSABLE_DATA,closedByParent:s=!1,isVoid:i=!1,ignoreFirstLf:a=!1,preventNamespaceInheritance:o=!1,canSelfClose:u=!1}={}){this.closedByChildren={},this.closedByParent=!1,e&&e.length>0&&e.forEach(p=>this.closedByChildren[p]=!0),this.isVoid=i,this.closedByParent=s||i,this.implicitNamespacePrefix=r||null,this.contentType=n,this.ignoreFirstLf=a,this.preventNamespaceInheritance=o,this.canSelfClose=u??i}isClosedByChild(e){return this.isVoid||e.toLowerCase()in this.closedByChildren}getContentType(e){return typeof this.contentType=="object"?(e===void 0?void 0:this.contentType[e])??this.contentType.default:this.contentType}},Bs,html_lt;function html_Ge(t){return html_lt||(Bs=new m({canSelfClose:!0}),html_lt=Object.assign(Object.create(null),{base:new m({isVoid:!0}),meta:new m({isVoid:!0}),area:new m({isVoid:!0}),embed:new m({isVoid:!0}),link:new m({isVoid:!0}),img:new m({isVoid:!0}),input:new m({isVoid:!0}),param:new m({isVoid:!0}),hr:new m({isVoid:!0}),br:new m({isVoid:!0}),source:new m({isVoid:!0}),track:new m({isVoid:!0}),wbr:new m({isVoid:!0}),p:new m({closedByChildren:["address","article","aside","blockquote","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","main","nav","ol","p","pre","section","table","ul"],closedByParent:!0}),thead:new m({closedByChildren:["tbody","tfoot"]}),tbody:new m({closedByChildren:["tbody","tfoot"],closedByParent:!0}),tfoot:new m({closedByChildren:["tbody"],closedByParent:!0}),tr:new m({closedByChildren:["tr"],closedByParent:!0}),td:new m({closedByChildren:["td","th"],closedByParent:!0}),th:new m({closedByChildren:["td","th"],closedByParent:!0}),col:new m({isVoid:!0}),svg:new m({implicitNamespacePrefix:"svg"}),foreignObject:new m({implicitNamespacePrefix:"svg",preventNamespaceInheritance:!0}),math:new m({implicitNamespacePrefix:"math"}),li:new m({closedByChildren:["li"],closedByParent:!0}),dt:new m({closedByChildren:["dt","dd"]}),dd:new m({closedByChildren:["dt","dd"],closedByParent:!0}),rb:new m({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),rt:new m({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),rtc:new m({closedByChildren:["rb","rtc","rp"],closedByParent:!0}),rp:new m({closedByChildren:["rb","rt","rtc","rp"],closedByParent:!0}),optgroup:new m({closedByChildren:["optgroup"],closedByParent:!0}),option:new m({closedByChildren:["option","optgroup"],closedByParent:!0}),pre:new m({ignoreFirstLf:!0}),listing:new m({ignoreFirstLf:!0}),style:new m({contentType:html_I.RAW_TEXT}),script:new m({contentType:html_I.RAW_TEXT}),title:new m({contentType:{default:html_I.ESCAPABLE_RAW_TEXT,svg:html_I.PARSABLE_DATA}}),textarea:new m({contentType:html_I.ESCAPABLE_RAW_TEXT,ignoreFirstLf:!0})}),new html_Vt().allKnownElementNames().forEach(e=>{!html_lt[e]&&html_We(e)===null&&(html_lt[e]=new m({canSelfClose:!1}))})),html_lt[t]??Bs}var html_oe=class{constructor(e,r){this.sourceSpan=e,this.i18n=r}},html_Ut=class extends html_oe{constructor(e,r,n,s){super(r,s),this.value=e,this.tokens=n,this.type="text"}visit(e,r){return e.visitText(this,r)}},html_Wt=class extends html_oe{constructor(e,r,n,s){super(r,s),this.value=e,this.tokens=n,this.type="cdata"}visit(e,r){return e.visitCdata(this,r)}},html_zt=class extends html_oe{constructor(e,r,n,s,i,a){super(s,a),this.switchValue=e,this.type=r,this.cases=n,this.switchValueSourceSpan=i}visit(e,r){return e.visitExpansion(this,r)}},html_Gt=class{constructor(e,r,n,s,i){this.value=e,this.expression=r,this.sourceSpan=n,this.valueSourceSpan=s,this.expSourceSpan=i,this.type="expansionCase"}visit(e,r){return e.visitExpansionCase(this,r)}},html_Yt=class extends html_oe{constructor(e,r,n,s,i,a,o){super(n,o),this.name=e,this.value=r,this.keySpan=s,this.valueSpan=i,this.valueTokens=a,this.type="attribute"}visit(e,r){return e.visitAttribute(this,r)}get nameSpan(){return this.keySpan}},html_G=class extends html_oe{constructor(e,r,n,s,i,a=null,o=null,u){super(s,u),this.name=e,this.attrs=r,this.children=n,this.startSourceSpan=i,this.endSourceSpan=a,this.nameSpan=o,this.type="element"}visit(e,r){return e.visitElement(this,r)}},html_jt=class{constructor(e,r){this.value=e,this.sourceSpan=r,this.type="comment"}visit(e,r){return e.visitComment(this,r)}},html_Kt=class{constructor(e,r){this.value=e,this.sourceSpan=r,this.type="docType"}visit(e,r){return e.visitDocType(this,r)}},html_Z=class extends html_oe{constructor(e,r,n,s,i,a,o=null,u){super(s,u),this.name=e,this.parameters=r,this.children=n,this.nameSpan=i,this.startSourceSpan=a,this.endSourceSpan=o,this.type="block"}visit(e,r){return e.visitBlock(this,r)}},html_ct=class{constructor(e,r){this.expression=e,this.sourceSpan=r,this.type="blockParameter",this.startSourceSpan=null,this.endSourceSpan=null}visit(e,r){return e.visitBlockParameter(this,r)}},html_pt=class{constructor(e,r,n,s,i){this.name=e,this.value=r,this.sourceSpan=n,this.nameSpan=s,this.valueSpan=i,this.type="letDeclaration",this.startSourceSpan=null,this.endSourceSpan=null}visit(e,r){return e.visitLetDeclaration(this,r)}};function html_Qt(t,e,r=null){let n=[],s=t.visit?i=>t.visit(i,r)||i.visit(t,r):i=>i.visit(t,r);return e.forEach(i=>{let a=s(i);a&&n.push(a)}),n}var html_ht=class{constructor(){}visitElement(e,r){this.visitChildren(r,n=>{n(e.attrs),n(e.children)})}visitAttribute(e,r){}visitText(e,r){}visitCdata(e,r){}visitComment(e,r){}visitDocType(e,r){}visitExpansion(e,r){return this.visitChildren(r,n=>{n(e.cases)})}visitExpansionCase(e,r){}visitBlock(e,r){this.visitChildren(r,n=>{n(e.parameters),n(e.children)})}visitBlockParameter(e,r){}visitLetDeclaration(e,r){}visitChildren(e,r){let n=[],s=this;function i(a){a&&n.push(html_Qt(s,a,e))}return r(i),Array.prototype.concat.apply([],n)}};var html_Ye={AElig:"\xC6",AMP:"&",amp:"&",Aacute:"\xC1",Abreve:"\u0102",Acirc:"\xC2",Acy:"\u0410",Afr:"\u{1D504}",Agrave:"\xC0",Alpha:"\u0391",Amacr:"\u0100",And:"\u2A53",Aogon:"\u0104",Aopf:"\u{1D538}",ApplyFunction:"\u2061",af:"\u2061",Aring:"\xC5",angst:"\xC5",Ascr:"\u{1D49C}",Assign:"\u2254",colone:"\u2254",coloneq:"\u2254",Atilde:"\xC3",Auml:"\xC4",Backslash:"\u2216",setminus:"\u2216",setmn:"\u2216",smallsetminus:"\u2216",ssetmn:"\u2216",Barv:"\u2AE7",Barwed:"\u2306",doublebarwedge:"\u2306",Bcy:"\u0411",Because:"\u2235",becaus:"\u2235",because:"\u2235",Bernoullis:"\u212C",Bscr:"\u212C",bernou:"\u212C",Beta:"\u0392",Bfr:"\u{1D505}",Bopf:"\u{1D539}",Breve:"\u02D8",breve:"\u02D8",Bumpeq:"\u224E",HumpDownHump:"\u224E",bump:"\u224E",CHcy:"\u0427",COPY:"\xA9",copy:"\xA9",Cacute:"\u0106",Cap:"\u22D2",CapitalDifferentialD:"\u2145",DD:"\u2145",Cayleys:"\u212D",Cfr:"\u212D",Ccaron:"\u010C",Ccedil:"\xC7",Ccirc:"\u0108",Cconint:"\u2230",Cdot:"\u010A",Cedilla:"\xB8",cedil:"\xB8",CenterDot:"\xB7",centerdot:"\xB7",middot:"\xB7",Chi:"\u03A7",CircleDot:"\u2299",odot:"\u2299",CircleMinus:"\u2296",ominus:"\u2296",CirclePlus:"\u2295",oplus:"\u2295",CircleTimes:"\u2297",otimes:"\u2297",ClockwiseContourIntegral:"\u2232",cwconint:"\u2232",CloseCurlyDoubleQuote:"\u201D",rdquo:"\u201D",rdquor:"\u201D",CloseCurlyQuote:"\u2019",rsquo:"\u2019",rsquor:"\u2019",Colon:"\u2237",Proportion:"\u2237",Colone:"\u2A74",Congruent:"\u2261",equiv:"\u2261",Conint:"\u222F",DoubleContourIntegral:"\u222F",ContourIntegral:"\u222E",conint:"\u222E",oint:"\u222E",Copf:"\u2102",complexes:"\u2102",Coproduct:"\u2210",coprod:"\u2210",CounterClockwiseContourIntegral:"\u2233",awconint:"\u2233",Cross:"\u2A2F",Cscr:"\u{1D49E}",Cup:"\u22D3",CupCap:"\u224D",asympeq:"\u224D",DDotrahd:"\u2911",DJcy:"\u0402",DScy:"\u0405",DZcy:"\u040F",Dagger:"\u2021",ddagger:"\u2021",Darr:"\u21A1",Dashv:"\u2AE4",DoubleLeftTee:"\u2AE4",Dcaron:"\u010E",Dcy:"\u0414",Del:"\u2207",nabla:"\u2207",Delta:"\u0394",Dfr:"\u{1D507}",DiacriticalAcute:"\xB4",acute:"\xB4",DiacriticalDot:"\u02D9",dot:"\u02D9",DiacriticalDoubleAcute:"\u02DD",dblac:"\u02DD",DiacriticalGrave:"`",grave:"`",DiacriticalTilde:"\u02DC",tilde:"\u02DC",Diamond:"\u22C4",diam:"\u22C4",diamond:"\u22C4",DifferentialD:"\u2146",dd:"\u2146",Dopf:"\u{1D53B}",Dot:"\xA8",DoubleDot:"\xA8",die:"\xA8",uml:"\xA8",DotDot:"\u20DC",DotEqual:"\u2250",doteq:"\u2250",esdot:"\u2250",DoubleDownArrow:"\u21D3",Downarrow:"\u21D3",dArr:"\u21D3",DoubleLeftArrow:"\u21D0",Leftarrow:"\u21D0",lArr:"\u21D0",DoubleLeftRightArrow:"\u21D4",Leftrightarrow:"\u21D4",hArr:"\u21D4",iff:"\u21D4",DoubleLongLeftArrow:"\u27F8",Longleftarrow:"\u27F8",xlArr:"\u27F8",DoubleLongLeftRightArrow:"\u27FA",Longleftrightarrow:"\u27FA",xhArr:"\u27FA",DoubleLongRightArrow:"\u27F9",Longrightarrow:"\u27F9",xrArr:"\u27F9",DoubleRightArrow:"\u21D2",Implies:"\u21D2",Rightarrow:"\u21D2",rArr:"\u21D2",DoubleRightTee:"\u22A8",vDash:"\u22A8",DoubleUpArrow:"\u21D1",Uparrow:"\u21D1",uArr:"\u21D1",DoubleUpDownArrow:"\u21D5",Updownarrow:"\u21D5",vArr:"\u21D5",DoubleVerticalBar:"\u2225",par:"\u2225",parallel:"\u2225",shortparallel:"\u2225",spar:"\u2225",DownArrow:"\u2193",ShortDownArrow:"\u2193",darr:"\u2193",downarrow:"\u2193",DownArrowBar:"\u2913",DownArrowUpArrow:"\u21F5",duarr:"\u21F5",DownBreve:"\u0311",DownLeftRightVector:"\u2950",DownLeftTeeVector:"\u295E",DownLeftVector:"\u21BD",leftharpoondown:"\u21BD",lhard:"\u21BD",DownLeftVectorBar:"\u2956",DownRightTeeVector:"\u295F",DownRightVector:"\u21C1",rhard:"\u21C1",rightharpoondown:"\u21C1",DownRightVectorBar:"\u2957",DownTee:"\u22A4",top:"\u22A4",DownTeeArrow:"\u21A7",mapstodown:"\u21A7",Dscr:"\u{1D49F}",Dstrok:"\u0110",ENG:"\u014A",ETH:"\xD0",Eacute:"\xC9",Ecaron:"\u011A",Ecirc:"\xCA",Ecy:"\u042D",Edot:"\u0116",Efr:"\u{1D508}",Egrave:"\xC8",Element:"\u2208",in:"\u2208",isin:"\u2208",isinv:"\u2208",Emacr:"\u0112",EmptySmallSquare:"\u25FB",EmptyVerySmallSquare:"\u25AB",Eogon:"\u0118",Eopf:"\u{1D53C}",Epsilon:"\u0395",Equal:"\u2A75",EqualTilde:"\u2242",eqsim:"\u2242",esim:"\u2242",Equilibrium:"\u21CC",rightleftharpoons:"\u21CC",rlhar:"\u21CC",Escr:"\u2130",expectation:"\u2130",Esim:"\u2A73",Eta:"\u0397",Euml:"\xCB",Exists:"\u2203",exist:"\u2203",ExponentialE:"\u2147",ee:"\u2147",exponentiale:"\u2147",Fcy:"\u0424",Ffr:"\u{1D509}",FilledSmallSquare:"\u25FC",FilledVerySmallSquare:"\u25AA",blacksquare:"\u25AA",squarf:"\u25AA",squf:"\u25AA",Fopf:"\u{1D53D}",ForAll:"\u2200",forall:"\u2200",Fouriertrf:"\u2131",Fscr:"\u2131",GJcy:"\u0403",GT:">",gt:">",Gamma:"\u0393",Gammad:"\u03DC",Gbreve:"\u011E",Gcedil:"\u0122",Gcirc:"\u011C",Gcy:"\u0413",Gdot:"\u0120",Gfr:"\u{1D50A}",Gg:"\u22D9",ggg:"\u22D9",Gopf:"\u{1D53E}",GreaterEqual:"\u2265",ge:"\u2265",geq:"\u2265",GreaterEqualLess:"\u22DB",gel:"\u22DB",gtreqless:"\u22DB",GreaterFullEqual:"\u2267",gE:"\u2267",geqq:"\u2267",GreaterGreater:"\u2AA2",GreaterLess:"\u2277",gl:"\u2277",gtrless:"\u2277",GreaterSlantEqual:"\u2A7E",geqslant:"\u2A7E",ges:"\u2A7E",GreaterTilde:"\u2273",gsim:"\u2273",gtrsim:"\u2273",Gscr:"\u{1D4A2}",Gt:"\u226B",NestedGreaterGreater:"\u226B",gg:"\u226B",HARDcy:"\u042A",Hacek:"\u02C7",caron:"\u02C7",Hat:"^",Hcirc:"\u0124",Hfr:"\u210C",Poincareplane:"\u210C",HilbertSpace:"\u210B",Hscr:"\u210B",hamilt:"\u210B",Hopf:"\u210D",quaternions:"\u210D",HorizontalLine:"\u2500",boxh:"\u2500",Hstrok:"\u0126",HumpEqual:"\u224F",bumpe:"\u224F",bumpeq:"\u224F",IEcy:"\u0415",IJlig:"\u0132",IOcy:"\u0401",Iacute:"\xCD",Icirc:"\xCE",Icy:"\u0418",Idot:"\u0130",Ifr:"\u2111",Im:"\u2111",image:"\u2111",imagpart:"\u2111",Igrave:"\xCC",Imacr:"\u012A",ImaginaryI:"\u2148",ii:"\u2148",Int:"\u222C",Integral:"\u222B",int:"\u222B",Intersection:"\u22C2",bigcap:"\u22C2",xcap:"\u22C2",InvisibleComma:"\u2063",ic:"\u2063",InvisibleTimes:"\u2062",it:"\u2062",Iogon:"\u012E",Iopf:"\u{1D540}",Iota:"\u0399",Iscr:"\u2110",imagline:"\u2110",Itilde:"\u0128",Iukcy:"\u0406",Iuml:"\xCF",Jcirc:"\u0134",Jcy:"\u0419",Jfr:"\u{1D50D}",Jopf:"\u{1D541}",Jscr:"\u{1D4A5}",Jsercy:"\u0408",Jukcy:"\u0404",KHcy:"\u0425",KJcy:"\u040C",Kappa:"\u039A",Kcedil:"\u0136",Kcy:"\u041A",Kfr:"\u{1D50E}",Kopf:"\u{1D542}",Kscr:"\u{1D4A6}",LJcy:"\u0409",LT:"<",lt:"<",Lacute:"\u0139",Lambda:"\u039B",Lang:"\u27EA",Laplacetrf:"\u2112",Lscr:"\u2112",lagran:"\u2112",Larr:"\u219E",twoheadleftarrow:"\u219E",Lcaron:"\u013D",Lcedil:"\u013B",Lcy:"\u041B",LeftAngleBracket:"\u27E8",lang:"\u27E8",langle:"\u27E8",LeftArrow:"\u2190",ShortLeftArrow:"\u2190",larr:"\u2190",leftarrow:"\u2190",slarr:"\u2190",LeftArrowBar:"\u21E4",larrb:"\u21E4",LeftArrowRightArrow:"\u21C6",leftrightarrows:"\u21C6",lrarr:"\u21C6",LeftCeiling:"\u2308",lceil:"\u2308",LeftDoubleBracket:"\u27E6",lobrk:"\u27E6",LeftDownTeeVector:"\u2961",LeftDownVector:"\u21C3",dharl:"\u21C3",downharpoonleft:"\u21C3",LeftDownVectorBar:"\u2959",LeftFloor:"\u230A",lfloor:"\u230A",LeftRightArrow:"\u2194",harr:"\u2194",leftrightarrow:"\u2194",LeftRightVector:"\u294E",LeftTee:"\u22A3",dashv:"\u22A3",LeftTeeArrow:"\u21A4",mapstoleft:"\u21A4",LeftTeeVector:"\u295A",LeftTriangle:"\u22B2",vartriangleleft:"\u22B2",vltri:"\u22B2",LeftTriangleBar:"\u29CF",LeftTriangleEqual:"\u22B4",ltrie:"\u22B4",trianglelefteq:"\u22B4",LeftUpDownVector:"\u2951",LeftUpTeeVector:"\u2960",LeftUpVector:"\u21BF",uharl:"\u21BF",upharpoonleft:"\u21BF",LeftUpVectorBar:"\u2958",LeftVector:"\u21BC",leftharpoonup:"\u21BC",lharu:"\u21BC",LeftVectorBar:"\u2952",LessEqualGreater:"\u22DA",leg:"\u22DA",lesseqgtr:"\u22DA",LessFullEqual:"\u2266",lE:"\u2266",leqq:"\u2266",LessGreater:"\u2276",lessgtr:"\u2276",lg:"\u2276",LessLess:"\u2AA1",LessSlantEqual:"\u2A7D",leqslant:"\u2A7D",les:"\u2A7D",LessTilde:"\u2272",lesssim:"\u2272",lsim:"\u2272",Lfr:"\u{1D50F}",Ll:"\u22D8",Lleftarrow:"\u21DA",lAarr:"\u21DA",Lmidot:"\u013F",LongLeftArrow:"\u27F5",longleftarrow:"\u27F5",xlarr:"\u27F5",LongLeftRightArrow:"\u27F7",longleftrightarrow:"\u27F7",xharr:"\u27F7",LongRightArrow:"\u27F6",longrightarrow:"\u27F6",xrarr:"\u27F6",Lopf:"\u{1D543}",LowerLeftArrow:"\u2199",swarr:"\u2199",swarrow:"\u2199",LowerRightArrow:"\u2198",searr:"\u2198",searrow:"\u2198",Lsh:"\u21B0",lsh:"\u21B0",Lstrok:"\u0141",Lt:"\u226A",NestedLessLess:"\u226A",ll:"\u226A",Map:"\u2905",Mcy:"\u041C",MediumSpace:"\u205F",Mellintrf:"\u2133",Mscr:"\u2133",phmmat:"\u2133",Mfr:"\u{1D510}",MinusPlus:"\u2213",mnplus:"\u2213",mp:"\u2213",Mopf:"\u{1D544}",Mu:"\u039C",NJcy:"\u040A",Nacute:"\u0143",Ncaron:"\u0147",Ncedil:"\u0145",Ncy:"\u041D",NegativeMediumSpace:"\u200B",NegativeThickSpace:"\u200B",NegativeThinSpace:"\u200B",NegativeVeryThinSpace:"\u200B",ZeroWidthSpace:"\u200B",NewLine:`
`,Nfr:"\u{1D511}",NoBreak:"\u2060",NonBreakingSpace:"\xA0",nbsp:"\xA0",Nopf:"\u2115",naturals:"\u2115",Not:"\u2AEC",NotCongruent:"\u2262",nequiv:"\u2262",NotCupCap:"\u226D",NotDoubleVerticalBar:"\u2226",npar:"\u2226",nparallel:"\u2226",nshortparallel:"\u2226",nspar:"\u2226",NotElement:"\u2209",notin:"\u2209",notinva:"\u2209",NotEqual:"\u2260",ne:"\u2260",NotEqualTilde:"\u2242\u0338",nesim:"\u2242\u0338",NotExists:"\u2204",nexist:"\u2204",nexists:"\u2204",NotGreater:"\u226F",ngt:"\u226F",ngtr:"\u226F",NotGreaterEqual:"\u2271",nge:"\u2271",ngeq:"\u2271",NotGreaterFullEqual:"\u2267\u0338",ngE:"\u2267\u0338",ngeqq:"\u2267\u0338",NotGreaterGreater:"\u226B\u0338",nGtv:"\u226B\u0338",NotGreaterLess:"\u2279",ntgl:"\u2279",NotGreaterSlantEqual:"\u2A7E\u0338",ngeqslant:"\u2A7E\u0338",nges:"\u2A7E\u0338",NotGreaterTilde:"\u2275",ngsim:"\u2275",NotHumpDownHump:"\u224E\u0338",nbump:"\u224E\u0338",NotHumpEqual:"\u224F\u0338",nbumpe:"\u224F\u0338",NotLeftTriangle:"\u22EA",nltri:"\u22EA",ntriangleleft:"\u22EA",NotLeftTriangleBar:"\u29CF\u0338",NotLeftTriangleEqual:"\u22EC",nltrie:"\u22EC",ntrianglelefteq:"\u22EC",NotLess:"\u226E",nless:"\u226E",nlt:"\u226E",NotLessEqual:"\u2270",nle:"\u2270",nleq:"\u2270",NotLessGreater:"\u2278",ntlg:"\u2278",NotLessLess:"\u226A\u0338",nLtv:"\u226A\u0338",NotLessSlantEqual:"\u2A7D\u0338",nleqslant:"\u2A7D\u0338",nles:"\u2A7D\u0338",NotLessTilde:"\u2274",nlsim:"\u2274",NotNestedGreaterGreater:"\u2AA2\u0338",NotNestedLessLess:"\u2AA1\u0338",NotPrecedes:"\u2280",npr:"\u2280",nprec:"\u2280",NotPrecedesEqual:"\u2AAF\u0338",npre:"\u2AAF\u0338",npreceq:"\u2AAF\u0338",NotPrecedesSlantEqual:"\u22E0",nprcue:"\u22E0",NotReverseElement:"\u220C",notni:"\u220C",notniva:"\u220C",NotRightTriangle:"\u22EB",nrtri:"\u22EB",ntriangleright:"\u22EB",NotRightTriangleBar:"\u29D0\u0338",NotRightTriangleEqual:"\u22ED",nrtrie:"\u22ED",ntrianglerighteq:"\u22ED",NotSquareSubset:"\u228F\u0338",NotSquareSubsetEqual:"\u22E2",nsqsube:"\u22E2",NotSquareSuperset:"\u2290\u0338",NotSquareSupersetEqual:"\u22E3",nsqsupe:"\u22E3",NotSubset:"\u2282\u20D2",nsubset:"\u2282\u20D2",vnsub:"\u2282\u20D2",NotSubsetEqual:"\u2288",nsube:"\u2288",nsubseteq:"\u2288",NotSucceeds:"\u2281",nsc:"\u2281",nsucc:"\u2281",NotSucceedsEqual:"\u2AB0\u0338",nsce:"\u2AB0\u0338",nsucceq:"\u2AB0\u0338",NotSucceedsSlantEqual:"\u22E1",nsccue:"\u22E1",NotSucceedsTilde:"\u227F\u0338",NotSuperset:"\u2283\u20D2",nsupset:"\u2283\u20D2",vnsup:"\u2283\u20D2",NotSupersetEqual:"\u2289",nsupe:"\u2289",nsupseteq:"\u2289",NotTilde:"\u2241",nsim:"\u2241",NotTildeEqual:"\u2244",nsime:"\u2244",nsimeq:"\u2244",NotTildeFullEqual:"\u2247",ncong:"\u2247",NotTildeTilde:"\u2249",nap:"\u2249",napprox:"\u2249",NotVerticalBar:"\u2224",nmid:"\u2224",nshortmid:"\u2224",nsmid:"\u2224",Nscr:"\u{1D4A9}",Ntilde:"\xD1",Nu:"\u039D",OElig:"\u0152",Oacute:"\xD3",Ocirc:"\xD4",Ocy:"\u041E",Odblac:"\u0150",Ofr:"\u{1D512}",Ograve:"\xD2",Omacr:"\u014C",Omega:"\u03A9",ohm:"\u03A9",Omicron:"\u039F",Oopf:"\u{1D546}",OpenCurlyDoubleQuote:"\u201C",ldquo:"\u201C",OpenCurlyQuote:"\u2018",lsquo:"\u2018",Or:"\u2A54",Oscr:"\u{1D4AA}",Oslash:"\xD8",Otilde:"\xD5",Otimes:"\u2A37",Ouml:"\xD6",OverBar:"\u203E",oline:"\u203E",OverBrace:"\u23DE",OverBracket:"\u23B4",tbrk:"\u23B4",OverParenthesis:"\u23DC",PartialD:"\u2202",part:"\u2202",Pcy:"\u041F",Pfr:"\u{1D513}",Phi:"\u03A6",Pi:"\u03A0",PlusMinus:"\xB1",plusmn:"\xB1",pm:"\xB1",Popf:"\u2119",primes:"\u2119",Pr:"\u2ABB",Precedes:"\u227A",pr:"\u227A",prec:"\u227A",PrecedesEqual:"\u2AAF",pre:"\u2AAF",preceq:"\u2AAF",PrecedesSlantEqual:"\u227C",prcue:"\u227C",preccurlyeq:"\u227C",PrecedesTilde:"\u227E",precsim:"\u227E",prsim:"\u227E",Prime:"\u2033",Product:"\u220F",prod:"\u220F",Proportional:"\u221D",prop:"\u221D",propto:"\u221D",varpropto:"\u221D",vprop:"\u221D",Pscr:"\u{1D4AB}",Psi:"\u03A8",QUOT:'"',quot:'"',Qfr:"\u{1D514}",Qopf:"\u211A",rationals:"\u211A",Qscr:"\u{1D4AC}",RBarr:"\u2910",drbkarow:"\u2910",REG:"\xAE",circledR:"\xAE",reg:"\xAE",Racute:"\u0154",Rang:"\u27EB",Rarr:"\u21A0",twoheadrightarrow:"\u21A0",Rarrtl:"\u2916",Rcaron:"\u0158",Rcedil:"\u0156",Rcy:"\u0420",Re:"\u211C",Rfr:"\u211C",real:"\u211C",realpart:"\u211C",ReverseElement:"\u220B",SuchThat:"\u220B",ni:"\u220B",niv:"\u220B",ReverseEquilibrium:"\u21CB",leftrightharpoons:"\u21CB",lrhar:"\u21CB",ReverseUpEquilibrium:"\u296F",duhar:"\u296F",Rho:"\u03A1",RightAngleBracket:"\u27E9",rang:"\u27E9",rangle:"\u27E9",RightArrow:"\u2192",ShortRightArrow:"\u2192",rarr:"\u2192",rightarrow:"\u2192",srarr:"\u2192",RightArrowBar:"\u21E5",rarrb:"\u21E5",RightArrowLeftArrow:"\u21C4",rightleftarrows:"\u21C4",rlarr:"\u21C4",RightCeiling:"\u2309",rceil:"\u2309",RightDoubleBracket:"\u27E7",robrk:"\u27E7",RightDownTeeVector:"\u295D",RightDownVector:"\u21C2",dharr:"\u21C2",downharpoonright:"\u21C2",RightDownVectorBar:"\u2955",RightFloor:"\u230B",rfloor:"\u230B",RightTee:"\u22A2",vdash:"\u22A2",RightTeeArrow:"\u21A6",map:"\u21A6",mapsto:"\u21A6",RightTeeVector:"\u295B",RightTriangle:"\u22B3",vartriangleright:"\u22B3",vrtri:"\u22B3",RightTriangleBar:"\u29D0",RightTriangleEqual:"\u22B5",rtrie:"\u22B5",trianglerighteq:"\u22B5",RightUpDownVector:"\u294F",RightUpTeeVector:"\u295C",RightUpVector:"\u21BE",uharr:"\u21BE",upharpoonright:"\u21BE",RightUpVectorBar:"\u2954",RightVector:"\u21C0",rharu:"\u21C0",rightharpoonup:"\u21C0",RightVectorBar:"\u2953",Ropf:"\u211D",reals:"\u211D",RoundImplies:"\u2970",Rrightarrow:"\u21DB",rAarr:"\u21DB",Rscr:"\u211B",realine:"\u211B",Rsh:"\u21B1",rsh:"\u21B1",RuleDelayed:"\u29F4",SHCHcy:"\u0429",SHcy:"\u0428",SOFTcy:"\u042C",Sacute:"\u015A",Sc:"\u2ABC",Scaron:"\u0160",Scedil:"\u015E",Scirc:"\u015C",Scy:"\u0421",Sfr:"\u{1D516}",ShortUpArrow:"\u2191",UpArrow:"\u2191",uarr:"\u2191",uparrow:"\u2191",Sigma:"\u03A3",SmallCircle:"\u2218",compfn:"\u2218",Sopf:"\u{1D54A}",Sqrt:"\u221A",radic:"\u221A",Square:"\u25A1",squ:"\u25A1",square:"\u25A1",SquareIntersection:"\u2293",sqcap:"\u2293",SquareSubset:"\u228F",sqsub:"\u228F",sqsubset:"\u228F",SquareSubsetEqual:"\u2291",sqsube:"\u2291",sqsubseteq:"\u2291",SquareSuperset:"\u2290",sqsup:"\u2290",sqsupset:"\u2290",SquareSupersetEqual:"\u2292",sqsupe:"\u2292",sqsupseteq:"\u2292",SquareUnion:"\u2294",sqcup:"\u2294",Sscr:"\u{1D4AE}",Star:"\u22C6",sstarf:"\u22C6",Sub:"\u22D0",Subset:"\u22D0",SubsetEqual:"\u2286",sube:"\u2286",subseteq:"\u2286",Succeeds:"\u227B",sc:"\u227B",succ:"\u227B",SucceedsEqual:"\u2AB0",sce:"\u2AB0",succeq:"\u2AB0",SucceedsSlantEqual:"\u227D",sccue:"\u227D",succcurlyeq:"\u227D",SucceedsTilde:"\u227F",scsim:"\u227F",succsim:"\u227F",Sum:"\u2211",sum:"\u2211",Sup:"\u22D1",Supset:"\u22D1",Superset:"\u2283",sup:"\u2283",supset:"\u2283",SupersetEqual:"\u2287",supe:"\u2287",supseteq:"\u2287",THORN:"\xDE",TRADE:"\u2122",trade:"\u2122",TSHcy:"\u040B",TScy:"\u0426",Tab:"	",Tau:"\u03A4",Tcaron:"\u0164",Tcedil:"\u0162",Tcy:"\u0422",Tfr:"\u{1D517}",Therefore:"\u2234",there4:"\u2234",therefore:"\u2234",Theta:"\u0398",ThickSpace:"\u205F\u200A",ThinSpace:"\u2009",thinsp:"\u2009",Tilde:"\u223C",sim:"\u223C",thicksim:"\u223C",thksim:"\u223C",TildeEqual:"\u2243",sime:"\u2243",simeq:"\u2243",TildeFullEqual:"\u2245",cong:"\u2245",TildeTilde:"\u2248",ap:"\u2248",approx:"\u2248",asymp:"\u2248",thickapprox:"\u2248",thkap:"\u2248",Topf:"\u{1D54B}",TripleDot:"\u20DB",tdot:"\u20DB",Tscr:"\u{1D4AF}",Tstrok:"\u0166",Uacute:"\xDA",Uarr:"\u219F",Uarrocir:"\u2949",Ubrcy:"\u040E",Ubreve:"\u016C",Ucirc:"\xDB",Ucy:"\u0423",Udblac:"\u0170",Ufr:"\u{1D518}",Ugrave:"\xD9",Umacr:"\u016A",UnderBar:"_",lowbar:"_",UnderBrace:"\u23DF",UnderBracket:"\u23B5",bbrk:"\u23B5",UnderParenthesis:"\u23DD",Union:"\u22C3",bigcup:"\u22C3",xcup:"\u22C3",UnionPlus:"\u228E",uplus:"\u228E",Uogon:"\u0172",Uopf:"\u{1D54C}",UpArrowBar:"\u2912",UpArrowDownArrow:"\u21C5",udarr:"\u21C5",UpDownArrow:"\u2195",updownarrow:"\u2195",varr:"\u2195",UpEquilibrium:"\u296E",udhar:"\u296E",UpTee:"\u22A5",bot:"\u22A5",bottom:"\u22A5",perp:"\u22A5",UpTeeArrow:"\u21A5",mapstoup:"\u21A5",UpperLeftArrow:"\u2196",nwarr:"\u2196",nwarrow:"\u2196",UpperRightArrow:"\u2197",nearr:"\u2197",nearrow:"\u2197",Upsi:"\u03D2",upsih:"\u03D2",Upsilon:"\u03A5",Uring:"\u016E",Uscr:"\u{1D4B0}",Utilde:"\u0168",Uuml:"\xDC",VDash:"\u22AB",Vbar:"\u2AEB",Vcy:"\u0412",Vdash:"\u22A9",Vdashl:"\u2AE6",Vee:"\u22C1",bigvee:"\u22C1",xvee:"\u22C1",Verbar:"\u2016",Vert:"\u2016",VerticalBar:"\u2223",mid:"\u2223",shortmid:"\u2223",smid:"\u2223",VerticalLine:"|",verbar:"|",vert:"|",VerticalSeparator:"\u2758",VerticalTilde:"\u2240",wr:"\u2240",wreath:"\u2240",VeryThinSpace:"\u200A",hairsp:"\u200A",Vfr:"\u{1D519}",Vopf:"\u{1D54D}",Vscr:"\u{1D4B1}",Vvdash:"\u22AA",Wcirc:"\u0174",Wedge:"\u22C0",bigwedge:"\u22C0",xwedge:"\u22C0",Wfr:"\u{1D51A}",Wopf:"\u{1D54E}",Wscr:"\u{1D4B2}",Xfr:"\u{1D51B}",Xi:"\u039E",Xopf:"\u{1D54F}",Xscr:"\u{1D4B3}",YAcy:"\u042F",YIcy:"\u0407",YUcy:"\u042E",Yacute:"\xDD",Ycirc:"\u0176",Ycy:"\u042B",Yfr:"\u{1D51C}",Yopf:"\u{1D550}",Yscr:"\u{1D4B4}",Yuml:"\u0178",ZHcy:"\u0416",Zacute:"\u0179",Zcaron:"\u017D",Zcy:"\u0417",Zdot:"\u017B",Zeta:"\u0396",Zfr:"\u2128",zeetrf:"\u2128",Zopf:"\u2124",integers:"\u2124",Zscr:"\u{1D4B5}",aacute:"\xE1",abreve:"\u0103",ac:"\u223E",mstpos:"\u223E",acE:"\u223E\u0333",acd:"\u223F",acirc:"\xE2",acy:"\u0430",aelig:"\xE6",afr:"\u{1D51E}",agrave:"\xE0",alefsym:"\u2135",aleph:"\u2135",alpha:"\u03B1",amacr:"\u0101",amalg:"\u2A3F",and:"\u2227",wedge:"\u2227",andand:"\u2A55",andd:"\u2A5C",andslope:"\u2A58",andv:"\u2A5A",ang:"\u2220",angle:"\u2220",ange:"\u29A4",angmsd:"\u2221",measuredangle:"\u2221",angmsdaa:"\u29A8",angmsdab:"\u29A9",angmsdac:"\u29AA",angmsdad:"\u29AB",angmsdae:"\u29AC",angmsdaf:"\u29AD",angmsdag:"\u29AE",angmsdah:"\u29AF",angrt:"\u221F",angrtvb:"\u22BE",angrtvbd:"\u299D",angsph:"\u2222",angzarr:"\u237C",aogon:"\u0105",aopf:"\u{1D552}",apE:"\u2A70",apacir:"\u2A6F",ape:"\u224A",approxeq:"\u224A",apid:"\u224B",apos:"'",aring:"\xE5",ascr:"\u{1D4B6}",ast:"*",midast:"*",atilde:"\xE3",auml:"\xE4",awint:"\u2A11",bNot:"\u2AED",backcong:"\u224C",bcong:"\u224C",backepsilon:"\u03F6",bepsi:"\u03F6",backprime:"\u2035",bprime:"\u2035",backsim:"\u223D",bsim:"\u223D",backsimeq:"\u22CD",bsime:"\u22CD",barvee:"\u22BD",barwed:"\u2305",barwedge:"\u2305",bbrktbrk:"\u23B6",bcy:"\u0431",bdquo:"\u201E",ldquor:"\u201E",bemptyv:"\u29B0",beta:"\u03B2",beth:"\u2136",between:"\u226C",twixt:"\u226C",bfr:"\u{1D51F}",bigcirc:"\u25EF",xcirc:"\u25EF",bigodot:"\u2A00",xodot:"\u2A00",bigoplus:"\u2A01",xoplus:"\u2A01",bigotimes:"\u2A02",xotime:"\u2A02",bigsqcup:"\u2A06",xsqcup:"\u2A06",bigstar:"\u2605",starf:"\u2605",bigtriangledown:"\u25BD",xdtri:"\u25BD",bigtriangleup:"\u25B3",xutri:"\u25B3",biguplus:"\u2A04",xuplus:"\u2A04",bkarow:"\u290D",rbarr:"\u290D",blacklozenge:"\u29EB",lozf:"\u29EB",blacktriangle:"\u25B4",utrif:"\u25B4",blacktriangledown:"\u25BE",dtrif:"\u25BE",blacktriangleleft:"\u25C2",ltrif:"\u25C2",blacktriangleright:"\u25B8",rtrif:"\u25B8",blank:"\u2423",blk12:"\u2592",blk14:"\u2591",blk34:"\u2593",block:"\u2588",bne:"=\u20E5",bnequiv:"\u2261\u20E5",bnot:"\u2310",bopf:"\u{1D553}",bowtie:"\u22C8",boxDL:"\u2557",boxDR:"\u2554",boxDl:"\u2556",boxDr:"\u2553",boxH:"\u2550",boxHD:"\u2566",boxHU:"\u2569",boxHd:"\u2564",boxHu:"\u2567",boxUL:"\u255D",boxUR:"\u255A",boxUl:"\u255C",boxUr:"\u2559",boxV:"\u2551",boxVH:"\u256C",boxVL:"\u2563",boxVR:"\u2560",boxVh:"\u256B",boxVl:"\u2562",boxVr:"\u255F",boxbox:"\u29C9",boxdL:"\u2555",boxdR:"\u2552",boxdl:"\u2510",boxdr:"\u250C",boxhD:"\u2565",boxhU:"\u2568",boxhd:"\u252C",boxhu:"\u2534",boxminus:"\u229F",minusb:"\u229F",boxplus:"\u229E",plusb:"\u229E",boxtimes:"\u22A0",timesb:"\u22A0",boxuL:"\u255B",boxuR:"\u2558",boxul:"\u2518",boxur:"\u2514",boxv:"\u2502",boxvH:"\u256A",boxvL:"\u2561",boxvR:"\u255E",boxvh:"\u253C",boxvl:"\u2524",boxvr:"\u251C",brvbar:"\xA6",bscr:"\u{1D4B7}",bsemi:"\u204F",bsol:"\\",bsolb:"\u29C5",bsolhsub:"\u27C8",bull:"\u2022",bullet:"\u2022",bumpE:"\u2AAE",cacute:"\u0107",cap:"\u2229",capand:"\u2A44",capbrcup:"\u2A49",capcap:"\u2A4B",capcup:"\u2A47",capdot:"\u2A40",caps:"\u2229\uFE00",caret:"\u2041",ccaps:"\u2A4D",ccaron:"\u010D",ccedil:"\xE7",ccirc:"\u0109",ccups:"\u2A4C",ccupssm:"\u2A50",cdot:"\u010B",cemptyv:"\u29B2",cent:"\xA2",cfr:"\u{1D520}",chcy:"\u0447",check:"\u2713",checkmark:"\u2713",chi:"\u03C7",cir:"\u25CB",cirE:"\u29C3",circ:"\u02C6",circeq:"\u2257",cire:"\u2257",circlearrowleft:"\u21BA",olarr:"\u21BA",circlearrowright:"\u21BB",orarr:"\u21BB",circledS:"\u24C8",oS:"\u24C8",circledast:"\u229B",oast:"\u229B",circledcirc:"\u229A",ocir:"\u229A",circleddash:"\u229D",odash:"\u229D",cirfnint:"\u2A10",cirmid:"\u2AEF",cirscir:"\u29C2",clubs:"\u2663",clubsuit:"\u2663",colon:":",comma:",",commat:"@",comp:"\u2201",complement:"\u2201",congdot:"\u2A6D",copf:"\u{1D554}",copysr:"\u2117",crarr:"\u21B5",cross:"\u2717",cscr:"\u{1D4B8}",csub:"\u2ACF",csube:"\u2AD1",csup:"\u2AD0",csupe:"\u2AD2",ctdot:"\u22EF",cudarrl:"\u2938",cudarrr:"\u2935",cuepr:"\u22DE",curlyeqprec:"\u22DE",cuesc:"\u22DF",curlyeqsucc:"\u22DF",cularr:"\u21B6",curvearrowleft:"\u21B6",cularrp:"\u293D",cup:"\u222A",cupbrcap:"\u2A48",cupcap:"\u2A46",cupcup:"\u2A4A",cupdot:"\u228D",cupor:"\u2A45",cups:"\u222A\uFE00",curarr:"\u21B7",curvearrowright:"\u21B7",curarrm:"\u293C",curlyvee:"\u22CE",cuvee:"\u22CE",curlywedge:"\u22CF",cuwed:"\u22CF",curren:"\xA4",cwint:"\u2231",cylcty:"\u232D",dHar:"\u2965",dagger:"\u2020",daleth:"\u2138",dash:"\u2010",hyphen:"\u2010",dbkarow:"\u290F",rBarr:"\u290F",dcaron:"\u010F",dcy:"\u0434",ddarr:"\u21CA",downdownarrows:"\u21CA",ddotseq:"\u2A77",eDDot:"\u2A77",deg:"\xB0",delta:"\u03B4",demptyv:"\u29B1",dfisht:"\u297F",dfr:"\u{1D521}",diamondsuit:"\u2666",diams:"\u2666",digamma:"\u03DD",gammad:"\u03DD",disin:"\u22F2",div:"\xF7",divide:"\xF7",divideontimes:"\u22C7",divonx:"\u22C7",djcy:"\u0452",dlcorn:"\u231E",llcorner:"\u231E",dlcrop:"\u230D",dollar:"$",dopf:"\u{1D555}",doteqdot:"\u2251",eDot:"\u2251",dotminus:"\u2238",minusd:"\u2238",dotplus:"\u2214",plusdo:"\u2214",dotsquare:"\u22A1",sdotb:"\u22A1",drcorn:"\u231F",lrcorner:"\u231F",drcrop:"\u230C",dscr:"\u{1D4B9}",dscy:"\u0455",dsol:"\u29F6",dstrok:"\u0111",dtdot:"\u22F1",dtri:"\u25BF",triangledown:"\u25BF",dwangle:"\u29A6",dzcy:"\u045F",dzigrarr:"\u27FF",eacute:"\xE9",easter:"\u2A6E",ecaron:"\u011B",ecir:"\u2256",eqcirc:"\u2256",ecirc:"\xEA",ecolon:"\u2255",eqcolon:"\u2255",ecy:"\u044D",edot:"\u0117",efDot:"\u2252",fallingdotseq:"\u2252",efr:"\u{1D522}",eg:"\u2A9A",egrave:"\xE8",egs:"\u2A96",eqslantgtr:"\u2A96",egsdot:"\u2A98",el:"\u2A99",elinters:"\u23E7",ell:"\u2113",els:"\u2A95",eqslantless:"\u2A95",elsdot:"\u2A97",emacr:"\u0113",empty:"\u2205",emptyset:"\u2205",emptyv:"\u2205",varnothing:"\u2205",emsp13:"\u2004",emsp14:"\u2005",emsp:"\u2003",eng:"\u014B",ensp:"\u2002",eogon:"\u0119",eopf:"\u{1D556}",epar:"\u22D5",eparsl:"\u29E3",eplus:"\u2A71",epsi:"\u03B5",epsilon:"\u03B5",epsiv:"\u03F5",straightepsilon:"\u03F5",varepsilon:"\u03F5",equals:"=",equest:"\u225F",questeq:"\u225F",equivDD:"\u2A78",eqvparsl:"\u29E5",erDot:"\u2253",risingdotseq:"\u2253",erarr:"\u2971",escr:"\u212F",eta:"\u03B7",eth:"\xF0",euml:"\xEB",euro:"\u20AC",excl:"!",fcy:"\u0444",female:"\u2640",ffilig:"\uFB03",fflig:"\uFB00",ffllig:"\uFB04",ffr:"\u{1D523}",filig:"\uFB01",fjlig:"fj",flat:"\u266D",fllig:"\uFB02",fltns:"\u25B1",fnof:"\u0192",fopf:"\u{1D557}",fork:"\u22D4",pitchfork:"\u22D4",forkv:"\u2AD9",fpartint:"\u2A0D",frac12:"\xBD",half:"\xBD",frac13:"\u2153",frac14:"\xBC",frac15:"\u2155",frac16:"\u2159",frac18:"\u215B",frac23:"\u2154",frac25:"\u2156",frac34:"\xBE",frac35:"\u2157",frac38:"\u215C",frac45:"\u2158",frac56:"\u215A",frac58:"\u215D",frac78:"\u215E",frasl:"\u2044",frown:"\u2322",sfrown:"\u2322",fscr:"\u{1D4BB}",gEl:"\u2A8C",gtreqqless:"\u2A8C",gacute:"\u01F5",gamma:"\u03B3",gap:"\u2A86",gtrapprox:"\u2A86",gbreve:"\u011F",gcirc:"\u011D",gcy:"\u0433",gdot:"\u0121",gescc:"\u2AA9",gesdot:"\u2A80",gesdoto:"\u2A82",gesdotol:"\u2A84",gesl:"\u22DB\uFE00",gesles:"\u2A94",gfr:"\u{1D524}",gimel:"\u2137",gjcy:"\u0453",glE:"\u2A92",gla:"\u2AA5",glj:"\u2AA4",gnE:"\u2269",gneqq:"\u2269",gnap:"\u2A8A",gnapprox:"\u2A8A",gne:"\u2A88",gneq:"\u2A88",gnsim:"\u22E7",gopf:"\u{1D558}",gscr:"\u210A",gsime:"\u2A8E",gsiml:"\u2A90",gtcc:"\u2AA7",gtcir:"\u2A7A",gtdot:"\u22D7",gtrdot:"\u22D7",gtlPar:"\u2995",gtquest:"\u2A7C",gtrarr:"\u2978",gvertneqq:"\u2269\uFE00",gvnE:"\u2269\uFE00",hardcy:"\u044A",harrcir:"\u2948",harrw:"\u21AD",leftrightsquigarrow:"\u21AD",hbar:"\u210F",hslash:"\u210F",planck:"\u210F",plankv:"\u210F",hcirc:"\u0125",hearts:"\u2665",heartsuit:"\u2665",hellip:"\u2026",mldr:"\u2026",hercon:"\u22B9",hfr:"\u{1D525}",hksearow:"\u2925",searhk:"\u2925",hkswarow:"\u2926",swarhk:"\u2926",hoarr:"\u21FF",homtht:"\u223B",hookleftarrow:"\u21A9",larrhk:"\u21A9",hookrightarrow:"\u21AA",rarrhk:"\u21AA",hopf:"\u{1D559}",horbar:"\u2015",hscr:"\u{1D4BD}",hstrok:"\u0127",hybull:"\u2043",iacute:"\xED",icirc:"\xEE",icy:"\u0438",iecy:"\u0435",iexcl:"\xA1",ifr:"\u{1D526}",igrave:"\xEC",iiiint:"\u2A0C",qint:"\u2A0C",iiint:"\u222D",tint:"\u222D",iinfin:"\u29DC",iiota:"\u2129",ijlig:"\u0133",imacr:"\u012B",imath:"\u0131",inodot:"\u0131",imof:"\u22B7",imped:"\u01B5",incare:"\u2105",infin:"\u221E",infintie:"\u29DD",intcal:"\u22BA",intercal:"\u22BA",intlarhk:"\u2A17",intprod:"\u2A3C",iprod:"\u2A3C",iocy:"\u0451",iogon:"\u012F",iopf:"\u{1D55A}",iota:"\u03B9",iquest:"\xBF",iscr:"\u{1D4BE}",isinE:"\u22F9",isindot:"\u22F5",isins:"\u22F4",isinsv:"\u22F3",itilde:"\u0129",iukcy:"\u0456",iuml:"\xEF",jcirc:"\u0135",jcy:"\u0439",jfr:"\u{1D527}",jmath:"\u0237",jopf:"\u{1D55B}",jscr:"\u{1D4BF}",jsercy:"\u0458",jukcy:"\u0454",kappa:"\u03BA",kappav:"\u03F0",varkappa:"\u03F0",kcedil:"\u0137",kcy:"\u043A",kfr:"\u{1D528}",kgreen:"\u0138",khcy:"\u0445",kjcy:"\u045C",kopf:"\u{1D55C}",kscr:"\u{1D4C0}",lAtail:"\u291B",lBarr:"\u290E",lEg:"\u2A8B",lesseqqgtr:"\u2A8B",lHar:"\u2962",lacute:"\u013A",laemptyv:"\u29B4",lambda:"\u03BB",langd:"\u2991",lap:"\u2A85",lessapprox:"\u2A85",laquo:"\xAB",larrbfs:"\u291F",larrfs:"\u291D",larrlp:"\u21AB",looparrowleft:"\u21AB",larrpl:"\u2939",larrsim:"\u2973",larrtl:"\u21A2",leftarrowtail:"\u21A2",lat:"\u2AAB",latail:"\u2919",late:"\u2AAD",lates:"\u2AAD\uFE00",lbarr:"\u290C",lbbrk:"\u2772",lbrace:"{",lcub:"{",lbrack:"[",lsqb:"[",lbrke:"\u298B",lbrksld:"\u298F",lbrkslu:"\u298D",lcaron:"\u013E",lcedil:"\u013C",lcy:"\u043B",ldca:"\u2936",ldrdhar:"\u2967",ldrushar:"\u294B",ldsh:"\u21B2",le:"\u2264",leq:"\u2264",leftleftarrows:"\u21C7",llarr:"\u21C7",leftthreetimes:"\u22CB",lthree:"\u22CB",lescc:"\u2AA8",lesdot:"\u2A7F",lesdoto:"\u2A81",lesdotor:"\u2A83",lesg:"\u22DA\uFE00",lesges:"\u2A93",lessdot:"\u22D6",ltdot:"\u22D6",lfisht:"\u297C",lfr:"\u{1D529}",lgE:"\u2A91",lharul:"\u296A",lhblk:"\u2584",ljcy:"\u0459",llhard:"\u296B",lltri:"\u25FA",lmidot:"\u0140",lmoust:"\u23B0",lmoustache:"\u23B0",lnE:"\u2268",lneqq:"\u2268",lnap:"\u2A89",lnapprox:"\u2A89",lne:"\u2A87",lneq:"\u2A87",lnsim:"\u22E6",loang:"\u27EC",loarr:"\u21FD",longmapsto:"\u27FC",xmap:"\u27FC",looparrowright:"\u21AC",rarrlp:"\u21AC",lopar:"\u2985",lopf:"\u{1D55D}",loplus:"\u2A2D",lotimes:"\u2A34",lowast:"\u2217",loz:"\u25CA",lozenge:"\u25CA",lpar:"(",lparlt:"\u2993",lrhard:"\u296D",lrm:"\u200E",lrtri:"\u22BF",lsaquo:"\u2039",lscr:"\u{1D4C1}",lsime:"\u2A8D",lsimg:"\u2A8F",lsquor:"\u201A",sbquo:"\u201A",lstrok:"\u0142",ltcc:"\u2AA6",ltcir:"\u2A79",ltimes:"\u22C9",ltlarr:"\u2976",ltquest:"\u2A7B",ltrPar:"\u2996",ltri:"\u25C3",triangleleft:"\u25C3",lurdshar:"\u294A",luruhar:"\u2966",lvertneqq:"\u2268\uFE00",lvnE:"\u2268\uFE00",mDDot:"\u223A",macr:"\xAF",strns:"\xAF",male:"\u2642",malt:"\u2720",maltese:"\u2720",marker:"\u25AE",mcomma:"\u2A29",mcy:"\u043C",mdash:"\u2014",mfr:"\u{1D52A}",mho:"\u2127",micro:"\xB5",midcir:"\u2AF0",minus:"\u2212",minusdu:"\u2A2A",mlcp:"\u2ADB",models:"\u22A7",mopf:"\u{1D55E}",mscr:"\u{1D4C2}",mu:"\u03BC",multimap:"\u22B8",mumap:"\u22B8",nGg:"\u22D9\u0338",nGt:"\u226B\u20D2",nLeftarrow:"\u21CD",nlArr:"\u21CD",nLeftrightarrow:"\u21CE",nhArr:"\u21CE",nLl:"\u22D8\u0338",nLt:"\u226A\u20D2",nRightarrow:"\u21CF",nrArr:"\u21CF",nVDash:"\u22AF",nVdash:"\u22AE",nacute:"\u0144",nang:"\u2220\u20D2",napE:"\u2A70\u0338",napid:"\u224B\u0338",napos:"\u0149",natur:"\u266E",natural:"\u266E",ncap:"\u2A43",ncaron:"\u0148",ncedil:"\u0146",ncongdot:"\u2A6D\u0338",ncup:"\u2A42",ncy:"\u043D",ndash:"\u2013",neArr:"\u21D7",nearhk:"\u2924",nedot:"\u2250\u0338",nesear:"\u2928",toea:"\u2928",nfr:"\u{1D52B}",nharr:"\u21AE",nleftrightarrow:"\u21AE",nhpar:"\u2AF2",nis:"\u22FC",nisd:"\u22FA",njcy:"\u045A",nlE:"\u2266\u0338",nleqq:"\u2266\u0338",nlarr:"\u219A",nleftarrow:"\u219A",nldr:"\u2025",nopf:"\u{1D55F}",not:"\xAC",notinE:"\u22F9\u0338",notindot:"\u22F5\u0338",notinvb:"\u22F7",notinvc:"\u22F6",notnivb:"\u22FE",notnivc:"\u22FD",nparsl:"\u2AFD\u20E5",npart:"\u2202\u0338",npolint:"\u2A14",nrarr:"\u219B",nrightarrow:"\u219B",nrarrc:"\u2933\u0338",nrarrw:"\u219D\u0338",nscr:"\u{1D4C3}",nsub:"\u2284",nsubE:"\u2AC5\u0338",nsubseteqq:"\u2AC5\u0338",nsup:"\u2285",nsupE:"\u2AC6\u0338",nsupseteqq:"\u2AC6\u0338",ntilde:"\xF1",nu:"\u03BD",num:"#",numero:"\u2116",numsp:"\u2007",nvDash:"\u22AD",nvHarr:"\u2904",nvap:"\u224D\u20D2",nvdash:"\u22AC",nvge:"\u2265\u20D2",nvgt:">\u20D2",nvinfin:"\u29DE",nvlArr:"\u2902",nvle:"\u2264\u20D2",nvlt:"<\u20D2",nvltrie:"\u22B4\u20D2",nvrArr:"\u2903",nvrtrie:"\u22B5\u20D2",nvsim:"\u223C\u20D2",nwArr:"\u21D6",nwarhk:"\u2923",nwnear:"\u2927",oacute:"\xF3",ocirc:"\xF4",ocy:"\u043E",odblac:"\u0151",odiv:"\u2A38",odsold:"\u29BC",oelig:"\u0153",ofcir:"\u29BF",ofr:"\u{1D52C}",ogon:"\u02DB",ograve:"\xF2",ogt:"\u29C1",ohbar:"\u29B5",olcir:"\u29BE",olcross:"\u29BB",olt:"\u29C0",omacr:"\u014D",omega:"\u03C9",omicron:"\u03BF",omid:"\u29B6",oopf:"\u{1D560}",opar:"\u29B7",operp:"\u29B9",or:"\u2228",vee:"\u2228",ord:"\u2A5D",order:"\u2134",orderof:"\u2134",oscr:"\u2134",ordf:"\xAA",ordm:"\xBA",origof:"\u22B6",oror:"\u2A56",orslope:"\u2A57",orv:"\u2A5B",oslash:"\xF8",osol:"\u2298",otilde:"\xF5",otimesas:"\u2A36",ouml:"\xF6",ovbar:"\u233D",para:"\xB6",parsim:"\u2AF3",parsl:"\u2AFD",pcy:"\u043F",percnt:"%",period:".",permil:"\u2030",pertenk:"\u2031",pfr:"\u{1D52D}",phi:"\u03C6",phiv:"\u03D5",straightphi:"\u03D5",varphi:"\u03D5",phone:"\u260E",pi:"\u03C0",piv:"\u03D6",varpi:"\u03D6",planckh:"\u210E",plus:"+",plusacir:"\u2A23",pluscir:"\u2A22",plusdu:"\u2A25",pluse:"\u2A72",plussim:"\u2A26",plustwo:"\u2A27",pointint:"\u2A15",popf:"\u{1D561}",pound:"\xA3",prE:"\u2AB3",prap:"\u2AB7",precapprox:"\u2AB7",precnapprox:"\u2AB9",prnap:"\u2AB9",precneqq:"\u2AB5",prnE:"\u2AB5",precnsim:"\u22E8",prnsim:"\u22E8",prime:"\u2032",profalar:"\u232E",profline:"\u2312",profsurf:"\u2313",prurel:"\u22B0",pscr:"\u{1D4C5}",psi:"\u03C8",puncsp:"\u2008",qfr:"\u{1D52E}",qopf:"\u{1D562}",qprime:"\u2057",qscr:"\u{1D4C6}",quatint:"\u2A16",quest:"?",rAtail:"\u291C",rHar:"\u2964",race:"\u223D\u0331",racute:"\u0155",raemptyv:"\u29B3",rangd:"\u2992",range:"\u29A5",raquo:"\xBB",rarrap:"\u2975",rarrbfs:"\u2920",rarrc:"\u2933",rarrfs:"\u291E",rarrpl:"\u2945",rarrsim:"\u2974",rarrtl:"\u21A3",rightarrowtail:"\u21A3",rarrw:"\u219D",rightsquigarrow:"\u219D",ratail:"\u291A",ratio:"\u2236",rbbrk:"\u2773",rbrace:"}",rcub:"}",rbrack:"]",rsqb:"]",rbrke:"\u298C",rbrksld:"\u298E",rbrkslu:"\u2990",rcaron:"\u0159",rcedil:"\u0157",rcy:"\u0440",rdca:"\u2937",rdldhar:"\u2969",rdsh:"\u21B3",rect:"\u25AD",rfisht:"\u297D",rfr:"\u{1D52F}",rharul:"\u296C",rho:"\u03C1",rhov:"\u03F1",varrho:"\u03F1",rightrightarrows:"\u21C9",rrarr:"\u21C9",rightthreetimes:"\u22CC",rthree:"\u22CC",ring:"\u02DA",rlm:"\u200F",rmoust:"\u23B1",rmoustache:"\u23B1",rnmid:"\u2AEE",roang:"\u27ED",roarr:"\u21FE",ropar:"\u2986",ropf:"\u{1D563}",roplus:"\u2A2E",rotimes:"\u2A35",rpar:")",rpargt:"\u2994",rppolint:"\u2A12",rsaquo:"\u203A",rscr:"\u{1D4C7}",rtimes:"\u22CA",rtri:"\u25B9",triangleright:"\u25B9",rtriltri:"\u29CE",ruluhar:"\u2968",rx:"\u211E",sacute:"\u015B",scE:"\u2AB4",scap:"\u2AB8",succapprox:"\u2AB8",scaron:"\u0161",scedil:"\u015F",scirc:"\u015D",scnE:"\u2AB6",succneqq:"\u2AB6",scnap:"\u2ABA",succnapprox:"\u2ABA",scnsim:"\u22E9",succnsim:"\u22E9",scpolint:"\u2A13",scy:"\u0441",sdot:"\u22C5",sdote:"\u2A66",seArr:"\u21D8",sect:"\xA7",semi:";",seswar:"\u2929",tosa:"\u2929",sext:"\u2736",sfr:"\u{1D530}",sharp:"\u266F",shchcy:"\u0449",shcy:"\u0448",shy:"\xAD",sigma:"\u03C3",sigmaf:"\u03C2",sigmav:"\u03C2",varsigma:"\u03C2",simdot:"\u2A6A",simg:"\u2A9E",simgE:"\u2AA0",siml:"\u2A9D",simlE:"\u2A9F",simne:"\u2246",simplus:"\u2A24",simrarr:"\u2972",smashp:"\u2A33",smeparsl:"\u29E4",smile:"\u2323",ssmile:"\u2323",smt:"\u2AAA",smte:"\u2AAC",smtes:"\u2AAC\uFE00",softcy:"\u044C",sol:"/",solb:"\u29C4",solbar:"\u233F",sopf:"\u{1D564}",spades:"\u2660",spadesuit:"\u2660",sqcaps:"\u2293\uFE00",sqcups:"\u2294\uFE00",sscr:"\u{1D4C8}",star:"\u2606",sub:"\u2282",subset:"\u2282",subE:"\u2AC5",subseteqq:"\u2AC5",subdot:"\u2ABD",subedot:"\u2AC3",submult:"\u2AC1",subnE:"\u2ACB",subsetneqq:"\u2ACB",subne:"\u228A",subsetneq:"\u228A",subplus:"\u2ABF",subrarr:"\u2979",subsim:"\u2AC7",subsub:"\u2AD5",subsup:"\u2AD3",sung:"\u266A",sup1:"\xB9",sup2:"\xB2",sup3:"\xB3",supE:"\u2AC6",supseteqq:"\u2AC6",supdot:"\u2ABE",supdsub:"\u2AD8",supedot:"\u2AC4",suphsol:"\u27C9",suphsub:"\u2AD7",suplarr:"\u297B",supmult:"\u2AC2",supnE:"\u2ACC",supsetneqq:"\u2ACC",supne:"\u228B",supsetneq:"\u228B",supplus:"\u2AC0",supsim:"\u2AC8",supsub:"\u2AD4",supsup:"\u2AD6",swArr:"\u21D9",swnwar:"\u292A",szlig:"\xDF",target:"\u2316",tau:"\u03C4",tcaron:"\u0165",tcedil:"\u0163",tcy:"\u0442",telrec:"\u2315",tfr:"\u{1D531}",theta:"\u03B8",thetasym:"\u03D1",thetav:"\u03D1",vartheta:"\u03D1",thorn:"\xFE",times:"\xD7",timesbar:"\u2A31",timesd:"\u2A30",topbot:"\u2336",topcir:"\u2AF1",topf:"\u{1D565}",topfork:"\u2ADA",tprime:"\u2034",triangle:"\u25B5",utri:"\u25B5",triangleq:"\u225C",trie:"\u225C",tridot:"\u25EC",triminus:"\u2A3A",triplus:"\u2A39",trisb:"\u29CD",tritime:"\u2A3B",trpezium:"\u23E2",tscr:"\u{1D4C9}",tscy:"\u0446",tshcy:"\u045B",tstrok:"\u0167",uHar:"\u2963",uacute:"\xFA",ubrcy:"\u045E",ubreve:"\u016D",ucirc:"\xFB",ucy:"\u0443",udblac:"\u0171",ufisht:"\u297E",ufr:"\u{1D532}",ugrave:"\xF9",uhblk:"\u2580",ulcorn:"\u231C",ulcorner:"\u231C",ulcrop:"\u230F",ultri:"\u25F8",umacr:"\u016B",uogon:"\u0173",uopf:"\u{1D566}",upsi:"\u03C5",upsilon:"\u03C5",upuparrows:"\u21C8",uuarr:"\u21C8",urcorn:"\u231D",urcorner:"\u231D",urcrop:"\u230E",uring:"\u016F",urtri:"\u25F9",uscr:"\u{1D4CA}",utdot:"\u22F0",utilde:"\u0169",uuml:"\xFC",uwangle:"\u29A7",vBar:"\u2AE8",vBarv:"\u2AE9",vangrt:"\u299C",varsubsetneq:"\u228A\uFE00",vsubne:"\u228A\uFE00",varsubsetneqq:"\u2ACB\uFE00",vsubnE:"\u2ACB\uFE00",varsupsetneq:"\u228B\uFE00",vsupne:"\u228B\uFE00",varsupsetneqq:"\u2ACC\uFE00",vsupnE:"\u2ACC\uFE00",vcy:"\u0432",veebar:"\u22BB",veeeq:"\u225A",vellip:"\u22EE",vfr:"\u{1D533}",vopf:"\u{1D567}",vscr:"\u{1D4CB}",vzigzag:"\u299A",wcirc:"\u0175",wedbar:"\u2A5F",wedgeq:"\u2259",weierp:"\u2118",wp:"\u2118",wfr:"\u{1D534}",wopf:"\u{1D568}",wscr:"\u{1D4CC}",xfr:"\u{1D535}",xi:"\u03BE",xnis:"\u22FB",xopf:"\u{1D569}",xscr:"\u{1D4CD}",yacute:"\xFD",yacy:"\u044F",ycirc:"\u0177",ycy:"\u044B",yen:"\xA5",yfr:"\u{1D536}",yicy:"\u0457",yopf:"\u{1D56A}",yscr:"\u{1D4CE}",yucy:"\u044E",yuml:"\xFF",zacute:"\u017A",zcaron:"\u017E",zcy:"\u0437",zdot:"\u017C",zeta:"\u03B6",zfr:"\u{1D537}",zhcy:"\u0436",zigrarr:"\u21DD",zopf:"\u{1D56B}",zscr:"\u{1D4CF}",zwj:"\u200D",zwnj:"\u200C"},za="\uE500";html_Ye.ngsp=za;var Ga=[/@/,/^\s*$/,/[<>]/,/^[{}]$/,/&(#|[a-z])/i,/^\/\//];function Ls(t,e){if(e!=null&&!(Array.isArray(e)&&e.length==2))throw new Error(`Expected '${t}' to be an array, [start, end].`);if(e!=null){let r=e[0],n=e[1];Ga.forEach(s=>{if(s.test(r)||s.test(n))throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`)})}}var html_Lr=class t{static fromArray(e){return e?(Ls("interpolation",e),new t(e[0],e[1])):html_Fr}constructor(e,r){this.start=e,this.end=r}},html_Fr=new html_Lr("{{","}}");var html_ft=class extends html_Ue{constructor(e,r,n){super(n,e),this.tokenType=r}},html_$r=class{constructor(e,r,n){this.tokens=e,this.errors=r,this.nonNormalizedIcuExpressions=n}};function Ws(t,e,r,n={}){let s=new html_Or(new html_Te(t,e),r,n);return s.tokenize(),new html_$r(html_o(s.tokens),s.errors,s.nonNormalizedIcuExpressions)}var html_po=/\r\n?/g;function html_je(t){return`Unexpected character "${t===0?"EOF":String.fromCharCode(t)}"`}function Rs(t){return`Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`}function html_ho(t,e){return`Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`}var html_tr;(function(t){t.HEX="hexadecimal",t.DEC="decimal"})(html_tr||(html_tr={}));var html_dt=class{constructor(e){this.error=e}},html_Or=class{constructor(e,r,n){this._getTagContentType=r,this._currentTokenStart=null,this._currentTokenType=null,this._expansionCaseStack=[],this._inInterpolation=!1,this._fullNameStack=[],this.tokens=[],this.errors=[],this.nonNormalizedIcuExpressions=[],this._tokenizeIcu=n.tokenizeExpansionForms||!1,this._interpolationConfig=n.interpolationConfig||html_Fr,this._leadingTriviaCodePoints=n.leadingTriviaChars&&n.leadingTriviaChars.map(i=>i.codePointAt(0)||0),this._canSelfClose=n.canSelfClose||!1,this._allowHtmComponentClosingTags=n.allowHtmComponentClosingTags||!1;let s=n.range||{endPos:e.content.length,startPos:0,startLine:0,startCol:0};this._cursor=n.escapedString?new html_Mr(e,s):new html_rr(e,s),this._preserveLineEndings=n.preserveLineEndings||!1,this._i18nNormalizeLineEndingsInICUs=n.i18nNormalizeLineEndingsInICUs||!1,this._tokenizeBlocks=n.tokenizeBlocks??!0,this._tokenizeLet=n.tokenizeLet??!0;try{this._cursor.init()}catch(i){this.handleError(i)}}_processCarriageReturns(e){return this._preserveLineEndings?e:e.replace(html_po,`
`)}tokenize(){for(;this._cursor.peek()!==0;){let e=this._cursor.clone();try{if(this._attemptCharCode(60))if(this._attemptCharCode(33))this._attemptStr("[CDATA[")?this._consumeCdata(e):this._attemptStr("--")?this._consumeComment(e):this._attemptStrCaseInsensitive("doctype")?this._consumeDocType(e):this._consumeBogusComment(e);else if(this._attemptCharCode(47))this._consumeTagClose(e);else{let r=this._cursor.clone();this._attemptCharCode(63)?(this._cursor=r,this._consumeBogusComment(e)):this._consumeTagOpen(e)}else this._tokenizeLet&&this._cursor.peek()===64&&!this._inInterpolation&&this._attemptStr("@let")?this._consumeLetDeclaration(e):this._tokenizeBlocks&&this._attemptCharCode(64)?this._consumeBlockStart(e):this._tokenizeBlocks&&!this._inInterpolation&&!this._isInExpansionCase()&&!this._isInExpansionForm()&&this._attemptCharCode(125)?this._consumeBlockEnd(e):this._tokenizeIcu&&this._tokenizeExpansionForm()||this._consumeWithInterpolation(5,8,()=>this._isTextEnd(),()=>this._isTagStart())}catch(r){this.handleError(r)}}this._beginToken(34),this._endToken([])}_getBlockName(){let e=!1,r=this._cursor.clone();return this._attemptCharCodeUntilFn(n=>html_at(n)?!e:Ms(n)?(e=!0,!1):!0),this._cursor.getChars(r).trim()}_consumeBlockStart(e){this._beginToken(25,e);let r=this._endToken([this._getBlockName()]);if(this._cursor.peek()===40)if(this._cursor.advance(),this._consumeBlockParameters(),this._attemptCharCodeUntilFn(html_b),this._attemptCharCode(41))this._attemptCharCodeUntilFn(html_b);else{r.type=29;return}this._attemptCharCode(123)?(this._beginToken(26),this._endToken([])):r.type=29}_consumeBlockEnd(e){this._beginToken(27,e),this._endToken([])}_consumeBlockParameters(){for(this._attemptCharCodeUntilFn(qs);this._cursor.peek()!==41&&this._cursor.peek()!==0;){this._beginToken(28);let e=this._cursor.clone(),r=null,n=0;for(;this._cursor.peek()!==59&&this._cursor.peek()!==0||r!==null;){let s=this._cursor.peek();if(s===92)this._cursor.advance();else if(s===r)r=null;else if(r===null&&html_$t(s))r=s;else if(s===40&&r===null)n++;else if(s===41&&r===null){if(n===0)break;n>0&&n--}this._cursor.advance()}this._endToken([this._cursor.getChars(e)]),this._attemptCharCodeUntilFn(qs)}}_consumeLetDeclaration(e){if(this._beginToken(30,e),html_at(this._cursor.peek()))this._attemptCharCodeUntilFn(html_b);else{let s=this._endToken([this._cursor.getChars(e)]);s.type=33;return}let r=this._endToken([this._getLetDeclarationName()]);if(this._attemptCharCodeUntilFn(html_b),!this._attemptCharCode(61)){r.type=33;return}this._attemptCharCodeUntilFn(s=>html_b(s)&&!html_Rt(s)),this._consumeLetDeclarationValue(),this._cursor.peek()===59?(this._beginToken(32),this._endToken([]),this._cursor.advance()):(r.type=33,r.sourceSpan=this._cursor.getSpan(e))}_getLetDeclarationName(){let e=this._cursor.clone(),r=!1;return this._attemptCharCodeUntilFn(n=>html_ot(n)||n==36||n===95||r&&html_It(n)?(r=!0,!1):!0),this._cursor.getChars(e).trim()}_consumeLetDeclarationValue(){let e=this._cursor.clone();for(this._beginToken(31,e);this._cursor.peek()!==0;){let r=this._cursor.peek();if(r===59)break;html_$t(r)&&(this._cursor.advance(),this._attemptCharCodeUntilFn(n=>n===92?(this._cursor.advance(),!1):n===r)),this._cursor.advance()}this._endToken([this._cursor.getChars(e)])}_tokenizeExpansionForm(){if(this.isExpansionFormStart())return this._consumeExpansionFormStart(),!0;if(Co(this._cursor.peek())&&this._isInExpansionForm())return this._consumeExpansionCaseStart(),!0;if(this._cursor.peek()===125){if(this._isInExpansionCase())return this._consumeExpansionCaseEnd(),!0;if(this._isInExpansionForm())return this._consumeExpansionFormEnd(),!0}return!1}_beginToken(e,r=this._cursor.clone()){this._currentTokenStart=r,this._currentTokenType=e}_endToken(e,r){if(this._currentTokenStart===null)throw new html_ft("Programming error - attempted to end a token when there was no start to the token",this._currentTokenType,this._cursor.getSpan(r));if(this._currentTokenType===null)throw new html_ft("Programming error - attempted to end a token which has no token type",null,this._cursor.getSpan(this._currentTokenStart));let n={type:this._currentTokenType,parts:e,sourceSpan:(r??this._cursor).getSpan(this._currentTokenStart,this._leadingTriviaCodePoints)};return this.tokens.push(n),this._currentTokenStart=null,this._currentTokenType=null,n}_createError(e,r){this._isInExpansionForm()&&(e+=` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);let n=new html_ft(e,this._currentTokenType,r);return this._currentTokenStart=null,this._currentTokenType=null,new html_dt(n)}handleError(e){if(e instanceof html_gt&&(e=this._createError(e.msg,this._cursor.getSpan(e.cursor))),e instanceof html_dt)this.errors.push(e.error);else throw e}_attemptCharCode(e){return this._cursor.peek()===e?(this._cursor.advance(),!0):!1}_attemptCharCodeCaseInsensitive(e){return So(this._cursor.peek(),e)?(this._cursor.advance(),!0):!1}_requireCharCode(e){let r=this._cursor.clone();if(!this._attemptCharCode(e))throw this._createError(html_je(this._cursor.peek()),this._cursor.getSpan(r))}_attemptStr(e){let r=e.length;if(this._cursor.charsLeft()<r)return!1;let n=this._cursor.clone();for(let s=0;s<r;s++)if(!this._attemptCharCode(e.charCodeAt(s)))return this._cursor=n,!1;return!0}_attemptStrCaseInsensitive(e){for(let r=0;r<e.length;r++)if(!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))return!1;return!0}_requireStr(e){let r=this._cursor.clone();if(!this._attemptStr(e))throw this._createError(html_je(this._cursor.peek()),this._cursor.getSpan(r))}_requireStrCaseInsensitive(e){let r=this._cursor.clone();if(!this._attemptStrCaseInsensitive(e))throw this._createError(html_je(this._cursor.peek()),this._cursor.getSpan(r))}_attemptCharCodeUntilFn(e){for(;!e(this._cursor.peek());)this._cursor.advance()}_requireCharCodeUntilFn(e,r){let n=this._cursor.clone();if(this._attemptCharCodeUntilFn(e),this._cursor.diff(n)<r)throw this._createError(html_je(this._cursor.peek()),this._cursor.getSpan(n))}_attemptUntilChar(e){for(;this._cursor.peek()!==e;)this._cursor.advance()}_readChar(){let e=String.fromCodePoint(this._cursor.peek());return this._cursor.advance(),e}_consumeEntity(e){this._beginToken(9);let r=this._cursor.clone();if(this._cursor.advance(),this._attemptCharCode(35)){let n=this._attemptCharCode(120)||this._attemptCharCode(88),s=this._cursor.clone();if(this._attemptCharCodeUntilFn(html_fo),this._cursor.peek()!=59){this._cursor.advance();let a=n?html_tr.HEX:html_tr.DEC;throw this._createError(html_ho(a,this._cursor.getChars(r)),this._cursor.getSpan())}let i=this._cursor.getChars(s);this._cursor.advance();try{let a=parseInt(i,n?16:10);this._endToken([String.fromCharCode(a),this._cursor.getChars(r)])}catch{throw this._createError(Rs(this._cursor.getChars(r)),this._cursor.getSpan())}}else{let n=this._cursor.clone();if(this._attemptCharCodeUntilFn(html_go),this._cursor.peek()!=59)this._beginToken(e,r),this._cursor=n,this._endToken(["&"]);else{let s=this._cursor.getChars(n);this._cursor.advance();let i=html_Ye[s];if(!i)throw this._createError(Rs(s),this._cursor.getSpan(r));this._endToken([i,`&${s};`])}}}_consumeRawText(e,r){this._beginToken(e?6:7);let n=[];for(;;){let s=this._cursor.clone(),i=r();if(this._cursor=s,i)break;e&&this._cursor.peek()===38?(this._endToken([this._processCarriageReturns(n.join(""))]),n.length=0,this._consumeEntity(6),this._beginToken(6)):n.push(this._readChar())}this._endToken([this._processCarriageReturns(n.join(""))])}_consumeComment(e){this._beginToken(10,e),this._endToken([]),this._consumeRawText(!1,()=>this._attemptStr("-->")),this._beginToken(11),this._requireStr("-->"),this._endToken([])}_consumeBogusComment(e){this._beginToken(10,e),this._endToken([]),this._consumeRawText(!1,()=>this._cursor.peek()===62),this._beginToken(11),this._cursor.advance(),this._endToken([])}_consumeCdata(e){this._beginToken(12,e),this._endToken([]),this._consumeRawText(!1,()=>this._attemptStr("]]>")),this._beginToken(13),this._requireStr("]]>"),this._endToken([])}_consumeDocType(e){this._beginToken(18,e),this._endToken([]),this._consumeRawText(!1,()=>this._cursor.peek()===62),this._beginToken(19),this._cursor.advance(),this._endToken([])}_consumePrefixAndName(){let e=this._cursor.clone(),r="";for(;this._cursor.peek()!==58&&!html_mo(this._cursor.peek());)this._cursor.advance();let n;this._cursor.peek()===58?(r=this._cursor.getChars(e),this._cursor.advance(),n=this._cursor.clone()):n=e,this._requireCharCodeUntilFn($s,r===""?0:1);let s=this._cursor.getChars(n);return[r,s]}_consumeTagOpen(e){let r,n,s,i=[];try{if(!html_ot(this._cursor.peek()))throw this._createError(html_je(this._cursor.peek()),this._cursor.getSpan(e));for(s=this._consumeTagOpenStart(e),n=s.parts[0],r=s.parts[1],this._attemptCharCodeUntilFn(html_b);this._cursor.peek()!==47&&this._cursor.peek()!==62&&this._cursor.peek()!==60&&this._cursor.peek()!==0;){let[o,u]=this._consumeAttributeName();if(this._attemptCharCodeUntilFn(html_b),this._attemptCharCode(61)){this._attemptCharCodeUntilFn(html_b);let p=this._consumeAttributeValue();i.push({prefix:o,name:u,value:p})}else i.push({prefix:o,name:u});this._attemptCharCodeUntilFn(html_b)}this._consumeTagOpenEnd()}catch(o){if(o instanceof html_dt){s?s.type=4:(this._beginToken(5,e),this._endToken(["<"]));return}throw o}if(this._canSelfClose&&this.tokens[this.tokens.length-1].type===2)return;let a=this._getTagContentType(r,n,this._fullNameStack.length>0,i);this._handleFullNameStackForTagOpen(n,r),a===html_I.RAW_TEXT?this._consumeRawTextWithTagClose(n,r,!1):a===html_I.ESCAPABLE_RAW_TEXT&&this._consumeRawTextWithTagClose(n,r,!0)}_consumeRawTextWithTagClose(e,r,n){this._consumeRawText(n,()=>!this._attemptCharCode(60)||!this._attemptCharCode(47)||(this._attemptCharCodeUntilFn(html_b),!this._attemptStrCaseInsensitive(e?`${e}:${r}`:r))?!1:(this._attemptCharCodeUntilFn(html_b),this._attemptCharCode(62))),this._beginToken(3),this._requireCharCodeUntilFn(s=>s===62,3),this._cursor.advance(),this._endToken([e,r]),this._handleFullNameStackForTagClose(e,r)}_consumeTagOpenStart(e){this._beginToken(0,e);let r=this._consumePrefixAndName();return this._endToken(r)}_consumeAttributeName(){let e=this._cursor.peek();if(e===39||e===34)throw this._createError(html_je(e),this._cursor.getSpan());this._beginToken(14);let r=this._consumePrefixAndName();return this._endToken(r),r}_consumeAttributeValue(){let e;if(this._cursor.peek()===39||this._cursor.peek()===34){let r=this._cursor.peek();this._consumeQuote(r);let n=()=>this._cursor.peek()===r;e=this._consumeWithInterpolation(16,17,n,n),this._consumeQuote(r)}else{let r=()=>$s(this._cursor.peek());e=this._consumeWithInterpolation(16,17,r,r)}return e}_consumeQuote(e){this._beginToken(15),this._requireCharCode(e),this._endToken([String.fromCodePoint(e)])}_consumeTagOpenEnd(){let e=this._attemptCharCode(47)?2:1;this._beginToken(e),this._requireCharCode(62),this._endToken([])}_consumeTagClose(e){if(this._beginToken(3,e),this._attemptCharCodeUntilFn(html_b),this._allowHtmComponentClosingTags&&this._attemptCharCode(47))this._attemptCharCodeUntilFn(html_b),this._requireCharCode(62),this._endToken([]);else{let[r,n]=this._consumePrefixAndName();this._attemptCharCodeUntilFn(html_b),this._requireCharCode(62),this._endToken([r,n]),this._handleFullNameStackForTagClose(r,n)}}_consumeExpansionFormStart(){this._beginToken(20),this._requireCharCode(123),this._endToken([]),this._expansionCaseStack.push(20),this._beginToken(7);let e=this._readUntil(44),r=this._processCarriageReturns(e);if(this._i18nNormalizeLineEndingsInICUs)this._endToken([r]);else{let s=this._endToken([e]);r!==e&&this.nonNormalizedIcuExpressions.push(s)}this._requireCharCode(44),this._attemptCharCodeUntilFn(html_b),this._beginToken(7);let n=this._readUntil(44);this._endToken([n]),this._requireCharCode(44),this._attemptCharCodeUntilFn(html_b)}_consumeExpansionCaseStart(){this._beginToken(21);let e=this._readUntil(123).trim();this._endToken([e]),this._attemptCharCodeUntilFn(html_b),this._beginToken(22),this._requireCharCode(123),this._endToken([]),this._attemptCharCodeUntilFn(html_b),this._expansionCaseStack.push(22)}_consumeExpansionCaseEnd(){this._beginToken(23),this._requireCharCode(125),this._endToken([]),this._attemptCharCodeUntilFn(html_b),this._expansionCaseStack.pop()}_consumeExpansionFormEnd(){this._beginToken(24),this._requireCharCode(125),this._endToken([]),this._expansionCaseStack.pop()}_consumeWithInterpolation(e,r,n,s){this._beginToken(e);let i=[];for(;!n();){let o=this._cursor.clone();this._interpolationConfig&&this._attemptStr(this._interpolationConfig.start)?(this._endToken([this._processCarriageReturns(i.join(""))],o),i.length=0,this._consumeInterpolation(r,o,s),this._beginToken(e)):this._cursor.peek()===38?(this._endToken([this._processCarriageReturns(i.join(""))]),i.length=0,this._consumeEntity(e),this._beginToken(e)):i.push(this._readChar())}this._inInterpolation=!1;let a=this._processCarriageReturns(i.join(""));return this._endToken([a]),a}_consumeInterpolation(e,r,n){let s=[];this._beginToken(e,r),s.push(this._interpolationConfig.start);let i=this._cursor.clone(),a=null,o=!1;for(;this._cursor.peek()!==0&&(n===null||!n());){let u=this._cursor.clone();if(this._isTagStart()){this._cursor=u,s.push(this._getProcessedChars(i,u)),this._endToken(s);return}if(a===null)if(this._attemptStr(this._interpolationConfig.end)){s.push(this._getProcessedChars(i,u)),s.push(this._interpolationConfig.end),this._endToken(s);return}else this._attemptStr("//")&&(o=!0);let p=this._cursor.peek();this._cursor.advance(),p===92?this._cursor.advance():p===a?a=null:!o&&a===null&&html_$t(p)&&(a=p)}s.push(this._getProcessedChars(i,this._cursor)),this._endToken(s)}_getProcessedChars(e,r){return this._processCarriageReturns(r.getChars(e))}_isTextEnd(){return!!(this._isTagStart()||this._cursor.peek()===0||this._tokenizeIcu&&!this._inInterpolation&&(this.isExpansionFormStart()||this._cursor.peek()===125&&this._isInExpansionCase())||this._tokenizeBlocks&&!this._inInterpolation&&!this._isInExpansion()&&(this._isBlockStart()||this._cursor.peek()===64||this._cursor.peek()===125))}_isTagStart(){if(this._cursor.peek()===60){let e=this._cursor.clone();e.advance();let r=e.peek();if(97<=r&&r<=122||65<=r&&r<=90||r===47||r===33)return!0}return!1}_isBlockStart(){if(this._tokenizeBlocks&&this._cursor.peek()===64){let e=this._cursor.clone();if(e.advance(),Ms(e.peek()))return!0}return!1}_readUntil(e){let r=this._cursor.clone();return this._attemptUntilChar(e),this._cursor.getChars(r)}_isInExpansion(){return this._isInExpansionCase()||this._isInExpansionForm()}_isInExpansionCase(){return this._expansionCaseStack.length>0&&this._expansionCaseStack[this._expansionCaseStack.length-1]===22}_isInExpansionForm(){return this._expansionCaseStack.length>0&&this._expansionCaseStack[this._expansionCaseStack.length-1]===20}isExpansionFormStart(){if(this._cursor.peek()!==123)return!1;if(this._interpolationConfig){let e=this._cursor.clone(),r=this._attemptStr(this._interpolationConfig.start);return this._cursor=e,!r}return!0}_handleFullNameStackForTagOpen(e,r){let n=html_ze(e,r);(this._fullNameStack.length===0||this._fullNameStack[this._fullNameStack.length-1]===n)&&this._fullNameStack.push(n)}_handleFullNameStackForTagClose(e,r){let n=html_ze(e,r);this._fullNameStack.length!==0&&this._fullNameStack[this._fullNameStack.length-1]===n&&this._fullNameStack.pop()}};function html_b(t){return!html_at(t)||t===0}function $s(t){return html_at(t)||t===62||t===60||t===47||t===39||t===34||t===61||t===0}function html_mo(t){return(t<97||122<t)&&(t<65||90<t)&&(t<48||t>57)}function html_fo(t){return t===59||t===0||!Cs(t)}function html_go(t){return t===59||t===0||!html_ot(t)}function Co(t){return t!==125}function So(t,e){return Os(t)===Os(e)}function Os(t){return t>=97&&t<=122?t-97+65:t}function Ms(t){return html_ot(t)||html_It(t)||t===95}function qs(t){return t!==59&&html_b(t)}function html_o(t){let e=[],r;for(let n=0;n<t.length;n++){let s=t[n];r&&r.type===5&&s.type===5||r&&r.type===16&&s.type===16?(r.parts[0]+=s.parts[0],r.sourceSpan.end=s.sourceSpan.end):(r=s,e.push(r))}return e}var html_rr=class t{constructor(e,r){if(e instanceof t){this.file=e.file,this.input=e.input,this.end=e.end;let n=e.state;this.state={peek:n.peek,offset:n.offset,line:n.line,column:n.column}}else{if(!r)throw new Error("Programming error: the range argument must be provided with a file argument.");this.file=e,this.input=e.content,this.end=r.endPos,this.state={peek:-1,offset:r.startPos,line:r.startLine,column:r.startCol}}}clone(){return new t(this)}peek(){return this.state.peek}charsLeft(){return this.end-this.state.offset}diff(e){return this.state.offset-e.state.offset}advance(){this.advanceState(this.state)}init(){this.updatePeek(this.state)}getSpan(e,r){e=e||this;let n=e;if(r)for(;this.diff(e)>0&&r.indexOf(e.peek())!==-1;)n===e&&(e=e.clone()),e.advance();let s=this.locationFromCursor(e),i=this.locationFromCursor(this),a=n!==e?this.locationFromCursor(n):s;return new h(s,i,a)}getChars(e){return this.input.substring(e.state.offset,this.state.offset)}charAt(e){return this.input.charCodeAt(e)}advanceState(e){if(e.offset>=this.end)throw this.state=e,new html_gt('Unexpected character "EOF"',this);let r=this.charAt(e.offset);r===10?(e.line++,e.column=0):html_Rt(r)||e.column++,e.offset++,this.updatePeek(e)}updatePeek(e){e.peek=e.offset>=this.end?0:this.charAt(e.offset)}locationFromCursor(e){return new html_ae(e.file,e.state.offset,e.state.line,e.state.column)}},html_Mr=class t extends html_rr{constructor(e,r){e instanceof t?(super(e),this.internalState={...e.internalState}):(super(e,r),this.internalState=this.state)}advance(){this.state=this.internalState,super.advance(),this.processEscapeSequence()}init(){super.init(),this.processEscapeSequence()}clone(){return new t(this)}getChars(e){let r=e.clone(),n="";for(;r.internalState.offset<this.internalState.offset;)n+=String.fromCodePoint(r.peek()),r.advance();return n}processEscapeSequence(){let e=()=>this.internalState.peek;if(e()===92)if(this.internalState={...this.state},this.advanceState(this.internalState),e()===110)this.state.peek=10;else if(e()===114)this.state.peek=13;else if(e()===118)this.state.peek=11;else if(e()===116)this.state.peek=9;else if(e()===98)this.state.peek=8;else if(e()===102)this.state.peek=12;else if(e()===117)if(this.advanceState(this.internalState),e()===123){this.advanceState(this.internalState);let r=this.clone(),n=0;for(;e()!==125;)this.advanceState(this.internalState),n++;this.state.peek=this.decodeHexDigits(r,n)}else{let r=this.clone();this.advanceState(this.internalState),this.advanceState(this.internalState),this.advanceState(this.internalState),this.state.peek=this.decodeHexDigits(r,4)}else if(e()===120){this.advanceState(this.internalState);let r=this.clone();this.advanceState(this.internalState),this.state.peek=this.decodeHexDigits(r,2)}else if(html_yr(e())){let r="",n=0,s=this.clone();for(;html_yr(e())&&n<3;)s=this.clone(),r+=String.fromCodePoint(e()),this.advanceState(this.internalState),n++;this.state.peek=parseInt(r,8),this.internalState=s.internalState}else html_Rt(this.internalState.peek)?(this.advanceState(this.internalState),this.state=this.internalState):this.state.peek=this.internalState.peek}decodeHexDigits(e,r){let n=this.input.slice(e.internalState.offset,e.internalState.offset+r),s=parseInt(n,16);if(isNaN(s))throw e.state=e.internalState,new html_gt("Invalid hexadecimal escape sequence",e);return s}},html_gt=class{constructor(e,r){this.msg=e,this.cursor=r}};var html_L=class t extends html_Ue{static create(e,r,n){return new t(e,r,n)}constructor(e,r,n){super(r,n),this.elementName=e}},html_Vr=class{constructor(e,r){this.rootNodes=e,this.errors=r}},html_nr=class{constructor(e){this.getTagDefinition=e}parse(e,r,n,s=!1,i){let a=D=>(R,...F)=>D(R.toLowerCase(),...F),o=s?this.getTagDefinition:a(this.getTagDefinition),u=D=>o(D).getContentType(),p=s?i:a(i),f=Ws(e,r,i?(D,R,F,c)=>{let g=p(D,R,F,c);return g!==void 0?g:u(D)}:u,n),d=n&&n.canSelfClose||!1,C=n&&n.allowHtmComponentClosingTags||!1,A=new html_Ur(f.tokens,o,d,C,s);return A.build(),new html_Vr(A.rootNodes,f.errors.concat(A.errors))}},html_Ur=class t{constructor(e,r,n,s,i){this.tokens=e,this.getTagDefinition=r,this.canSelfClose=n,this.allowHtmComponentClosingTags=s,this.isTagNameCaseSensitive=i,this._index=-1,this._containerStack=[],this.rootNodes=[],this.errors=[],this._advance()}build(){for(;this._peek.type!==34;)this._peek.type===0||this._peek.type===4?this._consumeStartTag(this._advance()):this._peek.type===3?(this._closeVoidElement(),this._consumeEndTag(this._advance())):this._peek.type===12?(this._closeVoidElement(),this._consumeCdata(this._advance())):this._peek.type===10?(this._closeVoidElement(),this._consumeComment(this._advance())):this._peek.type===5||this._peek.type===7||this._peek.type===6?(this._closeVoidElement(),this._consumeText(this._advance())):this._peek.type===20?this._consumeExpansion(this._advance()):this._peek.type===25?(this._closeVoidElement(),this._consumeBlockOpen(this._advance())):this._peek.type===27?(this._closeVoidElement(),this._consumeBlockClose(this._advance())):this._peek.type===29?(this._closeVoidElement(),this._consumeIncompleteBlock(this._advance())):this._peek.type===30?(this._closeVoidElement(),this._consumeLet(this._advance())):this._peek.type===18?this._consumeDocType(this._advance()):this._peek.type===33?(this._closeVoidElement(),this._consumeIncompleteLet(this._advance())):this._advance();for(let e of this._containerStack)e instanceof html_Z&&this.errors.push(html_L.create(e.name,e.sourceSpan,`Unclosed block "${e.name}"`))}_advance(){let e=this._peek;return this._index<this.tokens.length-1&&this._index++,this._peek=this.tokens[this._index],e}_advanceIf(e){return this._peek.type===e?this._advance():null}_consumeCdata(e){let r=this._advance(),n=this._getText(r),s=this._advanceIf(13);this._addToParent(new html_Wt(n,new h(e.sourceSpan.start,(s||r).sourceSpan.end),[r]))}_consumeComment(e){let r=this._advanceIf(7),n=this._advanceIf(11),s=r!=null?r.parts[0].trim():null,i=n==null?e.sourceSpan:new h(e.sourceSpan.start,n.sourceSpan.end,e.sourceSpan.fullStart);this._addToParent(new html_jt(s,i))}_consumeDocType(e){let r=this._advanceIf(7),n=this._advanceIf(19),s=r!=null?r.parts[0].trim():null,i=new h(e.sourceSpan.start,(n||r||e).sourceSpan.end);this._addToParent(new html_Kt(s,i))}_consumeExpansion(e){let r=this._advance(),n=this._advance(),s=[];for(;this._peek.type===21;){let a=this._parseExpansionCase();if(!a)return;s.push(a)}if(this._peek.type!==24){this.errors.push(html_L.create(null,this._peek.sourceSpan,"Invalid ICU message. Missing '}'."));return}let i=new h(e.sourceSpan.start,this._peek.sourceSpan.end,e.sourceSpan.fullStart);this._addToParent(new html_zt(r.parts[0],n.parts[0],s,i,r.sourceSpan)),this._advance()}_parseExpansionCase(){let e=this._advance();if(this._peek.type!==22)return this.errors.push(html_L.create(null,this._peek.sourceSpan,"Invalid ICU message. Missing '{'.")),null;let r=this._advance(),n=this._collectExpansionExpTokens(r);if(!n)return null;let s=this._advance();n.push({type:34,parts:[],sourceSpan:s.sourceSpan});let i=new t(n,this.getTagDefinition,this.canSelfClose,this.allowHtmComponentClosingTags,this.isTagNameCaseSensitive);if(i.build(),i.errors.length>0)return this.errors=this.errors.concat(i.errors),null;let a=new h(e.sourceSpan.start,s.sourceSpan.end,e.sourceSpan.fullStart),o=new h(r.sourceSpan.start,s.sourceSpan.end,r.sourceSpan.fullStart);return new html_Gt(e.parts[0],i.rootNodes,a,e.sourceSpan,o)}_collectExpansionExpTokens(e){let r=[],n=[22];for(;;){if((this._peek.type===20||this._peek.type===22)&&n.push(this._peek.type),this._peek.type===23)if(zs(n,22)){if(n.pop(),n.length===0)return r}else return this.errors.push(html_L.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;if(this._peek.type===24)if(zs(n,20))n.pop();else return this.errors.push(html_L.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;if(this._peek.type===34)return this.errors.push(html_L.create(null,e.sourceSpan,"Invalid ICU message. Missing '}'.")),null;r.push(this._advance())}}_getText(e){let r=e.parts[0];if(r.length>0&&r[0]==`
`){let n=this._getClosestParentElement();n!=null&&n.children.length==0&&this.getTagDefinition(n.name).ignoreFirstLf&&(r=r.substring(1))}return r}_consumeText(e){let r=[e],n=e.sourceSpan,s=e.parts[0];if(s.length>0&&s[0]===`
`){let i=this._getContainer();i!=null&&i.children.length===0&&this.getTagDefinition(i.name).ignoreFirstLf&&(s=s.substring(1),r[0]={type:e.type,sourceSpan:e.sourceSpan,parts:[s]})}for(;this._peek.type===8||this._peek.type===5||this._peek.type===9;)e=this._advance(),r.push(e),e.type===8?s+=e.parts.join("").replace(/&([^;]+);/g,Gs):e.type===9?s+=e.parts[0]:s+=e.parts.join("");if(s.length>0){let i=e.sourceSpan;this._addToParent(new html_Ut(s,new h(n.start,i.end,n.fullStart,n.details),r))}}_closeVoidElement(){let e=this._getContainer();e instanceof html_G&&this.getTagDefinition(e.name).isVoid&&this._containerStack.pop()}_consumeStartTag(e){let[r,n]=e.parts,s=[];for(;this._peek.type===14;)s.push(this._consumeAttr(this._advance()));let i=this._getElementFullName(r,n,this._getClosestParentElement()),a=!1;if(this._peek.type===2){this._advance(),a=!0;let C=this.getTagDefinition(i);this.canSelfClose||C.canSelfClose||html_We(i)!==null||C.isVoid||this.errors.push(html_L.create(i,e.sourceSpan,`Only void, custom and foreign elements can be self closed "${e.parts[1]}"`))}else this._peek.type===1&&(this._advance(),a=!1);let o=this._peek.sourceSpan.fullStart,u=new h(e.sourceSpan.start,o,e.sourceSpan.fullStart),p=new h(e.sourceSpan.start,o,e.sourceSpan.fullStart),l=new h(e.sourceSpan.start.moveBy(1),e.sourceSpan.end),f=new html_G(i,s,[],u,p,void 0,l),d=this._getContainer();this._pushContainer(f,d instanceof html_G&&this.getTagDefinition(d.name).isClosedByChild(f.name)),a?this._popContainer(i,html_G,u):e.type===4&&(this._popContainer(i,html_G,null),this.errors.push(html_L.create(i,u,`Opening tag "${i}" not terminated.`)))}_pushContainer(e,r){r&&this._containerStack.pop(),this._addToParent(e),this._containerStack.push(e)}_consumeEndTag(e){let r=this.allowHtmComponentClosingTags&&e.parts.length===0?null:this._getElementFullName(e.parts[0],e.parts[1],this._getClosestParentElement());if(r&&this.getTagDefinition(r).isVoid)this.errors.push(html_L.create(r,e.sourceSpan,`Void elements do not have end tags "${e.parts[1]}"`));else if(!this._popContainer(r,html_G,e.sourceSpan)){let n=`Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;this.errors.push(html_L.create(r,e.sourceSpan,n))}}_popContainer(e,r,n){let s=!1;for(let i=this._containerStack.length-1;i>=0;i--){let a=this._containerStack[i];if(html_We(a.name)?a.name===e:(e==null||a.name.toLowerCase()===e.toLowerCase())&&a instanceof r)return a.endSourceSpan=n,a.sourceSpan.end=n!==null?n.end:a.sourceSpan.end,this._containerStack.splice(i,this._containerStack.length-i),!s;(a instanceof html_Z||a instanceof html_G&&!this.getTagDefinition(a.name).closedByParent)&&(s=!0)}return!1}_consumeAttr(e){let r=html_ze(e.parts[0],e.parts[1]),n=e.sourceSpan.end,s;this._peek.type===15&&(s=this._advance());let i="",a=[],o,u;if(this._peek.type===16)for(o=this._peek.sourceSpan,u=this._peek.sourceSpan.end;this._peek.type===16||this._peek.type===17||this._peek.type===9;){let f=this._advance();a.push(f),f.type===17?i+=f.parts.join("").replace(/&([^;]+);/g,Gs):f.type===9?i+=f.parts[0]:i+=f.parts.join(""),u=n=f.sourceSpan.end}this._peek.type===15&&(u=n=this._advance().sourceSpan.end);let l=o&&u&&new h((s==null?void 0:s.sourceSpan.start)??o.start,u,(s==null?void 0:s.sourceSpan.fullStart)??o.fullStart);return new html_Yt(r,i,new h(e.sourceSpan.start,n,e.sourceSpan.fullStart),e.sourceSpan,l,a.length>0?a:void 0,void 0)}_consumeBlockOpen(e){let r=[];for(;this._peek.type===28;){let o=this._advance();r.push(new html_ct(o.parts[0],o.sourceSpan))}this._peek.type===26&&this._advance();let n=this._peek.sourceSpan.fullStart,s=new h(e.sourceSpan.start,n,e.sourceSpan.fullStart),i=new h(e.sourceSpan.start,n,e.sourceSpan.fullStart),a=new html_Z(e.parts[0],r,[],s,e.sourceSpan,i);this._pushContainer(a,!1)}_consumeBlockClose(e){this._popContainer(null,html_Z,e.sourceSpan)||this.errors.push(html_L.create(null,e.sourceSpan,'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'))}_consumeIncompleteBlock(e){let r=[];for(;this._peek.type===28;){let o=this._advance();r.push(new html_ct(o.parts[0],o.sourceSpan))}let n=this._peek.sourceSpan.fullStart,s=new h(e.sourceSpan.start,n,e.sourceSpan.fullStart),i=new h(e.sourceSpan.start,n,e.sourceSpan.fullStart),a=new html_Z(e.parts[0],r,[],s,e.sourceSpan,i);this._pushContainer(a,!1),this._popContainer(null,html_Z,null),this.errors.push(html_L.create(e.parts[0],s,`Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`))}_consumeLet(e){let r=e.parts[0],n,s;if(this._peek.type!==31){this.errors.push(html_L.create(e.parts[0],e.sourceSpan,`Invalid @let declaration "${r}". Declaration must have a value.`));return}else n=this._advance();if(this._peek.type!==32){this.errors.push(html_L.create(e.parts[0],e.sourceSpan,`Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));return}else s=this._advance();let i=s.sourceSpan.fullStart,a=new h(e.sourceSpan.start,i,e.sourceSpan.fullStart),o=e.sourceSpan.toString().lastIndexOf(r),u=e.sourceSpan.start.moveBy(o),p=new h(u,e.sourceSpan.end),l=new html_pt(r,n.parts[0],a,p,n.sourceSpan);this._addToParent(l)}_consumeIncompleteLet(e){let r=e.parts[0]??"",n=r?` "${r}"`:"";if(r.length>0){let s=e.sourceSpan.toString().lastIndexOf(r),i=e.sourceSpan.start.moveBy(s),a=new h(i,e.sourceSpan.end),o=new h(e.sourceSpan.start,e.sourceSpan.start.moveBy(0)),u=new html_pt(r,"",e.sourceSpan,a,o);this._addToParent(u)}this.errors.push(html_L.create(e.parts[0],e.sourceSpan,`Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``))}_getContainer(){return this._containerStack.length>0?this._containerStack[this._containerStack.length-1]:null}_getClosestParentElement(){for(let e=this._containerStack.length-1;e>-1;e--)if(this._containerStack[e]instanceof html_G)return this._containerStack[e];return null}_addToParent(e){let r=this._getContainer();r===null?this.rootNodes.push(e):r.children.push(e)}_getElementFullName(e,r,n){if(e===""&&(e=this.getTagDefinition(r).implicitNamespacePrefix||"",e===""&&n!=null)){let s=html_ut(n.name)[1];this.getTagDefinition(s).preventNamespaceInheritance||(e=html_We(n.name))}return html_ze(e,r)}};function zs(t,e){return t.length>0&&t[t.length-1]===e}function Gs(t,e){return html_Ye[e]!==void 0?html_Ye[e]||t:/^#x[a-f0-9]+$/i.test(e)?String.fromCodePoint(parseInt(e.slice(2),16)):/^#\d+$/.test(e)?String.fromCodePoint(parseInt(e.slice(1),10)):t}var html_sr=class extends html_nr{constructor(){super(html_Ge)}parse(e,r,n,s=!1,i){return super.parse(e,r,n,s,i)}};var html_Wr=null,html_Eo=()=>(html_Wr||(html_Wr=new html_sr),html_Wr);function html_zr(t,e={}){let{canSelfClose:r=!1,allowHtmComponentClosingTags:n=!1,isTagNameCaseSensitive:s=!1,getTagContentType:i,tokenizeAngularBlocks:a=!1,tokenizeAngularLetDeclaration:o=!1}=e;return html_Eo().parse(t,"angular-html-parser",{tokenizeExpansionForms:a,interpolationConfig:void 0,canSelfClose:r,allowHtmComponentClosingTags:n,tokenizeBlocks:a,tokenizeLet:o},s,i)}function html_Ao(t,e){let r=new SyntaxError(t+" ("+e.loc.start.line+":"+e.loc.start.column+")");return Object.assign(r,e)}var Ys=html_Ao;var Ct=3;function html_Do(t){let e=t.slice(0,Ct);if(e!=="---"&&e!=="+++")return;let r=t.indexOf(`
`,Ct);if(r===-1)return;let n=t.slice(Ct,r).trim(),s=t.indexOf(`
${e}`,r),i=n;if(i||(i=e==="+++"?"toml":"yaml"),s===-1&&e==="---"&&i==="yaml"&&(s=t.indexOf(`
...`,r)),s===-1)return;let a=s+1+Ct,o=t.charAt(a+1);if(!/\s?/u.test(o))return;let u=t.slice(0,a);return{type:"front-matter",language:i,explicitLanguage:n,value:t.slice(r+1,s),startDelimiter:e,endDelimiter:u.slice(-Ct),raw:u}}function vo(t){let e=html_Do(t);if(!e)return{content:t};let{raw:r}=e;return{frontMatter:e,content:w(!1,r,/[^\n]/gu," ")+t.slice(r.length)}}var js=vo;var html_ir={attrs:!0,children:!0,cases:!0,expression:!0},Ks=new Set(["parent"]),html_ar=class t{constructor(e={}){for(let r of new Set([...Ks,...Object.keys(e)]))this.setProperty(r,e[r])}setProperty(e,r){if(this[e]!==r){if(e in html_ir&&(r=r.map(n=>this.createChild(n))),!Ks.has(e)){this[e]=r;return}Object.defineProperty(this,e,{value:r,enumerable:!1,configurable:!0})}}map(e){let r;for(let n in html_ir){let s=this[n];if(s){let i=html_yo(s,a=>a.map(e));r!==s&&(r||(r=new t({parent:this.parent})),r.setProperty(n,i))}}if(r)for(let n in this)n in html_ir||(r[n]=this[n]);return e(r||this)}walk(e){for(let r in html_ir){let n=this[r];if(n)for(let s=0;s<n.length;s++)n[s].walk(e)}e(this)}createChild(e){let r=e instanceof t?e.clone():new t(e);return r.setProperty("parent",this),r}insertChildBefore(e,r){this.children.splice(this.children.indexOf(e),0,this.createChild(r))}removeChild(e){this.children.splice(this.children.indexOf(e),1)}replaceChild(e,r){this.children[this.children.indexOf(e)]=this.createChild(r)}clone(){return new t(this)}get firstChild(){var e;return(e=this.children)==null?void 0:e[0]}get lastChild(){var e;return(e=this.children)==null?void 0:e[this.children.length-1]}get prev(){var e,r;return(r=(e=this.parent)==null?void 0:e.children)==null?void 0:r[this.parent.children.indexOf(this)-1]}get next(){var e,r;return(r=(e=this.parent)==null?void 0:e.children)==null?void 0:r[this.parent.children.indexOf(this)+1]}get rawName(){return this.hasExplicitNamespace?this.fullName:this.name}get fullName(){return this.namespace?this.namespace+":"+this.name:this.name}get attrMap(){return Object.fromEntries(this.attrs.map(e=>[e.fullName,e.value]))}};function html_yo(t,e){let r=t.map(e);return r.some((n,s)=>n!==t[s])?r:t}var html_wo=[{regex:/^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su,parse:bo},{regex:/^\[if([^\]]*)\]><!$/u,parse:To},{regex:/^<!\s*\[endif\]$/u,parse:html_xo}];function Qs(t,e){if(t.value)for(let{regex:r,parse:n}of html_wo){let s=t.value.match(r);if(s)return n(t,e,s)}return null}function bo(t,e,r){let[,n,s,i]=r,a=4+n.length,o=t.sourceSpan.start.moveBy(a),u=o.moveBy(i.length),[p,l]=(()=>{try{return[!0,e(i,o).children]}catch{return[!1,[{type:"text",value:i,sourceSpan:new h(o,u)}]]}})();return{type:"ieConditionalComment",complete:p,children:l,condition:w(!1,s.trim(),/\s+/gu," "),sourceSpan:t.sourceSpan,startSourceSpan:new h(t.sourceSpan.start,o),endSourceSpan:new h(u,t.sourceSpan.end)}}function To(t,e,r){let[,n]=r;return{type:"ieConditionalStartComment",condition:w(!1,n.trim(),/\s+/gu," "),sourceSpan:t.sourceSpan}}function html_xo(t){return{type:"ieConditionalEndComment",sourceSpan:t.sourceSpan}}var html_or=new Map([["*",new Set(["accesskey","autocapitalize","autofocus","class","contenteditable","dir","draggable","enterkeyhint","hidden","id","inert","inputmode","is","itemid","itemprop","itemref","itemscope","itemtype","lang","nonce","popover","slot","spellcheck","style","tabindex","title","translate","writingsuggestions"])],["a",new Set(["charset","coords","download","href","hreflang","name","ping","referrerpolicy","rel","rev","shape","target","type"])],["applet",new Set(["align","alt","archive","code","codebase","height","hspace","name","object","vspace","width"])],["area",new Set(["alt","coords","download","href","hreflang","nohref","ping","referrerpolicy","rel","shape","target","type"])],["audio",new Set(["autoplay","controls","crossorigin","loop","muted","preload","src"])],["base",new Set(["href","target"])],["basefont",new Set(["color","face","size"])],["blockquote",new Set(["cite"])],["body",new Set(["alink","background","bgcolor","link","text","vlink"])],["br",new Set(["clear"])],["button",new Set(["disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","name","popovertarget","popovertargetaction","type","value"])],["canvas",new Set(["height","width"])],["caption",new Set(["align"])],["col",new Set(["align","char","charoff","span","valign","width"])],["colgroup",new Set(["align","char","charoff","span","valign","width"])],["data",new Set(["value"])],["del",new Set(["cite","datetime"])],["details",new Set(["name","open"])],["dialog",new Set(["open"])],["dir",new Set(["compact"])],["div",new Set(["align"])],["dl",new Set(["compact"])],["embed",new Set(["height","src","type","width"])],["fieldset",new Set(["disabled","form","name"])],["font",new Set(["color","face","size"])],["form",new Set(["accept","accept-charset","action","autocomplete","enctype","method","name","novalidate","target"])],["frame",new Set(["frameborder","longdesc","marginheight","marginwidth","name","noresize","scrolling","src"])],["frameset",new Set(["cols","rows"])],["h1",new Set(["align"])],["h2",new Set(["align"])],["h3",new Set(["align"])],["h4",new Set(["align"])],["h5",new Set(["align"])],["h6",new Set(["align"])],["head",new Set(["profile"])],["hr",new Set(["align","noshade","size","width"])],["html",new Set(["manifest","version"])],["iframe",new Set(["align","allow","allowfullscreen","allowpaymentrequest","allowusermedia","frameborder","height","loading","longdesc","marginheight","marginwidth","name","referrerpolicy","sandbox","scrolling","src","srcdoc","width"])],["img",new Set(["align","alt","border","crossorigin","decoding","fetchpriority","height","hspace","ismap","loading","longdesc","name","referrerpolicy","sizes","src","srcset","usemap","vspace","width"])],["input",new Set(["accept","align","alt","autocomplete","checked","dirname","disabled","form","formaction","formenctype","formmethod","formnovalidate","formtarget","height","ismap","list","max","maxlength","min","minlength","multiple","name","pattern","placeholder","popovertarget","popovertargetaction","readonly","required","size","src","step","type","usemap","value","width"])],["ins",new Set(["cite","datetime"])],["isindex",new Set(["prompt"])],["label",new Set(["for","form"])],["legend",new Set(["align"])],["li",new Set(["type","value"])],["link",new Set(["as","blocking","charset","color","crossorigin","disabled","fetchpriority","href","hreflang","imagesizes","imagesrcset","integrity","media","referrerpolicy","rel","rev","sizes","target","type"])],["map",new Set(["name"])],["menu",new Set(["compact"])],["meta",new Set(["charset","content","http-equiv","media","name","scheme"])],["meter",new Set(["high","low","max","min","optimum","value"])],["object",new Set(["align","archive","border","classid","codebase","codetype","data","declare","form","height","hspace","name","standby","type","typemustmatch","usemap","vspace","width"])],["ol",new Set(["compact","reversed","start","type"])],["optgroup",new Set(["disabled","label"])],["option",new Set(["disabled","label","selected","value"])],["output",new Set(["for","form","name"])],["p",new Set(["align"])],["param",new Set(["name","type","value","valuetype"])],["pre",new Set(["width"])],["progress",new Set(["max","value"])],["q",new Set(["cite"])],["script",new Set(["async","blocking","charset","crossorigin","defer","fetchpriority","integrity","language","nomodule","referrerpolicy","src","type"])],["select",new Set(["autocomplete","disabled","form","multiple","name","required","size"])],["slot",new Set(["name"])],["source",new Set(["height","media","sizes","src","srcset","type","width"])],["style",new Set(["blocking","media","type"])],["table",new Set(["align","bgcolor","border","cellpadding","cellspacing","frame","rules","summary","width"])],["tbody",new Set(["align","char","charoff","valign"])],["td",new Set(["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"])],["template",new Set(["shadowrootclonable","shadowrootdelegatesfocus","shadowrootmode"])],["textarea",new Set(["autocomplete","cols","dirname","disabled","form","maxlength","minlength","name","placeholder","readonly","required","rows","wrap"])],["tfoot",new Set(["align","char","charoff","valign"])],["th",new Set(["abbr","align","axis","bgcolor","char","charoff","colspan","headers","height","nowrap","rowspan","scope","valign","width"])],["thead",new Set(["align","char","charoff","valign"])],["time",new Set(["datetime"])],["tr",new Set(["align","bgcolor","char","charoff","valign"])],["track",new Set(["default","kind","label","src","srclang"])],["ul",new Set(["compact","type"])],["video",new Set(["autoplay","controls","crossorigin","height","loop","muted","playsinline","poster","preload","src","width"])]]);var Xs=new Set(["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","bgsound","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","command","content","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","element","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","image","img","input","ins","isindex","kbd","keygen","label","legend","li","link","listing","main","map","mark","marquee","math","menu","menuitem","meta","meter","multicol","nav","nextid","nobr","noembed","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","plaintext","pre","progress","q","rb","rbc","rp","rt","rtc","ruby","s","samp","script","search","section","select","shadow","slot","small","source","spacer","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr","xmp"]);function html_ko(t){if(t.type==="block"){if(t.name=w(!1,t.name.toLowerCase(),/\s+/gu," ").trim(),t.type="angularControlFlowBlock",!html_qe(t.parameters)){delete t.parameters;return}for(let e of t.parameters)e.type="angularControlFlowBlockParameter";t.parameters={type:"angularControlFlowBlockParameters",children:t.parameters,sourceSpan:new h(t.parameters[0].sourceSpan.start,html_X(!1,t.parameters,-1).sourceSpan.end)}}}function html_Bo(t){t.type==="letDeclaration"&&(t.type="angularLetDeclaration",t.id=t.name,t.init={type:"angularLetDeclarationInitializer",sourceSpan:new h(t.valueSpan.start,t.valueSpan.end),value:t.value},delete t.name,delete t.value)}function html_Lo(t){(t.type==="plural"||t.type==="select")&&(t.clause=t.type,t.type="angularIcuExpression"),t.type==="expansionCase"&&(t.type="angularIcuCase")}function Zs(t,e,r){let{name:n,canSelfClose:s=!0,normalizeTagName:i=!1,normalizeAttributeName:a=!1,allowHtmComponentClosingTags:o=!1,isTagNameCaseSensitive:u=!1,shouldParseAsRawText:p}=e,{rootNodes:l,errors:f}=html_zr(t,{canSelfClose:s,allowHtmComponentClosingTags:o,isTagNameCaseSensitive:u,getTagContentType:p?(...c)=>p(...c)?html_I.RAW_TEXT:void 0:void 0,tokenizeAngularBlocks:n==="angular"?!0:void 0,tokenizeAngularLetDeclaration:n==="angular"?!0:void 0});if(n==="vue"){if(l.some(x=>x.type==="docType"&&x.value==="html"||x.type==="element"&&x.name.toLowerCase()==="html"))return Zs(t,html_ti,r);let g,y=()=>g??(g=html_zr(t,{canSelfClose:s,allowHtmComponentClosingTags:o,isTagNameCaseSensitive:u})),M=x=>y().rootNodes.find(({startSourceSpan:V})=>V&&V.start.offset===x.startSourceSpan.start.offset)??x;for(let[x,V]of l.entries()){let{endSourceSpan:jr,startSourceSpan:ri}=V;if(jr===null)f=y().errors,l[x]=M(V);else if(html_Fo(V,r)){let Kr=y().errors.find(Qr=>Qr.span.start.offset>ri.start.offset&&Qr.span.start.offset<jr.end.offset);Kr&&Js(Kr),l[x]=M(V)}}}f.length>0&&Js(f[0]);let d=c=>{let g=c.name.startsWith(":")?c.name.slice(1).split(":")[0]:null,y=c.nameSpan.toString(),M=g!==null&&y.startsWith(`${g}:`),x=M?y.slice(g.length+1):y;c.name=x,c.namespace=g,c.hasExplicitNamespace=M},C=c=>{switch(c.type){case"element":d(c);for(let g of c.attrs)d(g),g.valueSpan?(g.value=g.valueSpan.toString(),/["']/u.test(g.value[0])&&(g.value=g.value.slice(1,-1))):g.value=null;break;case"comment":c.value=c.sourceSpan.toString().slice(4,-3);break;case"text":c.value=c.sourceSpan.toString();break}},A=(c,g)=>{let y=c.toLowerCase();return g(y)?y:c},D=c=>{if(c.type==="element"&&(i&&(!c.namespace||c.namespace===c.tagDefinition.implicitNamespacePrefix||html_Se(c))&&(c.name=A(c.name,g=>Xs.has(g))),a))for(let g of c.attrs)g.namespace||(g.name=A(g.name,y=>html_or.has(c.name)&&(html_or.get("*").has(y)||html_or.get(c.name).has(y))))},R=c=>{c.sourceSpan&&c.endSourceSpan&&(c.sourceSpan=new h(c.sourceSpan.start,c.endSourceSpan.end))},F=c=>{if(c.type==="element"){let g=html_Ge(u?c.name:c.name.toLowerCase());!c.namespace||c.namespace===g.implicitNamespacePrefix||html_Se(c)?c.tagDefinition=g:c.tagDefinition=html_Ge("")}};return html_Qt(new class extends html_ht{visitExpansionCase(c,g){n==="angular"&&this.visitChildren(g,y=>{y(c.expression)})}visit(c){C(c),F(c),D(c),R(c)}},l),l}function html_Fo(t,e){var n;if(t.type!=="element"||t.name!=="template")return!1;let r=(n=t.attrs.find(s=>s.name==="lang"))==null?void 0:n.value;return!r||html_Oe(e,{language:r})==="html"}function Js(t){let{msg:e,span:{start:r,end:n}}=t;throw Ys(e,{loc:{start:{line:r.line+1,column:r.col+1},end:{line:n.line+1,column:n.col+1}},cause:t})}function html_ei(t,e,r={},n=!0){let{frontMatter:s,content:i}=n?js(t):{frontMatter:null,content:t},a=new html_Te(t,r.filepath),o=new html_ae(a,0,0,0),u=o.moveBy(t.length),p={type:"root",sourceSpan:new h(o,u),children:Zs(i,e,r)};if(s){let d=new html_ae(a,0,0,0),C=d.moveBy(s.raw.length);s.sourceSpan=new h(d,C),p.children.unshift(s)}let l=new html_ar(p),f=(d,C)=>{let{offset:A}=C,D=w(!1,t.slice(0,A),/[^\n\r]/gu," "),F=html_ei(D+d,e,r,!1);F.sourceSpan=new h(C,html_X(!1,F.children,-1).sourceSpan.end);let c=F.children[0];return c.length===A?F.children.shift():(c.sourceSpan=new h(c.sourceSpan.start.moveBy(A),c.sourceSpan.end),c.value=c.value.slice(A)),F};return l.walk(d=>{if(d.type==="comment"){let C=Qs(d,f);C&&d.parent.replaceChild(d,C)}html_ko(d),html_Bo(d),html_Lo(d)}),l}function html_ur(t){return{parse:(e,r)=>html_ei(e,t,r),hasPragma:os,astFormat:"html",locStart:html_se,locEnd:html_ie}}var html_ti={name:"html",normalizeTagName:!0,normalizeAttributeName:!0,allowHtmComponentClosingTags:!0},No=html_ur(html_ti),html_Po=html_ur({name:"angular"}),html_Io=html_ur({name:"vue",isTagNameCaseSensitive:!0,shouldParseAsRawText(t,e,r,n){return t.toLowerCase()!=="html"&&!r&&(t!=="template"||n.some(({name:s,value:i})=>s==="lang"&&i!=="html"&&i!==""&&i!==void 0))}}),html_Ro=html_ur({name:"lwc",canSelfClose:!1});var html_$o={html:As};var Ih=html_Yr;

// EXTERNAL MODULE: external "node:stream"
var external_node_stream_ = __webpack_require__(157075);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js
var react_jsx_runtime = __webpack_require__(891069);
;// ../../node_modules/@react-email/render/dist/node/index.mjs
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/node/render.tsx



// src/shared/utils/pretty.ts


var defaults = {
  endOfLine: "lf",
  tabWidth: 2,
  plugins: [Ih],
  parser: "html"
};
var pretty = (str, options = {}) => {
  return gu(str, __spreadValues(__spreadValues({}, defaults), options));
};

// src/shared/plain-text-selectors.ts
var plainTextSelectors = [
  { selector: "img", format: "skip" },
  { selector: "#__react-email-preview", format: "skip" },
  {
    selector: "a",
    options: { linkBrackets: false }
  }
];

// src/node/read-stream.ts

var decoder = new TextDecoder("utf-8");
var readStream = (stream) => __async(void 0, null, function* () {
  let result = "";
  if ("pipeTo" in stream) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder.decode(chunk);
      }
    });
    yield stream.pipeTo(writableStream);
  } else {
    const writable = new external_node_stream_.Writable({
      write(chunk, _encoding, callback) {
        result += decoder.decode(chunk);
        callback();
      }
    });
    stream.pipe(writable);
    yield new Promise((resolve, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
    });
  }
  return result;
});

// src/node/render.tsx

var node_render = (element, options) => __async(void 0, null, function* () {
  const suspendedElement = /* @__PURE__ */ (0,react_jsx_runtime.jsx)(react.Suspense, { children: element });
  const reactDOMServer = yield __webpack_require__.e(/* import() */ 5138).then(__webpack_require__.t.bind(__webpack_require__, 545138, 19));
  let html2;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html2 = yield readStream(
      yield reactDOMServer.renderToReadableStream(suspendedElement)
    );
  } else {
    yield new Promise((resolve, reject) => {
      const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {
        onAllReady() {
          return __async(this, null, function* () {
            html2 = yield readStream(stream);
            resolve();
          });
        },
        onError(error) {
          reject(error);
        }
      });
    });
  }
  if (options == null ? void 0 : options.plainText) {
    return convert(html2, __spreadValues({
      selectors: plainTextSelectors
    }, options.htmlToTextOptions));
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? void 0 : options.pretty) {
    return pretty(document);
  }
  return document;
});

// src/node/render-async.tsx



var renderAsync = (element, options) => __async(void 0, null, function* () {
  const suspendedElement = /* @__PURE__ */ jsx2(Suspense2, { children: element });
  const reactDOMServer = yield __webpack_require__.e(/* import() */ 5138).then(__webpack_require__.t.bind(__webpack_require__, 545138, 19));
  let html2;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream")) {
    html2 = yield readStream(
      yield reactDOMServer.renderToReadableStream(suspendedElement)
    );
  } else {
    yield new Promise((resolve, reject) => {
      const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {
        onAllReady() {
          return __async(this, null, function* () {
            html2 = yield readStream(stream);
            resolve();
          });
        },
        onError(error) {
          reject(error);
        }
      });
    });
  }
  if (options == null ? void 0 : options.plainText) {
    return convert2(html2, __spreadValues({
      selectors: plainTextSelectors
    }, options.htmlToTextOptions));
  }
  const doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
  const document = `${doctype}${html2.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options == null ? void 0 : options.pretty) {
    return pretty(document);
  }
  return document;
});



/***/ }),

/***/ 791807:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ Row)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/row.tsx


var Row = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "table",
      __spreadProps(__spreadValues({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tbody", { style: { width: "100%" }, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tr", { style: { width: "100%" }, children }) })
      })
    );
  }
);
Row.displayName = "Row";



/***/ }),

/***/ 752096:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   w: () => (/* binding */ Section)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/section.tsx


var Section = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { children, style } = _b, props = __objRest(_b, ["children", "style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "table",
      __spreadProps(__spreadValues({
        align: "center",
        width: "100%",
        border: 0,
        cellPadding: "0",
        cellSpacing: "0",
        role: "presentation"
      }, props), {
        ref,
        style,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tbody", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("tr", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("td", { children }) }) })
      })
    );
  }
);
Section.displayName = "Section";



/***/ }),

/***/ 433289:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ pd)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891069);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(922728);



var ni = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Qe(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function Is(s) {
  if (s.__esModule)
    return s;
  var e = s.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(s).forEach(function(r) {
    var n = Object.getOwnPropertyDescriptor(s, r);
    Object.defineProperty(t, r, n.get ? n : {
      enumerable: !0,
      get: function() {
        return s[r];
      }
    });
  }), t;
}
var bn = { exports: {} }, Re = String, Di = function() {
  return { isColorSupported: !1, reset: Re, bold: Re, dim: Re, italic: Re, underline: Re, inverse: Re, hidden: Re, strikethrough: Re, black: Re, red: Re, green: Re, yellow: Re, blue: Re, magenta: Re, cyan: Re, white: Re, gray: Re, bgBlack: Re, bgRed: Re, bgGreen: Re, bgYellow: Re, bgBlue: Re, bgMagenta: Re, bgCyan: Re, bgWhite: Re };
};
bn.exports = Di();
bn.exports.createColors = Di;
var Rs = bn.exports;
const $s = {}, Ds = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $s
}, Symbol.toStringTag, { value: "Module" })), Le = /* @__PURE__ */ Is(Ds);
let ii = Rs, ai = Le, Dr = class Ni extends Error {
  constructor(e, t, r, n, l, i) {
    super(e), this.name = "CssSyntaxError", this.reason = e, l && (this.file = l), n && (this.source = n), i && (this.plugin = i), typeof t < "u" && typeof r < "u" && (typeof t == "number" ? (this.line = t, this.column = r) : (this.line = t.line, this.column = t.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ni);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source)
      return "";
    let t = this.source;
    e == null && (e = ii.isColorSupported), ai && e && (t = ai(t));
    let r = t.split(/\r?\n/), n = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, r.length), i = String(l).length, c, a;
    if (e) {
      let { bold: o, gray: f, red: u } = ii.createColors(!0);
      c = (p) => o(u(p)), a = (p) => f(p);
    } else
      c = a = (o) => o;
    return r.slice(n, l).map((o, f) => {
      let u = n + 1 + f, p = " " + (" " + u).slice(-i) + " | ";
      if (u === this.line) {
        let _ = a(p.replace(/\d/g, " ")) + o.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return c(">") + a(p) + o + `
 ` + _ + c("^");
      }
      return " " + a(p) + o;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
};
var xn = Dr;
Dr.default = Dr;
var _t = {};
_t.isClean = Symbol("isClean");
_t.my = Symbol("my");
const si = {
  after: `
`,
  beforeClose: `
`,
  beforeComment: `
`,
  beforeDecl: `
`,
  beforeOpen: " ",
  beforeRule: `
`,
  colon: ": ",
  commentLeft: " ",
  commentRight: " ",
  emptyBody: "",
  indent: "    ",
  semicolon: !1
};
function Ns(s) {
  return s[0].toUpperCase() + s.slice(1);
}
let Nr = class {
  constructor(e) {
    this.builder = e;
  }
  atrule(e, t) {
    let r = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : n && (r += " "), e.nodes)
      this.block(e, r + n);
    else {
      let l = (e.raws.between || "") + (t ? ";" : "");
      this.builder(r + n + l, e);
    }
  }
  beforeAfter(e, t) {
    let r;
    e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : t === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
    let n = e.parent, l = 0;
    for (; n && n.type !== "root"; )
      l += 1, n = n.parent;
    if (r.includes(`
`)) {
      let i = this.raw(e, null, "indent");
      if (i.length)
        for (let c = 0; c < l; c++)
          r += i;
    }
    return r;
  }
  block(e, t) {
    let r = this.raw(e, "between", "beforeOpen");
    this.builder(t + r + "{", e, "start");
    let n;
    e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let r = this.raw(e, "semicolon");
    for (let n = 0; n < e.nodes.length; n++) {
      let l = e.nodes[n], i = this.raw(l, "before");
      i && this.builder(i), this.stringify(l, t !== n || r);
    }
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + r + "*/", e);
  }
  decl(e, t) {
    let r = this.raw(e, "between", "colon"), n = e.prop + r + this.rawValue(e, "value");
    e.important && (n += e.raws.important || " !important"), t && (n += ";"), this.builder(n, e);
  }
  document(e) {
    this.body(e);
  }
  raw(e, t, r) {
    let n;
    if (r || (r = t), t && (n = e.raws[t], typeof n < "u"))
      return n;
    let l = e.parent;
    if (r === "before" && (!l || l.type === "root" && l.first === e || l && l.type === "document"))
      return "";
    if (!l)
      return si[r];
    let i = e.root();
    if (i.rawCache || (i.rawCache = {}), typeof i.rawCache[r] < "u")
      return i.rawCache[r];
    if (r === "before" || r === "after")
      return this.beforeAfter(e, r);
    {
      let c = "raw" + Ns(r);
      this[c] ? n = this[c](i, e) : i.walk((a) => {
        if (n = a.raws[t], typeof n < "u")
          return !1;
      });
    }
    return typeof n > "u" && (n = si[r]), i.rawCache[r] = n, n;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u")
        return t = r.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeComment(e, t) {
    let r;
    return e.walkComments((n) => {
      if (typeof n.raws.before < "u")
        return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(t, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeDecl(e, t) {
    let r;
    return e.walkDecls((n) => {
      if (typeof n.raws.before < "u")
        return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), !1;
    }), typeof r > "u" ? r = this.raw(t, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((r) => {
      if (r.type !== "decl" && (t = r.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((r) => {
      if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u")
        return t = r.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((r) => {
      if (typeof r.raws.between < "u")
        return t = r.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length === 0 && (t = r.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent)
      return e.raws.indent;
    let t;
    return e.walk((r) => {
      let n = r.parent;
      if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < "u") {
        let l = r.raws.before.split(`
`);
        return t = l[l.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((r) => {
      if (r.nodes && r.nodes.length && r.last.type === "decl" && (t = r.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawValue(e, t) {
    let r = e[t], n = e.raws[t];
    return n && n.value === r ? n.raw : r;
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
};
var Li = Nr;
Nr.default = Nr;
let Ls = Li;
function Lr(s, e) {
  new Ls(e).stringify(s);
}
var Kt = Lr;
Lr.default = Lr;
let { isClean: Mt, my: Fs } = _t, zs = xn, Us = Li, js = Kt;
function Fr(s, e) {
  let t = new s.constructor();
  for (let r in s) {
    if (!Object.prototype.hasOwnProperty.call(s, r) || r === "proxyCache")
      continue;
    let n = s[r], l = typeof n;
    r === "parent" && l === "object" ? e && (t[r] = e) : r === "source" ? t[r] = n : Array.isArray(n) ? t[r] = n.map((i) => Fr(i, t)) : (l === "object" && n !== null && (n = Fr(n)), t[r] = n);
  }
  return t;
}
let zr = class {
  constructor(e = {}) {
    this.raws = {}, this[Mt] = !1, this[Fs] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let r of e[t])
          typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
      } else
        this[t] = e[t];
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  clone(e = {}) {
    let t = Fr(this);
    for (let r in e)
      t[r] = e[r];
    return t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  error(e, t = {}) {
    if (this.source) {
      let { end: r, start: n } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { column: n.column, line: n.line },
        { column: r.column, line: r.line },
        t
      );
    }
    return new zs(e);
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      },
      set(e, t, r) {
        return e[t] === r || (e[t] = r, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      }
    };
  }
  markDirty() {
    if (this[Mt]) {
      this[Mt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Mt] = !1;
    }
  }
  next() {
    if (!this.parent)
      return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  positionBy(e, t) {
    let r = this.source.start;
    if (e.index)
      r = this.positionInside(e.index, t);
    else if (e.word) {
      t = this.toString();
      let n = t.indexOf(e.word);
      n !== -1 && (r = this.positionInside(n, t));
    }
    return r;
  }
  positionInside(e, t) {
    let r = t || this.toString(), n = this.source.start.column, l = this.source.start.line;
    for (let i = 0; i < e; i++)
      r[i] === `
` ? (n = 1, l += 1) : n += 1;
    return { column: n, line: l };
  }
  prev() {
    if (!this.parent)
      return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  rangeBy(e) {
    let t = {
      column: this.source.start.column,
      line: this.source.start.line
    }, r = this.source.end ? {
      column: this.source.end.column + 1,
      line: this.source.end.line
    } : {
      column: t.column + 1,
      line: t.line
    };
    if (e.word) {
      let n = this.toString(), l = n.indexOf(e.word);
      l !== -1 && (t = this.positionInside(l, n), r = this.positionInside(l + e.word.length, n));
    } else
      e.start ? t = {
        column: e.start.column,
        line: e.start.line
      } : e.index && (t = this.positionInside(e.index)), e.end ? r = {
        column: e.end.column,
        line: e.end.line
      } : typeof e.endIndex == "number" ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
    return (r.line < t.line || r.line === t.line && r.column <= t.column) && (r = { column: t.column + 1, line: t.line }), { end: r, start: t };
  }
  raw(e, t) {
    return new Us().raw(this, e, t);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, r = !1;
      for (let n of e)
        n === this ? r = !0 : r ? (this.parent.insertAfter(t, n), t = n) : this.parent.insertBefore(t, n);
      r || this.remove();
    }
    return this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  toJSON(e, t) {
    let r = {}, n = t == null;
    t = t || /* @__PURE__ */ new Map();
    let l = 0;
    for (let i in this) {
      if (!Object.prototype.hasOwnProperty.call(this, i) || i === "parent" || i === "proxyCache")
        continue;
      let c = this[i];
      if (Array.isArray(c))
        r[i] = c.map((a) => typeof a == "object" && a.toJSON ? a.toJSON(null, t) : a);
      else if (typeof c == "object" && c.toJSON)
        r[i] = c.toJSON(null, t);
      else if (i === "source") {
        let a = t.get(c.input);
        a == null && (a = l, t.set(c.input, l), l++), r[i] = {
          end: c.end,
          inputId: a,
          start: c.start
        };
      } else
        r[i] = c;
    }
    return n && (r.inputs = [...t.keys()].map((i) => i.toJSON())), r;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(e = js) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (r) => {
      t += r;
    }), t;
  }
  warn(e, t, r) {
    let n = { node: this };
    for (let l in r)
      n[l] = r[l];
    return e.warn(t, n);
  }
  get proxyOf() {
    return this;
  }
};
var Xt = zr;
zr.default = zr;
let Vs = Xt, Ur = class extends Vs {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
};
var Zt = Ur;
Ur.default = Ur;
let Ws = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Bs = (s, e = 21) => (t = e) => {
  let r = "", n = t;
  for (; n--; )
    r += s[Math.random() * s.length | 0];
  return r;
}, qs = (s = 21) => {
  let e = "", t = s;
  for (; t--; )
    e += Ws[Math.random() * 64 | 0];
  return e;
};
var Gs = { nanoid: qs, customAlphabet: Bs };
let { SourceMapConsumer: oi, SourceMapGenerator: li } = Le, { existsSync: Ys, readFileSync: Hs } = Le, { dirname: gr, join: Qs } = Le;
function Js(s) {
  return Buffer ? Buffer.from(s, "base64").toString() : window.atob(s);
}
let jr = class {
  constructor(e, t) {
    if (t.map === !1)
      return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let r = t.map ? t.map.prev : void 0, n = this.loadMap(t.from, r);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = gr(this.mapFile)), n && (this.text = n);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new oi(this.text)), this.consumerCache;
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, r = /^data:application\/json;base64,/, n = /^data:application\/json;charset=utf-?8,/, l = /^data:application\/json,/;
    if (n.test(e) || l.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || r.test(e))
      return Js(e.substr(RegExp.lastMatch.length));
    let i = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + i);
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t)
      return;
    let r = e.lastIndexOf(t.pop()), n = e.indexOf("*/", r);
    r > -1 && n > -1 && (this.annotation = this.getAnnotationURL(e.substring(r, n)));
  }
  loadFile(e) {
    if (this.root = gr(e), Ys(e))
      return this.mapFile = e, Hs(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1)
      return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let r = t(e);
        if (r) {
          let n = this.loadFile(r);
          if (!n)
            throw new Error(
              "Unable to load previous source map: " + r.toString()
            );
          return n;
        }
      } else {
        if (t instanceof oi)
          return li.fromSourceMap(t).toString();
        if (t instanceof li)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let r = this.annotation;
        return e && (r = Qs(gr(e), r)), this.loadFile(r);
      }
    }
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var Fi = jr;
jr.default = jr;
let { SourceMapConsumer: Ks, SourceMapGenerator: Xs } = Le, { fileURLToPath: ui, pathToFileURL: It } = Le, { isAbsolute: Vr, resolve: Wr } = Le, { nanoid: Zs } = Gs, vr = Le, fi = xn, eo = Fi, yr = Symbol("fromOffsetCache"), to = !!(Ks && Xs), ci = !!(Wr && Vr), qt = class {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!ci || /^\w+:\/\//.test(t.from) || Vr(t.from) ? this.file = t.from : this.file = Wr(t.from)), ci && to) {
      let r = new eo(this.css, t);
      if (r.text) {
        this.map = r;
        let n = r.consumer().file;
        !this.file && n && (this.file = this.mapResolve(n));
      }
    }
    this.file || (this.id = "<input css " + Zs(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(e, t, r, n = {}) {
    let l, i, c;
    if (t && typeof t == "object") {
      let o = t, f = r;
      if (typeof o.offset == "number") {
        let u = this.fromOffset(o.offset);
        t = u.line, r = u.col;
      } else
        t = o.line, r = o.column;
      if (typeof f.offset == "number") {
        let u = this.fromOffset(f.offset);
        i = u.line, c = u.col;
      } else
        i = f.line, c = f.column;
    } else if (!r) {
      let o = this.fromOffset(t);
      t = o.line, r = o.col;
    }
    let a = this.origin(t, r, i, c);
    return a ? l = new fi(
      e,
      a.endLine === void 0 ? a.line : { column: a.column, line: a.line },
      a.endLine === void 0 ? a.column : { column: a.endColumn, line: a.endLine },
      a.source,
      a.file,
      n.plugin
    ) : l = new fi(
      e,
      i === void 0 ? t : { column: r, line: t },
      i === void 0 ? r : { column: c, line: i },
      this.css,
      this.file,
      n.plugin
    ), l.input = { column: r, endColumn: c, endLine: i, line: t, source: this.css }, this.file && (It && (l.input.url = It(this.file).toString()), l.input.file = this.file), l;
  }
  fromOffset(e) {
    let t, r;
    if (this[yr])
      r = this[yr];
    else {
      let l = this.css.split(`
`);
      r = new Array(l.length);
      let i = 0;
      for (let c = 0, a = l.length; c < a; c++)
        r[c] = i, i += l[c].length + 1;
      this[yr] = r;
    }
    t = r[r.length - 1];
    let n = 0;
    if (e >= t)
      n = r.length - 1;
    else {
      let l = r.length - 2, i;
      for (; n < l; )
        if (i = n + (l - n >> 1), e < r[i])
          l = i - 1;
        else if (e >= r[i + 1])
          n = i + 1;
        else {
          n = i;
          break;
        }
    }
    return {
      col: e - r[n] + 1,
      line: n + 1
    };
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Wr(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  origin(e, t, r, n) {
    if (!this.map)
      return !1;
    let l = this.map.consumer(), i = l.originalPositionFor({ column: t, line: e });
    if (!i.source)
      return !1;
    let c;
    typeof r == "number" && (c = l.originalPositionFor({ column: n, line: r }));
    let a;
    Vr(i.source) ? a = It(i.source) : a = new URL(
      i.source,
      this.map.consumer().sourceRoot || It(this.map.mapFile)
    );
    let o = {
      column: i.column,
      endColumn: c && c.column,
      endLine: c && c.line,
      line: i.line,
      url: a.toString()
    };
    if (a.protocol === "file:")
      if (ui)
        o.file = ui(a);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let f = l.sourceContentFor(i.source);
    return f && (o.source = f), o;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
  get from() {
    return this.file || this.id;
  }
};
var er = qt;
qt.default = qt;
vr && vr.registerInput && vr.registerInput(qt);
let { SourceMapConsumer: zi, SourceMapGenerator: Wt } = Le, { dirname: Bt, relative: Ui, resolve: ji, sep: Vi } = Le, { pathToFileURL: di } = Le, ro = er, no = !!(zi && Wt), io = !!(Bt && ji && Ui && Vi), ao = class {
  constructor(e, t, r, n) {
    this.stringify = e, this.mapOpts = r.map || {}, this.root = t, this.opts = r, this.css = n, this.originalCSS = n, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), r = e.root || Bt(e.file), n;
      this.mapOpts.sourcesContent === !1 ? (n = new zi(e.text), n.sourcesContent && (n.sourcesContent = null)) : n = e.consumer(), this.map.applySourceMap(n, t, this.toUrl(this.path(r)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else
        this.css && (this.css = this.css.replace(/\n*?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), io && no && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Wt.fromSourceMap(e, {
        ignoreInvalidMapping: !0
      });
    } else
      this.map = new Wt({
        file: this.outputFile(),
        ignoreInvalidMapping: !0
      }), this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new Wt({
      file: this.outputFile(),
      ignoreInvalidMapping: !0
    });
    let e = 1, t = 1, r = "<no source>", n = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ""
    }, l, i;
    this.stringify(this.root, (c, a, o) => {
      if (this.css += c, a && o !== "end" && (n.generated.line = e, n.generated.column = t - 1, a.source && a.source.start ? (n.source = this.sourcePath(a), n.original.line = a.source.start.line, n.original.column = a.source.start.column - 1, this.map.addMapping(n)) : (n.source = r, n.original.line = 1, n.original.column = 0, this.map.addMapping(n))), l = c.match(/\n/g), l ? (e += l.length, i = c.lastIndexOf(`
`), t = c.length - i) : t += c.length, a && o !== "start") {
        let f = a.parent || { raws: {} };
        (!(a.type === "decl" || a.type === "atrule" && !a.nodes) || a !== f.last || f.raws.semicolon) && (a.source && a.source.end ? (n.source = this.sourcePath(a), n.original.line = a.source.end.line, n.original.column = a.source.end.column - 1, n.generated.line = e, n.generated.column = t - 2, this.map.addMapping(n)) : (n.source = r, n.original.line = 1, n.original.column = 0, n.generated.line = e, n.generated.column = t - 1, this.map.addMapping(n)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(e) {
    if (this.mapOpts.absolute || e.charCodeAt(0) === 60 || /^\w+:\/\//.test(e))
      return e;
    let t = this.memoizedPaths.get(e);
    if (t)
      return t;
    let r = this.opts.to ? Bt(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (r = Bt(ji(r, this.mapOpts.annotation)));
    let n = Ui(r, e);
    return this.memoizedPaths.set(e, n), n;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new ro(this.originalCSS, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let r = t.source.input.from;
          if (r && !e[r]) {
            e[r] = !0;
            let n = this.usesFileUrls ? this.toFileUrl(r) : this.toUrl(this.path(r));
            this.map.setSourceContent(n, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  toBase64(e) {
    return Buffer ? Buffer.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  toFileUrl(e) {
    let t = this.memoizedFileURLs.get(e);
    if (t)
      return t;
    if (di) {
      let r = di(e).toString();
      return this.memoizedFileURLs.set(e, r), r;
    } else
      throw new Error(
        "`map.absolute` option is not available in this PostCSS build"
      );
  }
  toUrl(e) {
    let t = this.memoizedURLs.get(e);
    if (t)
      return t;
    Vi === "\\" && (e = e.replace(/\\/g, "/"));
    let r = encodeURI(e).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(e, r), r;
  }
};
var Wi = ao;
let so = Xt, Br = class extends so {
  constructor(e) {
    super(e), this.type = "comment";
  }
};
var tr = Br;
Br.default = Br;
let { isClean: Bi, my: qi } = _t, Gi = Zt, Yi = tr, oo = Xt, Hi, _n, Sn, Qi;
function Ji(s) {
  return s.map((e) => (e.nodes && (e.nodes = Ji(e.nodes)), delete e.source, e));
}
function Ki(s) {
  if (s[Bi] = !1, s.proxyOf.nodes)
    for (let e of s.proxyOf.nodes)
      Ki(e);
}
let Ze = class Xi extends oo {
  append(...e) {
    for (let t of e) {
      let r = this.normalize(t, this.last);
      for (let n of r)
        this.proxyOf.nodes.push(n);
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes)
        t.cleanRaws(e);
  }
  each(e) {
    if (!this.proxyOf.nodes)
      return;
    let t = this.getIterator(), r, n;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (r = this.indexes[t], n = e(this.proxyOf.nodes[r], r), n !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], n;
  }
  every(e) {
    return this.nodes.every(e);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
  getProxyProcessor() {
    return {
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...r) => e[t](
          ...r.map((n) => typeof n == "function" ? (l, i) => n(l.toProxy(), i) : n)
        ) : t === "every" || t === "some" ? (r) => e[t](
          (n, ...l) => r(n.toProxy(), ...l)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((r) => r.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      },
      set(e, t, r) {
        return e[t] === r || (e[t] = r, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      }
    };
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  insertAfter(e, t) {
    let r = this.index(e), n = this.normalize(t, this.proxyOf.nodes[r]).reverse();
    r = this.index(e);
    for (let i of n)
      this.proxyOf.nodes.splice(r + 1, 0, i);
    let l;
    for (let i in this.indexes)
      l = this.indexes[i], r < l && (this.indexes[i] = l + n.length);
    return this.markDirty(), this;
  }
  insertBefore(e, t) {
    let r = this.index(e), n = r === 0 ? "prepend" : !1, l = this.normalize(
      t,
      this.proxyOf.nodes[r],
      n
    ).reverse();
    r = this.index(e);
    for (let c of l)
      this.proxyOf.nodes.splice(r, 0, c);
    let i;
    for (let c in this.indexes)
      i = this.indexes[c], r <= i && (this.indexes[c] = i + l.length);
    return this.markDirty(), this;
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = Ji(Hi(e).nodes);
    else if (typeof e > "u")
      e = [];
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let n of e)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let n of e)
        n.parent && n.parent.removeChild(n, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new Gi(e)];
    } else if (e.selector)
      e = [new _n(e)];
    else if (e.name)
      e = [new Sn(e)];
    else if (e.text)
      e = [new Yi(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((n) => (n[qi] || Xi.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[Bi] && Ki(n), typeof n.raws.before > "u" && t && typeof t.raws.before < "u" && (n.raws.before = t.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let r = this.normalize(t, this.first, "prepend").reverse();
      for (let n of r)
        this.proxyOf.nodes.unshift(n);
      for (let n in this.indexes)
        this.indexes[n] = this.indexes[n] + r.length;
    }
    return this.markDirty(), this;
  }
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes)
      e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let r in this.indexes)
      t = this.indexes[r], t >= e && (this.indexes[r] = t - 1);
    return this.markDirty(), this;
  }
  replaceValues(e, t, r) {
    return r || (r = t, t = {}), this.walkDecls((n) => {
      t.props && !t.props.includes(n.prop) || t.fast && !n.value.includes(t.fast) || (n.value = n.value.replace(e, r));
    }), this.markDirty(), this;
  }
  some(e) {
    return this.nodes.some(e);
  }
  walk(e) {
    return this.each((t, r) => {
      let n;
      try {
        n = e(t, r);
      } catch (l) {
        throw t.addToError(l);
      }
      return n !== !1 && t.walk && (n = t.walk(e)), n;
    });
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((r, n) => {
      if (r.type === "atrule" && e.test(r.name))
        return t(r, n);
    }) : this.walk((r, n) => {
      if (r.type === "atrule" && r.name === e)
        return t(r, n);
    }) : (t = e, this.walk((r, n) => {
      if (r.type === "atrule")
        return t(r, n);
    }));
  }
  walkComments(e) {
    return this.walk((t, r) => {
      if (t.type === "comment")
        return e(t, r);
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((r, n) => {
      if (r.type === "decl" && e.test(r.prop))
        return t(r, n);
    }) : this.walk((r, n) => {
      if (r.type === "decl" && r.prop === e)
        return t(r, n);
    }) : (t = e, this.walk((r, n) => {
      if (r.type === "decl")
        return t(r, n);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((r, n) => {
      if (r.type === "rule" && e.test(r.selector))
        return t(r, n);
    }) : this.walk((r, n) => {
      if (r.type === "rule" && r.selector === e)
        return t(r, n);
    }) : (t = e, this.walk((r, n) => {
      if (r.type === "rule")
        return t(r, n);
    }));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
};
Ze.registerParse = (s) => {
  Hi = s;
};
Ze.registerRule = (s) => {
  _n = s;
};
Ze.registerAtRule = (s) => {
  Sn = s;
};
Ze.registerRoot = (s) => {
  Qi = s;
};
var st = Ze;
Ze.default = Ze;
Ze.rebuild = (s) => {
  s.type === "atrule" ? Object.setPrototypeOf(s, Sn.prototype) : s.type === "rule" ? Object.setPrototypeOf(s, _n.prototype) : s.type === "decl" ? Object.setPrototypeOf(s, Gi.prototype) : s.type === "comment" ? Object.setPrototypeOf(s, Yi.prototype) : s.type === "root" && Object.setPrototypeOf(s, Qi.prototype), s[qi] = !0, s.nodes && s.nodes.forEach((e) => {
    Ze.rebuild(e);
  });
};
let lo = st, Zi, ea, vt = class extends lo {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new Zi(new ea(), this, e).stringify();
  }
};
vt.registerLazyResult = (s) => {
  Zi = s;
};
vt.registerProcessor = (s) => {
  ea = s;
};
var On = vt;
vt.default = vt;
let pi = {};
var ta = function(e) {
  pi[e] || (pi[e] = !0, typeof console < "u" && console.warn && console.warn(e));
};
let qr = class {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let r = t.node.rangeBy(t);
      this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
    }
    for (let r in t)
      this[r] = t[r];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      index: this.index,
      plugin: this.plugin,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var ra = qr;
qr.default = qr;
let uo = ra, Gr = class {
  constructor(e, t, r) {
    this.processor = e, this.messages = [], this.root = t, this.opts = r, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let r = new uo(e, t);
    return this.messages.push(r), r;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
};
var kn = Gr;
Gr.default = Gr;
const wr = 39, hi = 34, Rt = 92, mi = 47, $t = 10, ht = 32, Dt = 12, Nt = 9, Lt = 13, fo = 91, co = 93, po = 40, ho = 41, mo = 123, go = 125, vo = 59, yo = 42, wo = 58, bo = 64, Ft = /[\t\n\f\r "#'()/;[\\\]{}]/g, zt = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, xo = /.[\r\n"'(/\\]/, gi = /[\da-f]/i;
var _o = function(e, t = {}) {
  let r = e.css.valueOf(), n = t.ignoreErrors, l, i, c, a, o, f, u, p, _, x, h = r.length, m = 0, C = [], S = [];
  function k() {
    return m;
  }
  function O(P) {
    throw e.error("Unclosed " + P, m);
  }
  function E() {
    return S.length === 0 && m >= h;
  }
  function M(P) {
    if (S.length)
      return S.pop();
    if (m >= h)
      return;
    let b = P ? P.ignoreUnclosed : !1;
    switch (l = r.charCodeAt(m), l) {
      case $t:
      case ht:
      case Nt:
      case Lt:
      case Dt: {
        i = m;
        do
          i += 1, l = r.charCodeAt(i);
        while (l === ht || l === $t || l === Nt || l === Lt || l === Dt);
        x = ["space", r.slice(m, i)], m = i - 1;
        break;
      }
      case fo:
      case co:
      case mo:
      case go:
      case wo:
      case vo:
      case ho: {
        let A = String.fromCharCode(l);
        x = [A, A, m];
        break;
      }
      case po: {
        if (p = C.length ? C.pop()[1] : "", _ = r.charCodeAt(m + 1), p === "url" && _ !== wr && _ !== hi && _ !== ht && _ !== $t && _ !== Nt && _ !== Dt && _ !== Lt) {
          i = m;
          do {
            if (f = !1, i = r.indexOf(")", i + 1), i === -1)
              if (n || b) {
                i = m;
                break;
              } else
                O("bracket");
            for (u = i; r.charCodeAt(u - 1) === Rt; )
              u -= 1, f = !f;
          } while (f);
          x = ["brackets", r.slice(m, i + 1), m, i], m = i;
        } else
          i = r.indexOf(")", m + 1), a = r.slice(m, i + 1), i === -1 || xo.test(a) ? x = ["(", "(", m] : (x = ["brackets", a, m, i], m = i);
        break;
      }
      case wr:
      case hi: {
        c = l === wr ? "'" : '"', i = m;
        do {
          if (f = !1, i = r.indexOf(c, i + 1), i === -1)
            if (n || b) {
              i = m + 1;
              break;
            } else
              O("string");
          for (u = i; r.charCodeAt(u - 1) === Rt; )
            u -= 1, f = !f;
        } while (f);
        x = ["string", r.slice(m, i + 1), m, i], m = i;
        break;
      }
      case bo: {
        Ft.lastIndex = m + 1, Ft.test(r), Ft.lastIndex === 0 ? i = r.length - 1 : i = Ft.lastIndex - 2, x = ["at-word", r.slice(m, i + 1), m, i], m = i;
        break;
      }
      case Rt: {
        for (i = m, o = !0; r.charCodeAt(i + 1) === Rt; )
          i += 1, o = !o;
        if (l = r.charCodeAt(i + 1), o && l !== mi && l !== ht && l !== $t && l !== Nt && l !== Lt && l !== Dt && (i += 1, gi.test(r.charAt(i)))) {
          for (; gi.test(r.charAt(i + 1)); )
            i += 1;
          r.charCodeAt(i + 1) === ht && (i += 1);
        }
        x = ["word", r.slice(m, i + 1), m, i], m = i;
        break;
      }
      default: {
        l === mi && r.charCodeAt(m + 1) === yo ? (i = r.indexOf("*/", m + 2) + 1, i === 0 && (n || b ? i = r.length : O("comment")), x = ["comment", r.slice(m, i + 1), m, i], m = i) : (zt.lastIndex = m + 1, zt.test(r), zt.lastIndex === 0 ? i = r.length - 1 : i = zt.lastIndex - 2, x = ["word", r.slice(m, i + 1), m, i], C.push(x), m = i);
        break;
      }
    }
    return m++, x;
  }
  function D(P) {
    S.push(P);
  }
  return {
    back: D,
    endOfFile: E,
    nextToken: M,
    position: k
  };
};
let na = st, Gt = class extends na {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
};
var An = Gt;
Gt.default = Gt;
na.registerAtRule(Gt);
let ia = st, aa, sa, ut = class extends ia {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(e, t, r) {
    let n = super.normalize(e);
    if (t) {
      if (r === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let l of n)
          l.raws.before = t.raws.before;
    }
    return n;
  }
  removeChild(e, t) {
    let r = this.index(e);
    return !t && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
  }
  toResult(e = {}) {
    return new aa(new sa(), this, e).stringify();
  }
};
ut.registerLazyResult = (s) => {
  aa = s;
};
ut.registerProcessor = (s) => {
  sa = s;
};
var St = ut;
ut.default = ut;
ia.registerRoot(ut);
let yt = {
  comma(s) {
    return yt.split(s, [","], !0);
  },
  space(s) {
    let e = [" ", `
`, "	"];
    return yt.split(s, e);
  },
  split(s, e, t) {
    let r = [], n = "", l = !1, i = 0, c = !1, a = "", o = !1;
    for (let f of s)
      o ? o = !1 : f === "\\" ? o = !0 : c ? f === a && (c = !1) : f === '"' || f === "'" ? (c = !0, a = f) : f === "(" ? i += 1 : f === ")" ? i > 0 && (i -= 1) : i === 0 && e.includes(f) && (l = !0), l ? (n !== "" && r.push(n.trim()), n = "", l = !1) : n += f;
    return (t || n !== "") && r.push(n.trim()), r;
  }
};
var oa = yt;
yt.default = yt;
let la = st, So = oa, Yt = class extends la {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return So.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, r = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(r);
  }
};
var Cn = Yt;
Yt.default = Yt;
la.registerRule(Yt);
let Oo = Zt, ko = _o, Ao = tr, Co = An, Eo = St, vi = Cn;
const yi = {
  empty: !0,
  space: !0
};
function Po(s) {
  for (let e = s.length - 1; e >= 0; e--) {
    let t = s[e], r = t[3] || t[2];
    if (r)
      return r;
  }
}
let To = class {
  constructor(e) {
    this.input = e, this.root = new Eo(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(e) {
    let t = new Co();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let r, n, l, i = !1, c = !1, a = [], o = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? o.push(r === "(" ? ")" : "]") : r === "{" && o.length > 0 ? o.push("}") : r === o[o.length - 1] && o.pop(), o.length === 0)
        if (r === ";") {
          t.source.end = this.getPosition(e[2]), t.source.end.offset++, this.semicolon = !0;
          break;
        } else if (r === "{") {
          c = !0;
          break;
        } else if (r === "}") {
          if (a.length > 0) {
            for (l = a.length - 1, n = a[l]; n && n[0] === "space"; )
              n = a[--l];
            n && (t.source.end = this.getPosition(n[3] || n[2]), t.source.end.offset++);
          }
          this.end(e);
          break;
        } else
          a.push(e);
      else
        a.push(e);
      if (this.tokenizer.endOfFile()) {
        i = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(a), a.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(a), this.raw(t, "params", a), i && (e = a[a.length - 1], t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++, this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), c && (t.nodes = [], this.current = t);
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1)
      return;
    let r = 0, n;
    for (let l = t - 1; l >= 0 && (n = e[l], !(n[0] !== "space" && (r += 1, r === 2))); l--)
      ;
    throw this.input.error(
      "Missed semicolon",
      n[0] === "word" ? n[3] + 1 : n[2]
    );
  }
  colon(e) {
    let t = 0, r, n, l;
    for (let [i, c] of e.entries()) {
      if (r = c, n = r[0], n === "(" && (t += 1), n === ")" && (t -= 1), t === 0 && n === ":")
        if (!l)
          this.doubleColon(r);
        else {
          if (l[0] === "word" && l[1] === "progid")
            continue;
          return i;
        }
      l = r;
    }
    return !1;
  }
  comment(e) {
    let t = new Ao();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]), t.source.end.offset++;
    let r = e[1].slice(2, -2);
    if (/^\s*$/.test(r))
      t.text = "", t.raws.left = r, t.raws.right = "";
    else {
      let n = r.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = n[2], t.raws.left = n[1], t.raws.right = n[3];
    }
  }
  createTokenizer() {
    this.tokenizer = ko(this.input);
  }
  decl(e, t) {
    let r = new Oo();
    this.init(r, e[0][2]);
    let n = e[e.length - 1];
    for (n[0] === ";" && (this.semicolon = !0, e.pop()), r.source.end = this.getPosition(
      n[3] || n[2] || Po(e)
    ), r.source.end.offset++; e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
    for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length; ) {
      let o = e[0][0];
      if (o === ":" || o === "space" || o === "comment")
        break;
      r.prop += e.shift()[1];
    }
    r.raws.between = "";
    let l;
    for (; e.length; )
      if (l = e.shift(), l[0] === ":") {
        r.raws.between += l[1];
        break;
      } else
        l[0] === "word" && /\w/.test(l[1]) && this.unknownWord([l]), r.raws.between += l[1];
    (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
    let i = [], c;
    for (; e.length && (c = e[0][0], !(c !== "space" && c !== "comment")); )
      i.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let o = e.length - 1; o >= 0; o--) {
      if (l = e[o], l[1].toLowerCase() === "!important") {
        r.important = !0;
        let f = this.stringFrom(e, o);
        f = this.spacesFromEnd(e) + f, f !== " !important" && (r.raws.important = f);
        break;
      } else if (l[1].toLowerCase() === "important") {
        let f = e.slice(0), u = "";
        for (let p = o; p > 0; p--) {
          let _ = f[p][0];
          if (u.trim().indexOf("!") === 0 && _ !== "space")
            break;
          u = f.pop()[1] + u;
        }
        u.trim().indexOf("!") === 0 && (r.important = !0, r.raws.important = u, e = f);
      }
      if (l[0] !== "space" && l[0] !== "comment")
        break;
    }
    e.some((o) => o[0] !== "space" && o[0] !== "comment") && (r.raws.between += i.map((o) => o[1]).join(""), i = []), this.raw(r, "value", i.concat(e), t), r.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  emptyRule(e) {
    let t = new vi();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      column: t.col,
      line: t.line,
      offset: e
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      input: this.input,
      start: this.getPosition(t)
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  other(e) {
    let t = !1, r = null, n = !1, l = null, i = [], c = e[1].startsWith("--"), a = [], o = e;
    for (; o; ) {
      if (r = o[0], a.push(o), r === "(" || r === "[")
        l || (l = o), i.push(r === "(" ? ")" : "]");
      else if (c && n && r === "{")
        l || (l = o), i.push("}");
      else if (i.length === 0)
        if (r === ";")
          if (n) {
            this.decl(a, c);
            return;
          } else
            break;
        else if (r === "{") {
          this.rule(a);
          return;
        } else if (r === "}") {
          this.tokenizer.back(a.pop()), t = !0;
          break;
        } else
          r === ":" && (n = !0);
      else
        r === i[i.length - 1] && (i.pop(), i.length === 0 && (l = null));
      o = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(l), t && n) {
      if (!c)
        for (; a.length && (o = a[a.length - 1][0], !(o !== "space" && o !== "comment")); )
          this.tokenizer.back(a.pop());
      this.decl(a, c);
    } else
      this.unknownWord(a);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(e, t, r, n) {
    let l, i, c = r.length, a = "", o = !0, f, u;
    for (let p = 0; p < c; p += 1)
      l = r[p], i = l[0], i === "space" && p === c - 1 && !n ? o = !1 : i === "comment" ? (u = r[p - 1] ? r[p - 1][0] : "empty", f = r[p + 1] ? r[p + 1][0] : "empty", !yi[u] && !yi[f] ? a.slice(-1) === "," ? o = !1 : a += l[1] : o = !1) : a += l[1];
    if (!o) {
      let p = r.reduce((_, x) => _ + x[1], "");
      e.raws[t] = { raw: p, value: a };
    }
    e[t] = a;
  }
  rule(e) {
    e.pop();
    let t = new vi();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  spacesAndCommentsFromEnd(e) {
    let t, r = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      r = e.pop()[1] + r;
    return r;
  }
  // Errors
  spacesAndCommentsFromStart(e) {
    let t, r = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      r += e.shift()[1];
    return r;
  }
  spacesFromEnd(e) {
    let t, r = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      r = e.pop()[1] + r;
    return r;
  }
  stringFrom(e, t) {
    let r = "";
    for (let n = t; n < e.length; n++)
      r += e[n][1];
    return e.splice(t, e.length - t), r;
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
};
var Mo = To;
let Io = st, Ro = Mo, $o = er;
function Ht(s, e) {
  let t = new $o(s, e), r = new Ro(t);
  try {
    r.parse();
  } catch (n) {
    throw  false && (0), n;
  }
  return r.root;
}
var En = Ht;
Ht.default = Ht;
Io.registerParse(Ht);
let { isClean: Je, my: Do } = _t, No = Wi, Lo = Kt, Fo = st, zo = On, Uo = (/* unused pure expression or super */ null && (ta)), wi = kn, jo = En, Vo = St;
const Wo = {
  atrule: "AtRule",
  comment: "Comment",
  decl: "Declaration",
  document: "Document",
  root: "Root",
  rule: "Rule"
}, Bo = {
  AtRule: !0,
  AtRuleExit: !0,
  Comment: !0,
  CommentExit: !0,
  Declaration: !0,
  DeclarationExit: !0,
  Document: !0,
  DocumentExit: !0,
  Once: !0,
  OnceExit: !0,
  postcssPlugin: !0,
  prepare: !0,
  Root: !0,
  RootExit: !0,
  Rule: !0,
  RuleExit: !0
}, qo = {
  Once: !0,
  postcssPlugin: !0,
  prepare: !0
}, ft = 0;
function mt(s) {
  return typeof s == "object" && typeof s.then == "function";
}
function ua(s) {
  let e = !1, t = Wo[s.type];
  return s.type === "decl" ? e = s.prop.toLowerCase() : s.type === "atrule" && (e = s.name.toLowerCase()), e && s.append ? [
    t,
    t + "-" + e,
    ft,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : s.append ? [t, ft, t + "Exit"] : [t, t + "Exit"];
}
function bi(s) {
  let e;
  return s.type === "document" ? e = ["Document", ft, "DocumentExit"] : s.type === "root" ? e = ["Root", ft, "RootExit"] : e = ua(s), {
    eventIndex: 0,
    events: e,
    iterator: 0,
    node: s,
    visitorIndex: 0,
    visitors: []
  };
}
function Yr(s) {
  return s[Je] = !1, s.nodes && s.nodes.forEach((e) => Yr(e)), s;
}
let Hr = {}, ct = class fa {
  constructor(e, t, r) {
    this.stringified = !1, this.processed = !1;
    let n;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      n = Yr(t);
    else if (t instanceof fa || t instanceof wi)
      n = Yr(t.root), t.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = !1), r.map.prev = t.map);
    else {
      let l = jo;
      r.syntax && (l = r.syntax.parse), r.parser && (l = r.parser), l.parse && (l = l.parse);
      try {
        n = l(t, r);
      } catch (i) {
        this.processed = !0, this.error = i;
      }
      n && !n[Do] && Fo.rebuild(n);
    }
    this.result = new wi(e, n, r), this.helpers = { ...Hr, postcss: Hr, result: this.result }, this.plugins = this.processor.plugins.map((l) => typeof l == "object" && l.prepare ? { ...l, ...l.prepare(this.result) } : l);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let r = this.result.lastPlugin;
    try {
      if (t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin)
        e.plugin = r.postcssPlugin, e.setMessage();
      else if (r.postcssVersion && "production" !== "production") {}
    } catch (n) {
      console && console.error && console.error(n);
    }
    return e;
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, r, n) => {
      this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([t, n]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let r in t) {
          if (!Bo[r] && /^[A-Z]/.test(r))
            throw new Error(
              `Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!qo[r])
            if (typeof t[r] == "object")
              for (let n in t[r])
                n === "*" ? e(t, r, t[r][n]) : e(
                  t,
                  r + "-" + n.toLowerCase(),
                  t[r][n]
                );
            else
              typeof t[r] == "function" && e(t, r, t[r]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], r = this.runOnRoot(t);
      if (mt(r))
        try {
          await r;
        } catch (n) {
          throw this.handleError(n);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Je]; ) {
        e[Je] = !0;
        let t = [bi(e)];
        for (; t.length > 0; ) {
          let r = this.visitTick(t);
          if (mt(r))
            try {
              await r;
            } catch (n) {
              let l = t[t.length - 1].node;
              throw this.handleError(n, l);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, r] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let n = e.nodes.map(
                (l) => r(l, this.helpers)
              );
              await Promise.all(n);
            } else
              await r(e, this.helpers);
          } catch (n) {
            throw this.handleError(n);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (r) => e.Once(r, this.helpers)
          );
          return mt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  stringify() {
    if (this.error)
      throw this.error;
    if (this.stringified)
      return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = Lo;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let n = new No(t, this.result.root, this.result.opts).generate();
    return this.result.css = n[0], this.result.map = n[1], this.result;
  }
  sync() {
    if (this.error)
      throw this.error;
    if (this.processed)
      return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (mt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Je]; )
        e[Je] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  then(e, t) {
    return  false && (0), this.async().then(e, t);
  }
  toString() {
    return this.css;
  }
  visitSync(e, t) {
    for (let [r, n] of e) {
      this.result.lastPlugin = r;
      let l;
      try {
        l = n(t, this.helpers);
      } catch (i) {
        throw this.handleError(i, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (mt(l))
        throw this.getAsyncError();
    }
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: r, visitors: n } = t;
    if (r.type !== "root" && r.type !== "document" && !r.parent) {
      e.pop();
      return;
    }
    if (n.length > 0 && t.visitorIndex < n.length) {
      let [i, c] = n[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === n.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = i;
      try {
        return c(r.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, r);
      }
    }
    if (t.iterator !== 0) {
      let i = t.iterator, c;
      for (; c = r.nodes[r.indexes[i]]; )
        if (r.indexes[i] += 1, !c[Je]) {
          c[Je] = !0, e.push(bi(c));
          return;
        }
      t.iterator = 0, delete r.indexes[i];
    }
    let l = t.events;
    for (; t.eventIndex < l.length; ) {
      let i = l[t.eventIndex];
      if (t.eventIndex += 1, i === ft) {
        r.nodes && r.nodes.length && (r[Je] = !0, t.iterator = r.getIterator());
        return;
      } else if (this.listeners[i]) {
        t.visitors = this.listeners[i];
        return;
      }
    }
    e.pop();
  }
  walkSync(e) {
    e[Je] = !0;
    let t = ua(e);
    for (let r of t)
      if (r === ft)
        e.nodes && e.each((n) => {
          n[Je] || this.walkSync(n);
        });
      else {
        let n = this.listeners[r];
        if (n && this.visitSync(n, e.toProxy()))
          return;
      }
  }
  warnings() {
    return this.sync().warnings();
  }
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
};
ct.registerPostcss = (s) => {
  Hr = s;
};
var ca = ct;
ct.default = ct;
Vo.registerLazyResult(ct);
zo.registerLazyResult(ct);
let Go = Wi, Yo = Kt, Ho = (/* unused pure expression or super */ null && (ta)), Qo = En;
const Jo = kn;
let Qr = class {
  constructor(e, t, r) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = r, this._map = void 0;
    let n, l = Yo;
    this.result = new Jo(this._processor, n, this._opts), this.result.css = t;
    let i = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return i.root;
      }
    });
    let c = new Go(l, n, this._opts, t);
    if (c.isMap()) {
      let [a, o] = c.generate();
      a && (this.result.css = a), o && (this.result.map = o);
    } else
      c.clearAnnotation(), this.result.css = c.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  sync() {
    if (this.error)
      throw this.error;
    return this.result;
  }
  then(e, t) {
    return  false && (0), this.async().then(e, t);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = Qo;
    try {
      e = t(this._css, this._opts);
    } catch (r) {
      this.error = r;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
};
var Ko = Qr;
Qr.default = Qr;
let Xo = Ko, Zo = ca, el = On, tl = St, wt = class {
  constructor(e = []) {
    this.version = "8.4.40", this.plugins = this.normalize(e);
  }
  normalize(e) {
    let t = [];
    for (let r of e)
      if (r.postcss === !0 ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins))
        t = t.concat(r.plugins);
      else if (typeof r == "object" && r.postcssPlugin)
        t.push(r);
      else if (typeof r == "function")
        t.push(r);
      else if (typeof r == "object" && (r.parse || r.stringify)) {
        if (false)
          {}
      } else
        throw new Error(r + " is not a PostCSS plugin");
    return t;
  }
  process(e, t = {}) {
    return !this.plugins.length && !t.parser && !t.stringifier && !t.syntax ? new Xo(this, e, t) : new Zo(this, e, t);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
};
var rl = wt;
wt.default = wt;
tl.registerProcessor(wt);
el.registerProcessor(wt);
let nl = Zt, il = Fi, al = tr, sl = An, ol = er, ll = St, ul = Cn;
function bt(s, e) {
  if (Array.isArray(s))
    return s.map((n) => bt(n));
  let { inputs: t, ...r } = s;
  if (t) {
    e = [];
    for (let n of t) {
      let l = { ...n, __proto__: ol.prototype };
      l.map && (l.map = {
        ...l.map,
        __proto__: il.prototype
      }), e.push(l);
    }
  }
  if (r.nodes && (r.nodes = s.nodes.map((n) => bt(n, e))), r.source) {
    let { inputId: n, ...l } = r.source;
    r.source = l, n != null && (r.source.input = e[n]);
  }
  if (r.type === "root")
    return new ll(r);
  if (r.type === "decl")
    return new nl(r);
  if (r.type === "rule")
    return new ul(r);
  if (r.type === "comment")
    return new al(r);
  if (r.type === "atrule")
    return new sl(r);
  throw new Error("Unknown node type: " + s.type);
}
var fl = bt;
bt.default = bt;
let cl = xn, da = Zt, dl = ca, pl = st, Pn = rl, hl = Kt, ml = fl, pa = On, gl = ra, ha = tr, ma = An, vl = kn, yl = er, wl = En, bl = oa, ga = Cn, va = St, xl = Xt;
function Ee(...s) {
  return s.length === 1 && Array.isArray(s[0]) && (s = s[0]), new Pn(s);
}
Ee.plugin = function(e, t) {
  let r = !1;
  function n(...i) {
    console && console.warn && !r && (r = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
      e + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
    ));
    let c = t(...i);
    return c.postcssPlugin = e, c.postcssVersion = new Pn().version, c;
  }
  let l;
  return Object.defineProperty(n, "postcss", {
    get() {
      return l || (l = n()), l;
    }
  }), n.process = function(i, c, a) {
    return Ee([n(a)]).process(i, c);
  }, n;
};
Ee.stringify = hl;
Ee.parse = wl;
Ee.fromJSON = ml;
Ee.list = bl;
Ee.comment = (s) => new ha(s);
Ee.atRule = (s) => new ma(s);
Ee.decl = (s) => new da(s);
Ee.rule = (s) => new ga(s);
Ee.root = (s) => new va(s);
Ee.document = (s) => new pa(s);
Ee.CssSyntaxError = cl;
Ee.Declaration = da;
Ee.Container = pl;
Ee.Processor = Pn;
Ee.Document = pa;
Ee.Comment = ha;
Ee.Warning = gl;
Ee.AtRule = ma;
Ee.Result = vl;
Ee.Input = yl;
Ee.Rule = ga;
Ee.Root = va;
Ee.Node = xl;
dl.registerPostcss(Ee);
var qe = Ee;
Ee.default = Ee;
const De = /* @__PURE__ */ Qe(qe);
De.stringify;
De.fromJSON;
De.plugin;
const _l = De.parse;
De.list;
De.document;
De.comment;
De.atRule;
const Sl = De.rule, Ol = De.decl;
De.root;
De.CssSyntaxError;
De.Declaration;
De.Container;
De.Processor;
De.Document;
De.Comment;
De.Warning;
const kl = De.AtRule;
De.Result;
De.Input;
const xi = De.Rule, Al = De.Root;
De.Node;
const Cl = (s) => s.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}");
var ya = {}, wa = { exports: {} };
(function(s, e) {
  (function(t, r) {
    s.exports = function(n, l, i, c, a) {
      for (l = l.split ? l.split(".") : l, c = 0; c < l.length; c++)
        n = n ? n[l[c]] : a;
      return n === a ? i : n;
    };
  })();
})(wa);
var ba = wa.exports, xa = { exports: {} };
(function(s) {
  (function() {
    function e(n, l, i) {
      if (!n)
        return null;
      e.caseSensitive || (n = n.toLowerCase());
      var c = e.threshold === null ? null : e.threshold * n.length, a = e.thresholdAbsolute, o;
      c !== null && a !== null ? o = Math.min(c, a) : c !== null ? o = c : a !== null ? o = a : o = null;
      var f, u, p, _, x, h = l.length;
      for (x = 0; x < h; x++)
        if (u = l[x], i && (u = u[i]), !!u && (e.caseSensitive ? p = u : p = u.toLowerCase(), _ = r(n, p, o), (o === null || _ < o) && (o = _, i && e.returnWinningObject ? f = l[x] : f = u, e.returnFirstMatch)))
          return f;
      return f || e.nullResultValue;
    }
    e.threshold = 0.4, e.thresholdAbsolute = 20, e.caseSensitive = !1, e.nullResultValue = null, e.returnWinningObject = null, e.returnFirstMatch = !1, s.exports ? s.exports = e : window.didYouMean = e;
    var t = Math.pow(2, 32) - 1;
    function r(n, l, i) {
      i = i || i === 0 ? i : t;
      var c = n.length, a = l.length;
      if (c === 0)
        return Math.min(i + 1, a);
      if (a === 0)
        return Math.min(i + 1, c);
      if (Math.abs(c - a) > i)
        return i + 1;
      var o = [], f, u, p, _, x;
      for (f = 0; f <= a; f++)
        o[f] = [f];
      for (u = 0; u <= c; u++)
        o[0][u] = u;
      for (f = 1; f <= a; f++) {
        for (p = t, _ = 1, f > i && (_ = f - i), x = a + 1, x > i + f && (x = i + f), u = 1; u <= c; u++)
          u < _ || u > x ? o[f][u] = i + 1 : l.charAt(f - 1) === n.charAt(u - 1) ? o[f][u] = o[f - 1][u - 1] : o[f][u] = Math.min(
            o[f - 1][u - 1] + 1,
            // Substitute
            Math.min(
              o[f][u - 1] + 1,
              // Insert
              o[f - 1][u] + 1
            )
          ), o[f][u] < p && (p = o[f][u]);
        if (p > i)
          return i + 1;
      }
      return o[a][c];
    }
  })();
})(xa);
var El = xa.exports, Ot = {}, dt = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    if (Object.prototype.toString.call(t) !== "[object Object]")
      return !1;
    const r = Object.getPrototypeOf(t);
    return r === null || Object.getPrototypeOf(r) === null;
  }
})(dt);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r(qe), t = /* @__PURE__ */ r(dt);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n(l) {
    return [
      "fontSize",
      "outline"
    ].includes(l) ? (i) => (typeof i == "function" && (i = i({})), Array.isArray(i) && (i = i[0]), i) : l === "fontFamily" ? (i) => {
      typeof i == "function" && (i = i({}));
      let c = Array.isArray(i) && (0, t.default)(i[1]) ? i[0] : i;
      return Array.isArray(c) ? c.join(", ") : c;
    } : [
      "boxShadow",
      "transitionProperty",
      "transitionDuration",
      "transitionDelay",
      "transitionTimingFunction",
      "backgroundImage",
      "backgroundSize",
      "backgroundColor",
      "cursor",
      "animation"
    ].includes(l) ? (i) => (typeof i == "function" && (i = i({})), Array.isArray(i) && (i = i.join(", ")), i) : [
      "gridTemplateColumns",
      "gridTemplateRows",
      "objectPosition"
    ].includes(l) ? (i) => (typeof i == "function" && (i = i({})), typeof i == "string" && (i = e.default.list.comma(i).join(" ")), i) : (i, c = {}) => (typeof i == "function" && (i = i(c)), i);
  }
})(Ot);
var br = 40, xr = 41, Ut = 39, _r = 34, Sr = 92, lt = 47, Or = 44, kr = 58, jt = 42, Pl = 117, Tl = 85, Ml = 43, Il = /^[a-f0-9?-]+$/i, Rl = function(s) {
  for (var e = [], t = s, r, n, l, i, c, a, o, f, u = 0, p = t.charCodeAt(u), _ = t.length, x = [
    {
      nodes: e
    }
  ], h = 0, m, C = "", S = "", k = ""; u < _; )
    if (p <= 32) {
      r = u;
      do
        r += 1, p = t.charCodeAt(r);
      while (p <= 32);
      i = t.slice(u, r), l = e[e.length - 1], p === xr && h ? k = i : l && l.type === "div" ? (l.after = i, l.sourceEndIndex += i.length) : p === Or || p === kr || p === lt && t.charCodeAt(r + 1) !== jt && (!m || m && m.type === "function" && !1) ? S = i : e.push({
        type: "space",
        sourceIndex: u,
        sourceEndIndex: r,
        value: i
      }), u = r;
    } else if (p === Ut || p === _r) {
      r = u, n = p === Ut ? "'" : '"', i = {
        type: "string",
        sourceIndex: u,
        quote: n
      };
      do
        if (c = !1, r = t.indexOf(n, r + 1), ~r)
          for (a = r; t.charCodeAt(a - 1) === Sr; )
            a -= 1, c = !c;
        else
          t += n, r = t.length - 1, i.unclosed = !0;
      while (c);
      i.value = t.slice(u + 1, r), i.sourceEndIndex = i.unclosed ? r : r + 1, e.push(i), u = r + 1, p = t.charCodeAt(u);
    } else if (p === lt && t.charCodeAt(u + 1) === jt)
      r = t.indexOf("*/", u), i = {
        type: "comment",
        sourceIndex: u,
        sourceEndIndex: r + 2
      }, r === -1 && (i.unclosed = !0, r = t.length, i.sourceEndIndex = r), i.value = t.slice(u + 2, r), e.push(i), u = r + 2, p = t.charCodeAt(u);
    else if ((p === lt || p === jt) && m && m.type === "function")
      i = t[u], e.push({
        type: "word",
        sourceIndex: u - S.length,
        sourceEndIndex: u + i.length,
        value: i
      }), u += 1, p = t.charCodeAt(u);
    else if (p === lt || p === Or || p === kr)
      i = t[u], e.push({
        type: "div",
        sourceIndex: u - S.length,
        sourceEndIndex: u + i.length,
        value: i,
        before: S,
        after: ""
      }), S = "", u += 1, p = t.charCodeAt(u);
    else if (br === p) {
      r = u;
      do
        r += 1, p = t.charCodeAt(r);
      while (p <= 32);
      if (f = u, i = {
        type: "function",
        sourceIndex: u - C.length,
        value: C,
        before: t.slice(f + 1, r)
      }, u = r, C === "url" && p !== Ut && p !== _r) {
        r -= 1;
        do
          if (c = !1, r = t.indexOf(")", r + 1), ~r)
            for (a = r; t.charCodeAt(a - 1) === Sr; )
              a -= 1, c = !c;
          else
            t += ")", r = t.length - 1, i.unclosed = !0;
        while (c);
        o = r;
        do
          o -= 1, p = t.charCodeAt(o);
        while (p <= 32);
        f < o ? (u !== o + 1 ? i.nodes = [
          {
            type: "word",
            sourceIndex: u,
            sourceEndIndex: o + 1,
            value: t.slice(u, o + 1)
          }
        ] : i.nodes = [], i.unclosed && o + 1 !== r ? (i.after = "", i.nodes.push({
          type: "space",
          sourceIndex: o + 1,
          sourceEndIndex: r,
          value: t.slice(o + 1, r)
        })) : (i.after = t.slice(o + 1, r), i.sourceEndIndex = r)) : (i.after = "", i.nodes = []), u = r + 1, i.sourceEndIndex = i.unclosed ? r : u, p = t.charCodeAt(u), e.push(i);
      } else
        h += 1, i.after = "", i.sourceEndIndex = u + 1, e.push(i), x.push(i), e = i.nodes = [], m = i;
      C = "";
    } else if (xr === p && h)
      u += 1, p = t.charCodeAt(u), m.after = k, m.sourceEndIndex += k.length, k = "", h -= 1, x[x.length - 1].sourceEndIndex = u, x.pop(), m = x[h], e = m.nodes;
    else {
      r = u;
      do
        p === Sr && (r += 1), r += 1, p = t.charCodeAt(r);
      while (r < _ && !(p <= 32 || p === Ut || p === _r || p === Or || p === kr || p === lt || p === br || p === jt && m && m.type === "function" || p === lt && m.type === "function" || p === xr && h));
      i = t.slice(u, r), br === p ? C = i : (Pl === i.charCodeAt(0) || Tl === i.charCodeAt(0)) && Ml === i.charCodeAt(1) && Il.test(i.slice(2)) ? e.push({
        type: "unicode-range",
        sourceIndex: u,
        sourceEndIndex: r,
        value: i
      }) : e.push({
        type: "word",
        sourceIndex: u,
        sourceEndIndex: r,
        value: i
      }), u = r;
    }
  for (u = x.length - 1; u; u -= 1)
    x[u].unclosed = !0, x[u].sourceEndIndex = t.length;
  return x[0].nodes;
}, $l = function s(e, t, r) {
  var n, l, i, c;
  for (n = 0, l = e.length; n < l; n += 1)
    i = e[n], r || (c = t(i, n, e)), c !== !1 && i.type === "function" && Array.isArray(i.nodes) && s(i.nodes, t, r), r && t(i, n, e);
};
function _i(s, e) {
  var t = s.type, r = s.value, n, l;
  return e && (l = e(s)) !== void 0 ? l : t === "word" || t === "space" ? r : t === "string" ? (n = s.quote || "", n + r + (s.unclosed ? "" : n)) : t === "comment" ? "/*" + r + (s.unclosed ? "" : "*/") : t === "div" ? (s.before || "") + r + (s.after || "") : Array.isArray(s.nodes) ? (n = _a(s.nodes, e), t !== "function" ? n : r + "(" + (s.before || "") + n + (s.after || "") + (s.unclosed ? "" : ")")) : r;
}
function _a(s, e) {
  var t, r;
  if (Array.isArray(s)) {
    for (t = "", r = s.length - 1; ~r; r -= 1)
      t = _i(s[r], e) + t;
    return t;
  }
  return _i(s, e);
}
var Dl = _a, Ar, Si;
function Nl() {
  if (Si)
    return Ar;
  Si = 1;
  var s = 45, e = 43, t = 46, r = 101, n = 69;
  function l(i) {
    var c = i.charCodeAt(0), a;
    if (c === e || c === s) {
      if (a = i.charCodeAt(1), a >= 48 && a <= 57)
        return !0;
      var o = i.charCodeAt(2);
      return a === t && o >= 48 && o <= 57;
    }
    return c === t ? (a = i.charCodeAt(1), a >= 48 && a <= 57) : c >= 48 && c <= 57;
  }
  return Ar = function(i) {
    var c = 0, a = i.length, o, f, u;
    if (a === 0 || !l(i))
      return !1;
    for (o = i.charCodeAt(c), (o === e || o === s) && c++; c < a && (o = i.charCodeAt(c), !(o < 48 || o > 57)); )
      c += 1;
    if (o = i.charCodeAt(c), f = i.charCodeAt(c + 1), o === t && f >= 48 && f <= 57)
      for (c += 2; c < a && (o = i.charCodeAt(c), !(o < 48 || o > 57)); )
        c += 1;
    if (o = i.charCodeAt(c), f = i.charCodeAt(c + 1), u = i.charCodeAt(c + 2), (o === r || o === n) && (f >= 48 && f <= 57 || (f === e || f === s) && u >= 48 && u <= 57))
      for (c += f === e || f === s ? 3 : 2; c < a && (o = i.charCodeAt(c), !(o < 48 || o > 57)); )
        c += 1;
    return {
      number: i.slice(0, c),
      unit: i.slice(c)
    };
  }, Ar;
}
var Ll = Rl, Sa = $l, Oa = Dl;
function nt(s) {
  return this instanceof nt ? (this.nodes = Ll(s), this) : new nt(s);
}
nt.prototype.toString = function() {
  return Array.isArray(this.nodes) ? Oa(this.nodes) : "";
};
nt.prototype.walk = function(s, e) {
  return Sa(this.nodes, s, e), this;
};
nt.unit = Nl();
nt.walk = Sa;
nt.stringify = Oa;
var Fl = nt, rr = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(c, a) {
    for (var o in a)
      Object.defineProperty(c, o, {
        enumerable: !0,
        get: a[o]
      });
  }
  e(s, {
    normalizeScreens: function() {
      return t;
    },
    isScreenSortable: function() {
      return r;
    },
    compareScreens: function() {
      return n;
    },
    toScreen: function() {
      return l;
    }
  });
  function t(c, a = !0) {
    return Array.isArray(c) ? c.map((o) => {
      if (a && Array.isArray(o))
        throw new Error("The tuple syntax is not supported for `screens`.");
      if (typeof o == "string")
        return {
          name: o.toString(),
          not: !1,
          values: [
            {
              min: o,
              max: void 0
            }
          ]
        };
      let [f, u] = o;
      return f = f.toString(), typeof u == "string" ? {
        name: f,
        not: !1,
        values: [
          {
            min: u,
            max: void 0
          }
        ]
      } : Array.isArray(u) ? {
        name: f,
        not: !1,
        values: u.map((p) => i(p))
      } : {
        name: f,
        not: !1,
        values: [
          i(u)
        ]
      };
    }) : t(Object.entries(c ?? {}), !1);
  }
  function r(c) {
    return c.values.length !== 1 ? {
      result: !1,
      reason: "multiple-values"
    } : c.values[0].raw !== void 0 ? {
      result: !1,
      reason: "raw-values"
    } : c.values[0].min !== void 0 && c.values[0].max !== void 0 ? {
      result: !1,
      reason: "min-and-max"
    } : {
      result: !0,
      reason: null
    };
  }
  function n(c, a, o) {
    let f = l(a, c), u = l(o, c), p = r(f), _ = r(u);
    if (p.reason === "multiple-values" || _.reason === "multiple-values")
      throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (p.reason === "raw-values" || _.reason === "raw-values")
      throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (p.reason === "min-and-max" || _.reason === "min-and-max")
      throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    let { min: x, max: h } = f.values[0], { min: m, max: C } = u.values[0];
    a.not && ([x, h] = [
      h,
      x
    ]), o.not && ([m, C] = [
      C,
      m
    ]), x = x === void 0 ? x : parseFloat(x), h = h === void 0 ? h : parseFloat(h), m = m === void 0 ? m : parseFloat(m), C = C === void 0 ? C : parseFloat(C);
    let [S, k] = c === "min" ? [
      x,
      m
    ] : [
      C,
      h
    ];
    return S - k;
  }
  function l(c, a) {
    return typeof c == "object" ? c : {
      name: "arbitrary-screen",
      values: [
        {
          [a]: c
        }
      ]
    };
  }
  function i({ "min-width": c, min: a = c, max: o, raw: f } = {}) {
    return {
      min: a,
      max: o,
      raw: f
    };
  }
})(rr);
var nr = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    return t = Array.isArray(t) ? t : [
      t
    ], t.map((r) => {
      let n = r.values.map((l) => l.raw !== void 0 ? l.raw : [
        l.min && `(min-width: ${l.min})`,
        l.max && `(max-width: ${l.max})`
      ].filter(Boolean).join(" and "));
      return r.not ? `not all and ${n}` : n;
    }).join(", ");
  }
})(nr);
var ir = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "toPath", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    if (Array.isArray(t))
      return t;
    let r = t.split("[").length - 1, n = t.split("]").length - 1;
    if (r !== n)
      throw new Error(`Path is invalid. Has unbalanced brackets: ${t}`);
    return t.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
})(ir);
var kt = {}, Tn = {}, ka = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = {
    aliceblue: [
      240,
      248,
      255
    ],
    antiquewhite: [
      250,
      235,
      215
    ],
    aqua: [
      0,
      255,
      255
    ],
    aquamarine: [
      127,
      255,
      212
    ],
    azure: [
      240,
      255,
      255
    ],
    beige: [
      245,
      245,
      220
    ],
    bisque: [
      255,
      228,
      196
    ],
    black: [
      0,
      0,
      0
    ],
    blanchedalmond: [
      255,
      235,
      205
    ],
    blue: [
      0,
      0,
      255
    ],
    blueviolet: [
      138,
      43,
      226
    ],
    brown: [
      165,
      42,
      42
    ],
    burlywood: [
      222,
      184,
      135
    ],
    cadetblue: [
      95,
      158,
      160
    ],
    chartreuse: [
      127,
      255,
      0
    ],
    chocolate: [
      210,
      105,
      30
    ],
    coral: [
      255,
      127,
      80
    ],
    cornflowerblue: [
      100,
      149,
      237
    ],
    cornsilk: [
      255,
      248,
      220
    ],
    crimson: [
      220,
      20,
      60
    ],
    cyan: [
      0,
      255,
      255
    ],
    darkblue: [
      0,
      0,
      139
    ],
    darkcyan: [
      0,
      139,
      139
    ],
    darkgoldenrod: [
      184,
      134,
      11
    ],
    darkgray: [
      169,
      169,
      169
    ],
    darkgreen: [
      0,
      100,
      0
    ],
    darkgrey: [
      169,
      169,
      169
    ],
    darkkhaki: [
      189,
      183,
      107
    ],
    darkmagenta: [
      139,
      0,
      139
    ],
    darkolivegreen: [
      85,
      107,
      47
    ],
    darkorange: [
      255,
      140,
      0
    ],
    darkorchid: [
      153,
      50,
      204
    ],
    darkred: [
      139,
      0,
      0
    ],
    darksalmon: [
      233,
      150,
      122
    ],
    darkseagreen: [
      143,
      188,
      143
    ],
    darkslateblue: [
      72,
      61,
      139
    ],
    darkslategray: [
      47,
      79,
      79
    ],
    darkslategrey: [
      47,
      79,
      79
    ],
    darkturquoise: [
      0,
      206,
      209
    ],
    darkviolet: [
      148,
      0,
      211
    ],
    deeppink: [
      255,
      20,
      147
    ],
    deepskyblue: [
      0,
      191,
      255
    ],
    dimgray: [
      105,
      105,
      105
    ],
    dimgrey: [
      105,
      105,
      105
    ],
    dodgerblue: [
      30,
      144,
      255
    ],
    firebrick: [
      178,
      34,
      34
    ],
    floralwhite: [
      255,
      250,
      240
    ],
    forestgreen: [
      34,
      139,
      34
    ],
    fuchsia: [
      255,
      0,
      255
    ],
    gainsboro: [
      220,
      220,
      220
    ],
    ghostwhite: [
      248,
      248,
      255
    ],
    gold: [
      255,
      215,
      0
    ],
    goldenrod: [
      218,
      165,
      32
    ],
    gray: [
      128,
      128,
      128
    ],
    green: [
      0,
      128,
      0
    ],
    greenyellow: [
      173,
      255,
      47
    ],
    grey: [
      128,
      128,
      128
    ],
    honeydew: [
      240,
      255,
      240
    ],
    hotpink: [
      255,
      105,
      180
    ],
    indianred: [
      205,
      92,
      92
    ],
    indigo: [
      75,
      0,
      130
    ],
    ivory: [
      255,
      255,
      240
    ],
    khaki: [
      240,
      230,
      140
    ],
    lavender: [
      230,
      230,
      250
    ],
    lavenderblush: [
      255,
      240,
      245
    ],
    lawngreen: [
      124,
      252,
      0
    ],
    lemonchiffon: [
      255,
      250,
      205
    ],
    lightblue: [
      173,
      216,
      230
    ],
    lightcoral: [
      240,
      128,
      128
    ],
    lightcyan: [
      224,
      255,
      255
    ],
    lightgoldenrodyellow: [
      250,
      250,
      210
    ],
    lightgray: [
      211,
      211,
      211
    ],
    lightgreen: [
      144,
      238,
      144
    ],
    lightgrey: [
      211,
      211,
      211
    ],
    lightpink: [
      255,
      182,
      193
    ],
    lightsalmon: [
      255,
      160,
      122
    ],
    lightseagreen: [
      32,
      178,
      170
    ],
    lightskyblue: [
      135,
      206,
      250
    ],
    lightslategray: [
      119,
      136,
      153
    ],
    lightslategrey: [
      119,
      136,
      153
    ],
    lightsteelblue: [
      176,
      196,
      222
    ],
    lightyellow: [
      255,
      255,
      224
    ],
    lime: [
      0,
      255,
      0
    ],
    limegreen: [
      50,
      205,
      50
    ],
    linen: [
      250,
      240,
      230
    ],
    magenta: [
      255,
      0,
      255
    ],
    maroon: [
      128,
      0,
      0
    ],
    mediumaquamarine: [
      102,
      205,
      170
    ],
    mediumblue: [
      0,
      0,
      205
    ],
    mediumorchid: [
      186,
      85,
      211
    ],
    mediumpurple: [
      147,
      112,
      219
    ],
    mediumseagreen: [
      60,
      179,
      113
    ],
    mediumslateblue: [
      123,
      104,
      238
    ],
    mediumspringgreen: [
      0,
      250,
      154
    ],
    mediumturquoise: [
      72,
      209,
      204
    ],
    mediumvioletred: [
      199,
      21,
      133
    ],
    midnightblue: [
      25,
      25,
      112
    ],
    mintcream: [
      245,
      255,
      250
    ],
    mistyrose: [
      255,
      228,
      225
    ],
    moccasin: [
      255,
      228,
      181
    ],
    navajowhite: [
      255,
      222,
      173
    ],
    navy: [
      0,
      0,
      128
    ],
    oldlace: [
      253,
      245,
      230
    ],
    olive: [
      128,
      128,
      0
    ],
    olivedrab: [
      107,
      142,
      35
    ],
    orange: [
      255,
      165,
      0
    ],
    orangered: [
      255,
      69,
      0
    ],
    orchid: [
      218,
      112,
      214
    ],
    palegoldenrod: [
      238,
      232,
      170
    ],
    palegreen: [
      152,
      251,
      152
    ],
    paleturquoise: [
      175,
      238,
      238
    ],
    palevioletred: [
      219,
      112,
      147
    ],
    papayawhip: [
      255,
      239,
      213
    ],
    peachpuff: [
      255,
      218,
      185
    ],
    peru: [
      205,
      133,
      63
    ],
    pink: [
      255,
      192,
      203
    ],
    plum: [
      221,
      160,
      221
    ],
    powderblue: [
      176,
      224,
      230
    ],
    purple: [
      128,
      0,
      128
    ],
    rebeccapurple: [
      102,
      51,
      153
    ],
    red: [
      255,
      0,
      0
    ],
    rosybrown: [
      188,
      143,
      143
    ],
    royalblue: [
      65,
      105,
      225
    ],
    saddlebrown: [
      139,
      69,
      19
    ],
    salmon: [
      250,
      128,
      114
    ],
    sandybrown: [
      244,
      164,
      96
    ],
    seagreen: [
      46,
      139,
      87
    ],
    seashell: [
      255,
      245,
      238
    ],
    sienna: [
      160,
      82,
      45
    ],
    silver: [
      192,
      192,
      192
    ],
    skyblue: [
      135,
      206,
      235
    ],
    slateblue: [
      106,
      90,
      205
    ],
    slategray: [
      112,
      128,
      144
    ],
    slategrey: [
      112,
      128,
      144
    ],
    snow: [
      255,
      250,
      250
    ],
    springgreen: [
      0,
      255,
      127
    ],
    steelblue: [
      70,
      130,
      180
    ],
    tan: [
      210,
      180,
      140
    ],
    teal: [
      0,
      128,
      128
    ],
    thistle: [
      216,
      191,
      216
    ],
    tomato: [
      255,
      99,
      71
    ],
    turquoise: [
      64,
      224,
      208
    ],
    violet: [
      238,
      130,
      238
    ],
    wheat: [
      245,
      222,
      179
    ],
    white: [
      255,
      255,
      255
    ],
    whitesmoke: [
      245,
      245,
      245
    ],
    yellow: [
      255,
      255,
      0
    ],
    yellowgreen: [
      154,
      205,
      50
    ]
  };
})(ka);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(x, h) {
    for (var m in h)
      Object.defineProperty(x, m, {
        enumerable: !0,
        get: h[m]
      });
  }
  e(s, {
    parseColor: function() {
      return p;
    },
    formatColor: function() {
      return _;
    }
  });
  const t = /* @__PURE__ */ r(ka);
  function r(x) {
    return x && x.__esModule ? x : {
      default: x
    };
  }
  let n = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, l = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, i = /(?:\d+|\d*\.\d+)%?/, c = /(?:\s*,\s*|\s+)/, a = /\s*[,/]\s*/, o = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, f = new RegExp(`^(rgba?)\\(\\s*(${i.source}|${o.source})(?:${c.source}(${i.source}|${o.source}))?(?:${c.source}(${i.source}|${o.source}))?(?:${a.source}(${i.source}|${o.source}))?\\s*\\)$`), u = new RegExp(`^(hsla?)\\(\\s*((?:${i.source})(?:deg|rad|grad|turn)?|${o.source})(?:${c.source}(${i.source}|${o.source}))?(?:${c.source}(${i.source}|${o.source}))?(?:${a.source}(${i.source}|${o.source}))?\\s*\\)$`);
  function p(x, { loose: h = !1 } = {}) {
    var m, C;
    if (typeof x != "string")
      return null;
    if (x = x.trim(), x === "transparent")
      return {
        mode: "rgb",
        color: [
          "0",
          "0",
          "0"
        ],
        alpha: "0"
      };
    if (x in t.default)
      return {
        mode: "rgb",
        color: t.default[x].map((M) => M.toString())
      };
    let S = x.replace(l, (M, D, P, b, A) => [
      "#",
      D,
      D,
      P,
      P,
      b,
      b,
      A ? A + A : ""
    ].join("")).match(n);
    if (S !== null)
      return {
        mode: "rgb",
        color: [
          parseInt(S[1], 16),
          parseInt(S[2], 16),
          parseInt(S[3], 16)
        ].map((M) => M.toString()),
        alpha: S[4] ? (parseInt(S[4], 16) / 255).toString() : void 0
      };
    var k;
    let O = (k = x.match(f)) !== null && k !== void 0 ? k : x.match(u);
    if (O === null)
      return null;
    let E = [
      O[2],
      O[3],
      O[4]
    ].filter(Boolean).map((M) => M.toString());
    return E.length === 2 && E[0].startsWith("var(") ? {
      mode: O[1],
      color: [
        E[0]
      ],
      alpha: E[1]
    } : !h && E.length !== 3 || E.length < 3 && !E.some((M) => /^var\(.*?\)$/.test(M)) ? null : {
      mode: O[1],
      color: E,
      alpha: (m = O[5]) === null || m === void 0 || (C = m.toString) === null || C === void 0 ? void 0 : C.call(m)
    };
  }
  function _({ mode: x, color: h, alpha: m }) {
    let C = m !== void 0;
    return x === "rgba" || x === "hsla" ? `${x}(${h.join(", ")}${C ? `, ${m}` : ""})` : `${x}(${h.join(" ")}${C ? ` / ${m}` : ""})`;
  }
})(Tn);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(l, i) {
    for (var c in i)
      Object.defineProperty(l, c, {
        enumerable: !0,
        get: i[c]
      });
  }
  e(s, {
    withAlphaValue: function() {
      return r;
    },
    default: function() {
      return n;
    }
  });
  const t = Tn;
  function r(l, i, c) {
    if (typeof l == "function")
      return l({
        opacityValue: i
      });
    let a = (0, t.parseColor)(l, {
      loose: !0
    });
    return a === null ? c : (0, t.formatColor)({
      ...a,
      alpha: i
    });
  }
  function n({ color: l, property: i, variable: c }) {
    let a = [].concat(i);
    if (typeof l == "function")
      return {
        [c]: "1",
        ...Object.fromEntries(a.map((f) => [
          f,
          l({
            opacityVariable: c,
            opacityValue: `var(${c})`
          })
        ]))
      };
    const o = (0, t.parseColor)(l);
    return o === null ? Object.fromEntries(a.map((f) => [
      f,
      l
    ])) : o.alpha !== void 0 ? Object.fromEntries(a.map((f) => [
      f,
      l
    ])) : {
      [c]: "1",
      ...Object.fromEntries(a.map((f) => [
        f,
        (0, t.formatColor)({
          ...o,
          alpha: `var(${c})`
        })
      ]))
    };
  }
})(kt);
var At = {}, ar = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    return t.replace(/\\,/g, "\\2c ");
  }
})(ar);
var Ct = {}, Mn = {}, ot = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "splitAtTopLevelOnly", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t, r) {
    let n = [], l = [], i = 0, c = !1;
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      n.length === 0 && o === r[0] && !c && (r.length === 1 || t.slice(a, a + r.length) === r) && (l.push(t.slice(i, a)), i = a + r.length), c = c ? !1 : o === "\\", o === "(" || o === "[" || o === "{" ? n.push(o) : (o === ")" && n[n.length - 1] === "(" || o === "]" && n[n.length - 1] === "[" || o === "}" && n[n.length - 1] === "{") && n.pop();
    }
    return l.push(t.slice(i)), l;
  }
})(ot);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(a, o) {
    for (var f in o)
      Object.defineProperty(a, f, {
        enumerable: !0,
        get: o[f]
      });
  }
  e(s, {
    parseBoxShadowValue: function() {
      return i;
    },
    formatBoxShadowValue: function() {
      return c;
    }
  });
  const t = ot;
  let r = /* @__PURE__ */ new Set([
    "inset",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]), n = /\ +(?![^(]*\))/g, l = /^-?(\d+|\.\d+)(.*?)$/g;
  function i(a) {
    return (0, t.splitAtTopLevelOnly)(a, ",").map((f) => {
      let u = f.trim(), p = {
        raw: u
      }, _ = u.split(n), x = /* @__PURE__ */ new Set();
      for (let h of _)
        l.lastIndex = 0, !x.has("KEYWORD") && r.has(h) ? (p.keyword = h, x.add("KEYWORD")) : l.test(h) ? x.has("X") ? x.has("Y") ? x.has("BLUR") ? x.has("SPREAD") || (p.spread = h, x.add("SPREAD")) : (p.blur = h, x.add("BLUR")) : (p.y = h, x.add("Y")) : (p.x = h, x.add("X")) : p.color ? (p.unknown || (p.unknown = []), p.unknown.push(h)) : p.color = h;
      return p.valid = p.x !== void 0 && p.y !== void 0, p;
    });
  }
  function c(a) {
    return a.map((o) => o.valid ? [
      o.keyword,
      o.x,
      o.y,
      o.blur,
      o.spread,
      o.color
    ].filter(Boolean).join(" ") : o.raw).join(", ");
  }
})(Mn);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(y, R) {
    for (var F in R)
      Object.defineProperty(y, F, {
        enumerable: !0,
        get: R[F]
      });
  }
  e(s, {
    normalize: function() {
      return a;
    },
    normalizeAttributeSelectors: function() {
      return o;
    },
    url: function() {
      return u;
    },
    number: function() {
      return p;
    },
    percentage: function() {
      return _;
    },
    length: function() {
      return m;
    },
    lineWidth: function() {
      return S;
    },
    shadow: function() {
      return k;
    },
    color: function() {
      return O;
    },
    image: function() {
      return E;
    },
    gradient: function() {
      return D;
    },
    position: function() {
      return b;
    },
    familyName: function() {
      return A;
    },
    genericName: function() {
      return T;
    },
    absoluteSize: function() {
      return d;
    },
    relativeSize: function() {
      return v;
    }
  });
  const t = Tn, r = Mn, n = ot;
  let l = [
    "min",
    "max",
    "clamp",
    "calc"
  ];
  function i(y) {
    return l.some((R) => new RegExp(`^${R}\\(.*\\)`).test(y));
  }
  const c = /* @__PURE__ */ new Set([
    // Concrete properties
    "scroll-timeline-name",
    "timeline-scope",
    "view-timeline-name",
    "font-palette",
    "anchor-name",
    "anchor-scope",
    "position-anchor",
    "position-try-options",
    // Shorthand properties
    "scroll-timeline",
    "animation-timeline",
    "view-timeline",
    "position-try"
  ]);
  function a(y, R = null, F = !0) {
    let $ = R && c.has(R.property);
    return y.startsWith("--") && !$ ? `var(${y})` : y.includes("url(") ? y.split(/(url\(.*?\))/g).filter(Boolean).map((z) => /^url\(.*?\)$/.test(z) ? z : a(z, R, !1)).join("") : (y = y.replace(/([^\\])_+/g, (z, j) => j + " ".repeat(z.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), F && (y = y.trim()), y = f(y), y);
  }
  function o(y) {
    return y.includes("=") && (y = y.replace(/(=.*)/g, (R, F) => {
      if (F[1] === "'" || F[1] === '"')
        return F;
      if (F.length > 2) {
        let $ = F[F.length - 1];
        if (F[F.length - 2] === " " && ($ === "i" || $ === "I" || $ === "s" || $ === "S"))
          return `="${F.slice(1, -2)}" ${F[F.length - 1]}`;
      }
      return `="${F.slice(1)}"`;
    })), y;
  }
  function f(y) {
    let R = [
      "theme"
    ], F = [
      "min-content",
      "max-content",
      "fit-content",
      // Env
      "safe-area-inset-top",
      "safe-area-inset-right",
      "safe-area-inset-bottom",
      "safe-area-inset-left",
      "titlebar-area-x",
      "titlebar-area-y",
      "titlebar-area-width",
      "titlebar-area-height",
      "keyboard-inset-top",
      "keyboard-inset-right",
      "keyboard-inset-bottom",
      "keyboard-inset-left",
      "keyboard-inset-width",
      "keyboard-inset-height",
      "radial-gradient",
      "linear-gradient",
      "conic-gradient",
      "repeating-radial-gradient",
      "repeating-linear-gradient",
      "repeating-conic-gradient"
    ];
    return y.replace(/(calc|min|max|clamp)\(.+\)/g, ($) => {
      let z = "";
      function j() {
        let W = z.trimEnd();
        return W[W.length - 1];
      }
      for (let W = 0; W < $.length; W++) {
        let I = function(w) {
          return w.split("").every((L, B) => $[W + B] === L);
        }, G = function(w) {
          let L = 1 / 0;
          for (let H of w) {
            let Y = $.indexOf(H, W);
            Y !== -1 && Y < L && (L = Y);
          }
          let B = $.slice(W, L);
          return W += B.length - 1, B;
        }, re = $[W];
        if (I("var"))
          z += G([
            ")",
            ","
          ]);
        else if (F.some((w) => I(w))) {
          let w = F.find((L) => I(L));
          z += w, W += w.length - 1;
        } else
          R.some((w) => I(w)) ? z += G([
            ")"
          ]) : I("[") ? z += G([
            "]"
          ]) : [
            "+",
            "-",
            "*",
            "/"
          ].includes(re) && ![
            "(",
            "+",
            "-",
            "*",
            "/",
            ","
          ].includes(j()) ? z += ` ${re} ` : z += re;
      }
      return z.replace(/\s+/g, " ");
    });
  }
  function u(y) {
    return y.startsWith("url(");
  }
  function p(y) {
    return !isNaN(Number(y)) || i(y);
  }
  function _(y) {
    return y.endsWith("%") && p(y.slice(0, -1)) || i(y);
  }
  let h = `(?:${[
    "cm",
    "mm",
    "Q",
    "in",
    "pc",
    "pt",
    "px",
    "em",
    "ex",
    "ch",
    "rem",
    "lh",
    "rlh",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "vb",
    "vi",
    "svw",
    "svh",
    "lvw",
    "lvh",
    "dvw",
    "dvh",
    "cqw",
    "cqh",
    "cqi",
    "cqb",
    "cqmin",
    "cqmax"
  ].join("|")})`;
  function m(y) {
    return y === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${h}$`).test(y) || i(y);
  }
  let C = /* @__PURE__ */ new Set([
    "thin",
    "medium",
    "thick"
  ]);
  function S(y) {
    return C.has(y);
  }
  function k(y) {
    let R = (0, r.parseBoxShadowValue)(a(y));
    for (let F of R)
      if (!F.valid)
        return !1;
    return !0;
  }
  function O(y) {
    let R = 0;
    return (0, n.splitAtTopLevelOnly)(y, "_").every(($) => ($ = a($), $.startsWith("var(") ? !0 : (0, t.parseColor)($, {
      loose: !0
    }) !== null ? (R++, !0) : !1)) ? R > 0 : !1;
  }
  function E(y) {
    let R = 0;
    return (0, n.splitAtTopLevelOnly)(y, ",").every(($) => ($ = a($), $.startsWith("var(") ? !0 : u($) || D($) || [
      "element(",
      "image(",
      "cross-fade(",
      "image-set("
    ].some((z) => $.startsWith(z)) ? (R++, !0) : !1)) ? R > 0 : !1;
  }
  let M = /* @__PURE__ */ new Set([
    "conic-gradient",
    "linear-gradient",
    "radial-gradient",
    "repeating-conic-gradient",
    "repeating-linear-gradient",
    "repeating-radial-gradient"
  ]);
  function D(y) {
    y = a(y);
    for (let R of M)
      if (y.startsWith(`${R}(`))
        return !0;
    return !1;
  }
  let P = /* @__PURE__ */ new Set([
    "center",
    "top",
    "right",
    "bottom",
    "left"
  ]);
  function b(y) {
    let R = 0;
    return (0, n.splitAtTopLevelOnly)(y, "_").every(($) => ($ = a($), $.startsWith("var(") ? !0 : P.has($) || m($) || _($) ? (R++, !0) : !1)) ? R > 0 : !1;
  }
  function A(y) {
    let R = 0;
    return (0, n.splitAtTopLevelOnly)(y, ",").every(($) => ($ = a($), $.startsWith("var(") ? !0 : $.includes(" ") && !/(['"])([^"']+)\1/g.test($) || /^\d/g.test($) ? !1 : (R++, !0))) ? R > 0 : !1;
  }
  let N = /* @__PURE__ */ new Set([
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
    "ui-serif",
    "ui-sans-serif",
    "ui-monospace",
    "ui-rounded",
    "math",
    "emoji",
    "fangsong"
  ]);
  function T(y) {
    return N.has(y);
  }
  let V = /* @__PURE__ */ new Set([
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "xx-large",
    "xxx-large"
  ]);
  function d(y) {
    return V.has(y);
  }
  let g = /* @__PURE__ */ new Set([
    "larger",
    "smaller"
  ]);
  function v(y) {
    return g.has(y);
  }
})(Ct);
var sr = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    if (t = `${t}`, t === "0")
      return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t))
      return t.replace(/^[+-]?/, (n) => n === "-" ? "" : "-");
    let r = [
      "var",
      "calc",
      "min",
      "max",
      "clamp"
    ];
    for (const n of r)
      if (t.includes(`${n}(`))
        return `calc(${t} * -1)`;
  }
})(sr);
var Aa = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "backgroundSize", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  const e = Ct, t = ot;
  function r(n) {
    let l = [
      "cover",
      "contain"
    ];
    return (0, t.splitAtTopLevelOnly)(n, ",").every((i) => {
      let c = (0, t.splitAtTopLevelOnly)(i, "_").filter(Boolean);
      return c.length === 1 && l.includes(c[0]) ? !0 : c.length !== 1 && c.length !== 2 ? !1 : c.every((a) => (0, e.length)(a) || (0, e.percentage)(a) || a === "auto");
    });
  }
})(Aa);
var it = {}, In = { exports: {} }, we = String, Ca = function() {
  return { isColorSupported: !1, reset: we, bold: we, dim: we, italic: we, underline: we, inverse: we, hidden: we, strikethrough: we, black: we, red: we, green: we, yellow: we, blue: we, magenta: we, cyan: we, white: we, gray: we, bgBlack: we, bgRed: we, bgGreen: we, bgYellow: we, bgBlue: we, bgMagenta: we, bgCyan: we, bgWhite: we, blackBright: we, redBright: we, greenBright: we, yellowBright: we, blueBright: we, magentaBright: we, cyanBright: we, whiteBright: we, bgBlackBright: we, bgRedBright: we, bgGreenBright: we, bgYellowBright: we, bgBlueBright: we, bgMagentaBright: we, bgCyanBright: we, bgWhiteBright: we };
};
In.exports = Ca();
In.exports.createColors = Ca;
var Ea = In.exports, et = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(a, o) {
    for (var f in o)
      Object.defineProperty(a, f, {
        enumerable: !0,
        get: o[f]
      });
  }
  e(s, {
    dim: function() {
      return i;
    },
    default: function() {
      return c;
    }
  });
  const t = /* @__PURE__ */ r(Ea);
  function r(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  let n = /* @__PURE__ */ new Set();
  function l(a, o, f) {
    typeof process < "u" && process.env.JEST_WORKER_ID || f && n.has(f) || (f && n.add(f), console.warn(""), o.forEach((u) => console.warn(a, "-", u)));
  }
  function i(a) {
    return t.default.dim(a);
  }
  const c = {
    info(a, o) {
      l(t.default.bold(t.default.cyan("info")), ...Array.isArray(a) ? [
        a
      ] : [
        o,
        a
      ]);
    },
    warn(a, o) {
      l(t.default.bold(t.default.yellow("warn")), ...Array.isArray(a) ? [
        a
      ] : [
        o,
        a
      ]);
    },
    risk(a, o) {
      l(t.default.bold(t.default.magenta("risk")), ...Array.isArray(a) ? [
        a
      ] : [
        o,
        a
      ]);
    }
  };
})(et);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(u, p) {
    for (var _ in p)
      Object.defineProperty(u, _, {
        enumerable: !0,
        get: p[_]
      });
  }
  e(s, {
    flagEnabled: function() {
      return c;
    },
    issueFlagNotices: function() {
      return o;
    },
    default: function() {
      return f;
    }
  });
  const t = /* @__PURE__ */ n(Ea), r = /* @__PURE__ */ n(et);
  function n(u) {
    return u && u.__esModule ? u : {
      default: u
    };
  }
  let l = {
    optimizeUniversalDefaults: !1,
    generalizedModifiers: !0,
    disableColorOpacityUtilitiesByDefault: !1,
    relativeContentPathsByDefault: !1
  }, i = {
    future: [
      "hoverOnlyWhenSupported",
      "respectDefaultRingColorOpacity",
      "disableColorOpacityUtilitiesByDefault",
      "relativeContentPathsByDefault"
    ],
    experimental: [
      "optimizeUniversalDefaults",
      "generalizedModifiers"
    ]
  };
  function c(u, p) {
    if (i.future.includes(p)) {
      var _, x, h;
      return u.future === "all" || ((h = (x = u == null || (_ = u.future) === null || _ === void 0 ? void 0 : _[p]) !== null && x !== void 0 ? x : l[p]) !== null && h !== void 0 ? h : !1);
    }
    if (i.experimental.includes(p)) {
      var m, C, S;
      return u.experimental === "all" || ((S = (C = u == null || (m = u.experimental) === null || m === void 0 ? void 0 : m[p]) !== null && C !== void 0 ? C : l[p]) !== null && S !== void 0 ? S : !1);
    }
    return !1;
  }
  function a(u) {
    if (u.experimental === "all")
      return i.experimental;
    var p;
    return Object.keys((p = u == null ? void 0 : u.experimental) !== null && p !== void 0 ? p : {}).filter((_) => i.experimental.includes(_) && u.experimental[_]);
  }
  function o(u) {
    if (process.env.JEST_WORKER_ID === void 0 && a(u).length > 0) {
      let p = a(u).map((_) => t.default.yellow(_)).join(", ");
      r.default.warn("experimental-flags-enabled", [
        `You have enabled experimental features: ${p}`,
        "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
      ]);
    }
  }
  const f = i;
})(it);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(b, A) {
    for (var N in A)
      Object.defineProperty(b, N, {
        enumerable: !0,
        get: A[N]
      });
  }
  e(s, {
    updateAllClasses: function() {
      return o;
    },
    asValue: function() {
      return p;
    },
    parseColorFormat: function() {
      return h;
    },
    asColor: function() {
      return C;
    },
    asLookupValue: function() {
      return S;
    },
    typeMap: function() {
      return O;
    },
    coerceValue: function() {
      return D;
    },
    getMatchingTypes: function() {
      return P;
    }
  });
  const t = /* @__PURE__ */ a(ar), r = kt, n = Ct, l = /* @__PURE__ */ a(sr), i = Aa, c = it;
  function a(b) {
    return b && b.__esModule ? b : {
      default: b
    };
  }
  function o(b, A) {
    b.walkClasses((N) => {
      N.value = A(N.value), N.raws && N.raws.value && (N.raws.value = (0, t.default)(N.raws.value));
    });
  }
  function f(b, A) {
    if (!_(b))
      return;
    let N = b.slice(1, -1);
    if (A(N))
      return (0, n.normalize)(N);
  }
  function u(b, A = {}, N) {
    let T = A[b];
    if (T !== void 0)
      return (0, l.default)(T);
    if (_(b)) {
      let V = f(b, N);
      return V === void 0 ? void 0 : (0, l.default)(V);
    }
  }
  function p(b, A = {}, { validate: N = () => !0 } = {}) {
    var T;
    let V = (T = A.values) === null || T === void 0 ? void 0 : T[b];
    return V !== void 0 ? V : A.supportsNegativeValues && b.startsWith("-") ? u(b.slice(1), A.values, N) : f(b, N);
  }
  function _(b) {
    return b.startsWith("[") && b.endsWith("]");
  }
  function x(b) {
    let A = b.lastIndexOf("/"), N = b.lastIndexOf("[", A), T = b.indexOf("]", A);
    return b[A - 1] === "]" || b[A + 1] === "[" || N !== -1 && T !== -1 && N < A && A < T && (A = b.lastIndexOf("/", N)), A === -1 || A === b.length - 1 ? [
      b,
      void 0
    ] : _(b) && !b.includes("]/[") ? [
      b,
      void 0
    ] : [
      b.slice(0, A),
      b.slice(A + 1)
    ];
  }
  function h(b) {
    if (typeof b == "string" && b.includes("<alpha-value>")) {
      let A = b;
      return ({ opacityValue: N = 1 }) => A.replace(/<alpha-value>/g, N);
    }
    return b;
  }
  function m(b) {
    return (0, n.normalize)(b.slice(1, -1));
  }
  function C(b, A = {}, { tailwindConfig: N = {} } = {}) {
    var T;
    if (((T = A.values) === null || T === void 0 ? void 0 : T[b]) !== void 0) {
      var V;
      return h((V = A.values) === null || V === void 0 ? void 0 : V[b]);
    }
    let [d, g] = x(b);
    if (g !== void 0) {
      var v, y, R, F;
      let $ = (F = (v = A.values) === null || v === void 0 ? void 0 : v[d]) !== null && F !== void 0 ? F : _(d) ? d.slice(1, -1) : void 0;
      return $ === void 0 ? void 0 : ($ = h($), _(g) ? (0, r.withAlphaValue)($, m(g)) : ((y = N.theme) === null || y === void 0 || (R = y.opacity) === null || R === void 0 ? void 0 : R[g]) === void 0 ? void 0 : (0, r.withAlphaValue)($, N.theme.opacity[g]));
    }
    return p(b, A, {
      validate: n.color
    });
  }
  function S(b, A = {}) {
    var N;
    return (N = A.values) === null || N === void 0 ? void 0 : N[b];
  }
  function k(b) {
    return (A, N) => p(A, N, {
      validate: b
    });
  }
  let O = {
    any: p,
    color: C,
    url: k(n.url),
    image: k(n.image),
    length: k(n.length),
    percentage: k(n.percentage),
    position: k(n.position),
    lookup: S,
    "generic-name": k(n.genericName),
    "family-name": k(n.familyName),
    number: k(n.number),
    "line-width": k(n.lineWidth),
    "absolute-size": k(n.absoluteSize),
    "relative-size": k(n.relativeSize),
    shadow: k(n.shadow),
    size: k(i.backgroundSize)
  }, E = Object.keys(O);
  function M(b, A) {
    let N = b.indexOf(A);
    return N === -1 ? [
      void 0,
      b
    ] : [
      b.slice(0, N),
      b.slice(N + 1)
    ];
  }
  function D(b, A, N, T) {
    if (N.values && A in N.values)
      for (let { type: d } of b ?? []) {
        let g = O[d](A, N, {
          tailwindConfig: T
        });
        if (g !== void 0)
          return [
            g,
            d,
            null
          ];
      }
    if (_(A)) {
      let d = A.slice(1, -1), [g, v] = M(d, ":");
      if (!/^[\w-_]+$/g.test(g))
        v = d;
      else if (g !== void 0 && !E.includes(g))
        return [];
      if (v.length > 0 && E.includes(g))
        return [
          p(`[${v}]`, N),
          g,
          null
        ];
    }
    let V = P(b, A, N, T);
    for (let d of V)
      return d;
    return [];
  }
  function* P(b, A, N, T) {
    let V = (0, c.flagEnabled)(T, "generalizedModifiers"), [d, g] = x(A);
    if (V && N.modifiers != null && (N.modifiers === "any" || typeof N.modifiers == "object" && (g && _(g) || g in N.modifiers)) || (d = A, g = void 0), g !== void 0 && d === "" && (d = "DEFAULT"), g !== void 0 && typeof N.modifiers == "object") {
      var y, R;
      let F = (R = (y = N.modifiers) === null || y === void 0 ? void 0 : y[g]) !== null && R !== void 0 ? R : null;
      F !== null ? g = F : _(g) && (g = m(g));
    }
    for (let { type: F } of b ?? []) {
      let $ = O[F](d, N, {
        tailwindConfig: T
      });
      $ !== void 0 && (yield [
        $,
        F,
        g ?? null
      ]);
    }
  }
})(At);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return P;
    }
  });
  const e = /* @__PURE__ */ u(ba), t = /* @__PURE__ */ u(El), r = /* @__PURE__ */ u(Ot), n = /* @__PURE__ */ u(Fl), l = rr, i = /* @__PURE__ */ u(nr), c = ir, a = kt, o = At, f = /* @__PURE__ */ u(et);
  function u(b) {
    return b && b.__esModule ? b : {
      default: b
    };
  }
  function p(b) {
    return typeof b == "object" && b !== null;
  }
  function _(b, A) {
    let N = (0, c.toPath)(A);
    do
      if (N.pop(), (0, e.default)(b, N) !== void 0)
        break;
    while (N.length);
    return N.length ? N : void 0;
  }
  function x(b) {
    return typeof b == "string" ? b : b.reduce((A, N, T) => N.includes(".") ? `${A}[${N}]` : T === 0 ? N : `${A}.${N}`, "");
  }
  function h(b) {
    return b.map((A) => `'${A}'`).join(", ");
  }
  function m(b) {
    return h(Object.keys(b));
  }
  function C(b, A, N, T = {}) {
    const V = Array.isArray(A) ? x(A) : A.replace(/^['"]+|['"]+$/g, ""), d = Array.isArray(A) ? A : (0, c.toPath)(V), g = (0, e.default)(b.theme, d, N);
    if (g === void 0) {
      let y = `'${V}' does not exist in your theme config.`;
      const R = d.slice(0, -1), F = (0, e.default)(b.theme, R);
      if (p(F)) {
        const $ = Object.keys(F).filter((j) => C(b, [
          ...R,
          j
        ]).isValid), z = (0, t.default)(d[d.length - 1], $);
        z ? y += ` Did you mean '${x([
          ...R,
          z
        ])}'?` : $.length > 0 && (y += ` '${x(R)}' has the following valid keys: ${h($)}`);
      } else {
        const $ = _(b.theme, V);
        if ($) {
          const z = (0, e.default)(b.theme, $);
          p(z) ? y += ` '${x($)}' has the following keys: ${m(z)}` : y += ` '${x($)}' is not an object.`;
        } else
          y += ` Your theme has the following top-level keys: ${m(b.theme)}`;
      }
      return {
        isValid: !1,
        error: y
      };
    }
    if (!(typeof g == "string" || typeof g == "number" || typeof g == "function" || g instanceof String || g instanceof Number || Array.isArray(g))) {
      let y = `'${V}' was found but does not resolve to a string.`;
      if (p(g)) {
        let R = Object.keys(g).filter((F) => C(b, [
          ...d,
          F
        ]).isValid);
        R.length && (y += ` Did you mean something like '${x([
          ...d,
          R[0]
        ])}'?`);
      }
      return {
        isValid: !1,
        error: y
      };
    }
    const [v] = d;
    return {
      isValid: !0,
      value: (0, r.default)(v)(g, T)
    };
  }
  function S(b, A, N) {
    A = A.map((V) => k(b, V, N));
    let T = [
      ""
    ];
    for (let V of A)
      V.type === "div" && V.value === "," ? T.push("") : T[T.length - 1] += n.default.stringify(V);
    return T;
  }
  function k(b, A, N) {
    if (A.type === "function" && N[A.value] !== void 0) {
      let T = S(b, A.nodes, N);
      A.type = "word", A.value = N[A.value](b, ...T);
    }
    return A;
  }
  function O(b, A, N) {
    return Object.keys(N).some((V) => A.includes(`${V}(`)) ? (0, n.default)(A).walk((V) => {
      k(b, V, N);
    }).toString() : A;
  }
  let E = {
    atrule: "params",
    decl: "value"
  };
  function* M(b) {
    b = b.replace(/^['"]+|['"]+$/g, "");
    let A = b.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), N;
    yield [
      b,
      void 0
    ], A && (b = A[1], N = A[2], yield [
      b,
      N
    ]);
  }
  function D(b, A, N) {
    const T = Array.from(M(A)).map(([d, g]) => Object.assign(C(b, d, N, {
      opacityValue: g
    }), {
      resolvedPath: d,
      alpha: g
    }));
    var V;
    return (V = T.find((d) => d.isValid)) !== null && V !== void 0 ? V : T[0];
  }
  function P(b) {
    let A = b.tailwindConfig, N = {
      theme: (T, V, ...d) => {
        let { isValid: g, value: v, error: y, alpha: R } = D(A, V, d.length ? d : void 0);
        if (!g) {
          var F;
          let j = T.parent, W = (F = j == null ? void 0 : j.raws.tailwind) === null || F === void 0 ? void 0 : F.candidate;
          if (j && W !== void 0) {
            b.markInvalidUtilityNode(j), j.remove(), f.default.warn("invalid-theme-key-in-class", [
              `The utility \`${W}\` contains an invalid theme value and was not generated.`
            ]);
            return;
          }
          throw T.error(y);
        }
        let $ = (0, o.parseColorFormat)(v);
        return (R !== void 0 || $ !== void 0 && typeof $ == "function") && (R === void 0 && (R = 1), v = (0, a.withAlphaValue)($, R, $)), v;
      },
      screen: (T, V) => {
        V = V.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
        let g = (0, l.normalizeScreens)(A.theme.screens).find(({ name: v }) => v === V);
        if (!g)
          throw T.error(`The '${V}' screen does not exist in your theme.`);
        return (0, i.default)(g);
      }
    };
    return (T) => {
      T.walk((V) => {
        let d = E[V.type];
        d !== void 0 && (V[d] = O(V, V[d], N));
      });
    };
  }
})(ya);
const zl = /* @__PURE__ */ Qe(ya);
var Pa = {}, Jr = { exports: {} }, Kr = { exports: {} }, Xr = { exports: {} }, Zr = { exports: {} }, en = { exports: {} }, tn = { exports: {} }, Be = {}, rn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = n;
  function t(l) {
    for (var i = l.toLowerCase(), c = "", a = !1, o = 0; o < 6 && i[o] !== void 0; o++) {
      var f = i.charCodeAt(o), u = f >= 97 && f <= 102 || f >= 48 && f <= 57;
      if (a = f === 32, !u)
        break;
      c += i[o];
    }
    if (c.length !== 0) {
      var p = parseInt(c, 16), _ = p >= 55296 && p <= 57343;
      return _ || p === 0 || p > 1114111 ? ["�", c.length + (a ? 1 : 0)] : [String.fromCodePoint(p), c.length + (a ? 1 : 0)];
    }
  }
  var r = /\\/;
  function n(l) {
    var i = r.test(l);
    if (!i)
      return l;
    for (var c = "", a = 0; a < l.length; a++) {
      if (l[a] === "\\") {
        var o = t(l.slice(a + 1, a + 7));
        if (o !== void 0) {
          c += o[0], a += o[1];
          continue;
        }
        if (l[a + 1] === "\\") {
          c += "\\", a++;
          continue;
        }
        l.length === a + 1 && (c += l[a]);
        continue;
      }
      c += l[a];
    }
    return c;
  }
  s.exports = e.default;
})(rn, rn.exports);
var Rn = rn.exports, nn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = t;
  function t(r) {
    for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      l[i - 1] = arguments[i];
    for (; l.length > 0; ) {
      var c = l.shift();
      if (!r[c])
        return;
      r = r[c];
    }
    return r;
  }
  s.exports = e.default;
})(nn, nn.exports);
var Ul = nn.exports, an = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = t;
  function t(r) {
    for (var n = arguments.length, l = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      l[i - 1] = arguments[i];
    for (; l.length > 0; ) {
      var c = l.shift();
      r[c] || (r[c] = {}), r = r[c];
    }
  }
  s.exports = e.default;
})(an, an.exports);
var jl = an.exports, sn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = t;
  function t(r) {
    for (var n = "", l = r.indexOf("/*"), i = 0; l >= 0; ) {
      n = n + r.slice(i, l);
      var c = r.indexOf("*/", l + 2);
      if (c < 0)
        return n;
      i = c + 2, l = r.indexOf("/*", i);
    }
    return n = n + r.slice(i), n;
  }
  s.exports = e.default;
})(sn, sn.exports);
var Vl = sn.exports;
Be.__esModule = !0;
Be.unesc = Be.stripComments = Be.getProp = Be.ensureObject = void 0;
var Wl = or(Rn);
Be.unesc = Wl.default;
var Bl = or(Ul);
Be.getProp = Bl.default;
var ql = or(jl);
Be.ensureObject = ql.default;
var Gl = or(Vl);
Be.stripComments = Gl.default;
function or(s) {
  return s && s.__esModule ? s : { default: s };
}
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = Be;
  function r(c, a) {
    for (var o = 0; o < a.length; o++) {
      var f = a[o];
      f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(c, f.key, f);
    }
  }
  function n(c, a, o) {
    return a && r(c.prototype, a), Object.defineProperty(c, "prototype", { writable: !1 }), c;
  }
  var l = function c(a, o) {
    if (typeof a != "object" || a === null)
      return a;
    var f = new a.constructor();
    for (var u in a)
      if (a.hasOwnProperty(u)) {
        var p = a[u], _ = typeof p;
        u === "parent" && _ === "object" ? o && (f[u] = o) : p instanceof Array ? f[u] = p.map(function(x) {
          return c(x, f);
        }) : f[u] = c(p, f);
      }
    return f;
  }, i = /* @__PURE__ */ function() {
    function c(o) {
      o === void 0 && (o = {}), Object.assign(this, o), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var a = c.prototype;
    return a.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, a.replaceWith = function() {
      if (this.parent) {
        for (var f in arguments)
          this.parent.insertBefore(this, arguments[f]);
        this.remove();
      }
      return this;
    }, a.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, a.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, a.clone = function(f) {
      f === void 0 && (f = {});
      var u = l(this);
      for (var p in f)
        u[p] = f[p];
      return u;
    }, a.appendToPropertyAndEscape = function(f, u, p) {
      this.raws || (this.raws = {});
      var _ = this[f], x = this.raws[f];
      this[f] = _ + u, x || p !== u ? this.raws[f] = (x || _) + p : delete this.raws[f];
    }, a.setPropertyAndEscape = function(f, u, p) {
      this.raws || (this.raws = {}), this[f] = u, this.raws[f] = p;
    }, a.setPropertyWithoutEscape = function(f, u) {
      this[f] = u, this.raws && delete this.raws[f];
    }, a.isAtPosition = function(f, u) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > f || this.source.end.line < f || this.source.start.line === f && this.source.start.column > u || this.source.end.line === f && this.source.end.column < u);
    }, a.stringifyProperty = function(f) {
      return this.raws && this.raws[f] || this[f];
    }, a.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, a.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, n(c, [{
      key: "rawSpaceBefore",
      get: function() {
        var f = this.raws && this.raws.spaces && this.raws.spaces.before;
        return f === void 0 && (f = this.spaces && this.spaces.before), f || "";
      },
      set: function(f) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = f;
      }
    }, {
      key: "rawSpaceAfter",
      get: function() {
        var f = this.raws && this.raws.spaces && this.raws.spaces.after;
        return f === void 0 && (f = this.spaces.after), f || "";
      },
      set: function(f) {
        (0, t.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = f;
      }
    }]), c;
  }();
  e.default = i, s.exports = e.default;
})(tn, tn.exports);
var at = tn.exports, be = {};
be.__esModule = !0;
be.UNIVERSAL = be.TAG = be.STRING = be.SELECTOR = be.ROOT = be.PSEUDO = be.NESTING = be.ID = be.COMMENT = be.COMBINATOR = be.CLASS = be.ATTRIBUTE = void 0;
var Yl = "tag";
be.TAG = Yl;
var Hl = "string";
be.STRING = Hl;
var Ql = "selector";
be.SELECTOR = Ql;
var Jl = "root";
be.ROOT = Jl;
var Kl = "pseudo";
be.PSEUDO = Kl;
var Xl = "nesting";
be.NESTING = Xl;
var Zl = "id";
be.ID = Zl;
var eu = "comment";
be.COMMENT = eu;
var tu = "combinator";
be.COMBINATOR = tu;
var ru = "class";
be.CLASS = ru;
var nu = "attribute";
be.ATTRIBUTE = nu;
var iu = "universal";
be.UNIVERSAL = iu;
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(at), r = l(be);
  function n(h) {
    if (typeof WeakMap != "function")
      return null;
    var m = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
    return (n = function(k) {
      return k ? C : m;
    })(h);
  }
  function l(h, m) {
    if (h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return { default: h };
    var C = n(m);
    if (C && C.has(h))
      return C.get(h);
    var S = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var O in h)
      if (O !== "default" && Object.prototype.hasOwnProperty.call(h, O)) {
        var E = k ? Object.getOwnPropertyDescriptor(h, O) : null;
        E && (E.get || E.set) ? Object.defineProperty(S, O, E) : S[O] = h[O];
      }
    return S.default = h, C && C.set(h, S), S;
  }
  function i(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function c(h, m) {
    var C = typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
    if (C)
      return (C = C.call(h)).next.bind(C);
    if (Array.isArray(h) || (C = a(h)) || m) {
      C && (h = C);
      var S = 0;
      return function() {
        return S >= h.length ? { done: !0 } : { done: !1, value: h[S++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function a(h, m) {
    if (h) {
      if (typeof h == "string")
        return o(h, m);
      var C = Object.prototype.toString.call(h).slice(8, -1);
      if (C === "Object" && h.constructor && (C = h.constructor.name), C === "Map" || C === "Set")
        return Array.from(h);
      if (C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C))
        return o(h, m);
    }
  }
  function o(h, m) {
    (m == null || m > h.length) && (m = h.length);
    for (var C = 0, S = new Array(m); C < m; C++)
      S[C] = h[C];
    return S;
  }
  function f(h, m) {
    for (var C = 0; C < m.length; C++) {
      var S = m[C];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(h, S.key, S);
    }
  }
  function u(h, m, C) {
    return m && f(h.prototype, m), Object.defineProperty(h, "prototype", { writable: !1 }), h;
  }
  function p(h, m) {
    h.prototype = Object.create(m.prototype), h.prototype.constructor = h, _(h, m);
  }
  function _(h, m) {
    return _ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, k) {
      return S.__proto__ = k, S;
    }, _(h, m);
  }
  var x = /* @__PURE__ */ function(h) {
    p(m, h);
    function m(S) {
      var k;
      return k = h.call(this, S) || this, k.nodes || (k.nodes = []), k;
    }
    var C = m.prototype;
    return C.append = function(k) {
      return k.parent = this, this.nodes.push(k), this;
    }, C.prepend = function(k) {
      return k.parent = this, this.nodes.unshift(k), this;
    }, C.at = function(k) {
      return this.nodes[k];
    }, C.index = function(k) {
      return typeof k == "number" ? k : this.nodes.indexOf(k);
    }, C.removeChild = function(k) {
      k = this.index(k), this.at(k).parent = void 0, this.nodes.splice(k, 1);
      var O;
      for (var E in this.indexes)
        O = this.indexes[E], O >= k && (this.indexes[E] = O - 1);
      return this;
    }, C.removeAll = function() {
      for (var k = c(this.nodes), O; !(O = k()).done; ) {
        var E = O.value;
        E.parent = void 0;
      }
      return this.nodes = [], this;
    }, C.empty = function() {
      return this.removeAll();
    }, C.insertAfter = function(k, O) {
      O.parent = this;
      var E = this.index(k);
      this.nodes.splice(E + 1, 0, O), O.parent = this;
      var M;
      for (var D in this.indexes)
        M = this.indexes[D], E <= M && (this.indexes[D] = M + 1);
      return this;
    }, C.insertBefore = function(k, O) {
      O.parent = this;
      var E = this.index(k);
      this.nodes.splice(E, 0, O), O.parent = this;
      var M;
      for (var D in this.indexes)
        M = this.indexes[D], M <= E && (this.indexes[D] = M + 1);
      return this;
    }, C._findChildAtPosition = function(k, O) {
      var E = void 0;
      return this.each(function(M) {
        if (M.atPosition) {
          var D = M.atPosition(k, O);
          if (D)
            return E = D, !1;
        } else if (M.isAtPosition(k, O))
          return E = M, !1;
      }), E;
    }, C.atPosition = function(k, O) {
      if (this.isAtPosition(k, O))
        return this._findChildAtPosition(k, O) || this;
    }, C._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, C.each = function(k) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var O = this.lastEach;
      if (this.indexes[O] = 0, !!this.length) {
        for (var E, M; this.indexes[O] < this.length && (E = this.indexes[O], M = k(this.at(E), E), M !== !1); )
          this.indexes[O] += 1;
        if (delete this.indexes[O], M === !1)
          return !1;
      }
    }, C.walk = function(k) {
      return this.each(function(O, E) {
        var M = k(O, E);
        if (M !== !1 && O.length && (M = O.walk(k)), M === !1)
          return !1;
      });
    }, C.walkAttributes = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.ATTRIBUTE)
          return k.call(O, E);
      });
    }, C.walkClasses = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.CLASS)
          return k.call(O, E);
      });
    }, C.walkCombinators = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.COMBINATOR)
          return k.call(O, E);
      });
    }, C.walkComments = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.COMMENT)
          return k.call(O, E);
      });
    }, C.walkIds = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.ID)
          return k.call(O, E);
      });
    }, C.walkNesting = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.NESTING)
          return k.call(O, E);
      });
    }, C.walkPseudos = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.PSEUDO)
          return k.call(O, E);
      });
    }, C.walkTags = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.TAG)
          return k.call(O, E);
      });
    }, C.walkUniversals = function(k) {
      var O = this;
      return this.walk(function(E) {
        if (E.type === r.UNIVERSAL)
          return k.call(O, E);
      });
    }, C.split = function(k) {
      var O = this, E = [];
      return this.reduce(function(M, D, P) {
        var b = k.call(O, D);
        return E.push(D), b ? (M.push(E), E = []) : P === O.length - 1 && M.push(E), M;
      }, []);
    }, C.map = function(k) {
      return this.nodes.map(k);
    }, C.reduce = function(k, O) {
      return this.nodes.reduce(k, O);
    }, C.every = function(k) {
      return this.nodes.every(k);
    }, C.some = function(k) {
      return this.nodes.some(k);
    }, C.filter = function(k) {
      return this.nodes.filter(k);
    }, C.sort = function(k) {
      return this.nodes.sort(k);
    }, C.toString = function() {
      return this.map(String).join("");
    }, u(m, [{
      key: "first",
      get: function() {
        return this.at(0);
      }
    }, {
      key: "last",
      get: function() {
        return this.at(this.length - 1);
      }
    }, {
      key: "length",
      get: function() {
        return this.nodes.length;
      }
    }]), m;
  }(t.default);
  e.default = x, s.exports = e.default;
})(en, en.exports);
var $n = en.exports;
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n($n), r = be;
  function n(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function l(f, u) {
    for (var p = 0; p < u.length; p++) {
      var _ = u[p];
      _.enumerable = _.enumerable || !1, _.configurable = !0, "value" in _ && (_.writable = !0), Object.defineProperty(f, _.key, _);
    }
  }
  function i(f, u, p) {
    return u && l(f.prototype, u), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function c(f, u) {
    f.prototype = Object.create(u.prototype), f.prototype.constructor = f, a(f, u);
  }
  function a(f, u) {
    return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(_, x) {
      return _.__proto__ = x, _;
    }, a(f, u);
  }
  var o = /* @__PURE__ */ function(f) {
    c(u, f);
    function u(_) {
      var x;
      return x = f.call(this, _) || this, x.type = r.ROOT, x;
    }
    var p = u.prototype;
    return p.toString = function() {
      var x = this.reduce(function(h, m) {
        return h.push(String(m)), h;
      }, []).join(",");
      return this.trailingComma ? x + "," : x;
    }, p.error = function(x, h) {
      return this._error ? this._error(x, h) : new Error(x);
    }, i(u, [{
      key: "errorGenerator",
      set: function(x) {
        this._error = x;
      }
    }]), u;
  }(t.default);
  e.default = o, s.exports = e.default;
})(Zr, Zr.exports);
var Ta = Zr.exports, on = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n($n), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.SELECTOR, u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(on, on.exports);
var Ma = on.exports, ln = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var au = {}, su = au.hasOwnProperty, ou = function(e, t) {
  if (!e)
    return t;
  var r = {};
  for (var n in t)
    r[n] = su.call(e, n) ? e[n] : t[n];
  return r;
}, lu = /[ -,\.\/:-@\[-\^`\{-~]/, uu = /[ -,\.\/:-@\[\]\^`\{-~]/, fu = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Dn = function s(e, t) {
  t = ou(t, s.options), t.quotes != "single" && t.quotes != "double" && (t.quotes = "single");
  for (var r = t.quotes == "double" ? '"' : "'", n = t.isIdentifier, l = e.charAt(0), i = "", c = 0, a = e.length; c < a; ) {
    var o = e.charAt(c++), f = o.charCodeAt(), u = void 0;
    if (f < 32 || f > 126) {
      if (f >= 55296 && f <= 56319 && c < a) {
        var p = e.charCodeAt(c++);
        (p & 64512) == 56320 ? f = ((f & 1023) << 10) + (p & 1023) + 65536 : c--;
      }
      u = "\\" + f.toString(16).toUpperCase() + " ";
    } else
      t.escapeEverything ? lu.test(o) ? u = "\\" + o : u = "\\" + f.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(o) ? u = "\\" + f.toString(16).toUpperCase() + " " : o == "\\" || !n && (o == '"' && r == o || o == "'" && r == o) || n && uu.test(o) ? u = "\\" + o : u = o;
    i += u;
  }
  return n && (/^-[-\d]/.test(i) ? i = "\\-" + i.slice(1) : /\d/.test(l) && (i = "\\3" + l + " " + i.slice(1))), i = i.replace(fu, function(_, x, h) {
    return x && x.length % 2 ? _ : (x || "") + h;
  }), !n && t.wrap ? r + i + r : i;
};
Dn.options = {
  escapeEverything: !1,
  isIdentifier: !1,
  quotes: "single",
  wrap: !1
};
Dn.version = "3.0.0";
var Nn = Dn;
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(Nn), r = Be, n = i(at), l = be;
  function i(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function c(p, _) {
    for (var x = 0; x < _.length; x++) {
      var h = _[x];
      h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(p, h.key, h);
    }
  }
  function a(p, _, x) {
    return _ && c(p.prototype, _), Object.defineProperty(p, "prototype", { writable: !1 }), p;
  }
  function o(p, _) {
    p.prototype = Object.create(_.prototype), p.prototype.constructor = p, f(p, _);
  }
  function f(p, _) {
    return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(h, m) {
      return h.__proto__ = m, h;
    }, f(p, _);
  }
  var u = /* @__PURE__ */ function(p) {
    o(_, p);
    function _(h) {
      var m;
      return m = p.call(this, h) || this, m.type = l.CLASS, m._constructed = !0, m;
    }
    var x = _.prototype;
    return x.valueToString = function() {
      return "." + p.prototype.valueToString.call(this);
    }, a(_, [{
      key: "value",
      get: function() {
        return this._value;
      },
      set: function(m) {
        if (this._constructed) {
          var C = (0, t.default)(m, {
            isIdentifier: !0
          });
          C !== m ? ((0, r.ensureObject)(this, "raws"), this.raws.value = C) : this.raws && delete this.raws.value;
        }
        this._value = m;
      }
    }]), _;
  }(n.default);
  e.default = u, s.exports = e.default;
})(ln, ln.exports);
var Ia = ln.exports, un = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(at), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.COMMENT, u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(un, un.exports);
var Ra = un.exports, fn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(at), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(u) {
      var p;
      return p = a.call(this, u) || this, p.type = r.ID, p;
    }
    var f = o.prototype;
    return f.valueToString = function() {
      return "#" + a.prototype.valueToString.call(this);
    }, o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(fn, fn.exports);
var $a = fn.exports, cn = { exports: {} }, dn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = l(Nn), r = Be, n = l(at);
  function l(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function i(u, p) {
    for (var _ = 0; _ < p.length; _++) {
      var x = p[_];
      x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(u, x.key, x);
    }
  }
  function c(u, p, _) {
    return p && i(u.prototype, p), Object.defineProperty(u, "prototype", { writable: !1 }), u;
  }
  function a(u, p) {
    u.prototype = Object.create(p.prototype), u.prototype.constructor = u, o(u, p);
  }
  function o(u, p) {
    return o = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, h) {
      return x.__proto__ = h, x;
    }, o(u, p);
  }
  var f = /* @__PURE__ */ function(u) {
    a(p, u);
    function p() {
      return u.apply(this, arguments) || this;
    }
    var _ = p.prototype;
    return _.qualifiedName = function(h) {
      return this.namespace ? this.namespaceString + "|" + h : h;
    }, _.valueToString = function() {
      return this.qualifiedName(u.prototype.valueToString.call(this));
    }, c(p, [{
      key: "namespace",
      get: function() {
        return this._namespace;
      },
      set: function(h) {
        if (h === !0 || h === "*" || h === "&") {
          this._namespace = h, this.raws && delete this.raws.namespace;
          return;
        }
        var m = (0, t.default)(h, {
          isIdentifier: !0
        });
        this._namespace = h, m !== h ? ((0, r.ensureObject)(this, "raws"), this.raws.namespace = m) : this.raws && delete this.raws.namespace;
      }
    }, {
      key: "ns",
      get: function() {
        return this._namespace;
      },
      set: function(h) {
        this.namespace = h;
      }
    }, {
      key: "namespaceString",
      get: function() {
        if (this.namespace) {
          var h = this.stringifyProperty("namespace");
          return h === !0 ? "" : h;
        } else
          return "";
      }
    }]), p;
  }(n.default);
  e.default = f, s.exports = e.default;
})(dn, dn.exports);
var Ln = dn.exports;
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(Ln), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.TAG, u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(cn, cn.exports);
var Da = cn.exports, pn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(at), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.STRING, u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(pn, pn.exports);
var Na = pn.exports, hn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n($n), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(u) {
      var p;
      return p = a.call(this, u) || this, p.type = r.PSEUDO, p;
    }
    var f = o.prototype;
    return f.toString = function() {
      var p = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), p, this.rawSpaceAfter].join("");
    }, o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(hn, hn.exports);
var La = hn.exports, Fn = {}, cu = du;
function du(s, e) {
  if (Cr("noDeprecation"))
    return s;
  var t = !1;
  function r() {
    if (!t) {
      if (Cr("throwDeprecation"))
        throw new Error(e);
      Cr("traceDeprecation") ? console.trace(e) : console.warn(e), t = !0;
    }
    return s.apply(this, arguments);
  }
  return r;
}
function Cr(s) {
  try {
    if (!ni.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var e = ni.localStorage[s];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
(function(s) {
  s.__esModule = !0, s.default = void 0, s.unescapeValue = m;
  var e = i(Nn), t = i(Rn), r = i(Ln), n = be, l;
  function i(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function c(E, M) {
    for (var D = 0; D < M.length; D++) {
      var P = M[D];
      P.enumerable = P.enumerable || !1, P.configurable = !0, "value" in P && (P.writable = !0), Object.defineProperty(E, P.key, P);
    }
  }
  function a(E, M, D) {
    return M && c(E.prototype, M), Object.defineProperty(E, "prototype", { writable: !1 }), E;
  }
  function o(E, M) {
    E.prototype = Object.create(M.prototype), E.prototype.constructor = E, f(E, M);
  }
  function f(E, M) {
    return f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(P, b) {
      return P.__proto__ = b, P;
    }, f(E, M);
  }
  var u = cu, p = /^('|")([^]*)\1$/, _ = u(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), x = u(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), h = u(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function m(E) {
    var M = !1, D = null, P = E, b = P.match(p);
    return b && (D = b[1], P = b[2]), P = (0, t.default)(P), P !== E && (M = !0), {
      deprecatedUsage: M,
      unescaped: P,
      quoteMark: D
    };
  }
  function C(E) {
    if (E.quoteMark !== void 0 || E.value === void 0)
      return E;
    h();
    var M = m(E.value), D = M.quoteMark, P = M.unescaped;
    return E.raws || (E.raws = {}), E.raws.value === void 0 && (E.raws.value = E.value), E.value = P, E.quoteMark = D, E;
  }
  var S = /* @__PURE__ */ function(E) {
    o(M, E);
    function M(P) {
      var b;
      return P === void 0 && (P = {}), b = E.call(this, C(P)) || this, b.type = n.ATTRIBUTE, b.raws = b.raws || {}, Object.defineProperty(b.raws, "unquoted", {
        get: u(function() {
          return b.value;
        }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
        set: u(function() {
          return b.value;
        }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
      }), b._constructed = !0, b;
    }
    var D = M.prototype;
    return D.getQuotedValue = function(b) {
      b === void 0 && (b = {});
      var A = this._determineQuoteMark(b), N = k[A], T = (0, e.default)(this._value, N);
      return T;
    }, D._determineQuoteMark = function(b) {
      return b.smart ? this.smartQuoteMark(b) : this.preferredQuoteMark(b);
    }, D.setValue = function(b, A) {
      A === void 0 && (A = {}), this._value = b, this._quoteMark = this._determineQuoteMark(A), this._syncRawValue();
    }, D.smartQuoteMark = function(b) {
      var A = this.value, N = A.replace(/[^']/g, "").length, T = A.replace(/[^"]/g, "").length;
      if (N + T === 0) {
        var V = (0, e.default)(A, {
          isIdentifier: !0
        });
        if (V === A)
          return M.NO_QUOTE;
        var d = this.preferredQuoteMark(b);
        if (d === M.NO_QUOTE) {
          var g = this.quoteMark || b.quoteMark || M.DOUBLE_QUOTE, v = k[g], y = (0, e.default)(A, v);
          if (y.length < V.length)
            return g;
        }
        return d;
      } else
        return T === N ? this.preferredQuoteMark(b) : T < N ? M.DOUBLE_QUOTE : M.SINGLE_QUOTE;
    }, D.preferredQuoteMark = function(b) {
      var A = b.preferCurrentQuoteMark ? this.quoteMark : b.quoteMark;
      return A === void 0 && (A = b.preferCurrentQuoteMark ? b.quoteMark : this.quoteMark), A === void 0 && (A = M.DOUBLE_QUOTE), A;
    }, D._syncRawValue = function() {
      var b = (0, e.default)(this._value, k[this.quoteMark]);
      b === this._value ? this.raws && delete this.raws.value : this.raws.value = b;
    }, D._handleEscapes = function(b, A) {
      if (this._constructed) {
        var N = (0, e.default)(A, {
          isIdentifier: !0
        });
        N !== A ? this.raws[b] = N : delete this.raws[b];
      }
    }, D._spacesFor = function(b) {
      var A = {
        before: "",
        after: ""
      }, N = this.spaces[b] || {}, T = this.raws.spaces && this.raws.spaces[b] || {};
      return Object.assign(A, N, T);
    }, D._stringFor = function(b, A, N) {
      A === void 0 && (A = b), N === void 0 && (N = O);
      var T = this._spacesFor(A);
      return N(this.stringifyProperty(b), T);
    }, D.offsetOf = function(b) {
      var A = 1, N = this._spacesFor("attribute");
      if (A += N.before.length, b === "namespace" || b === "ns")
        return this.namespace ? A : -1;
      if (b === "attributeNS" || (A += this.namespaceString.length, this.namespace && (A += 1), b === "attribute"))
        return A;
      A += this.stringifyProperty("attribute").length, A += N.after.length;
      var T = this._spacesFor("operator");
      A += T.before.length;
      var V = this.stringifyProperty("operator");
      if (b === "operator")
        return V ? A : -1;
      A += V.length, A += T.after.length;
      var d = this._spacesFor("value");
      A += d.before.length;
      var g = this.stringifyProperty("value");
      if (b === "value")
        return g ? A : -1;
      A += g.length, A += d.after.length;
      var v = this._spacesFor("insensitive");
      return A += v.before.length, b === "insensitive" && this.insensitive ? A : -1;
    }, D.toString = function() {
      var b = this, A = [this.rawSpaceBefore, "["];
      return A.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (A.push(this._stringFor("operator")), A.push(this._stringFor("value")), A.push(this._stringFor("insensitiveFlag", "insensitive", function(N, T) {
        return N.length > 0 && !b.quoted && T.before.length === 0 && !(b.spaces.value && b.spaces.value.after) && (T.before = " "), O(N, T);
      }))), A.push("]"), A.push(this.rawSpaceAfter), A.join("");
    }, a(M, [{
      key: "quoted",
      get: function() {
        var b = this.quoteMark;
        return b === "'" || b === '"';
      },
      set: function(b) {
        x();
      }
      /**
       * returns a single (`'`) or double (`"`) quote character if the value is quoted.
       * returns `null` if the value is not quoted.
       * returns `undefined` if the quotation state is unknown (this can happen when
       * the attribute is constructed without specifying a quote mark.)
       */
    }, {
      key: "quoteMark",
      get: function() {
        return this._quoteMark;
      },
      set: function(b) {
        if (!this._constructed) {
          this._quoteMark = b;
          return;
        }
        this._quoteMark !== b && (this._quoteMark = b, this._syncRawValue());
      }
    }, {
      key: "qualifiedAttribute",
      get: function() {
        return this.qualifiedName(this.raws.attribute || this.attribute);
      }
    }, {
      key: "insensitiveFlag",
      get: function() {
        return this.insensitive ? "i" : "";
      }
    }, {
      key: "value",
      get: function() {
        return this._value;
      },
      set: (
        /**
         * Before 3.0, the value had to be set to an escaped value including any wrapped
         * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
         * is unescaped during parsing and any quote marks are removed.
         *
         * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
         * a deprecation warning is raised when the new value contains any characters that would
         * require escaping (including if it contains wrapped quotes).
         *
         * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
         * how the new value is quoted.
         */
        function(b) {
          if (this._constructed) {
            var A = m(b), N = A.deprecatedUsage, T = A.unescaped, V = A.quoteMark;
            if (N && _(), T === this._value && V === this._quoteMark)
              return;
            this._value = T, this._quoteMark = V, this._syncRawValue();
          } else
            this._value = b;
        }
      )
    }, {
      key: "insensitive",
      get: function() {
        return this._insensitive;
      },
      set: function(b) {
        b || (this._insensitive = !1, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = b;
      }
    }, {
      key: "attribute",
      get: function() {
        return this._attribute;
      },
      set: function(b) {
        this._handleEscapes("attribute", b), this._attribute = b;
      }
    }]), M;
  }(r.default);
  s.default = S, S.NO_QUOTE = null, S.SINGLE_QUOTE = "'", S.DOUBLE_QUOTE = '"';
  var k = (l = {
    "'": {
      quotes: "single",
      wrap: !0
    },
    '"': {
      quotes: "double",
      wrap: !0
    }
  }, l[null] = {
    isIdentifier: !0
  }, l);
  function O(E, M) {
    return "" + M.before + E + M.after;
  }
})(Fn);
var mn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(Ln), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.UNIVERSAL, u.value = "*", u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(mn, mn.exports);
var Fa = mn.exports, gn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(at), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.COMBINATOR, u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(gn, gn.exports);
var za = gn.exports, vn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = n(at), r = be;
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function l(a, o) {
    a.prototype = Object.create(o.prototype), a.prototype.constructor = a, i(a, o);
  }
  function i(a, o) {
    return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, p) {
      return u.__proto__ = p, u;
    }, i(a, o);
  }
  var c = /* @__PURE__ */ function(a) {
    l(o, a);
    function o(f) {
      var u;
      return u = a.call(this, f) || this, u.type = r.NESTING, u.value = "&", u;
    }
    return o;
  }(t.default);
  e.default = c, s.exports = e.default;
})(vn, vn.exports);
var Ua = vn.exports, yn = { exports: {} };
(function(s, e) {
  e.__esModule = !0, e.default = t;
  function t(r) {
    return r.sort(function(n, l) {
      return n - l;
    });
  }
  s.exports = e.default;
})(yn, yn.exports);
var pu = yn.exports, ja = {}, ie = {};
ie.__esModule = !0;
ie.word = ie.tilde = ie.tab = ie.str = ie.space = ie.slash = ie.singleQuote = ie.semicolon = ie.plus = ie.pipe = ie.openSquare = ie.openParenthesis = ie.newline = ie.greaterThan = ie.feed = ie.equals = ie.doubleQuote = ie.dollar = ie.cr = ie.comment = ie.comma = ie.combinator = ie.colon = ie.closeSquare = ie.closeParenthesis = ie.caret = ie.bang = ie.backslash = ie.at = ie.asterisk = ie.ampersand = void 0;
var hu = 38;
ie.ampersand = hu;
var mu = 42;
ie.asterisk = mu;
var gu = 64;
ie.at = gu;
var vu = 44;
ie.comma = vu;
var yu = 58;
ie.colon = yu;
var wu = 59;
ie.semicolon = wu;
var bu = 40;
ie.openParenthesis = bu;
var xu = 41;
ie.closeParenthesis = xu;
var _u = 91;
ie.openSquare = _u;
var Su = 93;
ie.closeSquare = Su;
var Ou = 36;
ie.dollar = Ou;
var ku = 126;
ie.tilde = ku;
var Au = 94;
ie.caret = Au;
var Cu = 43;
ie.plus = Cu;
var Eu = 61;
ie.equals = Eu;
var Pu = 124;
ie.pipe = Pu;
var Tu = 62;
ie.greaterThan = Tu;
var Mu = 32;
ie.space = Mu;
var Va = 39;
ie.singleQuote = Va;
var Iu = 34;
ie.doubleQuote = Iu;
var Ru = 47;
ie.slash = Ru;
var $u = 33;
ie.bang = $u;
var Du = 92;
ie.backslash = Du;
var Nu = 13;
ie.cr = Nu;
var Lu = 12;
ie.feed = Lu;
var Fu = 10;
ie.newline = Fu;
var zu = 9;
ie.tab = zu;
var Uu = Va;
ie.str = Uu;
var ju = -1;
ie.comment = ju;
var Vu = -2;
ie.word = Vu;
var Wu = -3;
ie.combinator = Wu;
(function(s) {
  s.__esModule = !0, s.FIELDS = void 0, s.default = x;
  var e = l(ie), t, r;
  function n(h) {
    if (typeof WeakMap != "function")
      return null;
    var m = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
    return (n = function(k) {
      return k ? C : m;
    })(h);
  }
  function l(h, m) {
    if (h && h.__esModule)
      return h;
    if (h === null || typeof h != "object" && typeof h != "function")
      return { default: h };
    var C = n(m);
    if (C && C.has(h))
      return C.get(h);
    var S = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var O in h)
      if (O !== "default" && Object.prototype.hasOwnProperty.call(h, O)) {
        var E = k ? Object.getOwnPropertyDescriptor(h, O) : null;
        E && (E.get || E.set) ? Object.defineProperty(S, O, E) : S[O] = h[O];
      }
    return S.default = h, C && C.set(h, S), S;
  }
  for (var i = (t = {}, t[e.tab] = !0, t[e.newline] = !0, t[e.cr] = !0, t[e.feed] = !0, t), c = (r = {}, r[e.space] = !0, r[e.tab] = !0, r[e.newline] = !0, r[e.cr] = !0, r[e.feed] = !0, r[e.ampersand] = !0, r[e.asterisk] = !0, r[e.bang] = !0, r[e.comma] = !0, r[e.colon] = !0, r[e.semicolon] = !0, r[e.openParenthesis] = !0, r[e.closeParenthesis] = !0, r[e.openSquare] = !0, r[e.closeSquare] = !0, r[e.singleQuote] = !0, r[e.doubleQuote] = !0, r[e.plus] = !0, r[e.pipe] = !0, r[e.tilde] = !0, r[e.greaterThan] = !0, r[e.equals] = !0, r[e.dollar] = !0, r[e.caret] = !0, r[e.slash] = !0, r), a = {}, o = "0123456789abcdefABCDEF", f = 0; f < o.length; f++)
    a[o.charCodeAt(f)] = !0;
  function u(h, m) {
    var C = m, S;
    do {
      if (S = h.charCodeAt(C), c[S])
        return C - 1;
      S === e.backslash ? C = p(h, C) + 1 : C++;
    } while (C < h.length);
    return C - 1;
  }
  function p(h, m) {
    var C = m, S = h.charCodeAt(C + 1);
    if (!i[S])
      if (a[S]) {
        var k = 0;
        do
          C++, k++, S = h.charCodeAt(C + 1);
        while (a[S] && k < 6);
        k < 6 && S === e.space && C++;
      } else
        C++;
    return C;
  }
  var _ = {
    TYPE: 0,
    START_LINE: 1,
    START_COL: 2,
    END_LINE: 3,
    END_COL: 4,
    START_POS: 5,
    END_POS: 6
  };
  s.FIELDS = _;
  function x(h) {
    var m = [], C = h.css.valueOf(), S = C, k = S.length, O = -1, E = 1, M = 0, D = 0, P, b, A, N, T, V, d, g, v, y, R, F, $;
    function z(j, W) {
      if (h.safe)
        C += W, v = C.length - 1;
      else
        throw h.error("Unclosed " + j, E, M - O, M);
    }
    for (; M < k; ) {
      switch (P = C.charCodeAt(M), P === e.newline && (O = M, E += 1), P) {
        case e.space:
        case e.tab:
        case e.newline:
        case e.cr:
        case e.feed:
          v = M;
          do
            v += 1, P = C.charCodeAt(v), P === e.newline && (O = v, E += 1);
          while (P === e.space || P === e.newline || P === e.tab || P === e.cr || P === e.feed);
          $ = e.space, N = E, A = v - O - 1, D = v;
          break;
        case e.plus:
        case e.greaterThan:
        case e.tilde:
        case e.pipe:
          v = M;
          do
            v += 1, P = C.charCodeAt(v);
          while (P === e.plus || P === e.greaterThan || P === e.tilde || P === e.pipe);
          $ = e.combinator, N = E, A = M - O, D = v;
          break;
        case e.asterisk:
        case e.ampersand:
        case e.bang:
        case e.comma:
        case e.equals:
        case e.dollar:
        case e.caret:
        case e.openSquare:
        case e.closeSquare:
        case e.colon:
        case e.semicolon:
        case e.openParenthesis:
        case e.closeParenthesis:
          v = M, $ = P, N = E, A = M - O, D = v + 1;
          break;
        case e.singleQuote:
        case e.doubleQuote:
          F = P === e.singleQuote ? "'" : '"', v = M;
          do
            for (T = !1, v = C.indexOf(F, v + 1), v === -1 && z("quote", F), V = v; C.charCodeAt(V - 1) === e.backslash; )
              V -= 1, T = !T;
          while (T);
          $ = e.str, N = E, A = M - O, D = v + 1;
          break;
        default:
          P === e.slash && C.charCodeAt(M + 1) === e.asterisk ? (v = C.indexOf("*/", M + 2) + 1, v === 0 && z("comment", "*/"), b = C.slice(M, v + 1), g = b.split(`
`), d = g.length - 1, d > 0 ? (y = E + d, R = v - g[d].length) : (y = E, R = O), $ = e.comment, E = y, N = y, A = v - R) : P === e.slash ? (v = M, $ = P, N = E, A = M - O, D = v + 1) : (v = u(C, M), $ = e.word, N = E, A = v - O), D = v + 1;
          break;
      }
      m.push([
        $,
        // [0] Token type
        E,
        // [1] Starting line
        M - O,
        // [2] Starting column
        N,
        // [3] Ending line
        A,
        // [4] Ending column
        M,
        // [5] Start position / Source index
        D
        // [6] End position
      ]), R && (O = R, R = null), M = D;
    }
    return m;
  }
})(ja);
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = D(Ta), r = D(Ma), n = D(Ia), l = D(Ra), i = D($a), c = D(Da), a = D(Na), o = D(La), f = M(Fn), u = D(Fa), p = D(za), _ = D(Ua), x = D(pu), h = M(ja), m = M(ie), C = M(be), S = Be, k, O;
  function E(z) {
    if (typeof WeakMap != "function")
      return null;
    var j = /* @__PURE__ */ new WeakMap(), W = /* @__PURE__ */ new WeakMap();
    return (E = function(G) {
      return G ? W : j;
    })(z);
  }
  function M(z, j) {
    if (z && z.__esModule)
      return z;
    if (z === null || typeof z != "object" && typeof z != "function")
      return { default: z };
    var W = E(j);
    if (W && W.has(z))
      return W.get(z);
    var I = {}, G = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var re in z)
      if (re !== "default" && Object.prototype.hasOwnProperty.call(z, re)) {
        var w = G ? Object.getOwnPropertyDescriptor(z, re) : null;
        w && (w.get || w.set) ? Object.defineProperty(I, re, w) : I[re] = z[re];
      }
    return I.default = z, W && W.set(z, I), I;
  }
  function D(z) {
    return z && z.__esModule ? z : { default: z };
  }
  function P(z, j) {
    for (var W = 0; W < j.length; W++) {
      var I = j[W];
      I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(z, I.key, I);
    }
  }
  function b(z, j, W) {
    return j && P(z.prototype, j), Object.defineProperty(z, "prototype", { writable: !1 }), z;
  }
  var A = (k = {}, k[m.space] = !0, k[m.cr] = !0, k[m.feed] = !0, k[m.newline] = !0, k[m.tab] = !0, k), N = Object.assign({}, A, (O = {}, O[m.comment] = !0, O));
  function T(z) {
    return {
      line: z[h.FIELDS.START_LINE],
      column: z[h.FIELDS.START_COL]
    };
  }
  function V(z) {
    return {
      line: z[h.FIELDS.END_LINE],
      column: z[h.FIELDS.END_COL]
    };
  }
  function d(z, j, W, I) {
    return {
      start: {
        line: z,
        column: j
      },
      end: {
        line: W,
        column: I
      }
    };
  }
  function g(z) {
    return d(z[h.FIELDS.START_LINE], z[h.FIELDS.START_COL], z[h.FIELDS.END_LINE], z[h.FIELDS.END_COL]);
  }
  function v(z, j) {
    if (z)
      return d(z[h.FIELDS.START_LINE], z[h.FIELDS.START_COL], j[h.FIELDS.END_LINE], j[h.FIELDS.END_COL]);
  }
  function y(z, j) {
    var W = z[j];
    if (typeof W == "string")
      return W.indexOf("\\") !== -1 && ((0, S.ensureObject)(z, "raws"), z[j] = (0, S.unesc)(W), z.raws[j] === void 0 && (z.raws[j] = W)), z;
  }
  function R(z, j) {
    for (var W = -1, I = []; (W = z.indexOf(j, W + 1)) !== -1; )
      I.push(W);
    return I;
  }
  function F() {
    var z = Array.prototype.concat.apply([], arguments);
    return z.filter(function(j, W) {
      return W === z.indexOf(j);
    });
  }
  var $ = /* @__PURE__ */ function() {
    function z(W, I) {
      I === void 0 && (I = {}), this.rule = W, this.options = Object.assign({
        lossy: !1,
        safe: !1
      }, I), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, h.default)({
        css: this.css,
        error: this._errorGenerator(),
        safe: this.options.safe
      });
      var G = v(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new t.default({
        source: G
      }), this.root.errorGenerator = this._errorGenerator();
      var re = new r.default({
        source: {
          start: {
            line: 1,
            column: 1
          }
        }
      });
      this.root.append(re), this.current = re, this.loop();
    }
    var j = z.prototype;
    return j._errorGenerator = function() {
      var I = this;
      return function(G, re) {
        return typeof I.rule == "string" ? new Error(G) : I.rule.error(G, re);
      };
    }, j.attribute = function() {
      var I = [], G = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[h.FIELDS.TYPE] !== m.closeSquare; )
        I.push(this.currToken), this.position++;
      if (this.currToken[h.FIELDS.TYPE] !== m.closeSquare)
        return this.expected("closing square bracket", this.currToken[h.FIELDS.START_POS]);
      var re = I.length, w = {
        source: d(G[1], G[2], this.currToken[3], this.currToken[4]),
        sourceIndex: G[h.FIELDS.START_POS]
      };
      if (re === 1 && !~[m.word].indexOf(I[0][h.FIELDS.TYPE]))
        return this.expected("attribute", I[0][h.FIELDS.START_POS]);
      for (var L = 0, B = "", H = "", Y = null, J = !1; L < re; ) {
        var ee = I[L], Q = this.content(ee), le = I[L + 1];
        switch (ee[h.FIELDS.TYPE]) {
          case m.space:
            if (J = !0, this.options.lossy)
              break;
            if (Y) {
              (0, S.ensureObject)(w, "spaces", Y);
              var ye = w.spaces[Y].after || "";
              w.spaces[Y].after = ye + Q;
              var Oe = (0, S.getProp)(w, "raws", "spaces", Y, "after") || null;
              Oe && (w.raws.spaces[Y].after = Oe + Q);
            } else
              B = B + Q, H = H + Q;
            break;
          case m.asterisk:
            if (le[h.FIELDS.TYPE] === m.equals)
              w.operator = Q, Y = "operator";
            else if ((!w.namespace || Y === "namespace" && !J) && le) {
              B && ((0, S.ensureObject)(w, "spaces", "attribute"), w.spaces.attribute.before = B, B = ""), H && ((0, S.ensureObject)(w, "raws", "spaces", "attribute"), w.raws.spaces.attribute.before = B, H = ""), w.namespace = (w.namespace || "") + Q;
              var Ae = (0, S.getProp)(w, "raws", "namespace") || null;
              Ae && (w.raws.namespace += Q), Y = "namespace";
            }
            J = !1;
            break;
          case m.dollar:
            if (Y === "value") {
              var oe = (0, S.getProp)(w, "raws", "value");
              w.value += "$", oe && (w.raws.value = oe + "$");
              break;
            }
          case m.caret:
            le[h.FIELDS.TYPE] === m.equals && (w.operator = Q, Y = "operator"), J = !1;
            break;
          case m.combinator:
            if (Q === "~" && le[h.FIELDS.TYPE] === m.equals && (w.operator = Q, Y = "operator"), Q !== "|") {
              J = !1;
              break;
            }
            le[h.FIELDS.TYPE] === m.equals ? (w.operator = Q, Y = "operator") : !w.namespace && !w.attribute && (w.namespace = !0), J = !1;
            break;
          case m.word:
            if (le && this.content(le) === "|" && I[L + 2] && I[L + 2][h.FIELDS.TYPE] !== m.equals && // this look-ahead probably fails with comment nodes involved.
            !w.operator && !w.namespace)
              w.namespace = Q, Y = "namespace";
            else if (!w.attribute || Y === "attribute" && !J) {
              B && ((0, S.ensureObject)(w, "spaces", "attribute"), w.spaces.attribute.before = B, B = ""), H && ((0, S.ensureObject)(w, "raws", "spaces", "attribute"), w.raws.spaces.attribute.before = H, H = ""), w.attribute = (w.attribute || "") + Q;
              var Ne = (0, S.getProp)(w, "raws", "attribute") || null;
              Ne && (w.raws.attribute += Q), Y = "attribute";
            } else if (!w.value && w.value !== "" || Y === "value" && !(J || w.quoteMark)) {
              var q = (0, S.unesc)(Q), U = (0, S.getProp)(w, "raws", "value") || "", Z = w.value || "";
              w.value = Z + q, w.quoteMark = null, (q !== Q || U) && ((0, S.ensureObject)(w, "raws"), w.raws.value = (U || Z) + Q), Y = "value";
            } else {
              var K = Q === "i" || Q === "I";
              (w.value || w.value === "") && (w.quoteMark || J) ? (w.insensitive = K, (!K || Q === "I") && ((0, S.ensureObject)(w, "raws"), w.raws.insensitiveFlag = Q), Y = "insensitive", B && ((0, S.ensureObject)(w, "spaces", "insensitive"), w.spaces.insensitive.before = B, B = ""), H && ((0, S.ensureObject)(w, "raws", "spaces", "insensitive"), w.raws.spaces.insensitive.before = H, H = "")) : (w.value || w.value === "") && (Y = "value", w.value += Q, w.raws.value && (w.raws.value += Q));
            }
            J = !1;
            break;
          case m.str:
            if (!w.attribute || !w.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", {
                index: ee[h.FIELDS.START_POS]
              });
            var X = (0, f.unescapeValue)(Q), ae = X.unescaped, se = X.quoteMark;
            w.value = ae, w.quoteMark = se, Y = "value", (0, S.ensureObject)(w, "raws"), w.raws.value = Q, J = !1;
            break;
          case m.equals:
            if (!w.attribute)
              return this.expected("attribute", ee[h.FIELDS.START_POS], Q);
            if (w.value)
              return this.error('Unexpected "=" found; an operator was already defined.', {
                index: ee[h.FIELDS.START_POS]
              });
            w.operator = w.operator ? w.operator + Q : Q, Y = "operator", J = !1;
            break;
          case m.comment:
            if (Y)
              if (J || le && le[h.FIELDS.TYPE] === m.space || Y === "insensitive") {
                var Se = (0, S.getProp)(w, "spaces", Y, "after") || "", fe = (0, S.getProp)(w, "raws", "spaces", Y, "after") || Se;
                (0, S.ensureObject)(w, "raws", "spaces", Y), w.raws.spaces[Y].after = fe + Q;
              } else {
                var Pe = w[Y] || "", ge = (0, S.getProp)(w, "raws", Y) || Pe;
                (0, S.ensureObject)(w, "raws"), w.raws[Y] = ge + Q;
              }
            else
              H = H + Q;
            break;
          default:
            return this.error('Unexpected "' + Q + '" found.', {
              index: ee[h.FIELDS.START_POS]
            });
        }
        L++;
      }
      y(w, "attribute"), y(w, "namespace"), this.newNode(new f.default(w)), this.position++;
    }, j.parseWhitespaceEquivalentTokens = function(I) {
      I < 0 && (I = this.tokens.length);
      var G = this.position, re = [], w = "", L = void 0;
      do
        if (A[this.currToken[h.FIELDS.TYPE]])
          this.options.lossy || (w += this.content());
        else if (this.currToken[h.FIELDS.TYPE] === m.comment) {
          var B = {};
          w && (B.before = w, w = ""), L = new l.default({
            value: this.content(),
            source: g(this.currToken),
            sourceIndex: this.currToken[h.FIELDS.START_POS],
            spaces: B
          }), re.push(L);
        }
      while (++this.position < I);
      if (w) {
        if (L)
          L.spaces.after = w;
        else if (!this.options.lossy) {
          var H = this.tokens[G], Y = this.tokens[this.position - 1];
          re.push(new a.default({
            value: "",
            source: d(H[h.FIELDS.START_LINE], H[h.FIELDS.START_COL], Y[h.FIELDS.END_LINE], Y[h.FIELDS.END_COL]),
            sourceIndex: H[h.FIELDS.START_POS],
            spaces: {
              before: w,
              after: ""
            }
          }));
        }
      }
      return re;
    }, j.convertWhitespaceNodesToSpace = function(I, G) {
      var re = this;
      G === void 0 && (G = !1);
      var w = "", L = "";
      I.forEach(function(H) {
        var Y = re.lossySpace(H.spaces.before, G), J = re.lossySpace(H.rawSpaceBefore, G);
        w += Y + re.lossySpace(H.spaces.after, G && Y.length === 0), L += Y + H.value + re.lossySpace(H.rawSpaceAfter, G && J.length === 0);
      }), L === w && (L = void 0);
      var B = {
        space: w,
        rawSpace: L
      };
      return B;
    }, j.isNamedCombinator = function(I) {
      return I === void 0 && (I = this.position), this.tokens[I + 0] && this.tokens[I + 0][h.FIELDS.TYPE] === m.slash && this.tokens[I + 1] && this.tokens[I + 1][h.FIELDS.TYPE] === m.word && this.tokens[I + 2] && this.tokens[I + 2][h.FIELDS.TYPE] === m.slash;
    }, j.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var I = this.content(this.tokens[this.position + 1]), G = (0, S.unesc)(I).toLowerCase(), re = {};
        G !== I && (re.value = "/" + I + "/");
        var w = new p.default({
          value: "/" + G + "/",
          source: d(this.currToken[h.FIELDS.START_LINE], this.currToken[h.FIELDS.START_COL], this.tokens[this.position + 2][h.FIELDS.END_LINE], this.tokens[this.position + 2][h.FIELDS.END_COL]),
          sourceIndex: this.currToken[h.FIELDS.START_POS],
          raws: re
        });
        return this.position = this.position + 3, w;
      } else
        this.unexpected();
    }, j.combinator = function() {
      var I = this;
      if (this.content() === "|")
        return this.namespace();
      var G = this.locateNextMeaningfulToken(this.position);
      if (G < 0 || this.tokens[G][h.FIELDS.TYPE] === m.comma) {
        var re = this.parseWhitespaceEquivalentTokens(G);
        if (re.length > 0) {
          var w = this.current.last;
          if (w) {
            var L = this.convertWhitespaceNodesToSpace(re), B = L.space, H = L.rawSpace;
            H !== void 0 && (w.rawSpaceAfter += H), w.spaces.after += B;
          } else
            re.forEach(function(U) {
              return I.newNode(U);
            });
        }
        return;
      }
      var Y = this.currToken, J = void 0;
      G > this.position && (J = this.parseWhitespaceEquivalentTokens(G));
      var ee;
      if (this.isNamedCombinator() ? ee = this.namedCombinator() : this.currToken[h.FIELDS.TYPE] === m.combinator ? (ee = new p.default({
        value: this.content(),
        source: g(this.currToken),
        sourceIndex: this.currToken[h.FIELDS.START_POS]
      }), this.position++) : A[this.currToken[h.FIELDS.TYPE]] || J || this.unexpected(), ee) {
        if (J) {
          var Q = this.convertWhitespaceNodesToSpace(J), le = Q.space, ye = Q.rawSpace;
          ee.spaces.before = le, ee.rawSpaceBefore = ye;
        }
      } else {
        var Oe = this.convertWhitespaceNodesToSpace(J, !0), Ae = Oe.space, oe = Oe.rawSpace;
        oe || (oe = Ae);
        var Ne = {}, q = {
          spaces: {}
        };
        Ae.endsWith(" ") && oe.endsWith(" ") ? (Ne.before = Ae.slice(0, Ae.length - 1), q.spaces.before = oe.slice(0, oe.length - 1)) : Ae.startsWith(" ") && oe.startsWith(" ") ? (Ne.after = Ae.slice(1), q.spaces.after = oe.slice(1)) : q.value = oe, ee = new p.default({
          value: " ",
          source: v(Y, this.tokens[this.position - 1]),
          sourceIndex: Y[h.FIELDS.START_POS],
          spaces: Ne,
          raws: q
        });
      }
      return this.currToken && this.currToken[h.FIELDS.TYPE] === m.space && (ee.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(ee);
    }, j.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var I = new r.default({
        source: {
          start: T(this.tokens[this.position + 1])
        }
      });
      this.current.parent.append(I), this.current = I, this.position++;
    }, j.comment = function() {
      var I = this.currToken;
      this.newNode(new l.default({
        value: this.content(),
        source: g(I),
        sourceIndex: I[h.FIELDS.START_POS]
      })), this.position++;
    }, j.error = function(I, G) {
      throw this.root.error(I, G);
    }, j.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", {
        index: this.currToken[h.FIELDS.START_POS]
      });
    }, j.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[h.FIELDS.START_POS]);
    }, j.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[h.FIELDS.START_POS]);
    }, j.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[h.FIELDS.START_POS]);
    }, j.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[h.FIELDS.START_POS]);
    }, j.namespace = function() {
      var I = this.prevToken && this.content(this.prevToken) || !0;
      if (this.nextToken[h.FIELDS.TYPE] === m.word)
        return this.position++, this.word(I);
      if (this.nextToken[h.FIELDS.TYPE] === m.asterisk)
        return this.position++, this.universal(I);
      this.unexpectedPipe();
    }, j.nesting = function() {
      if (this.nextToken) {
        var I = this.content(this.nextToken);
        if (I === "|") {
          this.position++;
          return;
        }
      }
      var G = this.currToken;
      this.newNode(new _.default({
        value: this.content(),
        source: g(G),
        sourceIndex: G[h.FIELDS.START_POS]
      })), this.position++;
    }, j.parentheses = function() {
      var I = this.current.last, G = 1;
      if (this.position++, I && I.type === C.PSEUDO) {
        var re = new r.default({
          source: {
            start: T(this.tokens[this.position - 1])
          }
        }), w = this.current;
        for (I.append(re), this.current = re; this.position < this.tokens.length && G; )
          this.currToken[h.FIELDS.TYPE] === m.openParenthesis && G++, this.currToken[h.FIELDS.TYPE] === m.closeParenthesis && G--, G ? this.parse() : (this.current.source.end = V(this.currToken), this.current.parent.source.end = V(this.currToken), this.position++);
        this.current = w;
      } else {
        for (var L = this.currToken, B = "(", H; this.position < this.tokens.length && G; )
          this.currToken[h.FIELDS.TYPE] === m.openParenthesis && G++, this.currToken[h.FIELDS.TYPE] === m.closeParenthesis && G--, H = this.currToken, B += this.parseParenthesisToken(this.currToken), this.position++;
        I ? I.appendToPropertyAndEscape("value", B, B) : this.newNode(new a.default({
          value: B,
          source: d(L[h.FIELDS.START_LINE], L[h.FIELDS.START_COL], H[h.FIELDS.END_LINE], H[h.FIELDS.END_COL]),
          sourceIndex: L[h.FIELDS.START_POS]
        }));
      }
      if (G)
        return this.expected("closing parenthesis", this.currToken[h.FIELDS.START_POS]);
    }, j.pseudo = function() {
      for (var I = this, G = "", re = this.currToken; this.currToken && this.currToken[h.FIELDS.TYPE] === m.colon; )
        G += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[h.FIELDS.TYPE] === m.word)
        this.splitWord(!1, function(w, L) {
          G += w, I.newNode(new o.default({
            value: G,
            source: v(re, I.currToken),
            sourceIndex: re[h.FIELDS.START_POS]
          })), L > 1 && I.nextToken && I.nextToken[h.FIELDS.TYPE] === m.openParenthesis && I.error("Misplaced parenthesis.", {
            index: I.nextToken[h.FIELDS.START_POS]
          });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[h.FIELDS.START_POS]);
    }, j.space = function() {
      var I = this.content();
      this.position === 0 || this.prevToken[h.FIELDS.TYPE] === m.comma || this.prevToken[h.FIELDS.TYPE] === m.openParenthesis || this.current.nodes.every(function(G) {
        return G.type === "comment";
      }) ? (this.spaces = this.optionalSpace(I), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[h.FIELDS.TYPE] === m.comma || this.nextToken[h.FIELDS.TYPE] === m.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I), this.position++) : this.combinator();
    }, j.string = function() {
      var I = this.currToken;
      this.newNode(new a.default({
        value: this.content(),
        source: g(I),
        sourceIndex: I[h.FIELDS.START_POS]
      })), this.position++;
    }, j.universal = function(I) {
      var G = this.nextToken;
      if (G && this.content(G) === "|")
        return this.position++, this.namespace();
      var re = this.currToken;
      this.newNode(new u.default({
        value: this.content(),
        source: g(re),
        sourceIndex: re[h.FIELDS.START_POS]
      }), I), this.position++;
    }, j.splitWord = function(I, G) {
      for (var re = this, w = this.nextToken, L = this.content(); w && ~[m.dollar, m.caret, m.equals, m.word].indexOf(w[h.FIELDS.TYPE]); ) {
        this.position++;
        var B = this.content();
        if (L += B, B.lastIndexOf("\\") === B.length - 1) {
          var H = this.nextToken;
          H && H[h.FIELDS.TYPE] === m.space && (L += this.requiredSpace(this.content(H)), this.position++);
        }
        w = this.nextToken;
      }
      var Y = R(L, ".").filter(function(le) {
        var ye = L[le - 1] === "\\", Oe = /^\d+\.\d+%$/.test(L);
        return !ye && !Oe;
      }), J = R(L, "#").filter(function(le) {
        return L[le - 1] !== "\\";
      }), ee = R(L, "#{");
      ee.length && (J = J.filter(function(le) {
        return !~ee.indexOf(le);
      }));
      var Q = (0, x.default)(F([0].concat(Y, J)));
      Q.forEach(function(le, ye) {
        var Oe = Q[ye + 1] || L.length, Ae = L.slice(le, Oe);
        if (ye === 0 && G)
          return G.call(re, Ae, Q.length);
        var oe, Ne = re.currToken, q = Ne[h.FIELDS.START_POS] + Q[ye], U = d(Ne[1], Ne[2] + le, Ne[3], Ne[2] + (Oe - 1));
        if (~Y.indexOf(le)) {
          var Z = {
            value: Ae.slice(1),
            source: U,
            sourceIndex: q
          };
          oe = new n.default(y(Z, "value"));
        } else if (~J.indexOf(le)) {
          var K = {
            value: Ae.slice(1),
            source: U,
            sourceIndex: q
          };
          oe = new i.default(y(K, "value"));
        } else {
          var X = {
            value: Ae,
            source: U,
            sourceIndex: q
          };
          y(X, "value"), oe = new c.default(X);
        }
        re.newNode(oe, I), I = null;
      }), this.position++;
    }, j.word = function(I) {
      var G = this.nextToken;
      return G && this.content(G) === "|" ? (this.position++, this.namespace()) : this.splitWord(I);
    }, j.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.current._inferEndPosition(), this.root;
    }, j.parse = function(I) {
      switch (this.currToken[h.FIELDS.TYPE]) {
        case m.space:
          this.space();
          break;
        case m.comment:
          this.comment();
          break;
        case m.openParenthesis:
          this.parentheses();
          break;
        case m.closeParenthesis:
          I && this.missingParenthesis();
          break;
        case m.openSquare:
          this.attribute();
          break;
        case m.dollar:
        case m.caret:
        case m.equals:
        case m.word:
          this.word();
          break;
        case m.colon:
          this.pseudo();
          break;
        case m.comma:
          this.comma();
          break;
        case m.asterisk:
          this.universal();
          break;
        case m.ampersand:
          this.nesting();
          break;
        case m.slash:
        case m.combinator:
          this.combinator();
          break;
        case m.str:
          this.string();
          break;
        case m.closeSquare:
          this.missingSquareBracket();
        case m.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, j.expected = function(I, G, re) {
      if (Array.isArray(I)) {
        var w = I.pop();
        I = I.join(", ") + " or " + w;
      }
      var L = /^[aeiou]/.test(I[0]) ? "an" : "a";
      return re ? this.error("Expected " + L + " " + I + ', found "' + re + '" instead.', {
        index: G
      }) : this.error("Expected " + L + " " + I + ".", {
        index: G
      });
    }, j.requiredSpace = function(I) {
      return this.options.lossy ? " " : I;
    }, j.optionalSpace = function(I) {
      return this.options.lossy ? "" : I;
    }, j.lossySpace = function(I, G) {
      return this.options.lossy ? G ? " " : "" : I;
    }, j.parseParenthesisToken = function(I) {
      var G = this.content(I);
      return I[h.FIELDS.TYPE] === m.space ? this.requiredSpace(G) : G;
    }, j.newNode = function(I, G) {
      return G && (/^ +$/.test(G) && (this.options.lossy || (this.spaces = (this.spaces || "") + G), G = !0), I.namespace = G, y(I, "namespace")), this.spaces && (I.spaces.before = this.spaces, this.spaces = ""), this.current.append(I);
    }, j.content = function(I) {
      return I === void 0 && (I = this.currToken), this.css.slice(I[h.FIELDS.START_POS], I[h.FIELDS.END_POS]);
    }, j.locateNextMeaningfulToken = function(I) {
      I === void 0 && (I = this.position + 1);
      for (var G = I; G < this.tokens.length; )
        if (N[this.tokens[G][h.FIELDS.TYPE]]) {
          G++;
          continue;
        } else
          return G;
      return -1;
    }, b(z, [{
      key: "currToken",
      get: function() {
        return this.tokens[this.position];
      }
    }, {
      key: "nextToken",
      get: function() {
        return this.tokens[this.position + 1];
      }
    }, {
      key: "prevToken",
      get: function() {
        return this.tokens[this.position - 1];
      }
    }]), z;
  }();
  e.default = $, s.exports = e.default;
})(Xr, Xr.exports);
var Bu = Xr.exports;
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = r(Bu);
  function r(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var n = /* @__PURE__ */ function() {
    function l(c, a) {
      this.func = c || function() {
      }, this.funcRes = null, this.options = a;
    }
    var i = l.prototype;
    return i._shouldUpdateSelector = function(a, o) {
      o === void 0 && (o = {});
      var f = Object.assign({}, this.options, o);
      return f.updateSelector === !1 ? !1 : typeof a != "string";
    }, i._isLossy = function(a) {
      a === void 0 && (a = {});
      var o = Object.assign({}, this.options, a);
      return o.lossless === !1;
    }, i._root = function(a, o) {
      o === void 0 && (o = {});
      var f = new t.default(a, this._parseOptions(o));
      return f.root;
    }, i._parseOptions = function(a) {
      return {
        lossy: this._isLossy(a)
      };
    }, i._run = function(a, o) {
      var f = this;
      return o === void 0 && (o = {}), new Promise(function(u, p) {
        try {
          var _ = f._root(a, o);
          Promise.resolve(f.func(_)).then(function(x) {
            var h = void 0;
            return f._shouldUpdateSelector(a, o) && (h = _.toString(), a.selector = h), {
              transform: x,
              root: _,
              string: h
            };
          }).then(u, p);
        } catch (x) {
          p(x);
          return;
        }
      });
    }, i._runSync = function(a, o) {
      o === void 0 && (o = {});
      var f = this._root(a, o), u = this.func(f);
      if (u && typeof u.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var p = void 0;
      return o.updateSelector && typeof a != "string" && (p = f.toString(), a.selector = p), {
        transform: u,
        root: f,
        string: p
      };
    }, i.ast = function(a, o) {
      return this._run(a, o).then(function(f) {
        return f.root;
      });
    }, i.astSync = function(a, o) {
      return this._runSync(a, o).root;
    }, i.transform = function(a, o) {
      return this._run(a, o).then(function(f) {
        return f.transform;
      });
    }, i.transformSync = function(a, o) {
      return this._runSync(a, o).transform;
    }, i.process = function(a, o) {
      return this._run(a, o).then(function(f) {
        return f.string || f.root.toString();
      });
    }, i.processSync = function(a, o) {
      var f = this._runSync(a, o);
      return f.string || f.root.toString();
    }, l;
  }();
  e.default = n, s.exports = e.default;
})(Kr, Kr.exports);
var qu = Kr.exports, Wa = {}, Me = {};
Me.__esModule = !0;
Me.universal = Me.tag = Me.string = Me.selector = Me.root = Me.pseudo = Me.nesting = Me.id = Me.comment = Me.combinator = Me.className = Me.attribute = void 0;
var Gu = Ge(Fn), Yu = Ge(Ia), Hu = Ge(za), Qu = Ge(Ra), Ju = Ge($a), Ku = Ge(Ua), Xu = Ge(La), Zu = Ge(Ta), ef = Ge(Ma), tf = Ge(Na), rf = Ge(Da), nf = Ge(Fa);
function Ge(s) {
  return s && s.__esModule ? s : { default: s };
}
var af = function(e) {
  return new Gu.default(e);
};
Me.attribute = af;
var sf = function(e) {
  return new Yu.default(e);
};
Me.className = sf;
var of = function(e) {
  return new Hu.default(e);
};
Me.combinator = of;
var lf = function(e) {
  return new Qu.default(e);
};
Me.comment = lf;
var uf = function(e) {
  return new Ju.default(e);
};
Me.id = uf;
var ff = function(e) {
  return new Ku.default(e);
};
Me.nesting = ff;
var cf = function(e) {
  return new Xu.default(e);
};
Me.pseudo = cf;
var df = function(e) {
  return new Zu.default(e);
};
Me.root = df;
var pf = function(e) {
  return new ef.default(e);
};
Me.selector = pf;
var hf = function(e) {
  return new tf.default(e);
};
Me.string = hf;
var mf = function(e) {
  return new rf.default(e);
};
Me.tag = mf;
var gf = function(e) {
  return new nf.default(e);
};
Me.universal = gf;
var ke = {};
ke.__esModule = !0;
ke.isComment = ke.isCombinator = ke.isClassName = ke.isAttribute = void 0;
ke.isContainer = Ef;
ke.isIdentifier = void 0;
ke.isNamespace = Pf;
ke.isNesting = void 0;
ke.isNode = zn;
ke.isPseudo = void 0;
ke.isPseudoClass = Cf;
ke.isPseudoElement = Ga;
ke.isUniversal = ke.isTag = ke.isString = ke.isSelector = ke.isRoot = void 0;
var $e = be, je, vf = (je = {}, je[$e.ATTRIBUTE] = !0, je[$e.CLASS] = !0, je[$e.COMBINATOR] = !0, je[$e.COMMENT] = !0, je[$e.ID] = !0, je[$e.NESTING] = !0, je[$e.PSEUDO] = !0, je[$e.ROOT] = !0, je[$e.SELECTOR] = !0, je[$e.STRING] = !0, je[$e.TAG] = !0, je[$e.UNIVERSAL] = !0, je);
function zn(s) {
  return typeof s == "object" && vf[s.type];
}
function Ye(s, e) {
  return zn(e) && e.type === s;
}
var Ba = Ye.bind(null, $e.ATTRIBUTE);
ke.isAttribute = Ba;
var yf = Ye.bind(null, $e.CLASS);
ke.isClassName = yf;
var wf = Ye.bind(null, $e.COMBINATOR);
ke.isCombinator = wf;
var bf = Ye.bind(null, $e.COMMENT);
ke.isComment = bf;
var xf = Ye.bind(null, $e.ID);
ke.isIdentifier = xf;
var _f = Ye.bind(null, $e.NESTING);
ke.isNesting = _f;
var Un = Ye.bind(null, $e.PSEUDO);
ke.isPseudo = Un;
var Sf = Ye.bind(null, $e.ROOT);
ke.isRoot = Sf;
var Of = Ye.bind(null, $e.SELECTOR);
ke.isSelector = Of;
var kf = Ye.bind(null, $e.STRING);
ke.isString = kf;
var qa = Ye.bind(null, $e.TAG);
ke.isTag = qa;
var Af = Ye.bind(null, $e.UNIVERSAL);
ke.isUniversal = Af;
function Ga(s) {
  return Un(s) && s.value && (s.value.startsWith("::") || s.value.toLowerCase() === ":before" || s.value.toLowerCase() === ":after" || s.value.toLowerCase() === ":first-letter" || s.value.toLowerCase() === ":first-line");
}
function Cf(s) {
  return Un(s) && !Ga(s);
}
function Ef(s) {
  return !!(zn(s) && s.walk);
}
function Pf(s) {
  return Ba(s) || qa(s);
}
(function(s) {
  s.__esModule = !0;
  var e = be;
  Object.keys(e).forEach(function(n) {
    n === "default" || n === "__esModule" || n in s && s[n] === e[n] || (s[n] = e[n]);
  });
  var t = Me;
  Object.keys(t).forEach(function(n) {
    n === "default" || n === "__esModule" || n in s && s[n] === t[n] || (s[n] = t[n]);
  });
  var r = ke;
  Object.keys(r).forEach(function(n) {
    n === "default" || n === "__esModule" || n in s && s[n] === r[n] || (s[n] = r[n]);
  });
})(Wa);
(function(s, e) {
  e.__esModule = !0, e.default = void 0;
  var t = i(qu), r = l(Wa);
  function n(o) {
    if (typeof WeakMap != "function")
      return null;
    var f = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
    return (n = function(_) {
      return _ ? u : f;
    })(o);
  }
  function l(o, f) {
    if (o && o.__esModule)
      return o;
    if (o === null || typeof o != "object" && typeof o != "function")
      return { default: o };
    var u = n(f);
    if (u && u.has(o))
      return u.get(o);
    var p = {}, _ = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in o)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(o, x)) {
        var h = _ ? Object.getOwnPropertyDescriptor(o, x) : null;
        h && (h.get || h.set) ? Object.defineProperty(p, x, h) : p[x] = o[x];
      }
    return p.default = o, u && u.set(o, p), p;
  }
  function i(o) {
    return o && o.__esModule ? o : { default: o };
  }
  var c = function(f) {
    return new t.default(f);
  };
  Object.assign(c, r), delete c.__esModule;
  var a = c;
  e.default = a, s.exports = e.default;
})(Jr, Jr.exports);
var Ke = Jr.exports;
const Qt = /* @__PURE__ */ Qe(Ke);
var Er = {}, jn = {}, Vn = { exports: {} };
const { Rule: Ya, AtRule: Tf } = qe;
let Ha = Ke;
function wn(s, e) {
  let t;
  try {
    Ha((r) => {
      t = r;
    }).processSync(s);
  } catch (r) {
    throw s.includes(":") ? e ? e.error("Missed semicolon") : r : e ? e.error(r.message) : r;
  }
  return t.at(0);
}
function Qa(s, e) {
  let t = !1;
  return s.each((r) => {
    if (r.type === "nesting") {
      let n = e.clone({});
      r.value !== "&" ? r.replaceWith(
        wn(r.value.replace("&", n.toString()))
      ) : r.replaceWith(n), t = !0;
    } else
      "nodes" in r && r.nodes && Qa(r, e) && (t = !0);
  }), t;
}
function Ja(s, e) {
  let t = [];
  return s.selectors.forEach((r) => {
    let n = wn(r, s);
    e.selectors.forEach((l) => {
      if (!l)
        return;
      let i = wn(l, e);
      Qa(i, n) || (i.prepend(Ha.combinator({ value: " " })), i.prepend(n.clone({}))), t.push(i.toString());
    });
  }), t;
}
function Vt(s, e) {
  let t = s.prev();
  for (e.after(s); t && t.type === "comment"; ) {
    let r = t.prev();
    e.after(t), t = r;
  }
  return s;
}
function Mf(s) {
  return function e(t, r, n, l = n) {
    let i = [];
    if (r.each((c) => {
      c.type === "rule" && n ? l && (c.selectors = Ja(t, c)) : c.type === "atrule" && c.nodes ? s[c.name] ? e(t, c, l) : r[Wn] !== !1 && i.push(c) : i.push(c);
    }), n && i.length) {
      let c = t.clone({ nodes: [] });
      for (let a of i)
        c.append(a);
      r.prepend(c);
    }
  };
}
function Pr(s, e, t) {
  let r = new Ya({
    selector: s,
    nodes: []
  });
  return r.append(e), t.after(r), r;
}
function Oi(s, e) {
  let t = {};
  for (let r of s)
    t[r] = !0;
  if (e)
    for (let r of e)
      t[r.replace(/^@/, "")] = !0;
  return t;
}
function If(s) {
  s = s.trim();
  let e = s.match(/^\((.*)\)$/);
  if (!e)
    return { type: "basic", selector: s };
  let t = e[1].match(/^(with(?:out)?):(.+)$/);
  if (t) {
    let r = t[1] === "with", n = Object.fromEntries(
      t[2].trim().split(/\s+/).map((i) => [i, !0])
    );
    if (r && n.all)
      return { type: "noop" };
    let l = (i) => !!n[i];
    return n.all ? l = () => !0 : r && (l = (i) => i === "all" ? !1 : !n[i]), {
      type: "withrules",
      escapes: l
    };
  }
  return { type: "unknown" };
}
function Rf(s) {
  let e = [], t = s.parent;
  for (; t && t instanceof Tf; )
    e.push(t), t = t.parent;
  return e;
}
function $f(s) {
  let e = s[Ka];
  if (!e)
    s.after(s.nodes);
  else {
    let t = s.nodes, r, n = -1, l, i, c, a = Rf(s);
    if (a.forEach((o, f) => {
      if (e(o.name))
        r = o, n = f, i = c;
      else {
        let u = c;
        c = o.clone({ nodes: [] }), u && c.append(u), l = l || c;
      }
    }), r ? i ? (l.append(t), r.after(i)) : r.after(t) : s.after(t), s.next() && r) {
      let o;
      a.slice(0, n + 1).forEach((f, u, p) => {
        let _ = o;
        o = f.clone({ nodes: [] }), _ && o.append(_);
        let x = [], m = (p[u - 1] || s).next();
        for (; m; )
          x.push(m), m = m.next();
        o.append(x);
      }), o && (i || t[t.length - 1]).after(o);
    }
  }
  s.remove();
}
const Wn = Symbol("rootRuleMergeSel"), Ka = Symbol("rootRuleEscapes");
function Df(s) {
  let { params: e } = s, { type: t, selector: r, escapes: n } = If(e);
  if (t === "unknown")
    throw s.error(
      `Unknown @${s.name} parameter ${JSON.stringify(e)}`
    );
  if (t === "basic" && r) {
    let l = new Ya({ selector: r, nodes: s.nodes });
    s.removeAll(), s.append(l);
  }
  s[Ka] = n, s[Wn] = n ? !n("all") : t === "noop";
}
const Tr = Symbol("hasRootRule");
Vn.exports = (s = {}) => {
  let e = Oi(
    ["media", "supports", "layer", "container"],
    s.bubble
  ), t = Mf(e), r = Oi(
    [
      "document",
      "font-face",
      "keyframes",
      "-webkit-keyframes",
      "-moz-keyframes"
    ],
    s.unwrap
  ), n = (s.rootRuleName || "at-root").replace(/^@/, ""), l = s.preserveEmpty;
  return {
    postcssPlugin: "postcss-nested",
    Once(i) {
      i.walkAtRules(n, (c) => {
        Df(c), i[Tr] = !0;
      });
    },
    Rule(i) {
      let c = !1, a = i, o = !1, f = [];
      i.each((u) => {
        u.type === "rule" ? (f.length && (a = Pr(i.selector, f, a), f = []), o = !0, c = !0, u.selectors = Ja(i, u), a = Vt(u, a)) : u.type === "atrule" ? (f.length && (a = Pr(i.selector, f, a), f = []), u.name === n ? (c = !0, t(i, u, !0, u[Wn]), a = Vt(u, a)) : e[u.name] ? (o = !0, c = !0, t(i, u, !0), a = Vt(u, a)) : r[u.name] ? (o = !0, c = !0, t(i, u, !1), a = Vt(u, a)) : o && f.push(u)) : u.type === "decl" && o && f.push(u);
      }), f.length && (a = Pr(i.selector, f, a)), c && l !== !0 && (i.raws.semicolon = !0, i.nodes.length === 0 && i.remove());
    },
    RootExit(i) {
      i[Tr] && (i.walkAtRules(n, $f), i[Tr] = !1);
    }
  };
};
Vn.exports.postcss = !0;
var Nf = Vn.exports, ki = /-(\w|$)/g, Ai = function(e, t) {
  return t.toUpperCase();
}, Lf = function(e) {
  return e = e.toLowerCase(), e === "float" ? "cssFloat" : e.charCodeAt(0) === 45 && e.charCodeAt(1) === 109 && e.charCodeAt(2) === 115 && e.charCodeAt(3) === 45 ? e.substr(1).replace(ki, Ai) : e.replace(ki, Ai);
}, Ff = Lf;
let zf = Ff, Uf = {
  boxFlex: !0,
  boxFlexGroup: !0,
  columnCount: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  strokeDashoffset: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
function Mr(s) {
  return typeof s.nodes > "u" ? !0 : Bn(s);
}
function Bn(s) {
  let e, t = {};
  return s.each((r) => {
    if (r.type === "atrule")
      e = "@" + r.name, r.params && (e += " " + r.params), typeof t[e] > "u" ? t[e] = Mr(r) : Array.isArray(t[e]) ? t[e].push(Mr(r)) : t[e] = [t[e], Mr(r)];
    else if (r.type === "rule") {
      let n = Bn(r);
      if (t[r.selector])
        for (let l in n)
          t[r.selector][l] = n[l];
      else
        t[r.selector] = n;
    } else if (r.type === "decl") {
      r.prop[0] === "-" && r.prop[1] === "-" || r.parent && r.parent.selector === ":export" ? e = r.prop : e = zf(r.prop);
      let n = r.value;
      !isNaN(r.value) && Uf[e] && (n = parseFloat(r.value)), r.important && (n += " !important"), typeof t[e] > "u" ? t[e] = n : Array.isArray(t[e]) ? t[e].push(n) : t[e] = [t[e], n];
    }
  }), t;
}
var Xa = Bn;
let xt = qe, Ci = /\s*!important\s*$/i, jf = {
  "box-flex": !0,
  "box-flex-group": !0,
  "column-count": !0,
  flex: !0,
  "flex-grow": !0,
  "flex-positive": !0,
  "flex-shrink": !0,
  "flex-negative": !0,
  "font-weight": !0,
  "line-clamp": !0,
  "line-height": !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  "tab-size": !0,
  widows: !0,
  "z-index": !0,
  zoom: !0,
  "fill-opacity": !0,
  "stroke-dashoffset": !0,
  "stroke-opacity": !0,
  "stroke-width": !0
};
function Vf(s) {
  return s.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function Ei(s, e, t) {
  t === !1 || t === null || (e.startsWith("--") || (e = Vf(e)), typeof t == "number" && (t === 0 || jf[e] ? t = t.toString() : t += "px"), e === "css-float" && (e = "float"), Ci.test(t) ? (t = t.replace(Ci, ""), s.push(xt.decl({ prop: e, value: t, important: !0 }))) : s.push(xt.decl({ prop: e, value: t })));
}
function Pi(s, e, t) {
  let r = xt.atRule({ name: e[1], params: e[3] || "" });
  typeof t == "object" && (r.nodes = [], qn(t, r)), s.push(r);
}
function qn(s, e) {
  let t, r, n;
  for (t in s)
    if (r = s[t], !(r === null || typeof r > "u"))
      if (t[0] === "@") {
        let l = t.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
        if (Array.isArray(r))
          for (let i of r)
            Pi(e, l, i);
        else
          Pi(e, l, r);
      } else if (Array.isArray(r))
        for (let l of r)
          Ei(e, t, l);
      else
        typeof r == "object" ? (n = xt.rule({ selector: t }), qn(r, n), e.push(n)) : Ei(e, t, r);
}
var Gn = function(s) {
  let e = xt.root();
  return qn(s, e), e;
};
let Wf = Xa;
var Za = function(e) {
  return console && console.warn && e.warnings().forEach((t) => {
    let r = t.plugin || "PostCSS";
    console.warn(r + ": " + t.text);
  }), Wf(e.root);
};
let Bf = qe, qf = Za, Gf = Gn;
var Yf = function(e) {
  let t = Bf(e);
  return async (r) => {
    let n = await t.process(r, {
      parser: Gf,
      from: void 0
    });
    return qf(n);
  };
};
let Hf = qe, Qf = Za, Jf = Gn;
var Kf = function(s) {
  let e = Hf(s);
  return (t) => {
    let r = e.process(t, { parser: Jf, from: void 0 });
    return Qf(r);
  };
};
let Xf = Xa, Zf = Gn, ec = Yf, tc = Kf;
var rc = {
  objectify: Xf,
  parse: Zf,
  async: ec,
  sync: tc
};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ n(qe), t = /* @__PURE__ */ n(Nf), r = /* @__PURE__ */ n(rc);
  function n(i) {
    return i && i.__esModule ? i : {
      default: i
    };
  }
  function l(i) {
    return Array.isArray(i) ? i.flatMap((c) => (0, e.default)([
      (0, t.default)({
        bubble: [
          "screen"
        ]
      })
    ]).process(c, {
      parser: r.default
    }).root.nodes) : l([
      i
    ]);
  }
})(jn);
var lr = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(
    s,
    /**
    * @template {string | import('postcss-selector-parser').Root} T
    *
    * Prefix all classes in the selector with the given prefix
    *
    * It can take either a string or a selector AST and will return the same type
    *
    * @param {string} prefix
    * @param {T} selector
    * @param {boolean} prependNegative
    * @returns {T}
    */
    "default",
    {
      enumerable: !0,
      get: function() {
        return r;
      }
    }
  );
  const e = /* @__PURE__ */ t(Ke);
  function t(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  function r(n, l, i = !1) {
    if (n === "")
      return l;
    let c = typeof l == "string" ? (0, e.default)().astSync(l) : l;
    return c.walkClasses((a) => {
      let o = a.value, f = i && o.startsWith("-");
      a.value = f ? `-${n}${o.slice(1)}` : `${n}${o}`;
    }), typeof l == "string" ? c.toString() : c;
  }
})(lr);
var Et = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(f, u) {
    for (var p in u)
      Object.defineProperty(f, p, {
        enumerable: !0,
        get: u[p]
      });
  }
  e(s, {
    env: function() {
      return t;
    },
    contextMap: function() {
      return r;
    },
    configContextMap: function() {
      return n;
    },
    contextSourcesMap: function() {
      return l;
    },
    sourceHashMap: function() {
      return i;
    },
    NOT_ON_DEMAND: function() {
      return c;
    },
    NONE: function() {
      return a;
    },
    resolveDebug: function() {
      return o;
    }
  });
  const t = typeof process < "u" ? {
    NODE_ENV: "production",
    DEBUG: o(process.env.DEBUG)
  } : {
    NODE_ENV: "production",
    DEBUG: !1
  }, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), c = new String("*"), a = Symbol("__NONE__");
  function o(f) {
    if (f === void 0)
      return !1;
    if (f === "true" || f === "1")
      return !0;
    if (f === "false" || f === "0")
      return !1;
    if (f === "*")
      return !0;
    let u = f.split(",").map((p) => p.split(":")[0]);
    return u.includes("-tailwindcss") ? !1 : !!u.includes("tailwindcss");
  }
})(Et);
var Yn = {}, pt = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r(Ke), t = /* @__PURE__ */ r(ar);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n(l) {
    var i;
    let c = e.default.className();
    c.value = l;
    var a;
    return (0, t.default)((a = c == null || (i = c.raws) === null || i === void 0 ? void 0 : i.value) !== null && a !== void 0 ? a : c.value);
  }
})(pt);
var ur = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "movePseudos", {
    enumerable: !0,
    get: function() {
      return t;
    }
  });
  let e = {
    // Pseudo elements from the spec
    "::after": [
      "terminal",
      "jumpable"
    ],
    "::backdrop": [
      "terminal",
      "jumpable"
    ],
    "::before": [
      "terminal",
      "jumpable"
    ],
    "::cue": [
      "terminal"
    ],
    "::cue-region": [
      "terminal"
    ],
    "::first-letter": [
      "terminal",
      "jumpable"
    ],
    "::first-line": [
      "terminal",
      "jumpable"
    ],
    "::grammar-error": [
      "terminal"
    ],
    "::marker": [
      "terminal",
      "jumpable"
    ],
    "::part": [
      "terminal",
      "actionable"
    ],
    "::placeholder": [
      "terminal",
      "jumpable"
    ],
    "::selection": [
      "terminal",
      "jumpable"
    ],
    "::slotted": [
      "terminal"
    ],
    "::spelling-error": [
      "terminal"
    ],
    "::target-text": [
      "terminal"
    ],
    // Pseudo elements from the spec with special rules
    "::file-selector-button": [
      "terminal",
      "actionable"
    ],
    // Library-specific pseudo elements used by component libraries
    // These are Shadow DOM-like
    "::deep": [
      "actionable"
    ],
    "::v-deep": [
      "actionable"
    ],
    "::ng-deep": [
      "actionable"
    ],
    // Note: As a rule, double colons (::) should be used instead of a single colon
    // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
    // this distinction was not present in older versions of the W3C spec, most
    // browsers support both syntaxes for the original pseudo-elements.
    ":after": [
      "terminal",
      "jumpable"
    ],
    ":before": [
      "terminal",
      "jumpable"
    ],
    ":first-letter": [
      "terminal",
      "jumpable"
    ],
    ":first-line": [
      "terminal",
      "jumpable"
    ],
    ":where": [],
    ":is": [],
    ":has": [],
    // The default value is used when the pseudo-element is not recognized
    // Because it's not recognized, we don't know if it's terminal or not
    // So we assume it can be moved AND can have user-action pseudo classes attached to it
    __default__: [
      "terminal",
      "actionable"
    ]
  };
  function t(a) {
    let [o] = r(a);
    return o.forEach(([f, u]) => f.removeChild(u)), a.nodes.push(...o.map(([, f]) => f)), a;
  }
  function r(a) {
    let o = [], f = null;
    for (let p of a.nodes)
      if (p.type === "combinator")
        o = o.filter(([, _]) => c(_).includes("jumpable")), f = null;
      else if (p.type === "pseudo") {
        l(p) ? (f = p, o.push([
          a,
          p,
          null
        ])) : f && i(p, f) ? o.push([
          a,
          p,
          f
        ]) : f = null;
        var u;
        for (let _ of (u = p.nodes) !== null && u !== void 0 ? u : []) {
          let [x, h] = r(_);
          f = h || f, o.push(...x);
        }
      }
    return [
      o,
      f
    ];
  }
  function n(a) {
    return a.value.startsWith("::") || e[a.value] !== void 0;
  }
  function l(a) {
    return n(a) && c(a).includes("terminal");
  }
  function i(a, o) {
    return a.type !== "pseudo" || n(a) ? !1 : c(o).includes("actionable");
  }
  function c(a) {
    var o;
    return (o = e[a.value]) !== null && o !== void 0 ? o : e.__default__;
  }
})(ur);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(m, C) {
    for (var S in C)
      Object.defineProperty(m, S, {
        enumerable: !0,
        get: C[S]
      });
  }
  e(s, {
    formatVariantSelector: function() {
      return f;
    },
    eliminateIrrelevantSelectors: function() {
      return _;
    },
    finalizeSelector: function() {
      return x;
    },
    handleMergePseudo: function() {
      return h;
    }
  });
  const t = /* @__PURE__ */ a(Ke), r = /* @__PURE__ */ a(Rn), n = /* @__PURE__ */ a(pt), l = /* @__PURE__ */ a(lr), i = ur, c = ot;
  function a(m) {
    return m && m.__esModule ? m : {
      default: m
    };
  }
  let o = ":merge";
  function f(m, { context: C, candidate: S }) {
    var k;
    let O = (k = C == null ? void 0 : C.tailwindConfig.prefix) !== null && k !== void 0 ? k : "", E = m.map((D) => {
      let P = (0, t.default)().astSync(D.format);
      return {
        ...D,
        ast: D.respectPrefix ? (0, l.default)(O, P) : P
      };
    }), M = t.default.root({
      nodes: [
        t.default.selector({
          nodes: [
            t.default.className({
              value: (0, n.default)(S)
            })
          ]
        })
      ]
    });
    for (let { ast: D } of E)
      [M, D] = h(M, D), D.walkNesting((P) => P.replaceWith(...M.nodes[0].nodes)), M = D;
    return M;
  }
  function u(m) {
    let C = [];
    for (; m.prev() && m.prev().type !== "combinator"; )
      m = m.prev();
    for (; m && m.type !== "combinator"; )
      C.push(m), m = m.next();
    return C;
  }
  function p(m) {
    return m.sort((C, S) => C.type === "tag" && S.type === "class" ? -1 : C.type === "class" && S.type === "tag" ? 1 : C.type === "class" && S.type === "pseudo" && S.value.startsWith("::") ? -1 : C.type === "pseudo" && C.value.startsWith("::") && S.type === "class" ? 1 : m.index(C) - m.index(S)), m;
  }
  function _(m, C) {
    let S = !1;
    m.walk((k) => {
      if (k.type === "class" && k.value === C)
        return S = !0, !1;
    }), S || m.remove();
  }
  function x(m, C, { context: S, candidate: k, base: O }) {
    var E, M;
    let D = (M = S == null || (E = S.tailwindConfig) === null || E === void 0 ? void 0 : E.separator) !== null && M !== void 0 ? M : ":";
    O = O ?? (0, c.splitAtTopLevelOnly)(k, D).pop();
    let P = (0, t.default)().astSync(m);
    if (P.walkClasses((T) => {
      T.raws && T.value.includes(O) && (T.raws.value = (0, n.default)((0, r.default)(T.raws.value)));
    }), P.each((T) => _(T, O)), P.length === 0)
      return null;
    let b = Array.isArray(C) ? f(C, {
      context: S,
      candidate: k
    }) : C;
    if (b === null)
      return P.toString();
    let A = t.default.comment({
      value: "/*__simple__*/"
    }), N = t.default.comment({
      value: "/*__simple__*/"
    });
    return P.walkClasses((T) => {
      if (T.value !== O)
        return;
      let V = T.parent, d = b.nodes[0].nodes;
      if (V.nodes.length === 1) {
        T.replaceWith(...d);
        return;
      }
      let g = u(T);
      V.insertBefore(g[0], A), V.insertAfter(g[g.length - 1], N);
      for (let y of d)
        V.insertBefore(g[0], y.clone());
      T.remove(), g = u(A);
      let v = V.index(A);
      V.nodes.splice(v, g.length, ...p(t.default.selector({
        nodes: g
      })).nodes), A.remove(), N.remove();
    }), P.walkPseudos((T) => {
      T.value === o && T.replaceWith(T.nodes);
    }), P.each((T) => (0, i.movePseudos)(T)), P.toString();
  }
  function h(m, C) {
    let S = [];
    return m.walkPseudos((k) => {
      k.value === o && S.push({
        pseudo: k,
        value: k.nodes[0].toString()
      });
    }), C.walkPseudos((k) => {
      if (k.value !== o)
        return;
      let O = k.nodes[0].toString(), E = S.find((b) => b.value === O);
      if (!E)
        return;
      let M = [], D = k.next();
      for (; D && D.type !== "combinator"; )
        M.push(D), D = D.next();
      let P = D;
      E.pseudo.parent.insertAfter(E.pseudo, t.default.selector({
        nodes: M.map((b) => b.clone())
      })), k.remove(), M.forEach((b) => b.remove()), P && P.type === "combinator" && P.remove();
    }), [
      m,
      C
    ];
  }
})(Yn);
var Hn = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(a, o) {
    for (var f in o)
      Object.defineProperty(a, f, {
        enumerable: !0,
        get: o[f]
      });
  }
  e(s, {
    asClass: function() {
      return l;
    },
    default: function() {
      return i;
    },
    formatClass: function() {
      return c;
    }
  });
  const t = /* @__PURE__ */ n(pt), r = /* @__PURE__ */ n(ar);
  function n(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  function l(a) {
    return (0, r.default)(`.${(0, t.default)(a)}`);
  }
  function i(a, o) {
    return l(c(a, o));
  }
  function c(a, o) {
    return o === "DEFAULT" ? a : o === "-" || o === "-DEFAULT" ? `-${a}` : o.startsWith("-") ? `-${a}${o}` : o.startsWith("/") ? `${a}${o}` : `${a}-${o}`;
  }
})(Hn);
var Ir = {}, Rr = {}, es = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  const e = /* @__PURE__ */ t(Ot);
  function t(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  function r(n, l = [
    [
      n,
      [
        n
      ]
    ]
  ], { filterDefault: i = !1, ...c } = {}) {
    let a = (0, e.default)(n);
    return function({ matchUtilities: o, theme: f }) {
      for (let p of l) {
        let _ = Array.isArray(p[0]) ? p : [
          p
        ];
        var u;
        o(_.reduce((x, [h, m]) => Object.assign(x, {
          [h]: (C) => m.reduce((S, k) => Array.isArray(k) ? Object.assign(S, {
            [k[0]]: k[1]
          }) : Object.assign(S, {
            [k]: a(C)
          }), {})
        }), {}), {
          ...c,
          values: i ? Object.fromEntries(Object.entries((u = f(n)) !== null && u !== void 0 ? u : {}).filter(([x]) => x !== "DEFAULT")) : f(n)
        });
      }
    };
  }
})(es);
var ts = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return u;
    }
  });
  const e = /* @__PURE__ */ new Set([
    "normal",
    "reverse",
    "alternate",
    "alternate-reverse"
  ]), t = /* @__PURE__ */ new Set([
    "running",
    "paused"
  ]), r = /* @__PURE__ */ new Set([
    "none",
    "forwards",
    "backwards",
    "both"
  ]), n = /* @__PURE__ */ new Set([
    "infinite"
  ]), l = /* @__PURE__ */ new Set([
    "linear",
    "ease",
    "ease-in",
    "ease-out",
    "ease-in-out",
    "step-start",
    "step-end"
  ]), i = [
    "cubic-bezier",
    "steps"
  ], c = /\,(?![^(]*\))/g, a = /\ +(?![^(]*\))/g, o = /^(-?[\d.]+m?s)$/, f = /^(\d+)$/;
  function u(p) {
    return p.split(c).map((x) => {
      let h = x.trim(), m = {
        value: h
      }, C = h.split(a), S = /* @__PURE__ */ new Set();
      for (let k of C)
        !S.has("DIRECTIONS") && e.has(k) ? (m.direction = k, S.add("DIRECTIONS")) : !S.has("PLAY_STATES") && t.has(k) ? (m.playState = k, S.add("PLAY_STATES")) : !S.has("FILL_MODES") && r.has(k) ? (m.fillMode = k, S.add("FILL_MODES")) : !S.has("ITERATION_COUNTS") && (n.has(k) || f.test(k)) ? (m.iterationCount = k, S.add("ITERATION_COUNTS")) : !S.has("TIMING_FUNCTION") && l.has(k) || !S.has("TIMING_FUNCTION") && i.some((O) => k.startsWith(`${O}(`)) ? (m.timingFunction = k, S.add("TIMING_FUNCTION")) : !S.has("DURATION") && o.test(k) ? (m.duration = k, S.add("DURATION")) : !S.has("DELAY") && o.test(k) ? (m.delay = k, S.add("DELAY")) : S.has("NAME") ? (m.unknown || (m.unknown = []), m.unknown.push(k)) : (m.name = k, S.add("NAME"));
      return m;
    });
  }
})(ts);
var rs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return t;
    }
  });
  const e = (r) => Object.assign({}, ...Object.entries(r ?? {}).flatMap(([n, l]) => typeof l == "object" ? Object.entries(e(l)).map(([i, c]) => ({
    [n + (i === "DEFAULT" ? "" : `-${i}`)]: c
  })) : [
    {
      [`${n}`]: l
    }
  ])), t = e;
})(rs);
var Qn = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    return typeof t == "function" ? t({}) : t;
  }
})(Qn);
const nc = "tailwindcss", ic = "3.4.10", ac = "A utility-first CSS framework for rapidly building custom user interfaces.", sc = "MIT", oc = "lib/index.js", lc = "types/index.d.ts", uc = "https://github.com/tailwindlabs/tailwindcss.git", fc = "https://github.com/tailwindlabs/tailwindcss/issues", cc = "https://tailwindcss.com", dc = {
  tailwind: "lib/cli.js",
  tailwindcss: "lib/cli.js"
}, pc = {
  prebuild: "npm run generate && rimraf lib",
  build: "swc src --out-dir lib --copy-files",
  postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false",
  "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js",
  style: "eslint .",
  pretest: "npm run generate",
  test: "jest",
  "test:integrations": "npm run test --prefix ./integrations",
  "install:integrations": "node scripts/install-integrations.js",
  "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js",
  "generate:types": "node -r @swc/register scripts/generate-types.js",
  generate: "npm run generate:plugin-list && npm run generate:types",
  "release-channel": "node ./scripts/release-channel.js",
  "release-notes": "node ./scripts/release-notes.js",
  prepublishOnly: "npm install --force && npm run build"
}, hc = [
  "src/*",
  "cli/*",
  "lib/*",
  "peers/*",
  "scripts/*.js",
  "stubs/*",
  "nesting/*",
  "types/**/*",
  "*.d.ts",
  "*.css",
  "*.js"
], mc = {
  "@swc/cli": "^0.1.62",
  "@swc/core": "^1.3.55",
  "@swc/jest": "^0.2.26",
  "@swc/register": "^0.1.10",
  autoprefixer: "^10.4.14",
  browserslist: "^4.21.5",
  concurrently: "^8.0.1",
  cssnano: "^6.1.2",
  esbuild: "^0.20.2",
  eslint: "^8.39.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^4.2.1",
  jest: "^29.6.0",
  "jest-diff": "^29.6.0",
  lightningcss: "1.24.1",
  prettier: "^2.8.8",
  rimraf: "^5.0.0",
  "source-map-js": "^1.0.2",
  turbo: "^1.9.3"
}, gc = {
  "@alloc/quick-lru": "^5.2.0",
  arg: "^5.0.2",
  chokidar: "^3.5.3",
  didyoumean: "^1.2.2",
  dlv: "^1.1.3",
  "fast-glob": "^3.3.0",
  "glob-parent": "^6.0.2",
  "is-glob": "^4.0.3",
  jiti: "^1.21.0",
  lilconfig: "^2.1.0",
  micromatch: "^4.0.5",
  "normalize-path": "^3.0.0",
  "object-hash": "^3.0.0",
  picocolors: "^1.0.0",
  postcss: "^8.4.23",
  "postcss-import": "^15.1.0",
  "postcss-js": "^4.0.1",
  "postcss-load-config": "^4.0.1",
  "postcss-nested": "^6.0.1",
  "postcss-selector-parser": "^6.0.11",
  resolve: "^1.22.2",
  sucrase: "^3.32.0"
}, vc = [
  "> 1%",
  "not edge <= 18",
  "not ie 11",
  "not op_mini all"
], yc = {
  testTimeout: 3e4,
  setupFilesAfterEnv: [
    "<rootDir>/jest/customMatchers.js"
  ],
  testPathIgnorePatterns: [
    "/node_modules/",
    "/integrations/",
    "/standalone-cli/",
    "\\.test\\.skip\\.js$"
  ],
  transformIgnorePatterns: [
    "node_modules/(?!lightningcss)"
  ],
  transform: {
    "\\.js$": "@swc/jest",
    "\\.ts$": "@swc/jest"
  }
}, wc = {
  node: ">=14.0.0"
}, bc = {
  name: nc,
  version: ic,
  description: ac,
  license: sc,
  main: oc,
  types: lc,
  repository: uc,
  bugs: fc,
  homepage: cc,
  bin: dc,
  scripts: pc,
  files: hc,
  devDependencies: mc,
  dependencies: gc,
  browserslist: vc,
  jest: yc,
  engines: wc
};
var ns = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "removeAlphaVariables", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t, r) {
    t.walkDecls((n) => {
      if (r.includes(n.prop)) {
        n.remove();
        return;
      }
      for (let l of r)
        n.value.includes(`/ var(${l})`) && (n.value = n.value.replace(`/ var(${l})`, ""));
    });
  }
})(ns);
var Ti;
function xc() {
  return Ti || (Ti = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: !0
    });
    function e(d, g) {
      for (var v in g)
        Object.defineProperty(d, v, {
          enumerable: !0,
          get: g[v]
        });
    }
    e(s, {
      variantPlugins: function() {
        return b;
      },
      corePlugins: function() {
        return V;
      }
    });
    const t = /* @__PURE__ */ M(Le), r = /* @__PURE__ */ P(Le), n = /* @__PURE__ */ M(qe), l = /* @__PURE__ */ M(es), i = /* @__PURE__ */ M(nr), c = /* @__PURE__ */ M(pt), a = /* @__PURE__ */ M(ts), o = /* @__PURE__ */ M(rs), f = /* @__PURE__ */ P(kt), u = /* @__PURE__ */ M(Qn), p = /* @__PURE__ */ M(dt), _ = /* @__PURE__ */ M(Ot), x = bc, h = /* @__PURE__ */ M(et), m = rr, C = Mn, S = ns, k = it, O = Ct, E = Kn();
    function M(d) {
      return d && d.__esModule ? d : {
        default: d
      };
    }
    function D(d) {
      if (typeof WeakMap != "function")
        return null;
      var g = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
      return (D = function(y) {
        return y ? v : g;
      })(d);
    }
    function P(d, g) {
      if (d && d.__esModule)
        return d;
      if (d === null || typeof d != "object" && typeof d != "function")
        return {
          default: d
        };
      var v = D(g);
      if (v && v.has(d))
        return v.get(d);
      var y = {}, R = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var F in d)
        if (F !== "default" && Object.prototype.hasOwnProperty.call(d, F)) {
          var $ = R ? Object.getOwnPropertyDescriptor(d, F) : null;
          $ && ($.get || $.set) ? Object.defineProperty(y, F, $) : y[F] = d[F];
        }
      return y.default = d, v && v.set(d, y), y;
    }
    let b = {
      childVariant: ({ addVariant: d }) => {
        d("*", "& > *");
      },
      pseudoElementVariants: ({ addVariant: d }) => {
        d("first-letter", "&::first-letter"), d("first-line", "&::first-line"), d("marker", [
          ({ container: g }) => ((0, S.removeAlphaVariables)(g, [
            "--tw-text-opacity"
          ]), "& *::marker"),
          ({ container: g }) => ((0, S.removeAlphaVariables)(g, [
            "--tw-text-opacity"
          ]), "&::marker")
        ]), d("selection", [
          "& *::selection",
          "&::selection"
        ]), d("file", "&::file-selector-button"), d("placeholder", "&::placeholder"), d("backdrop", "&::backdrop"), d("before", ({ container: g }) => (g.walkRules((v) => {
          let y = !1;
          v.walkDecls("content", () => {
            y = !0;
          }), y || v.prepend(n.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::before")), d("after", ({ container: g }) => (g.walkRules((v) => {
          let y = !1;
          v.walkDecls("content", () => {
            y = !0;
          }), y || v.prepend(n.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::after"));
      },
      pseudoClassVariants: ({ addVariant: d, matchVariant: g, config: v, prefix: y }) => {
        let R = [
          // Positional
          [
            "first",
            "&:first-child"
          ],
          [
            "last",
            "&:last-child"
          ],
          [
            "only",
            "&:only-child"
          ],
          [
            "odd",
            "&:nth-child(odd)"
          ],
          [
            "even",
            "&:nth-child(even)"
          ],
          "first-of-type",
          "last-of-type",
          "only-of-type",
          // State
          [
            "visited",
            ({ container: $ }) => ((0, S.removeAlphaVariables)($, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]), "&:visited")
          ],
          "target",
          [
            "open",
            "&[open]"
          ],
          // Forms
          "default",
          "checked",
          "indeterminate",
          "placeholder-shown",
          "autofill",
          "optional",
          "required",
          "valid",
          "invalid",
          "in-range",
          "out-of-range",
          "read-only",
          // Content
          "empty",
          // Interactive
          "focus-within",
          [
            "hover",
            (0, k.flagEnabled)(v(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
          ],
          "focus",
          "focus-visible",
          "active",
          "enabled",
          "disabled"
        ].map(($) => Array.isArray($) ? $ : [
          $,
          `&:${$}`
        ]);
        for (let [$, z] of R)
          d($, (j) => typeof z == "function" ? z(j) : z);
        let F = {
          group: ($, { modifier: z }) => z ? [
            `:merge(${y(".group")}\\/${(0, c.default)(z)})`,
            " &"
          ] : [
            `:merge(${y(".group")})`,
            " &"
          ],
          peer: ($, { modifier: z }) => z ? [
            `:merge(${y(".peer")}\\/${(0, c.default)(z)})`,
            " ~ &"
          ] : [
            `:merge(${y(".peer")})`,
            " ~ &"
          ]
        };
        for (let [$, z] of Object.entries(F))
          g($, (j = "", W) => {
            let I = (0, O.normalize)(typeof j == "function" ? j(W) : j);
            I.includes("&") || (I = "&" + I);
            let [G, re] = z("", W), w = null, L = null, B = 0;
            for (let H = 0; H < I.length; ++H) {
              let Y = I[H];
              Y === "&" ? w = H : Y === "'" || Y === '"' ? B += 1 : w !== null && Y === " " && !B && (L = H);
            }
            return w !== null && L === null && (L = I.length), I.slice(0, w) + G + I.slice(w + 1, L) + re + I.slice(L);
          }, {
            values: Object.fromEntries(R),
            [E.INTERNAL_FEATURES]: {
              respectPrefix: !1
            }
          });
      },
      directionVariants: ({ addVariant: d }) => {
        d("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), d("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
      },
      reducedMotionVariants: ({ addVariant: d }) => {
        d("motion-safe", "@media (prefers-reduced-motion: no-preference)"), d("motion-reduce", "@media (prefers-reduced-motion: reduce)");
      },
      darkVariants: ({ config: d, addVariant: g }) => {
        let [v, y = ".dark"] = [].concat(d("darkMode", "media"));
        if (v === !1 && (v = "media", h.default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ])), v === "variant") {
          let R;
          if (Array.isArray(y) || typeof y == "function" ? R = y : typeof y == "string" && (R = [
            y
          ]), Array.isArray(R))
            for (let F of R)
              F === ".dark" ? (v = !1, h.default.warn("darkmode-variant-without-selector", [
                "When using `variant` for `darkMode`, you must provide a selector.",
                'Example: `darkMode: ["variant", ".your-selector &"]`'
              ])) : F.includes("&") || (v = !1, h.default.warn("darkmode-variant-without-ampersand", [
                "When using `variant` for `darkMode`, your selector must contain `&`.",
                'Example `darkMode: ["variant", ".your-selector &"]`'
              ]));
          y = R;
        }
        v === "selector" ? g("dark", `&:where(${y}, ${y} *)`) : v === "media" ? g("dark", "@media (prefers-color-scheme: dark)") : v === "variant" ? g("dark", y) : v === "class" && g("dark", `&:is(${y} *)`);
      },
      printVariant: ({ addVariant: d }) => {
        d("print", "@media print");
      },
      screenVariants: ({ theme: d, addVariant: g, matchVariant: v }) => {
        var y;
        let R = (y = d("screens")) !== null && y !== void 0 ? y : {}, F = Object.values(R).every((J) => typeof J == "string"), $ = (0, m.normalizeScreens)(d("screens")), z = /* @__PURE__ */ new Set([]);
        function j(J) {
          var ee, Q;
          return (Q = (ee = J.match(/(\D+)$/)) === null || ee === void 0 ? void 0 : ee[1]) !== null && Q !== void 0 ? Q : "(none)";
        }
        function W(J) {
          J !== void 0 && z.add(j(J));
        }
        function I(J) {
          return W(J), z.size === 1;
        }
        for (const J of $)
          for (const ee of J.values)
            W(ee.min), W(ee.max);
        let G = z.size <= 1;
        function re(J) {
          return Object.fromEntries($.filter((ee) => (0, m.isScreenSortable)(ee).result).map((ee) => {
            let { min: Q, max: le } = ee.values[0];
            if (le !== void 0)
              return ee;
            if (Q !== void 0)
              return {
                ...ee,
                not: !ee.not
              };
          }).map((ee) => [
            ee.name,
            ee
          ]));
        }
        function w(J) {
          return (ee, Q) => (0, m.compareScreens)(J, ee.value, Q.value);
        }
        let L = w("max"), B = w("min");
        function H(J) {
          return (ee) => {
            if (F)
              if (G) {
                if (typeof ee == "string" && !I(ee))
                  return h.default.warn("minmax-have-mixed-units", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                  ]), [];
              } else
                return h.default.warn("mixed-screen-units", [
                  "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                ]), [];
            else
              return h.default.warn("complex-screen-config", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
              ]), [];
            return [
              `@media ${(0, i.default)((0, m.toScreen)(ee, J))}`
            ];
          };
        }
        v("max", H("max"), {
          sort: L,
          values: F ? re() : {}
        });
        let Y = "min-screens";
        for (let J of $)
          g(J.name, `@media ${(0, i.default)(J)}`, {
            id: Y,
            sort: F && G ? B : void 0,
            value: J
          });
        v("min", H("min"), {
          id: Y,
          sort: B
        });
      },
      supportsVariants: ({ matchVariant: d, theme: g }) => {
        var v;
        d("supports", (y = "") => {
          let R = (0, O.normalize)(y), F = /^\w*\s*\(/.test(R);
          return R = F ? R.replace(/\b(and|or|not)\b/g, " $1 ") : R, F ? `@supports ${R}` : (R.includes(":") || (R = `${R}: var(--tw)`), R.startsWith("(") && R.endsWith(")") || (R = `(${R})`), `@supports ${R}`);
        }, {
          values: (v = g("supports")) !== null && v !== void 0 ? v : {}
        });
      },
      hasVariants: ({ matchVariant: d, prefix: g }) => {
        d("has", (v) => `&:has(${(0, O.normalize)(v)})`, {
          values: {},
          [E.INTERNAL_FEATURES]: {
            respectPrefix: !1
          }
        }), d("group-has", (v, { modifier: y }) => y ? `:merge(${g(".group")}\\/${y}):has(${(0, O.normalize)(v)}) &` : `:merge(${g(".group")}):has(${(0, O.normalize)(v)}) &`, {
          values: {},
          [E.INTERNAL_FEATURES]: {
            respectPrefix: !1
          }
        }), d("peer-has", (v, { modifier: y }) => y ? `:merge(${g(".peer")}\\/${y}):has(${(0, O.normalize)(v)}) ~ &` : `:merge(${g(".peer")}):has(${(0, O.normalize)(v)}) ~ &`, {
          values: {},
          [E.INTERNAL_FEATURES]: {
            respectPrefix: !1
          }
        });
      },
      ariaVariants: ({ matchVariant: d, theme: g }) => {
        var v;
        d("aria", (F) => `&[aria-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}]`, {
          values: (v = g("aria")) !== null && v !== void 0 ? v : {}
        });
        var y;
        d("group-aria", (F, { modifier: $ }) => $ ? `:merge(.group\\/${$})[aria-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] &` : `:merge(.group)[aria-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] &`, {
          values: (y = g("aria")) !== null && y !== void 0 ? y : {}
        });
        var R;
        d("peer-aria", (F, { modifier: $ }) => $ ? `:merge(.peer\\/${$})[aria-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] ~ &` : `:merge(.peer)[aria-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] ~ &`, {
          values: (R = g("aria")) !== null && R !== void 0 ? R : {}
        });
      },
      dataVariants: ({ matchVariant: d, theme: g }) => {
        var v;
        d("data", (F) => `&[data-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}]`, {
          values: (v = g("data")) !== null && v !== void 0 ? v : {}
        });
        var y;
        d("group-data", (F, { modifier: $ }) => $ ? `:merge(.group\\/${$})[data-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] &` : `:merge(.group)[data-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] &`, {
          values: (y = g("data")) !== null && y !== void 0 ? y : {}
        });
        var R;
        d("peer-data", (F, { modifier: $ }) => $ ? `:merge(.peer\\/${$})[data-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] ~ &` : `:merge(.peer)[data-${(0, O.normalizeAttributeSelectors)((0, O.normalize)(F))}] ~ &`, {
          values: (R = g("data")) !== null && R !== void 0 ? R : {}
        });
      },
      orientationVariants: ({ addVariant: d }) => {
        d("portrait", "@media (orientation: portrait)"), d("landscape", "@media (orientation: landscape)");
      },
      prefersContrastVariants: ({ addVariant: d }) => {
        d("contrast-more", "@media (prefers-contrast: more)"), d("contrast-less", "@media (prefers-contrast: less)");
      },
      forcedColorsVariants: ({ addVariant: d }) => {
        d("forced-colors", "@media (forced-colors: active)");
      }
    }, A = [
      "translate(var(--tw-translate-x), var(--tw-translate-y))",
      "rotate(var(--tw-rotate))",
      "skewX(var(--tw-skew-x))",
      "skewY(var(--tw-skew-y))",
      "scaleX(var(--tw-scale-x))",
      "scaleY(var(--tw-scale-y))"
    ].join(" "), N = [
      "var(--tw-blur)",
      "var(--tw-brightness)",
      "var(--tw-contrast)",
      "var(--tw-grayscale)",
      "var(--tw-hue-rotate)",
      "var(--tw-invert)",
      "var(--tw-saturate)",
      "var(--tw-sepia)",
      "var(--tw-drop-shadow)"
    ].join(" "), T = [
      "var(--tw-backdrop-blur)",
      "var(--tw-backdrop-brightness)",
      "var(--tw-backdrop-contrast)",
      "var(--tw-backdrop-grayscale)",
      "var(--tw-backdrop-hue-rotate)",
      "var(--tw-backdrop-invert)",
      "var(--tw-backdrop-opacity)",
      "var(--tw-backdrop-saturate)",
      "var(--tw-backdrop-sepia)"
    ].join(" "), V = {
      preflight: ({ addBase: d }) => {
        let g = n.default.parse(t.default.readFileSync(r.join(__dirname, "./css/preflight.css"), "utf8"));
        d([
          n.default.comment({
            text: `! tailwindcss v${x.version} | MIT License | https://tailwindcss.com`
          }),
          ...g.nodes
        ]);
      },
      container: /* @__PURE__ */ (() => {
        function d(v = []) {
          return v.flatMap((y) => y.values.map((R) => R.min)).filter((y) => y !== void 0);
        }
        function g(v, y, R) {
          if (typeof R > "u")
            return [];
          if (!(typeof R == "object" && R !== null))
            return [
              {
                screen: "DEFAULT",
                minWidth: 0,
                padding: R
              }
            ];
          let F = [];
          R.DEFAULT && F.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: R.DEFAULT
          });
          for (let $ of v)
            for (let z of y)
              for (let { min: j } of z.values)
                j === $ && F.push({
                  minWidth: $,
                  padding: R[z.name]
                });
          return F;
        }
        return function({ addComponents: v, theme: y }) {
          let R = (0, m.normalizeScreens)(y("container.screens", y("screens"))), F = d(R), $ = g(F, R, y("container.padding")), z = (W) => {
            let I = $.find((G) => G.minWidth === W);
            return I ? {
              paddingRight: I.padding,
              paddingLeft: I.padding
            } : {};
          }, j = Array.from(new Set(F.slice().sort((W, I) => parseInt(W) - parseInt(I)))).map((W) => ({
            [`@media (min-width: ${W})`]: {
              ".container": {
                "max-width": W,
                ...z(W)
              }
            }
          }));
          v([
            {
              ".container": Object.assign({
                width: "100%"
              }, y("container.center", !1) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, z(0))
            },
            ...j
          ]);
        };
      })(),
      accessibility: ({ addUtilities: d }) => {
        d({
          ".sr-only": {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: "0",
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0"
          },
          ".not-sr-only": {
            position: "static",
            width: "auto",
            height: "auto",
            padding: "0",
            margin: "0",
            overflow: "visible",
            clip: "auto",
            whiteSpace: "normal"
          }
        });
      },
      pointerEvents: ({ addUtilities: d }) => {
        d({
          ".pointer-events-none": {
            "pointer-events": "none"
          },
          ".pointer-events-auto": {
            "pointer-events": "auto"
          }
        });
      },
      visibility: ({ addUtilities: d }) => {
        d({
          ".visible": {
            visibility: "visible"
          },
          ".invisible": {
            visibility: "hidden"
          },
          ".collapse": {
            visibility: "collapse"
          }
        });
      },
      position: ({ addUtilities: d }) => {
        d({
          ".static": {
            position: "static"
          },
          ".fixed": {
            position: "fixed"
          },
          ".absolute": {
            position: "absolute"
          },
          ".relative": {
            position: "relative"
          },
          ".sticky": {
            position: "sticky"
          }
        });
      },
      inset: (0, l.default)("inset", [
        [
          "inset",
          [
            "inset"
          ]
        ],
        [
          [
            "inset-x",
            [
              "left",
              "right"
            ]
          ],
          [
            "inset-y",
            [
              "top",
              "bottom"
            ]
          ]
        ],
        [
          [
            "start",
            [
              "inset-inline-start"
            ]
          ],
          [
            "end",
            [
              "inset-inline-end"
            ]
          ],
          [
            "top",
            [
              "top"
            ]
          ],
          [
            "right",
            [
              "right"
            ]
          ],
          [
            "bottom",
            [
              "bottom"
            ]
          ],
          [
            "left",
            [
              "left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      isolation: ({ addUtilities: d }) => {
        d({
          ".isolate": {
            isolation: "isolate"
          },
          ".isolation-auto": {
            isolation: "auto"
          }
        });
      },
      zIndex: (0, l.default)("zIndex", [
        [
          "z",
          [
            "zIndex"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      order: (0, l.default)("order", void 0, {
        supportsNegativeValues: !0
      }),
      gridColumn: (0, l.default)("gridColumn", [
        [
          "col",
          [
            "gridColumn"
          ]
        ]
      ]),
      gridColumnStart: (0, l.default)("gridColumnStart", [
        [
          "col-start",
          [
            "gridColumnStart"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      gridColumnEnd: (0, l.default)("gridColumnEnd", [
        [
          "col-end",
          [
            "gridColumnEnd"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      gridRow: (0, l.default)("gridRow", [
        [
          "row",
          [
            "gridRow"
          ]
        ]
      ]),
      gridRowStart: (0, l.default)("gridRowStart", [
        [
          "row-start",
          [
            "gridRowStart"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      gridRowEnd: (0, l.default)("gridRowEnd", [
        [
          "row-end",
          [
            "gridRowEnd"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      float: ({ addUtilities: d }) => {
        d({
          ".float-start": {
            float: "inline-start"
          },
          ".float-end": {
            float: "inline-end"
          },
          ".float-right": {
            float: "right"
          },
          ".float-left": {
            float: "left"
          },
          ".float-none": {
            float: "none"
          }
        });
      },
      clear: ({ addUtilities: d }) => {
        d({
          ".clear-start": {
            clear: "inline-start"
          },
          ".clear-end": {
            clear: "inline-end"
          },
          ".clear-left": {
            clear: "left"
          },
          ".clear-right": {
            clear: "right"
          },
          ".clear-both": {
            clear: "both"
          },
          ".clear-none": {
            clear: "none"
          }
        });
      },
      margin: (0, l.default)("margin", [
        [
          "m",
          [
            "margin"
          ]
        ],
        [
          [
            "mx",
            [
              "margin-left",
              "margin-right"
            ]
          ],
          [
            "my",
            [
              "margin-top",
              "margin-bottom"
            ]
          ]
        ],
        [
          [
            "ms",
            [
              "margin-inline-start"
            ]
          ],
          [
            "me",
            [
              "margin-inline-end"
            ]
          ],
          [
            "mt",
            [
              "margin-top"
            ]
          ],
          [
            "mr",
            [
              "margin-right"
            ]
          ],
          [
            "mb",
            [
              "margin-bottom"
            ]
          ],
          [
            "ml",
            [
              "margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      boxSizing: ({ addUtilities: d }) => {
        d({
          ".box-border": {
            "box-sizing": "border-box"
          },
          ".box-content": {
            "box-sizing": "content-box"
          }
        });
      },
      lineClamp: ({ matchUtilities: d, addUtilities: g, theme: v }) => {
        d({
          "line-clamp": (y) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${y}`
          })
        }, {
          values: v("lineClamp")
        }), g({
          ".line-clamp-none": {
            overflow: "visible",
            display: "block",
            "-webkit-box-orient": "horizontal",
            "-webkit-line-clamp": "none"
          }
        });
      },
      display: ({ addUtilities: d }) => {
        d({
          ".block": {
            display: "block"
          },
          ".inline-block": {
            display: "inline-block"
          },
          ".inline": {
            display: "inline"
          },
          ".flex": {
            display: "flex"
          },
          ".inline-flex": {
            display: "inline-flex"
          },
          ".table": {
            display: "table"
          },
          ".inline-table": {
            display: "inline-table"
          },
          ".table-caption": {
            display: "table-caption"
          },
          ".table-cell": {
            display: "table-cell"
          },
          ".table-column": {
            display: "table-column"
          },
          ".table-column-group": {
            display: "table-column-group"
          },
          ".table-footer-group": {
            display: "table-footer-group"
          },
          ".table-header-group": {
            display: "table-header-group"
          },
          ".table-row-group": {
            display: "table-row-group"
          },
          ".table-row": {
            display: "table-row"
          },
          ".flow-root": {
            display: "flow-root"
          },
          ".grid": {
            display: "grid"
          },
          ".inline-grid": {
            display: "inline-grid"
          },
          ".contents": {
            display: "contents"
          },
          ".list-item": {
            display: "list-item"
          },
          ".hidden": {
            display: "none"
          }
        });
      },
      aspectRatio: (0, l.default)("aspectRatio", [
        [
          "aspect",
          [
            "aspect-ratio"
          ]
        ]
      ]),
      size: (0, l.default)("size", [
        [
          "size",
          [
            "width",
            "height"
          ]
        ]
      ]),
      height: (0, l.default)("height", [
        [
          "h",
          [
            "height"
          ]
        ]
      ]),
      maxHeight: (0, l.default)("maxHeight", [
        [
          "max-h",
          [
            "maxHeight"
          ]
        ]
      ]),
      minHeight: (0, l.default)("minHeight", [
        [
          "min-h",
          [
            "minHeight"
          ]
        ]
      ]),
      width: (0, l.default)("width", [
        [
          "w",
          [
            "width"
          ]
        ]
      ]),
      minWidth: (0, l.default)("minWidth", [
        [
          "min-w",
          [
            "minWidth"
          ]
        ]
      ]),
      maxWidth: (0, l.default)("maxWidth", [
        [
          "max-w",
          [
            "maxWidth"
          ]
        ]
      ]),
      flex: (0, l.default)("flex"),
      flexShrink: (0, l.default)("flexShrink", [
        [
          "flex-shrink",
          [
            "flex-shrink"
          ]
        ],
        [
          "shrink",
          [
            "flex-shrink"
          ]
        ]
      ]),
      flexGrow: (0, l.default)("flexGrow", [
        [
          "flex-grow",
          [
            "flex-grow"
          ]
        ],
        [
          "grow",
          [
            "flex-grow"
          ]
        ]
      ]),
      flexBasis: (0, l.default)("flexBasis", [
        [
          "basis",
          [
            "flex-basis"
          ]
        ]
      ]),
      tableLayout: ({ addUtilities: d }) => {
        d({
          ".table-auto": {
            "table-layout": "auto"
          },
          ".table-fixed": {
            "table-layout": "fixed"
          }
        });
      },
      captionSide: ({ addUtilities: d }) => {
        d({
          ".caption-top": {
            "caption-side": "top"
          },
          ".caption-bottom": {
            "caption-side": "bottom"
          }
        });
      },
      borderCollapse: ({ addUtilities: d }) => {
        d({
          ".border-collapse": {
            "border-collapse": "collapse"
          },
          ".border-separate": {
            "border-collapse": "separate"
          }
        });
      },
      borderSpacing: ({ addDefaults: d, matchUtilities: g, theme: v }) => {
        d("border-spacing", {
          "--tw-border-spacing-x": 0,
          "--tw-border-spacing-y": 0
        }), g({
          "border-spacing": (y) => ({
            "--tw-border-spacing-x": y,
            "--tw-border-spacing-y": y,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-x": (y) => ({
            "--tw-border-spacing-x": y,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-y": (y) => ({
            "--tw-border-spacing-y": y,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          })
        }, {
          values: v("borderSpacing")
        });
      },
      transformOrigin: (0, l.default)("transformOrigin", [
        [
          "origin",
          [
            "transformOrigin"
          ]
        ]
      ]),
      translate: (0, l.default)("translate", [
        [
          [
            "translate-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-x",
              [
                "transform",
                A
              ]
            ]
          ],
          [
            "translate-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-y",
              [
                "transform",
                A
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      rotate: (0, l.default)("rotate", [
        [
          "rotate",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-rotate",
            [
              "transform",
              A
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      skew: (0, l.default)("skew", [
        [
          [
            "skew-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-x",
              [
                "transform",
                A
              ]
            ]
          ],
          [
            "skew-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-y",
              [
                "transform",
                A
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      scale: (0, l.default)("scale", [
        [
          "scale",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            "--tw-scale-y",
            [
              "transform",
              A
            ]
          ]
        ],
        [
          [
            "scale-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-x",
              [
                "transform",
                A
              ]
            ]
          ],
          [
            "scale-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-y",
              [
                "transform",
                A
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      transform: ({ addDefaults: d, addUtilities: g }) => {
        d("transform", {
          "--tw-translate-x": "0",
          "--tw-translate-y": "0",
          "--tw-rotate": "0",
          "--tw-skew-x": "0",
          "--tw-skew-y": "0",
          "--tw-scale-x": "1",
          "--tw-scale-y": "1"
        }), g({
          ".transform": {
            "@defaults transform": {},
            transform: A
          },
          ".transform-cpu": {
            transform: A
          },
          ".transform-gpu": {
            transform: A.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
          },
          ".transform-none": {
            transform: "none"
          }
        });
      },
      animation: ({ matchUtilities: d, theme: g, config: v }) => {
        let y = ($) => (0, c.default)(v("prefix") + $);
        var R;
        let F = Object.fromEntries(Object.entries((R = g("keyframes")) !== null && R !== void 0 ? R : {}).map(([$, z]) => [
          $,
          {
            [`@keyframes ${y($)}`]: z
          }
        ]));
        d({
          animate: ($) => {
            let z = (0, a.default)($);
            return [
              ...z.flatMap((j) => F[j.name]),
              {
                animation: z.map(({ name: j, value: W }) => j === void 0 || F[j] === void 0 ? W : W.replace(j, y(j))).join(", ")
              }
            ];
          }
        }, {
          values: g("animation")
        });
      },
      cursor: (0, l.default)("cursor"),
      touchAction: ({ addDefaults: d, addUtilities: g }) => {
        d("touch-action", {
          "--tw-pan-x": " ",
          "--tw-pan-y": " ",
          "--tw-pinch-zoom": " "
        });
        let v = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        g({
          ".touch-auto": {
            "touch-action": "auto"
          },
          ".touch-none": {
            "touch-action": "none"
          },
          ".touch-pan-x": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-x",
            "touch-action": v
          },
          ".touch-pan-left": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-left",
            "touch-action": v
          },
          ".touch-pan-right": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-right",
            "touch-action": v
          },
          ".touch-pan-y": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-y",
            "touch-action": v
          },
          ".touch-pan-up": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-up",
            "touch-action": v
          },
          ".touch-pan-down": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-down",
            "touch-action": v
          },
          ".touch-pinch-zoom": {
            "@defaults touch-action": {},
            "--tw-pinch-zoom": "pinch-zoom",
            "touch-action": v
          },
          ".touch-manipulation": {
            "touch-action": "manipulation"
          }
        });
      },
      userSelect: ({ addUtilities: d }) => {
        d({
          ".select-none": {
            "user-select": "none"
          },
          ".select-text": {
            "user-select": "text"
          },
          ".select-all": {
            "user-select": "all"
          },
          ".select-auto": {
            "user-select": "auto"
          }
        });
      },
      resize: ({ addUtilities: d }) => {
        d({
          ".resize-none": {
            resize: "none"
          },
          ".resize-y": {
            resize: "vertical"
          },
          ".resize-x": {
            resize: "horizontal"
          },
          ".resize": {
            resize: "both"
          }
        });
      },
      scrollSnapType: ({ addDefaults: d, addUtilities: g }) => {
        d("scroll-snap-type", {
          "--tw-scroll-snap-strictness": "proximity"
        }), g({
          ".snap-none": {
            "scroll-snap-type": "none"
          },
          ".snap-x": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
          },
          ".snap-y": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
          },
          ".snap-both": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
          },
          ".snap-mandatory": {
            "--tw-scroll-snap-strictness": "mandatory"
          },
          ".snap-proximity": {
            "--tw-scroll-snap-strictness": "proximity"
          }
        });
      },
      scrollSnapAlign: ({ addUtilities: d }) => {
        d({
          ".snap-start": {
            "scroll-snap-align": "start"
          },
          ".snap-end": {
            "scroll-snap-align": "end"
          },
          ".snap-center": {
            "scroll-snap-align": "center"
          },
          ".snap-align-none": {
            "scroll-snap-align": "none"
          }
        });
      },
      scrollSnapStop: ({ addUtilities: d }) => {
        d({
          ".snap-normal": {
            "scroll-snap-stop": "normal"
          },
          ".snap-always": {
            "scroll-snap-stop": "always"
          }
        });
      },
      scrollMargin: (0, l.default)("scrollMargin", [
        [
          "scroll-m",
          [
            "scroll-margin"
          ]
        ],
        [
          [
            "scroll-mx",
            [
              "scroll-margin-left",
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-my",
            [
              "scroll-margin-top",
              "scroll-margin-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ms",
            [
              "scroll-margin-inline-start"
            ]
          ],
          [
            "scroll-me",
            [
              "scroll-margin-inline-end"
            ]
          ],
          [
            "scroll-mt",
            [
              "scroll-margin-top"
            ]
          ],
          [
            "scroll-mr",
            [
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-mb",
            [
              "scroll-margin-bottom"
            ]
          ],
          [
            "scroll-ml",
            [
              "scroll-margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      scrollPadding: (0, l.default)("scrollPadding", [
        [
          "scroll-p",
          [
            "scroll-padding"
          ]
        ],
        [
          [
            "scroll-px",
            [
              "scroll-padding-left",
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-py",
            [
              "scroll-padding-top",
              "scroll-padding-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ps",
            [
              "scroll-padding-inline-start"
            ]
          ],
          [
            "scroll-pe",
            [
              "scroll-padding-inline-end"
            ]
          ],
          [
            "scroll-pt",
            [
              "scroll-padding-top"
            ]
          ],
          [
            "scroll-pr",
            [
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-pb",
            [
              "scroll-padding-bottom"
            ]
          ],
          [
            "scroll-pl",
            [
              "scroll-padding-left"
            ]
          ]
        ]
      ]),
      listStylePosition: ({ addUtilities: d }) => {
        d({
          ".list-inside": {
            "list-style-position": "inside"
          },
          ".list-outside": {
            "list-style-position": "outside"
          }
        });
      },
      listStyleType: (0, l.default)("listStyleType", [
        [
          "list",
          [
            "listStyleType"
          ]
        ]
      ]),
      listStyleImage: (0, l.default)("listStyleImage", [
        [
          "list-image",
          [
            "listStyleImage"
          ]
        ]
      ]),
      appearance: ({ addUtilities: d }) => {
        d({
          ".appearance-none": {
            appearance: "none"
          },
          ".appearance-auto": {
            appearance: "auto"
          }
        });
      },
      columns: (0, l.default)("columns", [
        [
          "columns",
          [
            "columns"
          ]
        ]
      ]),
      breakBefore: ({ addUtilities: d }) => {
        d({
          ".break-before-auto": {
            "break-before": "auto"
          },
          ".break-before-avoid": {
            "break-before": "avoid"
          },
          ".break-before-all": {
            "break-before": "all"
          },
          ".break-before-avoid-page": {
            "break-before": "avoid-page"
          },
          ".break-before-page": {
            "break-before": "page"
          },
          ".break-before-left": {
            "break-before": "left"
          },
          ".break-before-right": {
            "break-before": "right"
          },
          ".break-before-column": {
            "break-before": "column"
          }
        });
      },
      breakInside: ({ addUtilities: d }) => {
        d({
          ".break-inside-auto": {
            "break-inside": "auto"
          },
          ".break-inside-avoid": {
            "break-inside": "avoid"
          },
          ".break-inside-avoid-page": {
            "break-inside": "avoid-page"
          },
          ".break-inside-avoid-column": {
            "break-inside": "avoid-column"
          }
        });
      },
      breakAfter: ({ addUtilities: d }) => {
        d({
          ".break-after-auto": {
            "break-after": "auto"
          },
          ".break-after-avoid": {
            "break-after": "avoid"
          },
          ".break-after-all": {
            "break-after": "all"
          },
          ".break-after-avoid-page": {
            "break-after": "avoid-page"
          },
          ".break-after-page": {
            "break-after": "page"
          },
          ".break-after-left": {
            "break-after": "left"
          },
          ".break-after-right": {
            "break-after": "right"
          },
          ".break-after-column": {
            "break-after": "column"
          }
        });
      },
      gridAutoColumns: (0, l.default)("gridAutoColumns", [
        [
          "auto-cols",
          [
            "gridAutoColumns"
          ]
        ]
      ]),
      gridAutoFlow: ({ addUtilities: d }) => {
        d({
          ".grid-flow-row": {
            gridAutoFlow: "row"
          },
          ".grid-flow-col": {
            gridAutoFlow: "column"
          },
          ".grid-flow-dense": {
            gridAutoFlow: "dense"
          },
          ".grid-flow-row-dense": {
            gridAutoFlow: "row dense"
          },
          ".grid-flow-col-dense": {
            gridAutoFlow: "column dense"
          }
        });
      },
      gridAutoRows: (0, l.default)("gridAutoRows", [
        [
          "auto-rows",
          [
            "gridAutoRows"
          ]
        ]
      ]),
      gridTemplateColumns: (0, l.default)("gridTemplateColumns", [
        [
          "grid-cols",
          [
            "gridTemplateColumns"
          ]
        ]
      ]),
      gridTemplateRows: (0, l.default)("gridTemplateRows", [
        [
          "grid-rows",
          [
            "gridTemplateRows"
          ]
        ]
      ]),
      flexDirection: ({ addUtilities: d }) => {
        d({
          ".flex-row": {
            "flex-direction": "row"
          },
          ".flex-row-reverse": {
            "flex-direction": "row-reverse"
          },
          ".flex-col": {
            "flex-direction": "column"
          },
          ".flex-col-reverse": {
            "flex-direction": "column-reverse"
          }
        });
      },
      flexWrap: ({ addUtilities: d }) => {
        d({
          ".flex-wrap": {
            "flex-wrap": "wrap"
          },
          ".flex-wrap-reverse": {
            "flex-wrap": "wrap-reverse"
          },
          ".flex-nowrap": {
            "flex-wrap": "nowrap"
          }
        });
      },
      placeContent: ({ addUtilities: d }) => {
        d({
          ".place-content-center": {
            "place-content": "center"
          },
          ".place-content-start": {
            "place-content": "start"
          },
          ".place-content-end": {
            "place-content": "end"
          },
          ".place-content-between": {
            "place-content": "space-between"
          },
          ".place-content-around": {
            "place-content": "space-around"
          },
          ".place-content-evenly": {
            "place-content": "space-evenly"
          },
          ".place-content-baseline": {
            "place-content": "baseline"
          },
          ".place-content-stretch": {
            "place-content": "stretch"
          }
        });
      },
      placeItems: ({ addUtilities: d }) => {
        d({
          ".place-items-start": {
            "place-items": "start"
          },
          ".place-items-end": {
            "place-items": "end"
          },
          ".place-items-center": {
            "place-items": "center"
          },
          ".place-items-baseline": {
            "place-items": "baseline"
          },
          ".place-items-stretch": {
            "place-items": "stretch"
          }
        });
      },
      alignContent: ({ addUtilities: d }) => {
        d({
          ".content-normal": {
            "align-content": "normal"
          },
          ".content-center": {
            "align-content": "center"
          },
          ".content-start": {
            "align-content": "flex-start"
          },
          ".content-end": {
            "align-content": "flex-end"
          },
          ".content-between": {
            "align-content": "space-between"
          },
          ".content-around": {
            "align-content": "space-around"
          },
          ".content-evenly": {
            "align-content": "space-evenly"
          },
          ".content-baseline": {
            "align-content": "baseline"
          },
          ".content-stretch": {
            "align-content": "stretch"
          }
        });
      },
      alignItems: ({ addUtilities: d }) => {
        d({
          ".items-start": {
            "align-items": "flex-start"
          },
          ".items-end": {
            "align-items": "flex-end"
          },
          ".items-center": {
            "align-items": "center"
          },
          ".items-baseline": {
            "align-items": "baseline"
          },
          ".items-stretch": {
            "align-items": "stretch"
          }
        });
      },
      justifyContent: ({ addUtilities: d }) => {
        d({
          ".justify-normal": {
            "justify-content": "normal"
          },
          ".justify-start": {
            "justify-content": "flex-start"
          },
          ".justify-end": {
            "justify-content": "flex-end"
          },
          ".justify-center": {
            "justify-content": "center"
          },
          ".justify-between": {
            "justify-content": "space-between"
          },
          ".justify-around": {
            "justify-content": "space-around"
          },
          ".justify-evenly": {
            "justify-content": "space-evenly"
          },
          ".justify-stretch": {
            "justify-content": "stretch"
          }
        });
      },
      justifyItems: ({ addUtilities: d }) => {
        d({
          ".justify-items-start": {
            "justify-items": "start"
          },
          ".justify-items-end": {
            "justify-items": "end"
          },
          ".justify-items-center": {
            "justify-items": "center"
          },
          ".justify-items-stretch": {
            "justify-items": "stretch"
          }
        });
      },
      gap: (0, l.default)("gap", [
        [
          "gap",
          [
            "gap"
          ]
        ],
        [
          [
            "gap-x",
            [
              "columnGap"
            ]
          ],
          [
            "gap-y",
            [
              "rowGap"
            ]
          ]
        ]
      ]),
      space: ({ matchUtilities: d, addUtilities: g, theme: v }) => {
        d({
          "space-x": (y) => (y = y === "0" ? "0px" : y, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${y} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${y} * calc(1 - var(--tw-space-x-reverse)))`
            }
          }),
          "space-y": (y) => (y = y === "0" ? "0px" : y, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${y} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${y} * var(--tw-space-y-reverse))`
            }
          })
        }, {
          values: v("space"),
          supportsNegativeValues: !0
        }), g({
          ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "1"
          },
          ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "1"
          }
        });
      },
      divideWidth: ({ matchUtilities: d, addUtilities: g, theme: v }) => {
        d({
          "divide-x": (y) => (y = y === "0" ? "0px" : y, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${y} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${y} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          }),
          "divide-y": (y) => (y = y === "0" ? "0px" : y, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${y} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${y} * var(--tw-divide-y-reverse))`
            }
          })
        }, {
          values: v("divideWidth"),
          type: [
            "line-width",
            "length",
            "any"
          ]
        }), g({
          ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "1"
          },
          ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "1"
          }
        });
      },
      divideStyle: ({ addUtilities: d }) => {
        d({
          ".divide-solid > :not([hidden]) ~ :not([hidden])": {
            "border-style": "solid"
          },
          ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dashed"
          },
          ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dotted"
          },
          ".divide-double > :not([hidden]) ~ :not([hidden])": {
            "border-style": "double"
          },
          ".divide-none > :not([hidden]) ~ :not([hidden])": {
            "border-style": "none"
          }
        });
      },
      divideColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          divide: (y) => v("divideOpacity") ? {
            "& > :not([hidden]) ~ :not([hidden])": (0, f.default)({
              color: y,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          } : {
            "& > :not([hidden]) ~ :not([hidden])": {
              "border-color": (0, u.default)(y)
            }
          }
        }, {
          values: (({ DEFAULT: y, ...R }) => R)((0, o.default)(g("divideColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      divideOpacity: ({ matchUtilities: d, theme: g }) => {
        d({
          "divide-opacity": (v) => ({
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-divide-opacity": v
            }
          })
        }, {
          values: g("divideOpacity")
        });
      },
      placeSelf: ({ addUtilities: d }) => {
        d({
          ".place-self-auto": {
            "place-self": "auto"
          },
          ".place-self-start": {
            "place-self": "start"
          },
          ".place-self-end": {
            "place-self": "end"
          },
          ".place-self-center": {
            "place-self": "center"
          },
          ".place-self-stretch": {
            "place-self": "stretch"
          }
        });
      },
      alignSelf: ({ addUtilities: d }) => {
        d({
          ".self-auto": {
            "align-self": "auto"
          },
          ".self-start": {
            "align-self": "flex-start"
          },
          ".self-end": {
            "align-self": "flex-end"
          },
          ".self-center": {
            "align-self": "center"
          },
          ".self-stretch": {
            "align-self": "stretch"
          },
          ".self-baseline": {
            "align-self": "baseline"
          }
        });
      },
      justifySelf: ({ addUtilities: d }) => {
        d({
          ".justify-self-auto": {
            "justify-self": "auto"
          },
          ".justify-self-start": {
            "justify-self": "start"
          },
          ".justify-self-end": {
            "justify-self": "end"
          },
          ".justify-self-center": {
            "justify-self": "center"
          },
          ".justify-self-stretch": {
            "justify-self": "stretch"
          }
        });
      },
      overflow: ({ addUtilities: d }) => {
        d({
          ".overflow-auto": {
            overflow: "auto"
          },
          ".overflow-hidden": {
            overflow: "hidden"
          },
          ".overflow-clip": {
            overflow: "clip"
          },
          ".overflow-visible": {
            overflow: "visible"
          },
          ".overflow-scroll": {
            overflow: "scroll"
          },
          ".overflow-x-auto": {
            "overflow-x": "auto"
          },
          ".overflow-y-auto": {
            "overflow-y": "auto"
          },
          ".overflow-x-hidden": {
            "overflow-x": "hidden"
          },
          ".overflow-y-hidden": {
            "overflow-y": "hidden"
          },
          ".overflow-x-clip": {
            "overflow-x": "clip"
          },
          ".overflow-y-clip": {
            "overflow-y": "clip"
          },
          ".overflow-x-visible": {
            "overflow-x": "visible"
          },
          ".overflow-y-visible": {
            "overflow-y": "visible"
          },
          ".overflow-x-scroll": {
            "overflow-x": "scroll"
          },
          ".overflow-y-scroll": {
            "overflow-y": "scroll"
          }
        });
      },
      overscrollBehavior: ({ addUtilities: d }) => {
        d({
          ".overscroll-auto": {
            "overscroll-behavior": "auto"
          },
          ".overscroll-contain": {
            "overscroll-behavior": "contain"
          },
          ".overscroll-none": {
            "overscroll-behavior": "none"
          },
          ".overscroll-y-auto": {
            "overscroll-behavior-y": "auto"
          },
          ".overscroll-y-contain": {
            "overscroll-behavior-y": "contain"
          },
          ".overscroll-y-none": {
            "overscroll-behavior-y": "none"
          },
          ".overscroll-x-auto": {
            "overscroll-behavior-x": "auto"
          },
          ".overscroll-x-contain": {
            "overscroll-behavior-x": "contain"
          },
          ".overscroll-x-none": {
            "overscroll-behavior-x": "none"
          }
        });
      },
      scrollBehavior: ({ addUtilities: d }) => {
        d({
          ".scroll-auto": {
            "scroll-behavior": "auto"
          },
          ".scroll-smooth": {
            "scroll-behavior": "smooth"
          }
        });
      },
      textOverflow: ({ addUtilities: d }) => {
        d({
          ".truncate": {
            overflow: "hidden",
            "text-overflow": "ellipsis",
            "white-space": "nowrap"
          },
          ".overflow-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-clip": {
            "text-overflow": "clip"
          }
        });
      },
      hyphens: ({ addUtilities: d }) => {
        d({
          ".hyphens-none": {
            hyphens: "none"
          },
          ".hyphens-manual": {
            hyphens: "manual"
          },
          ".hyphens-auto": {
            hyphens: "auto"
          }
        });
      },
      whitespace: ({ addUtilities: d }) => {
        d({
          ".whitespace-normal": {
            "white-space": "normal"
          },
          ".whitespace-nowrap": {
            "white-space": "nowrap"
          },
          ".whitespace-pre": {
            "white-space": "pre"
          },
          ".whitespace-pre-line": {
            "white-space": "pre-line"
          },
          ".whitespace-pre-wrap": {
            "white-space": "pre-wrap"
          },
          ".whitespace-break-spaces": {
            "white-space": "break-spaces"
          }
        });
      },
      textWrap: ({ addUtilities: d }) => {
        d({
          ".text-wrap": {
            "text-wrap": "wrap"
          },
          ".text-nowrap": {
            "text-wrap": "nowrap"
          },
          ".text-balance": {
            "text-wrap": "balance"
          },
          ".text-pretty": {
            "text-wrap": "pretty"
          }
        });
      },
      wordBreak: ({ addUtilities: d }) => {
        d({
          ".break-normal": {
            "overflow-wrap": "normal",
            "word-break": "normal"
          },
          ".break-words": {
            "overflow-wrap": "break-word"
          },
          ".break-all": {
            "word-break": "break-all"
          },
          ".break-keep": {
            "word-break": "keep-all"
          }
        });
      },
      borderRadius: (0, l.default)("borderRadius", [
        [
          "rounded",
          [
            "border-radius"
          ]
        ],
        [
          [
            "rounded-s",
            [
              "border-start-start-radius",
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-e",
            [
              "border-start-end-radius",
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-t",
            [
              "border-top-left-radius",
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-r",
            [
              "border-top-right-radius",
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-b",
            [
              "border-bottom-right-radius",
              "border-bottom-left-radius"
            ]
          ],
          [
            "rounded-l",
            [
              "border-top-left-radius",
              "border-bottom-left-radius"
            ]
          ]
        ],
        [
          [
            "rounded-ss",
            [
              "border-start-start-radius"
            ]
          ],
          [
            "rounded-se",
            [
              "border-start-end-radius"
            ]
          ],
          [
            "rounded-ee",
            [
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-es",
            [
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-tl",
            [
              "border-top-left-radius"
            ]
          ],
          [
            "rounded-tr",
            [
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-br",
            [
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-bl",
            [
              "border-bottom-left-radius"
            ]
          ]
        ]
      ]),
      borderWidth: (0, l.default)("borderWidth", [
        [
          "border",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-width"
          ]
        ],
        [
          [
            "border-x",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width",
              "border-right-width"
            ]
          ],
          [
            "border-y",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width",
              "border-bottom-width"
            ]
          ]
        ],
        [
          [
            "border-s",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-start-width"
            ]
          ],
          [
            "border-e",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-end-width"
            ]
          ],
          [
            "border-t",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width"
            ]
          ],
          [
            "border-r",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-right-width"
            ]
          ],
          [
            "border-b",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-bottom-width"
            ]
          ],
          [
            "border-l",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width"
            ]
          ]
        ]
      ], {
        type: [
          "line-width",
          "length"
        ]
      }),
      borderStyle: ({ addUtilities: d }) => {
        d({
          ".border-solid": {
            "border-style": "solid"
          },
          ".border-dashed": {
            "border-style": "dashed"
          },
          ".border-dotted": {
            "border-style": "dotted"
          },
          ".border-double": {
            "border-style": "double"
          },
          ".border-hidden": {
            "border-style": "hidden"
          },
          ".border-none": {
            "border-style": "none"
          }
        });
      },
      borderColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          border: (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-color": (0, u.default)(y)
          }
        }, {
          values: (({ DEFAULT: y, ...R }) => R)((0, o.default)(g("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), d({
          "border-x": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: [
              "border-left-color",
              "border-right-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, u.default)(y),
            "border-right-color": (0, u.default)(y)
          },
          "border-y": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: [
              "border-top-color",
              "border-bottom-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, u.default)(y),
            "border-bottom-color": (0, u.default)(y)
          }
        }, {
          values: (({ DEFAULT: y, ...R }) => R)((0, o.default)(g("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), d({
          "border-s": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-start-color": (0, u.default)(y)
          },
          "border-e": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-end-color": (0, u.default)(y)
          },
          "border-t": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, u.default)(y)
          },
          "border-r": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-right-color": (0, u.default)(y)
          },
          "border-b": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-bottom-color": (0, u.default)(y)
          },
          "border-l": (y) => v("borderOpacity") ? (0, f.default)({
            color: y,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, u.default)(y)
          }
        }, {
          values: (({ DEFAULT: y, ...R }) => R)((0, o.default)(g("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      borderOpacity: (0, l.default)("borderOpacity", [
        [
          "border-opacity",
          [
            "--tw-border-opacity"
          ]
        ]
      ]),
      backgroundColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          bg: (y) => v("backgroundOpacity") ? (0, f.default)({
            color: y,
            property: "background-color",
            variable: "--tw-bg-opacity"
          }) : {
            "background-color": (0, u.default)(y)
          }
        }, {
          values: (0, o.default)(g("backgroundColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      backgroundOpacity: (0, l.default)("backgroundOpacity", [
        [
          "bg-opacity",
          [
            "--tw-bg-opacity"
          ]
        ]
      ]),
      backgroundImage: (0, l.default)("backgroundImage", [
        [
          "bg",
          [
            "background-image"
          ]
        ]
      ], {
        type: [
          "lookup",
          "image",
          "url"
        ]
      }),
      gradientColorStops: /* @__PURE__ */ (() => {
        function d(g) {
          return (0, f.withAlphaValue)(g, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities: g, theme: v, addDefaults: y }) {
          y("gradient-color-stops", {
            "--tw-gradient-from-position": " ",
            "--tw-gradient-via-position": " ",
            "--tw-gradient-to-position": " "
          });
          let R = {
            values: (0, o.default)(v("gradientColorStops")),
            type: [
              "color",
              "any"
            ]
          }, F = {
            values: v("gradientColorStopPositions"),
            type: [
              "length",
              "percentage"
            ]
          };
          g({
            from: ($) => {
              let z = d($);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${(0, u.default)($)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${z} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
              };
            }
          }, R), g({
            from: ($) => ({
              "--tw-gradient-from-position": $
            })
          }, F), g({
            via: ($) => {
              let z = d($);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${z}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, u.default)($)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          }, R), g({
            via: ($) => ({
              "--tw-gradient-via-position": $
            })
          }, F), g({
            to: ($) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${(0, u.default)($)} var(--tw-gradient-to-position)`
            })
          }, R), g({
            to: ($) => ({
              "--tw-gradient-to-position": $
            })
          }, F);
        };
      })(),
      boxDecorationBreak: ({ addUtilities: d }) => {
        d({
          ".decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".decoration-clone": {
            "box-decoration-break": "clone"
          },
          ".box-decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".box-decoration-clone": {
            "box-decoration-break": "clone"
          }
        });
      },
      backgroundSize: (0, l.default)("backgroundSize", [
        [
          "bg",
          [
            "background-size"
          ]
        ]
      ], {
        type: [
          "lookup",
          "length",
          "percentage",
          "size"
        ]
      }),
      backgroundAttachment: ({ addUtilities: d }) => {
        d({
          ".bg-fixed": {
            "background-attachment": "fixed"
          },
          ".bg-local": {
            "background-attachment": "local"
          },
          ".bg-scroll": {
            "background-attachment": "scroll"
          }
        });
      },
      backgroundClip: ({ addUtilities: d }) => {
        d({
          ".bg-clip-border": {
            "background-clip": "border-box"
          },
          ".bg-clip-padding": {
            "background-clip": "padding-box"
          },
          ".bg-clip-content": {
            "background-clip": "content-box"
          },
          ".bg-clip-text": {
            "background-clip": "text"
          }
        });
      },
      backgroundPosition: (0, l.default)("backgroundPosition", [
        [
          "bg",
          [
            "background-position"
          ]
        ]
      ], {
        type: [
          "lookup",
          [
            "position",
            {
              preferOnConflict: !0
            }
          ]
        ]
      }),
      backgroundRepeat: ({ addUtilities: d }) => {
        d({
          ".bg-repeat": {
            "background-repeat": "repeat"
          },
          ".bg-no-repeat": {
            "background-repeat": "no-repeat"
          },
          ".bg-repeat-x": {
            "background-repeat": "repeat-x"
          },
          ".bg-repeat-y": {
            "background-repeat": "repeat-y"
          },
          ".bg-repeat-round": {
            "background-repeat": "round"
          },
          ".bg-repeat-space": {
            "background-repeat": "space"
          }
        });
      },
      backgroundOrigin: ({ addUtilities: d }) => {
        d({
          ".bg-origin-border": {
            "background-origin": "border-box"
          },
          ".bg-origin-padding": {
            "background-origin": "padding-box"
          },
          ".bg-origin-content": {
            "background-origin": "content-box"
          }
        });
      },
      fill: ({ matchUtilities: d, theme: g }) => {
        d({
          fill: (v) => ({
            fill: (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("fill")),
          type: [
            "color",
            "any"
          ]
        });
      },
      stroke: ({ matchUtilities: d, theme: g }) => {
        d({
          stroke: (v) => ({
            stroke: (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("stroke")),
          type: [
            "color",
            "url",
            "any"
          ]
        });
      },
      strokeWidth: (0, l.default)("strokeWidth", [
        [
          "stroke",
          [
            "stroke-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      objectFit: ({ addUtilities: d }) => {
        d({
          ".object-contain": {
            "object-fit": "contain"
          },
          ".object-cover": {
            "object-fit": "cover"
          },
          ".object-fill": {
            "object-fit": "fill"
          },
          ".object-none": {
            "object-fit": "none"
          },
          ".object-scale-down": {
            "object-fit": "scale-down"
          }
        });
      },
      objectPosition: (0, l.default)("objectPosition", [
        [
          "object",
          [
            "object-position"
          ]
        ]
      ]),
      padding: (0, l.default)("padding", [
        [
          "p",
          [
            "padding"
          ]
        ],
        [
          [
            "px",
            [
              "padding-left",
              "padding-right"
            ]
          ],
          [
            "py",
            [
              "padding-top",
              "padding-bottom"
            ]
          ]
        ],
        [
          [
            "ps",
            [
              "padding-inline-start"
            ]
          ],
          [
            "pe",
            [
              "padding-inline-end"
            ]
          ],
          [
            "pt",
            [
              "padding-top"
            ]
          ],
          [
            "pr",
            [
              "padding-right"
            ]
          ],
          [
            "pb",
            [
              "padding-bottom"
            ]
          ],
          [
            "pl",
            [
              "padding-left"
            ]
          ]
        ]
      ]),
      textAlign: ({ addUtilities: d }) => {
        d({
          ".text-left": {
            "text-align": "left"
          },
          ".text-center": {
            "text-align": "center"
          },
          ".text-right": {
            "text-align": "right"
          },
          ".text-justify": {
            "text-align": "justify"
          },
          ".text-start": {
            "text-align": "start"
          },
          ".text-end": {
            "text-align": "end"
          }
        });
      },
      textIndent: (0, l.default)("textIndent", [
        [
          "indent",
          [
            "text-indent"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      verticalAlign: ({ addUtilities: d, matchUtilities: g }) => {
        d({
          ".align-baseline": {
            "vertical-align": "baseline"
          },
          ".align-top": {
            "vertical-align": "top"
          },
          ".align-middle": {
            "vertical-align": "middle"
          },
          ".align-bottom": {
            "vertical-align": "bottom"
          },
          ".align-text-top": {
            "vertical-align": "text-top"
          },
          ".align-text-bottom": {
            "vertical-align": "text-bottom"
          },
          ".align-sub": {
            "vertical-align": "sub"
          },
          ".align-super": {
            "vertical-align": "super"
          }
        }), g({
          align: (v) => ({
            "vertical-align": v
          })
        });
      },
      fontFamily: ({ matchUtilities: d, theme: g }) => {
        d({
          font: (v) => {
            let [y, R = {}] = Array.isArray(v) && (0, p.default)(v[1]) ? v : [
              v
            ], { fontFeatureSettings: F, fontVariationSettings: $ } = R;
            return {
              "font-family": Array.isArray(y) ? y.join(", ") : y,
              ...F === void 0 ? {} : {
                "font-feature-settings": F
              },
              ...$ === void 0 ? {} : {
                "font-variation-settings": $
              }
            };
          }
        }, {
          values: g("fontFamily"),
          type: [
            "lookup",
            "generic-name",
            "family-name"
          ]
        });
      },
      fontSize: ({ matchUtilities: d, theme: g }) => {
        d({
          text: (v, { modifier: y }) => {
            let [R, F] = Array.isArray(v) ? v : [
              v
            ];
            if (y)
              return {
                "font-size": R,
                "line-height": y
              };
            let { lineHeight: $, letterSpacing: z, fontWeight: j } = (0, p.default)(F) ? F : {
              lineHeight: F
            };
            return {
              "font-size": R,
              ...$ === void 0 ? {} : {
                "line-height": $
              },
              ...z === void 0 ? {} : {
                "letter-spacing": z
              },
              ...j === void 0 ? {} : {
                "font-weight": j
              }
            };
          }
        }, {
          values: g("fontSize"),
          modifiers: g("lineHeight"),
          type: [
            "absolute-size",
            "relative-size",
            "length",
            "percentage"
          ]
        });
      },
      fontWeight: (0, l.default)("fontWeight", [
        [
          "font",
          [
            "fontWeight"
          ]
        ]
      ], {
        type: [
          "lookup",
          "number",
          "any"
        ]
      }),
      textTransform: ({ addUtilities: d }) => {
        d({
          ".uppercase": {
            "text-transform": "uppercase"
          },
          ".lowercase": {
            "text-transform": "lowercase"
          },
          ".capitalize": {
            "text-transform": "capitalize"
          },
          ".normal-case": {
            "text-transform": "none"
          }
        });
      },
      fontStyle: ({ addUtilities: d }) => {
        d({
          ".italic": {
            "font-style": "italic"
          },
          ".not-italic": {
            "font-style": "normal"
          }
        });
      },
      fontVariantNumeric: ({ addDefaults: d, addUtilities: g }) => {
        let v = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        d("font-variant-numeric", {
          "--tw-ordinal": " ",
          "--tw-slashed-zero": " ",
          "--tw-numeric-figure": " ",
          "--tw-numeric-spacing": " ",
          "--tw-numeric-fraction": " "
        }), g({
          ".normal-nums": {
            "font-variant-numeric": "normal"
          },
          ".ordinal": {
            "@defaults font-variant-numeric": {},
            "--tw-ordinal": "ordinal",
            "font-variant-numeric": v
          },
          ".slashed-zero": {
            "@defaults font-variant-numeric": {},
            "--tw-slashed-zero": "slashed-zero",
            "font-variant-numeric": v
          },
          ".lining-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "lining-nums",
            "font-variant-numeric": v
          },
          ".oldstyle-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "oldstyle-nums",
            "font-variant-numeric": v
          },
          ".proportional-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "proportional-nums",
            "font-variant-numeric": v
          },
          ".tabular-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "tabular-nums",
            "font-variant-numeric": v
          },
          ".diagonal-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "diagonal-fractions",
            "font-variant-numeric": v
          },
          ".stacked-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "stacked-fractions",
            "font-variant-numeric": v
          }
        });
      },
      lineHeight: (0, l.default)("lineHeight", [
        [
          "leading",
          [
            "lineHeight"
          ]
        ]
      ]),
      letterSpacing: (0, l.default)("letterSpacing", [
        [
          "tracking",
          [
            "letterSpacing"
          ]
        ]
      ], {
        supportsNegativeValues: !0
      }),
      textColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          text: (y) => v("textOpacity") ? (0, f.default)({
            color: y,
            property: "color",
            variable: "--tw-text-opacity"
          }) : {
            color: (0, u.default)(y)
          }
        }, {
          values: (0, o.default)(g("textColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textOpacity: (0, l.default)("textOpacity", [
        [
          "text-opacity",
          [
            "--tw-text-opacity"
          ]
        ]
      ]),
      textDecoration: ({ addUtilities: d }) => {
        d({
          ".underline": {
            "text-decoration-line": "underline"
          },
          ".overline": {
            "text-decoration-line": "overline"
          },
          ".line-through": {
            "text-decoration-line": "line-through"
          },
          ".no-underline": {
            "text-decoration-line": "none"
          }
        });
      },
      textDecorationColor: ({ matchUtilities: d, theme: g }) => {
        d({
          decoration: (v) => ({
            "text-decoration-color": (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("textDecorationColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textDecorationStyle: ({ addUtilities: d }) => {
        d({
          ".decoration-solid": {
            "text-decoration-style": "solid"
          },
          ".decoration-double": {
            "text-decoration-style": "double"
          },
          ".decoration-dotted": {
            "text-decoration-style": "dotted"
          },
          ".decoration-dashed": {
            "text-decoration-style": "dashed"
          },
          ".decoration-wavy": {
            "text-decoration-style": "wavy"
          }
        });
      },
      textDecorationThickness: (0, l.default)("textDecorationThickness", [
        [
          "decoration",
          [
            "text-decoration-thickness"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage"
        ]
      }),
      textUnderlineOffset: (0, l.default)("textUnderlineOffset", [
        [
          "underline-offset",
          [
            "text-underline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage",
          "any"
        ]
      }),
      fontSmoothing: ({ addUtilities: d }) => {
        d({
          ".antialiased": {
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          ".subpixel-antialiased": {
            "-webkit-font-smoothing": "auto",
            "-moz-osx-font-smoothing": "auto"
          }
        });
      },
      placeholderColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          placeholder: (y) => v("placeholderOpacity") ? {
            "&::placeholder": (0, f.default)({
              color: y,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          } : {
            "&::placeholder": {
              color: (0, u.default)(y)
            }
          }
        }, {
          values: (0, o.default)(g("placeholderColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      placeholderOpacity: ({ matchUtilities: d, theme: g }) => {
        d({
          "placeholder-opacity": (v) => ({
            "&::placeholder": {
              "--tw-placeholder-opacity": v
            }
          })
        }, {
          values: g("placeholderOpacity")
        });
      },
      caretColor: ({ matchUtilities: d, theme: g }) => {
        d({
          caret: (v) => ({
            "caret-color": (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("caretColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      accentColor: ({ matchUtilities: d, theme: g }) => {
        d({
          accent: (v) => ({
            "accent-color": (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("accentColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      opacity: (0, l.default)("opacity", [
        [
          "opacity",
          [
            "opacity"
          ]
        ]
      ]),
      backgroundBlendMode: ({ addUtilities: d }) => {
        d({
          ".bg-blend-normal": {
            "background-blend-mode": "normal"
          },
          ".bg-blend-multiply": {
            "background-blend-mode": "multiply"
          },
          ".bg-blend-screen": {
            "background-blend-mode": "screen"
          },
          ".bg-blend-overlay": {
            "background-blend-mode": "overlay"
          },
          ".bg-blend-darken": {
            "background-blend-mode": "darken"
          },
          ".bg-blend-lighten": {
            "background-blend-mode": "lighten"
          },
          ".bg-blend-color-dodge": {
            "background-blend-mode": "color-dodge"
          },
          ".bg-blend-color-burn": {
            "background-blend-mode": "color-burn"
          },
          ".bg-blend-hard-light": {
            "background-blend-mode": "hard-light"
          },
          ".bg-blend-soft-light": {
            "background-blend-mode": "soft-light"
          },
          ".bg-blend-difference": {
            "background-blend-mode": "difference"
          },
          ".bg-blend-exclusion": {
            "background-blend-mode": "exclusion"
          },
          ".bg-blend-hue": {
            "background-blend-mode": "hue"
          },
          ".bg-blend-saturation": {
            "background-blend-mode": "saturation"
          },
          ".bg-blend-color": {
            "background-blend-mode": "color"
          },
          ".bg-blend-luminosity": {
            "background-blend-mode": "luminosity"
          }
        });
      },
      mixBlendMode: ({ addUtilities: d }) => {
        d({
          ".mix-blend-normal": {
            "mix-blend-mode": "normal"
          },
          ".mix-blend-multiply": {
            "mix-blend-mode": "multiply"
          },
          ".mix-blend-screen": {
            "mix-blend-mode": "screen"
          },
          ".mix-blend-overlay": {
            "mix-blend-mode": "overlay"
          },
          ".mix-blend-darken": {
            "mix-blend-mode": "darken"
          },
          ".mix-blend-lighten": {
            "mix-blend-mode": "lighten"
          },
          ".mix-blend-color-dodge": {
            "mix-blend-mode": "color-dodge"
          },
          ".mix-blend-color-burn": {
            "mix-blend-mode": "color-burn"
          },
          ".mix-blend-hard-light": {
            "mix-blend-mode": "hard-light"
          },
          ".mix-blend-soft-light": {
            "mix-blend-mode": "soft-light"
          },
          ".mix-blend-difference": {
            "mix-blend-mode": "difference"
          },
          ".mix-blend-exclusion": {
            "mix-blend-mode": "exclusion"
          },
          ".mix-blend-hue": {
            "mix-blend-mode": "hue"
          },
          ".mix-blend-saturation": {
            "mix-blend-mode": "saturation"
          },
          ".mix-blend-color": {
            "mix-blend-mode": "color"
          },
          ".mix-blend-luminosity": {
            "mix-blend-mode": "luminosity"
          },
          ".mix-blend-plus-darker": {
            "mix-blend-mode": "plus-darker"
          },
          ".mix-blend-plus-lighter": {
            "mix-blend-mode": "plus-lighter"
          }
        });
      },
      boxShadow: (() => {
        let d = (0, _.default)("boxShadow"), g = [
          "var(--tw-ring-offset-shadow, 0 0 #0000)",
          "var(--tw-ring-shadow, 0 0 #0000)",
          "var(--tw-shadow)"
        ].join(", ");
        return function({ matchUtilities: v, addDefaults: y, theme: R }) {
          y("box-shadow", {
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          }), v({
            shadow: (F) => {
              F = d(F);
              let $ = (0, C.parseBoxShadowValue)(F);
              for (let z of $)
                z.valid && (z.color = "var(--tw-shadow-color)");
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": F === "none" ? "0 0 #0000" : F,
                "--tw-shadow-colored": F === "none" ? "0 0 #0000" : (0, C.formatBoxShadowValue)($),
                "box-shadow": g
              };
            }
          }, {
            values: R("boxShadow"),
            type: [
              "shadow"
            ]
          });
        };
      })(),
      boxShadowColor: ({ matchUtilities: d, theme: g }) => {
        d({
          shadow: (v) => ({
            "--tw-shadow-color": (0, u.default)(v),
            "--tw-shadow": "var(--tw-shadow-colored)"
          })
        }, {
          values: (0, o.default)(g("boxShadowColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      outlineStyle: ({ addUtilities: d }) => {
        d({
          ".outline-none": {
            outline: "2px solid transparent",
            "outline-offset": "2px"
          },
          ".outline": {
            "outline-style": "solid"
          },
          ".outline-dashed": {
            "outline-style": "dashed"
          },
          ".outline-dotted": {
            "outline-style": "dotted"
          },
          ".outline-double": {
            "outline-style": "double"
          }
        });
      },
      outlineWidth: (0, l.default)("outlineWidth", [
        [
          "outline",
          [
            "outline-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      outlineOffset: (0, l.default)("outlineOffset", [
        [
          "outline-offset",
          [
            "outline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage",
          "any"
        ],
        supportsNegativeValues: !0
      }),
      outlineColor: ({ matchUtilities: d, theme: g }) => {
        d({
          outline: (v) => ({
            "outline-color": (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("outlineColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringWidth: ({ matchUtilities: d, addDefaults: g, addUtilities: v, theme: y, config: R }) => {
        let F = (() => {
          var $, z;
          if ((0, k.flagEnabled)(R(), "respectDefaultRingColorOpacity"))
            return y("ringColor.DEFAULT");
          let j = y("ringOpacity.DEFAULT", "0.5");
          return !(($ = y("ringColor")) === null || $ === void 0) && $.DEFAULT ? (0, f.withAlphaValue)((z = y("ringColor")) === null || z === void 0 ? void 0 : z.DEFAULT, j, `rgb(147 197 253 / ${j})`) : `rgb(147 197 253 / ${j})`;
        })();
        g("ring-width", {
          "--tw-ring-inset": " ",
          "--tw-ring-offset-width": y("ringOffsetWidth.DEFAULT", "0px"),
          "--tw-ring-offset-color": y("ringOffsetColor.DEFAULT", "#fff"),
          "--tw-ring-color": F,
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), d({
          ring: ($) => ({
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${$} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              "var(--tw-ring-offset-shadow)",
              "var(--tw-ring-shadow)",
              "var(--tw-shadow, 0 0 #0000)"
            ].join(", ")
          })
        }, {
          values: y("ringWidth"),
          type: "length"
        }), v({
          ".ring-inset": {
            "@defaults ring-width": {},
            "--tw-ring-inset": "inset"
          }
        });
      },
      ringColor: ({ matchUtilities: d, theme: g, corePlugins: v }) => {
        d({
          ring: (y) => v("ringOpacity") ? (0, f.default)({
            color: y,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          }) : {
            "--tw-ring-color": (0, u.default)(y)
          }
        }, {
          values: Object.fromEntries(Object.entries((0, o.default)(g("ringColor"))).filter(([y]) => y !== "DEFAULT")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringOpacity: (d) => {
        let { config: g } = d;
        return (0, l.default)("ringOpacity", [
          [
            "ring-opacity",
            [
              "--tw-ring-opacity"
            ]
          ]
        ], {
          filterDefault: !(0, k.flagEnabled)(g(), "respectDefaultRingColorOpacity")
        })(d);
      },
      ringOffsetWidth: (0, l.default)("ringOffsetWidth", [
        [
          "ring-offset",
          [
            "--tw-ring-offset-width"
          ]
        ]
      ], {
        type: "length"
      }),
      ringOffsetColor: ({ matchUtilities: d, theme: g }) => {
        d({
          "ring-offset": (v) => ({
            "--tw-ring-offset-color": (0, u.default)(v)
          })
        }, {
          values: (0, o.default)(g("ringOffsetColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      blur: ({ matchUtilities: d, theme: g }) => {
        d({
          blur: (v) => ({
            "--tw-blur": v.trim() === "" ? " " : `blur(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("blur")
        });
      },
      brightness: ({ matchUtilities: d, theme: g }) => {
        d({
          brightness: (v) => ({
            "--tw-brightness": `brightness(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("brightness")
        });
      },
      contrast: ({ matchUtilities: d, theme: g }) => {
        d({
          contrast: (v) => ({
            "--tw-contrast": `contrast(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("contrast")
        });
      },
      dropShadow: ({ matchUtilities: d, theme: g }) => {
        d({
          "drop-shadow": (v) => ({
            "--tw-drop-shadow": Array.isArray(v) ? v.map((y) => `drop-shadow(${y})`).join(" ") : `drop-shadow(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("dropShadow")
        });
      },
      grayscale: ({ matchUtilities: d, theme: g }) => {
        d({
          grayscale: (v) => ({
            "--tw-grayscale": `grayscale(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("grayscale")
        });
      },
      hueRotate: ({ matchUtilities: d, theme: g }) => {
        d({
          "hue-rotate": (v) => ({
            "--tw-hue-rotate": `hue-rotate(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("hueRotate"),
          supportsNegativeValues: !0
        });
      },
      invert: ({ matchUtilities: d, theme: g }) => {
        d({
          invert: (v) => ({
            "--tw-invert": `invert(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("invert")
        });
      },
      saturate: ({ matchUtilities: d, theme: g }) => {
        d({
          saturate: (v) => ({
            "--tw-saturate": `saturate(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("saturate")
        });
      },
      sepia: ({ matchUtilities: d, theme: g }) => {
        d({
          sepia: (v) => ({
            "--tw-sepia": `sepia(${v})`,
            "@defaults filter": {},
            filter: N
          })
        }, {
          values: g("sepia")
        });
      },
      filter: ({ addDefaults: d, addUtilities: g }) => {
        d("filter", {
          "--tw-blur": " ",
          "--tw-brightness": " ",
          "--tw-contrast": " ",
          "--tw-grayscale": " ",
          "--tw-hue-rotate": " ",
          "--tw-invert": " ",
          "--tw-saturate": " ",
          "--tw-sepia": " ",
          "--tw-drop-shadow": " "
        }), g({
          ".filter": {
            "@defaults filter": {},
            filter: N
          },
          ".filter-none": {
            filter: "none"
          }
        });
      },
      backdropBlur: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-blur": (v) => ({
            "--tw-backdrop-blur": v.trim() === "" ? " " : `blur(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropBlur")
        });
      },
      backdropBrightness: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-brightness": (v) => ({
            "--tw-backdrop-brightness": `brightness(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropBrightness")
        });
      },
      backdropContrast: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-contrast": (v) => ({
            "--tw-backdrop-contrast": `contrast(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropContrast")
        });
      },
      backdropGrayscale: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-grayscale": (v) => ({
            "--tw-backdrop-grayscale": `grayscale(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropGrayscale")
        });
      },
      backdropHueRotate: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-hue-rotate": (v) => ({
            "--tw-backdrop-hue-rotate": `hue-rotate(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropHueRotate"),
          supportsNegativeValues: !0
        });
      },
      backdropInvert: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-invert": (v) => ({
            "--tw-backdrop-invert": `invert(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropInvert")
        });
      },
      backdropOpacity: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-opacity": (v) => ({
            "--tw-backdrop-opacity": `opacity(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropOpacity")
        });
      },
      backdropSaturate: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-saturate": (v) => ({
            "--tw-backdrop-saturate": `saturate(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropSaturate")
        });
      },
      backdropSepia: ({ matchUtilities: d, theme: g }) => {
        d({
          "backdrop-sepia": (v) => ({
            "--tw-backdrop-sepia": `sepia(${v})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          })
        }, {
          values: g("backdropSepia")
        });
      },
      backdropFilter: ({ addDefaults: d, addUtilities: g }) => {
        d("backdrop-filter", {
          "--tw-backdrop-blur": " ",
          "--tw-backdrop-brightness": " ",
          "--tw-backdrop-contrast": " ",
          "--tw-backdrop-grayscale": " ",
          "--tw-backdrop-hue-rotate": " ",
          "--tw-backdrop-invert": " ",
          "--tw-backdrop-opacity": " ",
          "--tw-backdrop-saturate": " ",
          "--tw-backdrop-sepia": " "
        }), g({
          ".backdrop-filter": {
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": T,
            "backdrop-filter": T
          },
          ".backdrop-filter-none": {
            "-webkit-backdrop-filter": "none",
            "backdrop-filter": "none"
          }
        });
      },
      transitionProperty: ({ matchUtilities: d, theme: g }) => {
        let v = g("transitionTimingFunction.DEFAULT"), y = g("transitionDuration.DEFAULT");
        d({
          transition: (R) => ({
            "transition-property": R,
            ...R === "none" ? {} : {
              "transition-timing-function": v,
              "transition-duration": y
            }
          })
        }, {
          values: g("transitionProperty")
        });
      },
      transitionDelay: (0, l.default)("transitionDelay", [
        [
          "delay",
          [
            "transitionDelay"
          ]
        ]
      ]),
      transitionDuration: (0, l.default)("transitionDuration", [
        [
          "duration",
          [
            "transitionDuration"
          ]
        ]
      ], {
        filterDefault: !0
      }),
      transitionTimingFunction: (0, l.default)("transitionTimingFunction", [
        [
          "ease",
          [
            "transitionTimingFunction"
          ]
        ]
      ], {
        filterDefault: !0
      }),
      willChange: (0, l.default)("willChange", [
        [
          "will-change",
          [
            "will-change"
          ]
        ]
      ]),
      contain: ({ addDefaults: d, addUtilities: g }) => {
        let v = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
        d("contain", {
          "--tw-contain-size": " ",
          "--tw-contain-layout": " ",
          "--tw-contain-paint": " ",
          "--tw-contain-style": " "
        }), g({
          ".contain-none": {
            contain: "none"
          },
          ".contain-content": {
            contain: "content"
          },
          ".contain-strict": {
            contain: "strict"
          },
          ".contain-size": {
            "@defaults contain": {},
            "--tw-contain-size": "size",
            contain: v
          },
          ".contain-inline-size": {
            "@defaults contain": {},
            "--tw-contain-size": "inline-size",
            contain: v
          },
          ".contain-layout": {
            "@defaults contain": {},
            "--tw-contain-layout": "layout",
            contain: v
          },
          ".contain-paint": {
            "@defaults contain": {},
            "--tw-contain-paint": "paint",
            contain: v
          },
          ".contain-style": {
            "@defaults contain": {},
            "--tw-contain-style": "style",
            contain: v
          }
        });
      },
      content: (0, l.default)("content", [
        [
          "content",
          [
            "--tw-content",
            [
              "content",
              "var(--tw-content)"
            ]
          ]
        ]
      ]),
      forcedColorAdjust: ({ addUtilities: d }) => {
        d({
          ".forced-color-adjust-auto": {
            "forced-color-adjust": "auto"
          },
          ".forced-color-adjust-none": {
            "forced-color-adjust": "none"
          }
        });
      }
    };
  }(Rr)), Rr;
}
var Jn = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(
    s,
    // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
    // values don't count, and brackets inside quotes also don't count.
    //
    // E.g.: w-[this-is]w-[weird-and-invalid]
    // E.g.: w-[this-is\\]w-\\[weird-but-valid]
    // E.g.: content-['this-is-also-valid]-weirdly-enough']
    "default",
    {
      enumerable: !0,
      get: function() {
        return n;
      }
    }
  );
  let e = /* @__PURE__ */ new Map([
    [
      "{",
      "}"
    ],
    [
      "[",
      "]"
    ],
    [
      "(",
      ")"
    ]
  ]), t = new Map(Array.from(e.entries()).map(([l, i]) => [
    i,
    l
  ])), r = /* @__PURE__ */ new Set([
    '"',
    "'",
    "`"
  ]);
  function n(l) {
    let i = [], c = !1;
    for (let a = 0; a < l.length; a++) {
      let o = l[a];
      if (o === ":" && !c && i.length === 0)
        return !1;
      if (r.has(o) && l[a - 1] !== "\\" && (c = !c), !c && l[a - 1] !== "\\") {
        if (e.has(o))
          i.push(o);
        else if (t.has(o)) {
          let f = t.get(o);
          if (i.length <= 0 || i.pop() !== f)
            return !1;
        }
      }
    }
    return !(i.length > 0);
  }
})(Jn);
var is = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "hasContentChanged", {
    enumerable: !0,
    get: function() {
      return c;
    }
  });
  const e = /* @__PURE__ */ r(Le), t = /* @__PURE__ */ l(Et);
  function r(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  function n(a) {
    if (typeof WeakMap != "function")
      return null;
    var o = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
    return (n = function(u) {
      return u ? f : o;
    })(a);
  }
  function l(a, o) {
    if (a && a.__esModule)
      return a;
    if (a === null || typeof a != "object" && typeof a != "function")
      return {
        default: a
      };
    var f = n(o);
    if (f && f.has(a))
      return f.get(a);
    var u = {}, p = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var _ in a)
      if (_ !== "default" && Object.prototype.hasOwnProperty.call(a, _)) {
        var x = p ? Object.getOwnPropertyDescriptor(a, _) : null;
        x && (x.get || x.set) ? Object.defineProperty(u, _, x) : u[_] = a[_];
      }
    return u.default = a, f && f.set(a, u), u;
  }
  function i(a) {
    try {
      return e.default.createHash("md5").update(a, "utf-8").digest("binary");
    } catch {
      return "";
    }
  }
  function c(a, o) {
    let f = o.toString();
    if (!f.includes("@tailwind"))
      return !1;
    let u = t.sourceHashMap.get(a), p = i(f), _ = u !== p;
    return t.sourceHashMap.set(a, p), _;
  }
})(is);
var as = {}, ss = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    return (t > 0n) - (t < 0n);
  }
})(ss);
var os = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "remapBitfield", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t, r) {
    let n = 0n, l = 0n;
    for (let [i, c] of r)
      t & i && (n = n | i, l = l | c);
    return t & ~n | l;
  }
})(os);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "Offsets", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r(ss), t = os;
  function r(c) {
    return c && c.__esModule ? c : {
      default: c
    };
  }
  class n {
    constructor() {
      this.offsets = {
        defaults: 0n,
        base: 0n,
        components: 0n,
        utilities: 0n,
        variants: 0n,
        user: 0n
      }, this.layerPositions = {
        defaults: 0n,
        base: 1n,
        components: 2n,
        utilities: 3n,
        // There isn't technically a "user" layer, but we need to give it a position
        // Because it's used for ordering user-css from @apply
        user: 4n,
        variants: 5n
      }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
    }
    /**
    * @param {Layer} layer
    * @returns {RuleOffset}
    */
    create(a) {
      return {
        layer: a,
        parentLayer: a,
        arbitrary: 0n,
        variants: 0n,
        parallelIndex: 0n,
        index: this.offsets[a]++,
        propertyOffset: 0n,
        property: "",
        options: []
      };
    }
    /**
    * @param {string} name
    * @returns {RuleOffset}
    */
    arbitraryProperty(a) {
      return {
        ...this.create("utilities"),
        arbitrary: 1n,
        property: a
      };
    }
    /**
    * Get the offset for a variant
    *
    * @param {string} variant
    * @param {number} index
    * @returns {RuleOffset}
    */
    forVariant(a, o = 0) {
      let f = this.variantOffsets.get(a);
      if (f === void 0)
        throw new Error(`Cannot find offset for unknown variant ${a}`);
      return {
        ...this.create("variants"),
        variants: f << BigInt(o)
      };
    }
    /**
    * @param {RuleOffset} rule
    * @param {RuleOffset} variant
    * @param {VariantOption} options
    * @returns {RuleOffset}
    */
    applyVariantOffset(a, o, f) {
      return f.variant = o.variants, {
        ...a,
        layer: "variants",
        parentLayer: a.layer === "variants" ? a.parentLayer : a.layer,
        variants: a.variants | o.variants,
        options: f.sort ? [].concat(f, a.options) : a.options,
        // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
        // We'll take the max of all the parallel indexes for now.
        // @ts-ignore
        parallelIndex: l([
          a.parallelIndex,
          o.parallelIndex
        ])
      };
    }
    /**
    * @param {RuleOffset} offset
    * @param {number} parallelIndex
    * @returns {RuleOffset}
    */
    applyParallelOffset(a, o) {
      return {
        ...a,
        parallelIndex: BigInt(o)
      };
    }
    /**
    * Each variant gets 1 bit per function / rule registered.
    * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
    * Additionally, every unique group of variants is grouped together in the stylesheet.
    *
    * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
    *
    * @param {string[]} variants
    * @param {(name: string) => number} getLength
    */
    recordVariants(a, o) {
      for (let f of a)
        this.recordVariant(f, o(f));
    }
    /**
    * The same as `recordVariants` but for a single arbitrary variant at runtime.
    * @param {string} variant
    * @param {number} fnCount
    *
    * @returns {RuleOffset} The highest offset for this variant
    */
    recordVariant(a, o = 1) {
      return this.variantOffsets.set(a, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(o), {
        ...this.create("variants"),
        variants: this.variantOffsets.get(a)
      };
    }
    /**
    * @param {RuleOffset} a
    * @param {RuleOffset} b
    * @returns {bigint}
    */
    compare(a, o) {
      if (a.layer !== o.layer)
        return this.layerPositions[a.layer] - this.layerPositions[o.layer];
      if (a.parentLayer !== o.parentLayer)
        return this.layerPositions[a.parentLayer] - this.layerPositions[o.parentLayer];
      for (let u of a.options)
        for (let p of o.options) {
          if (u.id !== p.id || !u.sort || !p.sort)
            continue;
          var f;
          let _ = (f = l([
            u.variant,
            p.variant
          ])) !== null && f !== void 0 ? f : 0n, x = ~(_ | _ - 1n), h = a.variants & x, m = o.variants & x;
          if (h !== m)
            continue;
          let C = u.sort({
            value: u.value,
            modifier: u.modifier
          }, {
            value: p.value,
            modifier: p.modifier
          });
          if (C !== 0)
            return C;
        }
      return a.variants !== o.variants ? a.variants - o.variants : a.parallelIndex !== o.parallelIndex ? a.parallelIndex - o.parallelIndex : a.arbitrary !== o.arbitrary ? a.arbitrary - o.arbitrary : a.propertyOffset !== o.propertyOffset ? a.propertyOffset - o.propertyOffset : a.index - o.index;
    }
    /**
    * Arbitrary variants are recorded in the order they're encountered.
    * This means that the order is not stable between environments and sets of content files.
    *
    * In order to make the order stable, we need to remap the arbitrary variant offsets to
    * be in alphabetical order starting from the offset of the first arbitrary variant.
    */
    recalculateVariantOffsets() {
      let a = Array.from(this.variantOffsets.entries()).filter(([u]) => u.startsWith("[")).sort(([u], [p]) => i(u, p)), o = a.map(([, u]) => u).sort((u, p) => (0, e.default)(u - p));
      return a.map(([, u], p) => [
        u,
        o[p]
      ]).filter(([u, p]) => u !== p);
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    remapArbitraryVariantOffsets(a) {
      let o = this.recalculateVariantOffsets();
      return o.length === 0 ? a : a.map((f) => {
        let [u, p] = f;
        return u = {
          ...u,
          variants: (0, t.remapBitfield)(u.variants, o)
        }, [
          u,
          p
        ];
      });
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    sortArbitraryProperties(a) {
      let o = /* @__PURE__ */ new Set();
      for (let [_] of a)
        _.arbitrary === 1n && o.add(_.property);
      if (o.size === 0)
        return a;
      let f = Array.from(o).sort(), u = /* @__PURE__ */ new Map(), p = 1n;
      for (let _ of f)
        u.set(_, p++);
      return a.map((_) => {
        let [x, h] = _;
        var m;
        return x = {
          ...x,
          propertyOffset: (m = u.get(x.property)) !== null && m !== void 0 ? m : 0n
        }, [
          x,
          h
        ];
      });
    }
    /**
    * @template T
    * @param {[RuleOffset, T][]} list
    * @returns {[RuleOffset, T][]}
    */
    sort(a) {
      return a = this.remapArbitraryVariantOffsets(a), a = this.sortArbitraryProperties(a), a.sort(([o], [f]) => (0, e.default)(this.compare(o, f)));
    }
  }
  function l(c) {
    let a = null;
    for (const o of c)
      a = a ?? o, a = a > o ? a : o;
    return a;
  }
  function i(c, a) {
    let o = c.length, f = a.length, u = o < f ? o : f;
    for (let p = 0; p < u; p++) {
      let _ = c.charCodeAt(p) - a.charCodeAt(p);
      if (_ !== 0)
        return _;
    }
    return o - f;
  }
})(as);
var Mi;
function Kn() {
  return Mi || (Mi = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: !0
    });
    function e(q, U) {
      for (var Z in U)
        Object.defineProperty(q, Z, {
          enumerable: !0,
          get: U[Z]
        });
    }
    e(s, {
      INTERNAL_FEATURES: function() {
        return T;
      },
      isValidVariantFormatString: function() {
        return I;
      },
      parseVariant: function() {
        return G;
      },
      getFileModifiedMap: function() {
        return L;
      },
      createContext: function() {
        return ye;
      },
      getContext: function() {
        return Ne;
      }
    });
    const t = /* @__PURE__ */ b(Le), r = /* @__PURE__ */ b(Le), n = /* @__PURE__ */ b(qe), l = /* @__PURE__ */ b(ba), i = /* @__PURE__ */ b(Ke), c = /* @__PURE__ */ b(Ot), a = /* @__PURE__ */ b(jn), o = /* @__PURE__ */ b(lr), f = /* @__PURE__ */ b(dt), u = /* @__PURE__ */ b(pt), p = /* @__PURE__ */ N(Hn), _ = At, x = xc(), h = /* @__PURE__ */ N(Et), m = ir, C = /* @__PURE__ */ b(et), S = /* @__PURE__ */ b(sr), k = /* @__PURE__ */ b(Jn), O = fr(), E = is, M = as, D = it, P = Yn;
    function b(q) {
      return q && q.__esModule ? q : {
        default: q
      };
    }
    function A(q) {
      if (typeof WeakMap != "function")
        return null;
      var U = /* @__PURE__ */ new WeakMap(), Z = /* @__PURE__ */ new WeakMap();
      return (A = function(K) {
        return K ? Z : U;
      })(q);
    }
    function N(q, U) {
      if (q && q.__esModule)
        return q;
      if (q === null || typeof q != "object" && typeof q != "function")
        return {
          default: q
        };
      var Z = A(U);
      if (Z && Z.has(q))
        return Z.get(q);
      var K = {}, X = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var ae in q)
        if (ae !== "default" && Object.prototype.hasOwnProperty.call(q, ae)) {
          var se = X ? Object.getOwnPropertyDescriptor(q, ae) : null;
          se && (se.get || se.set) ? Object.defineProperty(K, ae, se) : K[ae] = q[ae];
        }
      return K.default = q, Z && Z.set(q, K), K;
    }
    const T = Symbol(), V = {
      AddVariant: Symbol.for("ADD_VARIANT"),
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, d = {
      Base: 1,
      Dynamic: 2
    };
    function g(q, U) {
      let Z = q.tailwindConfig.prefix;
      return typeof Z == "function" ? Z(U) : Z + U;
    }
    function v({ type: q = "any", ...U }) {
      let Z = [].concat(q);
      return {
        ...U,
        types: Z.map((K) => Array.isArray(K) ? {
          type: K[0],
          ...K[1]
        } : {
          type: K,
          preferOnConflict: !1
        })
      };
    }
    function y(q) {
      let U = [], Z = "", K = 0;
      for (let X = 0; X < q.length; X++) {
        let ae = q[X];
        if (ae === "\\")
          Z += "\\" + q[++X];
        else if (ae === "{")
          ++K, U.push(Z.trim()), Z = "";
        else if (ae === "}") {
          if (--K < 0)
            throw new Error("Your { and } are unbalanced.");
          U.push(Z.trim()), Z = "";
        } else
          Z += ae;
      }
      return Z.length > 0 && U.push(Z.trim()), U = U.filter((X) => X !== ""), U;
    }
    function R(q, U, { before: Z = [] } = {}) {
      if (Z = [].concat(Z), Z.length <= 0) {
        q.push(U);
        return;
      }
      let K = q.length - 1;
      for (let X of Z) {
        let ae = q.indexOf(X);
        ae !== -1 && (K = Math.min(K, ae));
      }
      q.splice(K, 0, U);
    }
    function F(q) {
      return Array.isArray(q) ? q.flatMap((U) => !Array.isArray(U) && !(0, f.default)(U) ? U : (0, a.default)(U)) : F([
        q
      ]);
    }
    function $(q, U) {
      return (0, i.default)((K) => {
        let X = [];
        return U && U(K), K.walkClasses((ae) => {
          X.push(ae.value);
        }), X;
      }).transformSync(q);
    }
    function z(q) {
      q.walkPseudos((U) => {
        U.value === ":not" && U.remove();
      });
    }
    function j(q, U = {
      containsNonOnDemandable: !1
    }, Z = 0) {
      let K = [], X = [];
      q.type === "rule" ? X.push(...q.selectors) : q.type === "atrule" && q.walkRules((ae) => X.push(...ae.selectors));
      for (let ae of X) {
        let se = $(ae, z);
        se.length === 0 && (U.containsNonOnDemandable = !0);
        for (let Se of se)
          K.push(Se);
      }
      return Z === 0 ? [
        U.containsNonOnDemandable || K.length === 0,
        K
      ] : K;
    }
    function W(q) {
      return F(q).flatMap((U) => {
        let Z = /* @__PURE__ */ new Map(), [K, X] = j(U);
        return K && X.unshift(h.NOT_ON_DEMAND), X.map((ae) => (Z.has(U) || Z.set(U, U), [
          ae,
          Z.get(U)
        ]));
      });
    }
    function I(q) {
      return q.startsWith("@") || q.includes("&");
    }
    function G(q) {
      q = q.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let U = y(q).map((Z) => {
        if (!Z.startsWith("@"))
          return ({ format: se }) => se(Z);
        let [, K, X] = /@(\S*)( .+|[({].*)?/g.exec(Z);
        var ae;
        return ({ wrap: se }) => se(n.default.atRule({
          name: K,
          params: (ae = X == null ? void 0 : X.trim()) !== null && ae !== void 0 ? ae : ""
        }));
      }).reverse();
      return (Z) => {
        for (let K of U)
          K(Z);
      };
    }
    function re(q, U, { variantList: Z, variantMap: K, offsets: X, classList: ae }) {
      function se(ne, te) {
        return ne ? (0, l.default)(q, ne, te) : q;
      }
      function Se(ne) {
        return (0, o.default)(q.prefix, ne);
      }
      function fe(ne, te) {
        return ne === h.NOT_ON_DEMAND ? h.NOT_ON_DEMAND : te.respectPrefix ? U.tailwindConfig.prefix + ne : ne;
      }
      function Pe(ne, te, ue = {}) {
        let ve = (0, m.toPath)(ne), me = se([
          "theme",
          ...ve
        ], te);
        return (0, c.default)(ve[0])(me, ue);
      }
      let ge = 0, Ce = {
        postcss: n.default,
        prefix: Se,
        e: u.default,
        config: se,
        theme: Pe,
        corePlugins: (ne) => Array.isArray(q.corePlugins) ? q.corePlugins.includes(ne) : se([
          "corePlugins",
          ne
        ], !0),
        variants: () => [],
        addBase(ne) {
          for (let [te, ue] of W(ne)) {
            let ve = fe(te, {}), me = X.create("base");
            U.candidateRuleMap.has(ve) || U.candidateRuleMap.set(ve, []), U.candidateRuleMap.get(ve).push([
              {
                sort: me,
                layer: "base"
              },
              ue
            ]);
          }
        },
        /**
        * @param {string} group
        * @param {Record<string, string | string[]>} declarations
        */
        addDefaults(ne, te) {
          const ue = {
            [`@defaults ${ne}`]: te
          };
          for (let [ve, me] of W(ue)) {
            let de = fe(ve, {});
            U.candidateRuleMap.has(de) || U.candidateRuleMap.set(de, []), U.candidateRuleMap.get(de).push([
              {
                sort: X.create("defaults"),
                layer: "defaults"
              },
              me
            ]);
          }
        },
        addComponents(ne, te) {
          te = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !1
          }, Array.isArray(te) ? {} : te);
          for (let [ve, me] of W(ne)) {
            let de = fe(ve, te);
            ae.add(de), U.candidateRuleMap.has(de) || U.candidateRuleMap.set(de, []), U.candidateRuleMap.get(de).push([
              {
                sort: X.create("components"),
                layer: "components",
                options: te
              },
              me
            ]);
          }
        },
        addUtilities(ne, te) {
          te = Object.assign({}, {
            preserveSource: !1,
            respectPrefix: !0,
            respectImportant: !0
          }, Array.isArray(te) ? {} : te);
          for (let [ve, me] of W(ne)) {
            let de = fe(ve, te);
            ae.add(de), U.candidateRuleMap.has(de) || U.candidateRuleMap.set(de, []), U.candidateRuleMap.get(de).push([
              {
                sort: X.create("utilities"),
                layer: "utilities",
                options: te
              },
              me
            ]);
          }
        },
        matchUtilities: function(ne, te) {
          te = v({
            ...{
              respectPrefix: !0,
              respectImportant: !0,
              modifiers: !1
            },
            ...te
          });
          let ve = X.create("utilities");
          for (let me in ne) {
            let Ie = function(xe, { isOnlyPlugin: he }) {
              let [ce, _e, Fe] = (0, _.coerceValue)(te.types, xe, te, q);
              if (ce === void 0)
                return [];
              if (!te.types.some(({ type: Ue }) => Ue === _e))
                if (he)
                  C.default.warn([
                    `Unnecessary typehint \`${_e}\` in \`${me}-${xe}\`.`,
                    `You can safely update it to \`${me}-${xe.replace(_e + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, k.default)(ce))
                return [];
              let tt = {
                get modifier() {
                  return te.modifiers || C.default.warn(`modifier-used-without-options-for-${me}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Fe;
                }
              }, ze = (0, D.flagEnabled)(q, "generalizedModifiers");
              return [].concat(ze ? Te(ce, tt) : Te(ce)).filter(Boolean).map((Ue) => ({
                [(0, p.default)(me, xe)]: Ue
              }));
            }, de = fe(me, te), Te = ne[me];
            ae.add([
              de,
              te
            ]);
            let pe = [
              {
                sort: ve,
                layer: "utilities",
                options: te
              },
              Ie
            ];
            U.candidateRuleMap.has(de) || U.candidateRuleMap.set(de, []), U.candidateRuleMap.get(de).push(pe);
          }
        },
        matchComponents: function(ne, te) {
          te = v({
            ...{
              respectPrefix: !0,
              respectImportant: !1,
              modifiers: !1
            },
            ...te
          });
          let ve = X.create("components");
          for (let me in ne) {
            let Ie = function(xe, { isOnlyPlugin: he }) {
              let [ce, _e, Fe] = (0, _.coerceValue)(te.types, xe, te, q);
              if (ce === void 0)
                return [];
              if (!te.types.some(({ type: Ue }) => Ue === _e))
                if (he)
                  C.default.warn([
                    `Unnecessary typehint \`${_e}\` in \`${me}-${xe}\`.`,
                    `You can safely update it to \`${me}-${xe.replace(_e + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, k.default)(ce))
                return [];
              let tt = {
                get modifier() {
                  return te.modifiers || C.default.warn(`modifier-used-without-options-for-${me}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Fe;
                }
              }, ze = (0, D.flagEnabled)(q, "generalizedModifiers");
              return [].concat(ze ? Te(ce, tt) : Te(ce)).filter(Boolean).map((Ue) => ({
                [(0, p.default)(me, xe)]: Ue
              }));
            }, de = fe(me, te), Te = ne[me];
            ae.add([
              de,
              te
            ]);
            let pe = [
              {
                sort: ve,
                layer: "components",
                options: te
              },
              Ie
            ];
            U.candidateRuleMap.has(de) || U.candidateRuleMap.set(de, []), U.candidateRuleMap.get(de).push(pe);
          }
        },
        addVariant(ne, te, ue = {}) {
          te = [].concat(te).map((ve) => {
            if (typeof ve != "string")
              return (me = {}) => {
                let { args: de, modifySelectors: Te, container: Ie, separator: pe, wrap: xe, format: he } = me, ce = ve(Object.assign({
                  modifySelectors: Te,
                  container: Ie,
                  separator: pe
                }, ue.type === V.MatchVariant && {
                  args: de,
                  wrap: xe,
                  format: he
                }));
                if (typeof ce == "string" && !I(ce))
                  throw new Error(`Your custom variant \`${ne}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(ce) ? ce.filter((_e) => typeof _e == "string").map((_e) => G(_e)) : ce && typeof ce == "string" && G(ce)(me);
              };
            if (!I(ve))
              throw new Error(`Your custom variant \`${ne}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return G(ve);
          }), R(Z, ne, ue), K.set(ne, te), U.variantOptions.set(ne, ue);
        },
        matchVariant(ne, te, ue) {
          var ve;
          let me = (ve = ue == null ? void 0 : ue.id) !== null && ve !== void 0 ? ve : ++ge, de = ne === "@", Te = (0, D.flagEnabled)(q, "generalizedModifiers");
          var Ie;
          for (let [he, ce] of Object.entries((Ie = ue == null ? void 0 : ue.values) !== null && Ie !== void 0 ? Ie : {}))
            he !== "DEFAULT" && Ce.addVariant(de ? `${ne}${he}` : `${ne}-${he}`, ({ args: _e, container: Fe }) => te(ce, Te ? {
              modifier: _e == null ? void 0 : _e.modifier,
              container: Fe
            } : {
              container: Fe
            }), {
              ...ue,
              value: ce,
              id: me,
              type: V.MatchVariant,
              variantInfo: d.Base
            });
          var pe;
          let xe = "DEFAULT" in ((pe = ue == null ? void 0 : ue.values) !== null && pe !== void 0 ? pe : {});
          Ce.addVariant(ne, ({ args: he, container: ce }) => {
            if ((he == null ? void 0 : he.value) === h.NONE && !xe)
              return null;
            var _e;
            return te((he == null ? void 0 : he.value) === h.NONE ? ue.values.DEFAULT : (_e = he == null ? void 0 : he.value) !== null && _e !== void 0 ? _e : typeof he == "string" ? he : "", Te ? {
              modifier: he == null ? void 0 : he.modifier,
              container: ce
            } : {
              container: ce
            });
          }, {
            ...ue,
            id: me,
            type: V.MatchVariant,
            variantInfo: d.Dynamic
          });
        }
      };
      return Ce;
    }
    let w = /* @__PURE__ */ new WeakMap();
    function L(q) {
      return w.has(q) || w.set(q, /* @__PURE__ */ new Map()), w.get(q);
    }
    function B(q, U) {
      let Z = !1, K = /* @__PURE__ */ new Map();
      for (let ae of q) {
        var X;
        if (!ae)
          continue;
        let se = r.default.parse(ae), Se = se.hash ? se.href.replace(se.hash, "") : se.href;
        Se = se.search ? Se.replace(se.search, "") : Se;
        let fe = (X = t.default.statSync(decodeURIComponent(Se), {
          throwIfNoEntry: !1
        })) === null || X === void 0 ? void 0 : X.mtimeMs;
        fe && ((!U.has(ae) || fe > U.get(ae)) && (Z = !0), K.set(ae, fe));
      }
      return [
        Z,
        K
      ];
    }
    function H(q) {
      q.walkAtRules((U) => {
        [
          "responsive",
          "variants"
        ].includes(U.name) && (H(U), U.before(U.nodes), U.remove());
      });
    }
    function Y(q) {
      let U = [];
      return q.each((Z) => {
        Z.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(Z.name) && (Z.name = "layer", Z.params = "utilities");
      }), q.walkAtRules("layer", (Z) => {
        if (H(Z), Z.params === "base") {
          for (let K of Z.nodes)
            U.push(function({ addBase: X }) {
              X(K, {
                respectPrefix: !1
              });
            });
          Z.remove();
        } else if (Z.params === "components") {
          for (let K of Z.nodes)
            U.push(function({ addComponents: X }) {
              X(K, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          Z.remove();
        } else if (Z.params === "utilities") {
          for (let K of Z.nodes)
            U.push(function({ addUtilities: X }) {
              X(K, {
                respectPrefix: !1,
                preserveSource: !0
              });
            });
          Z.remove();
        }
      }), U;
    }
    function J(q, U) {
      let Z = Object.entries({
        ...x.variantPlugins,
        ...x.corePlugins
      }).map(([fe, Pe]) => q.tailwindConfig.corePlugins.includes(fe) ? Pe : null).filter(Boolean), K = q.tailwindConfig.plugins.map((fe) => (fe.__isOptionsFunction && (fe = fe()), typeof fe == "function" ? fe : fe.handler)), X = Y(U), ae = [
        x.variantPlugins.childVariant,
        x.variantPlugins.pseudoElementVariants,
        x.variantPlugins.pseudoClassVariants,
        x.variantPlugins.hasVariants,
        x.variantPlugins.ariaVariants,
        x.variantPlugins.dataVariants
      ], se = [
        x.variantPlugins.supportsVariants,
        x.variantPlugins.reducedMotionVariants,
        x.variantPlugins.prefersContrastVariants,
        x.variantPlugins.screenVariants,
        x.variantPlugins.orientationVariants,
        x.variantPlugins.directionVariants,
        x.variantPlugins.darkVariants,
        x.variantPlugins.forcedColorsVariants,
        x.variantPlugins.printVariant
      ];
      return (q.tailwindConfig.darkMode === "class" || Array.isArray(q.tailwindConfig.darkMode) && q.tailwindConfig.darkMode[0] === "class") && (se = [
        x.variantPlugins.supportsVariants,
        x.variantPlugins.reducedMotionVariants,
        x.variantPlugins.prefersContrastVariants,
        x.variantPlugins.darkVariants,
        x.variantPlugins.screenVariants,
        x.variantPlugins.orientationVariants,
        x.variantPlugins.directionVariants,
        x.variantPlugins.forcedColorsVariants,
        x.variantPlugins.printVariant
      ]), [
        ...Z,
        ...ae,
        ...K,
        ...se,
        ...X
      ];
    }
    function ee(q, U) {
      let Z = [], K = /* @__PURE__ */ new Map();
      U.variantMap = K;
      let X = new M.Offsets();
      U.offsets = X;
      let ae = /* @__PURE__ */ new Set(), se = re(U.tailwindConfig, U, {
        variantList: Z,
        variantMap: K,
        offsets: X,
        classList: ae
      });
      for (let te of q)
        if (Array.isArray(te))
          for (let ue of te)
            ue(se);
        else
          te == null || te(se);
      X.recordVariants(Z, (te) => K.get(te).length);
      for (let [te, ue] of K.entries())
        U.variantMap.set(te, ue.map((ve, me) => [
          X.forVariant(te, me),
          ve
        ]));
      var Se;
      let fe = ((Se = U.tailwindConfig.safelist) !== null && Se !== void 0 ? Se : []).filter(Boolean);
      if (fe.length > 0) {
        let te = [];
        for (let ue of fe) {
          if (typeof ue == "string") {
            U.changedContent.push({
              content: ue,
              extension: "html"
            });
            continue;
          }
          if (ue instanceof RegExp) {
            C.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          te.push(ue);
        }
        if (te.length > 0) {
          let ue = /* @__PURE__ */ new Map(), ve = U.tailwindConfig.prefix.length, me = te.some((de) => de.pattern.source.includes("!"));
          for (let de of ae) {
            let Te = Array.isArray(de) ? (() => {
              let [Ie, pe] = de;
              var xe;
              let ce = Object.keys((xe = pe == null ? void 0 : pe.values) !== null && xe !== void 0 ? xe : {}).map((_e) => (0, p.formatClass)(Ie, _e));
              return pe != null && pe.supportsNegativeValues && (ce = [
                ...ce,
                ...ce.map((_e) => "-" + _e)
              ], ce = [
                ...ce,
                ...ce.map((_e) => _e.slice(0, ve) + "-" + _e.slice(ve))
              ]), pe.types.some(({ type: _e }) => _e === "color") && (ce = [
                ...ce,
                ...ce.flatMap((_e) => Object.keys(U.tailwindConfig.theme.opacity).map((Fe) => `${_e}/${Fe}`))
              ]), me && (pe != null && pe.respectImportant) && (ce = [
                ...ce,
                ...ce.map((_e) => "!" + _e)
              ]), ce;
            })() : [
              de
            ];
            for (let Ie of Te)
              for (let { pattern: pe, variants: xe = [] } of te)
                if (pe.lastIndex = 0, ue.has(pe) || ue.set(pe, 0), !!pe.test(Ie)) {
                  ue.set(pe, ue.get(pe) + 1), U.changedContent.push({
                    content: Ie,
                    extension: "html"
                  });
                  for (let he of xe)
                    U.changedContent.push({
                      content: he + U.tailwindConfig.separator + Ie,
                      extension: "html"
                    });
                }
          }
          for (let [de, Te] of ue.entries())
            Te === 0 && C.default.warn([
              `The safelist pattern \`${de}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var Pe, ge;
      let Ce = (ge = [].concat((Pe = U.tailwindConfig.darkMode) !== null && Pe !== void 0 ? Pe : "media")[1]) !== null && ge !== void 0 ? ge : "dark", ne = [
        g(U, Ce),
        g(U, "group"),
        g(U, "peer")
      ];
      U.getClassOrder = function(ue) {
        let ve = [
          ...ue
        ].sort((pe, xe) => pe === xe ? 0 : pe < xe ? -1 : 1), me = new Map(ve.map((pe) => [
          pe,
          null
        ])), de = (0, O.generateRules)(new Set(ve), U, !0);
        de = U.offsets.sort(de);
        let Te = BigInt(ne.length);
        for (const [, pe] of de) {
          let xe = pe.raws.tailwind.candidate;
          var Ie;
          me.set(xe, (Ie = me.get(xe)) !== null && Ie !== void 0 ? Ie : Te++);
        }
        return ue.map((pe) => {
          var xe;
          let he = (xe = me.get(pe)) !== null && xe !== void 0 ? xe : null, ce = ne.indexOf(pe);
          return he === null && ce !== -1 && (he = BigInt(ce)), [
            pe,
            he
          ];
        });
      }, U.getClassList = function(ue = {}) {
        let ve = [];
        for (let pe of ae)
          if (Array.isArray(pe)) {
            var me;
            let [xe, he] = pe, ce = [];
            var de;
            let _e = Object.keys((de = he == null ? void 0 : he.modifiers) !== null && de !== void 0 ? de : {});
            if (!(he == null || (me = he.types) === null || me === void 0) && me.some(({ type: ze }) => ze === "color")) {
              var Te;
              _e.push(...Object.keys((Te = U.tailwindConfig.theme.opacity) !== null && Te !== void 0 ? Te : {}));
            }
            let Fe = {
              modifiers: _e
            }, tt = ue.includeMetadata && _e.length > 0;
            var Ie;
            for (let [ze, rt] of Object.entries((Ie = he == null ? void 0 : he.values) !== null && Ie !== void 0 ? Ie : {})) {
              if (rt == null)
                continue;
              let Ue = (0, p.formatClass)(xe, ze);
              if (ve.push(tt ? [
                Ue,
                Fe
              ] : Ue), he != null && he.supportsNegativeValues && (0, S.default)(rt)) {
                let Xe = (0, p.formatClass)(xe, `-${ze}`);
                ce.push(tt ? [
                  Xe,
                  Fe
                ] : Xe);
              }
            }
            ve.push(...ce);
          } else
            ve.push(pe);
        return ve;
      }, U.getVariants = function() {
        let ue = Math.random().toString(36).substring(7).toUpperCase(), ve = [];
        for (let [de, Te] of U.variantOptions.entries())
          if (Te.variantInfo !== d.Base) {
            var me;
            ve.push({
              name: de,
              isArbitrary: Te.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((me = Te.values) !== null && me !== void 0 ? me : {}),
              hasDash: de !== "@",
              selectors({ modifier: Ie, value: pe } = {}) {
                let xe = `TAILWINDPLACEHOLDER${ue}`, he = n.default.rule({
                  selector: `.${xe}`
                }), ce = n.default.root({
                  nodes: [
                    he.clone()
                  ]
                }), _e = ce.toString();
                var Fe;
                let tt = ((Fe = U.variantMap.get(de)) !== null && Fe !== void 0 ? Fe : []).flatMap(([Ve, We]) => We), ze = [];
                for (let Ve of tt) {
                  var rt;
                  let We = [];
                  var Ue;
                  let Pt = {
                    args: {
                      modifier: Ie,
                      value: (Ue = (rt = Te.values) === null || rt === void 0 ? void 0 : rt[pe]) !== null && Ue !== void 0 ? Ue : pe
                    },
                    separator: U.tailwindConfig.separator,
                    modifySelectors(He) {
                      return ce.each((hr) => {
                        hr.type === "rule" && (hr.selectors = hr.selectors.map((ri) => He({
                          get className() {
                            return (0, O.getClassNameFromSelector)(ri);
                          },
                          selector: ri
                        })));
                      }), ce;
                    },
                    format(He) {
                      We.push(He);
                    },
                    wrap(He) {
                      We.push(`@${He.name} ${He.params} { & }`);
                    },
                    container: ce
                  }, Tt = Ve(Pt);
                  if (We.length > 0 && ze.push(We), Array.isArray(Tt))
                    for (let He of Tt)
                      We = [], He(Pt), ze.push(We);
                }
                let Xe = [], Es = ce.toString();
                _e !== Es && (ce.walkRules((Ve) => {
                  let We = Ve.selector, Pt = (0, i.default)((Tt) => {
                    Tt.walkClasses((He) => {
                      He.value = `${de}${U.tailwindConfig.separator}${He.value}`;
                    });
                  }).processSync(We);
                  Xe.push(We.replace(Pt, "&").replace(xe, "&"));
                }), ce.walkAtRules((Ve) => {
                  Xe.push(`@${Ve.name} (${Ve.params}) { & }`);
                }));
                var cr;
                let Ps = !(pe in ((cr = Te.values) !== null && cr !== void 0 ? cr : {}));
                var dr;
                let Ts = (dr = Te[T]) !== null && dr !== void 0 ? dr : {}, ei = !(Ps || Ts.respectPrefix === !1);
                ze = ze.map((Ve) => Ve.map((We) => ({
                  format: We,
                  respectPrefix: ei
                }))), Xe = Xe.map((Ve) => ({
                  format: Ve,
                  respectPrefix: ei
                }));
                let pr = {
                  candidate: xe,
                  context: U
                }, ti = ze.map((Ve) => (0, P.finalizeSelector)(`.${xe}`, (0, P.formatVariantSelector)(Ve, pr), pr).replace(`.${xe}`, "&").replace("{ & }", "").trim());
                return Xe.length > 0 && ti.push((0, P.formatVariantSelector)(Xe, pr).toString().replace(`.${xe}`, "&")), ti;
              }
            });
          }
        return ve;
      };
    }
    function Q(q, U) {
      q.classCache.has(U) && (q.notClassCache.add(U), q.classCache.delete(U), q.applyClassCache.delete(U), q.candidateRuleMap.delete(U), q.candidateRuleCache.delete(U), q.stylesheetCache = null);
    }
    function le(q, U) {
      let Z = U.raws.tailwind.candidate;
      if (Z) {
        for (const K of q.ruleCache)
          K[1].raws.tailwind.candidate === Z && q.ruleCache.delete(K);
        Q(q, Z);
      }
    }
    function ye(q, U = [], Z = n.default.root()) {
      var K;
      let X = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set(),
        candidateRuleCache: /* @__PURE__ */ new Map(),
        classCache: /* @__PURE__ */ new Map(),
        applyClassCache: /* @__PURE__ */ new Map(),
        // Seed the not class cache with the blocklist (which is only strings)
        notClassCache: new Set((K = q.blocklist) !== null && K !== void 0 ? K : []),
        postCssNodeCache: /* @__PURE__ */ new Map(),
        candidateRuleMap: /* @__PURE__ */ new Map(),
        tailwindConfig: q,
        changedContent: U,
        variantMap: /* @__PURE__ */ new Map(),
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map(),
        markInvalidUtilityCandidate: (se) => Q(X, se),
        markInvalidUtilityNode: (se) => le(X, se)
      }, ae = J(X, Z);
      return ee(ae, X), X;
    }
    let Oe = h.contextMap, Ae = h.configContextMap, oe = h.contextSourcesMap;
    function Ne(q, U, Z, K, X, ae) {
      let se = U.opts.from, Se = K !== null;
      h.env.DEBUG && console.log("Source path:", se);
      let fe;
      if (Se && Oe.has(se))
        fe = Oe.get(se);
      else if (Ae.has(X)) {
        let ne = Ae.get(X);
        oe.get(ne).add(se), Oe.set(se, ne), fe = ne;
      }
      let Pe = (0, E.hasContentChanged)(se, q);
      if (fe) {
        let [ne, te] = B([
          ...ae
        ], L(fe));
        if (!ne && !Pe)
          return [
            fe,
            !1,
            te
          ];
      }
      if (Oe.has(se)) {
        let ne = Oe.get(se);
        if (oe.has(ne) && (oe.get(ne).delete(se), oe.get(ne).size === 0)) {
          oe.delete(ne);
          for (let [te, ue] of Ae)
            ue === ne && Ae.delete(te);
          for (let te of ne.disposables.splice(0))
            te(ne);
        }
      }
      h.env.DEBUG && console.log("Setting up new context...");
      let ge = ye(Z, [], q);
      Object.assign(ge, {
        userConfigPath: K
      });
      let [, Ce] = B([
        ...ae
      ], L(ge));
      return Ae.set(X, ge), Oe.set(se, ge), oe.has(ge) || oe.set(ge, /* @__PURE__ */ new Set()), oe.get(ge).add(se), [
        ge,
        !0,
        Ce
      ];
    }
  }(Ir)), Ir;
}
var Xn = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "applyImportantSelector", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r(Ke), t = ur;
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n(l, i) {
    let c = (0, e.default)().astSync(l);
    return c.each((a) => {
      a.nodes.some((f) => f.type === "combinator") && (a.nodes = [
        e.default.pseudo({
          value: ":is",
          nodes: [
            a.clone()
          ]
        })
      ]), (0, t.movePseudos)(a);
    }), `${i} ${c.toString()}`;
  }
})(Xn);
var Ii;
function fr() {
  return Ii || (Ii = 1, function(s) {
    Object.defineProperty(s, "__esModule", {
      value: !0
    });
    function e(w, L) {
      for (var B in L)
        Object.defineProperty(w, B, {
          enumerable: !0,
          get: L[B]
        });
    }
    e(s, {
      getClassNameFromSelector: function() {
        return M;
      },
      resolveMatches: function() {
        return z;
      },
      generateRules: function() {
        return G;
      }
    });
    const t = /* @__PURE__ */ S(qe), r = /* @__PURE__ */ S(Ke), n = /* @__PURE__ */ S(jn), l = /* @__PURE__ */ S(dt), i = /* @__PURE__ */ S(lr), c = At, a = /* @__PURE__ */ S(et), o = /* @__PURE__ */ O(Et), f = Yn, u = Hn, p = Ct, _ = Kn(), x = /* @__PURE__ */ S(Jn), h = ot, m = it, C = Xn;
    function S(w) {
      return w && w.__esModule ? w : {
        default: w
      };
    }
    function k(w) {
      if (typeof WeakMap != "function")
        return null;
      var L = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakMap();
      return (k = function(H) {
        return H ? B : L;
      })(w);
    }
    function O(w, L) {
      if (w && w.__esModule)
        return w;
      if (w === null || typeof w != "object" && typeof w != "function")
        return {
          default: w
        };
      var B = k(L);
      if (B && B.has(w))
        return B.get(w);
      var H = {}, Y = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J in w)
        if (J !== "default" && Object.prototype.hasOwnProperty.call(w, J)) {
          var ee = Y ? Object.getOwnPropertyDescriptor(w, J) : null;
          ee && (ee.get || ee.set) ? Object.defineProperty(H, J, ee) : H[J] = w[J];
        }
      return H.default = w, B && B.set(w, H), H;
    }
    let E = (0, r.default)((w) => w.first.filter(({ type: L }) => L === "class").pop().value);
    function M(w) {
      return E.transformSync(w);
    }
    function* D(w) {
      let L = 1 / 0;
      for (; L >= 0; ) {
        let B, H = !1;
        if (L === 1 / 0 && w.endsWith("]")) {
          let ee = w.indexOf("[");
          w[ee - 1] === "-" ? B = ee - 1 : w[ee - 1] === "/" ? (B = ee - 1, H = !0) : B = -1;
        } else
          L === 1 / 0 && w.includes("/") ? (B = w.lastIndexOf("/"), H = !0) : B = w.lastIndexOf("-", L);
        if (B < 0)
          break;
        let Y = w.slice(0, B), J = w.slice(H ? B : B + 1);
        L = B - 1, !(Y === "" || J === "/") && (yield [
          Y,
          J
        ]);
      }
    }
    function P(w, L) {
      if (w.length === 0 || L.tailwindConfig.prefix === "")
        return w;
      for (let B of w) {
        let [H] = B;
        if (H.options.respectPrefix) {
          let Y = t.default.root({
            nodes: [
              B[1].clone()
            ]
          }), J = B[1].raws.tailwind.classCandidate;
          Y.walkRules((ee) => {
            let Q = J.startsWith("-");
            ee.selector = (0, i.default)(L.tailwindConfig.prefix, ee.selector, Q);
          }), B[1] = Y.nodes[0];
        }
      }
      return w;
    }
    function b(w, L) {
      if (w.length === 0)
        return w;
      let B = [];
      function H(Y) {
        return Y.parent && Y.parent.type === "atrule" && Y.parent.name === "keyframes";
      }
      for (let [Y, J] of w) {
        let ee = t.default.root({
          nodes: [
            J.clone()
          ]
        });
        ee.walkRules((Q) => {
          if (H(Q))
            return;
          let le = (0, r.default)().astSync(Q.selector);
          le.each((ye) => (0, f.eliminateIrrelevantSelectors)(ye, L)), (0, c.updateAllClasses)(le, (ye) => ye === L ? `!${ye}` : ye), Q.selector = le.toString(), Q.walkDecls((ye) => ye.important = !0);
        }), B.push([
          {
            ...Y,
            important: !0
          },
          ee.nodes[0]
        ]);
      }
      return B;
    }
    function A(w, L, B) {
      if (L.length === 0)
        return L;
      let H = {
        modifier: null,
        value: o.NONE
      };
      {
        let [Q, ...le] = (0, h.splitAtTopLevelOnly)(w, "/");
        if (le.length > 1 && (Q = Q + "/" + le.slice(0, -1).join("/"), le = le.slice(-1)), le.length && !B.variantMap.has(w) && (w = Q, H.modifier = le[0], !(0, m.flagEnabled)(B.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if (w.endsWith("]") && !w.startsWith("[")) {
        let Q = /(.)(-?)\[(.*)\]/g.exec(w);
        if (Q) {
          let [, le, ye, Oe] = Q;
          if (le === "@" && ye === "-")
            return [];
          if (le !== "@" && ye === "")
            return [];
          w = w.replace(`${ye}[${Oe}]`, ""), H.value = Oe;
        }
      }
      if (re(w) && !B.variantMap.has(w)) {
        let Q = B.offsets.recordVariant(w), le = (0, p.normalize)(w.slice(1, -1)), ye = (0, h.splitAtTopLevelOnly)(le, ",");
        if (ye.length > 1)
          return [];
        if (!ye.every(_.isValidVariantFormatString))
          return [];
        let Oe = ye.map((Ae, oe) => [
          B.offsets.applyParallelOffset(Q, oe),
          (0, _.parseVariant)(Ae.trim())
        ]);
        B.variantMap.set(w, Oe);
      }
      if (B.variantMap.has(w)) {
        var Y;
        let Q = re(w);
        var J;
        let le = (J = (Y = B.variantOptions.get(w)) === null || Y === void 0 ? void 0 : Y[_.INTERNAL_FEATURES]) !== null && J !== void 0 ? J : {}, ye = B.variantMap.get(w).slice(), Oe = [], Ae = !(Q || le.respectPrefix === !1);
        for (let [oe, Ne] of L) {
          if (oe.layer === "user")
            continue;
          let q = t.default.root({
            nodes: [
              Ne.clone()
            ]
          });
          for (let [U, Z, K] of ye) {
            let se = function() {
              X.raws.neededBackup || (X.raws.neededBackup = !0, X.walkRules((ge) => ge.raws.originalSelector = ge.selector));
            }, Se = function(ge) {
              return se(), X.each((Ce) => {
                Ce.type === "rule" && (Ce.selectors = Ce.selectors.map((ne) => ge({
                  get className() {
                    return M(ne);
                  },
                  selector: ne
                })));
              }), X;
            }, X = (K ?? q).clone(), ae = [], fe = Z({
              // Public API
              get container() {
                return se(), X;
              },
              separator: B.tailwindConfig.separator,
              modifySelectors: Se,
              // Private API for now
              wrap(ge) {
                let Ce = X.nodes;
                X.removeAll(), ge.append(Ce), X.append(ge);
              },
              format(ge) {
                ae.push({
                  format: ge,
                  respectPrefix: Ae
                });
              },
              args: H
            });
            if (Array.isArray(fe)) {
              for (let [ge, Ce] of fe.entries())
                ye.push([
                  B.offsets.applyParallelOffset(U, ge),
                  Ce,
                  // If the clone has been modified we have to pass that back
                  // though so each rule can use the modified container
                  X.clone()
                ]);
              continue;
            }
            if (typeof fe == "string" && ae.push({
              format: fe,
              respectPrefix: Ae
            }), fe === null)
              continue;
            X.raws.neededBackup && (delete X.raws.neededBackup, X.walkRules((ge) => {
              let Ce = ge.raws.originalSelector;
              if (!Ce || (delete ge.raws.originalSelector, Ce === ge.selector))
                return;
              let ne = ge.selector, te = (0, r.default)((ue) => {
                ue.walkClasses((ve) => {
                  ve.value = `${w}${B.tailwindConfig.separator}${ve.value}`;
                });
              }).processSync(Ce);
              ae.push({
                format: ne.replace(te, "&"),
                respectPrefix: Ae
              }), ge.selector = Ce;
            })), X.nodes[0].raws.tailwind = {
              ...X.nodes[0].raws.tailwind,
              parentLayer: oe.layer
            };
            var ee;
            let Pe = [
              {
                ...oe,
                sort: B.offsets.applyVariantOffset(oe.sort, U, Object.assign(H, B.variantOptions.get(w))),
                collectedFormats: ((ee = oe.collectedFormats) !== null && ee !== void 0 ? ee : []).concat(ae)
              },
              X.nodes[0]
            ];
            Oe.push(Pe);
          }
        }
        return Oe;
      }
      return [];
    }
    function N(w, L, B = {}) {
      return !(0, l.default)(w) && !Array.isArray(w) ? [
        [
          w
        ],
        B
      ] : Array.isArray(w) ? N(w[0], L, w[1]) : (L.has(w) || L.set(w, (0, n.default)(w)), [
        L.get(w),
        B
      ]);
    }
    const T = /^[a-z_-]/;
    function V(w) {
      return T.test(w);
    }
    function d(w) {
      if (!w.includes("://"))
        return !1;
      try {
        const L = new URL(w);
        return L.scheme !== "" && L.host !== "";
      } catch {
        return !1;
      }
    }
    function g(w) {
      let L = !0;
      return w.walkDecls((B) => {
        if (!v(B.prop, B.value))
          return L = !1, !1;
      }), L;
    }
    function v(w, L) {
      if (d(`${w}:${L}`))
        return !1;
      try {
        return t.default.parse(`a{${w}:${L}}`).toResult(), !0;
      } catch {
        return !1;
      }
    }
    function y(w, L) {
      var B;
      let [, H, Y] = (B = w.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && B !== void 0 ? B : [];
      if (Y === void 0 || !V(H) || !(0, x.default)(Y))
        return null;
      let J = (0, p.normalize)(Y, {
        property: H
      });
      return v(H, J) ? [
        [
          {
            sort: L.offsets.arbitraryProperty(w),
            layer: "utilities",
            options: {
              respectImportant: !0
            }
          },
          () => ({
            [(0, u.asClass)(w)]: {
              [H]: J
            }
          })
        ]
      ] : null;
    }
    function* R(w, L) {
      L.candidateRuleMap.has(w) && (yield [
        L.candidateRuleMap.get(w),
        "DEFAULT"
      ]), yield* function* (Q) {
        Q !== null && (yield [
          Q,
          "DEFAULT"
        ]);
      }(y(w, L));
      let B = w, H = !1;
      const Y = L.tailwindConfig.prefix, J = Y.length, ee = B.startsWith(Y) || B.startsWith(`-${Y}`);
      B[J] === "-" && ee && (H = !0, B = Y + B.slice(J + 1)), H && L.candidateRuleMap.has(B) && (yield [
        L.candidateRuleMap.get(B),
        "-DEFAULT"
      ]);
      for (let [Q, le] of D(B))
        L.candidateRuleMap.has(Q) && (yield [
          L.candidateRuleMap.get(Q),
          H ? `-${le}` : le
        ]);
    }
    function F(w, L) {
      return w === o.NOT_ON_DEMAND ? [
        o.NOT_ON_DEMAND
      ] : (0, h.splitAtTopLevelOnly)(w, L);
    }
    function* $(w, L) {
      for (const Y of w) {
        var B, H;
        Y[1].raws.tailwind = {
          ...Y[1].raws.tailwind,
          classCandidate: L,
          preserveSource: (H = (B = Y[0].options) === null || B === void 0 ? void 0 : B.preserveSource) !== null && H !== void 0 ? H : !1
        }, yield Y;
      }
    }
    function* z(w, L) {
      let B = L.tailwindConfig.separator, [H, ...Y] = F(w, B).reverse(), J = !1;
      H.startsWith("!") && (J = !0, H = H.slice(1));
      for (let Ae of R(H, L)) {
        let oe = [], Ne = /* @__PURE__ */ new Map(), [q, U] = Ae, Z = q.length === 1;
        for (let [K, X] of q) {
          let ae = [];
          if (typeof X == "function")
            for (let se of [].concat(X(U, {
              isOnlyPlugin: Z
            }))) {
              let [Se, fe] = N(se, L.postCssNodeCache);
              for (let Pe of Se)
                ae.push([
                  {
                    ...K,
                    options: {
                      ...K.options,
                      ...fe
                    }
                  },
                  Pe
                ]);
            }
          else if (U === "DEFAULT" || U === "-DEFAULT") {
            let se = X, [Se, fe] = N(se, L.postCssNodeCache);
            for (let Pe of Se)
              ae.push([
                {
                  ...K,
                  options: {
                    ...K.options,
                    ...fe
                  }
                },
                Pe
              ]);
          }
          if (ae.length > 0) {
            var ee, Q, le;
            let se = Array.from((0, c.getMatchingTypes)((Q = (ee = K.options) === null || ee === void 0 ? void 0 : ee.types) !== null && Q !== void 0 ? Q : [], U, (le = K.options) !== null && le !== void 0 ? le : {}, L.tailwindConfig)).map(([Se, fe]) => fe);
            se.length > 0 && Ne.set(ae, se), oe.push(ae);
          }
        }
        if (re(U)) {
          if (oe.length > 1) {
            let ae = function(Se) {
              return Se.length === 1 ? Se[0] : Se.find((fe) => {
                let Pe = Ne.get(fe);
                return fe.some(([{ options: ge }, Ce]) => g(Ce) ? ge.types.some(({ type: ne, preferOnConflict: te }) => Pe.includes(ne) && te) : !1);
              });
            }, [K, X] = oe.reduce((Se, fe) => (fe.some(([{ options: ge }]) => ge.types.some(({ type: Ce }) => Ce === "any")) ? Se[0].push(fe) : Se[1].push(fe), Se), [
              [],
              []
            ]);
            var ye;
            let se = (ye = ae(X)) !== null && ye !== void 0 ? ye : ae(K);
            if (se)
              oe = [
                se
              ];
            else {
              var Oe;
              let Se = oe.map((Pe) => /* @__PURE__ */ new Set([
                ...(Oe = Ne.get(Pe)) !== null && Oe !== void 0 ? Oe : []
              ]));
              for (let Pe of Se)
                for (let ge of Pe) {
                  let Ce = !1;
                  for (let ne of Se)
                    Pe !== ne && ne.has(ge) && (ne.delete(ge), Ce = !0);
                  Ce && Pe.delete(ge);
                }
              let fe = [];
              for (let [Pe, ge] of Se.entries())
                for (let Ce of ge) {
                  let ne = oe[Pe].map(([, te]) => te).flat().map((te) => te.toString().split(`
`).slice(1, -1).map((ue) => ue.trim()).map((ue) => `      ${ue}`).join(`
`)).join(`

`);
                  fe.push(`  Use \`${w.replace("[", `[${Ce}:`)}\` for \`${ne.trim()}\``);
                  break;
                }
              a.default.warn([
                `The class \`${w}\` is ambiguous and matches multiple utilities.`,
                ...fe,
                `If this is content and not a class, replace it with \`${w.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          oe = oe.map((K) => K.filter((X) => g(X[1])));
        }
        oe = oe.flat(), oe = Array.from($(oe, H)), oe = P(oe, L), J && (oe = b(oe, H));
        for (let K of Y)
          oe = A(K, oe, L);
        for (let K of oe)
          K[1].raws.tailwind = {
            ...K[1].raws.tailwind,
            candidate: w
          }, K = j(K, {
            context: L,
            candidate: w
          }), K !== null && (yield K);
      }
    }
    function j(w, { context: L, candidate: B }) {
      if (!w[0].collectedFormats)
        return w;
      let H = !0, Y;
      try {
        Y = (0, f.formatVariantSelector)(w[0].collectedFormats, {
          context: L,
          candidate: B
        });
      } catch {
        return null;
      }
      let J = t.default.root({
        nodes: [
          w[1].clone()
        ]
      });
      return J.walkRules((ee) => {
        if (!W(ee))
          try {
            let Q = (0, f.finalizeSelector)(ee.selector, Y, {
              candidate: B,
              context: L
            });
            if (Q === null) {
              ee.remove();
              return;
            }
            ee.selector = Q;
          } catch {
            return H = !1, !1;
          }
      }), !H || J.nodes.length === 0 ? null : (w[1] = J.nodes[0], w);
    }
    function W(w) {
      return w.parent && w.parent.type === "atrule" && w.parent.name === "keyframes";
    }
    function I(w) {
      if (w === !0)
        return (L) => {
          W(L) || L.walkDecls((B) => {
            B.parent.type === "rule" && !W(B.parent) && (B.important = !0);
          });
        };
      if (typeof w == "string")
        return (L) => {
          W(L) || (L.selectors = L.selectors.map((B) => (0, C.applyImportantSelector)(B, w)));
        };
    }
    function G(w, L, B = !1) {
      let H = [], Y = I(L.tailwindConfig.important);
      for (let ee of w) {
        if (L.notClassCache.has(ee))
          continue;
        if (L.candidateRuleCache.has(ee)) {
          H = H.concat(Array.from(L.candidateRuleCache.get(ee)));
          continue;
        }
        let Q = Array.from(z(ee, L));
        if (Q.length === 0) {
          L.notClassCache.add(ee);
          continue;
        }
        L.classCache.set(ee, Q);
        var J;
        let le = (J = L.candidateRuleCache.get(ee)) !== null && J !== void 0 ? J : /* @__PURE__ */ new Set();
        L.candidateRuleCache.set(ee, le);
        for (const ye of Q) {
          let [{ sort: Oe, options: Ae }, oe] = ye;
          if (Ae.respectImportant && Y) {
            let q = t.default.root({
              nodes: [
                oe.clone()
              ]
            });
            q.walkRules(Y), oe = q.nodes[0];
          }
          let Ne = [
            Oe,
            B ? oe.clone() : oe
          ];
          le.add(Ne), L.ruleCache.add(Ne), H.push(Ne);
        }
      }
      return H;
    }
    function re(w) {
      return w.startsWith("[") && w.endsWith("]");
    }
  }(Er)), Er;
}
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return M;
    }
  });
  const e = /* @__PURE__ */ c(qe), t = /* @__PURE__ */ c(Ke), r = fr(), n = /* @__PURE__ */ c(pt), l = Xn, i = ur;
  function c(D) {
    return D && D.__esModule ? D : {
      default: D
    };
  }
  function a(D) {
    let P = /* @__PURE__ */ new Map();
    e.default.root({
      nodes: [
        D.clone()
      ]
    }).walkRules((T) => {
      (0, t.default)((V) => {
        V.walkClasses((d) => {
          let g = d.parent.toString(), v = P.get(g);
          v || P.set(g, v = /* @__PURE__ */ new Set()), v.add(d.value);
        });
      }).processSync(T.selector);
    });
    let A = Array.from(P.values(), (T) => Array.from(T)), N = A.flat();
    return Object.assign(N, {
      groups: A
    });
  }
  let o = (0, t.default)();
  function f(D) {
    return o.astSync(D);
  }
  function u(D, P) {
    let b = /* @__PURE__ */ new Set();
    for (let A of D)
      b.add(A.split(P).pop());
    return Array.from(b);
  }
  function p(D, P) {
    let b = D.tailwindConfig.prefix;
    return typeof b == "function" ? b(P) : b + P;
  }
  function* _(D) {
    for (yield D; D.parent; )
      yield D.parent, D = D.parent;
  }
  function x(D, P = {}) {
    let b = D.nodes;
    D.nodes = [];
    let A = D.clone(P);
    return D.nodes = b, A;
  }
  function h(D) {
    for (let P of _(D))
      if (D !== P) {
        if (P.type === "root")
          break;
        D = x(P, {
          nodes: [
            D
          ]
        });
      }
    return D;
  }
  function m(D, P) {
    let b = /* @__PURE__ */ new Map();
    return D.walkRules((A) => {
      for (let d of _(A)) {
        var N;
        if (((N = d.raws.tailwind) === null || N === void 0 ? void 0 : N.layer) !== void 0)
          return;
      }
      let T = h(A), V = P.offsets.create("user");
      for (let d of a(A)) {
        let g = b.get(d) || [];
        b.set(d, g), g.push([
          {
            layer: "user",
            sort: V,
            important: !1
          },
          T
        ]);
      }
    }), b;
  }
  function C(D, P) {
    for (let b of D) {
      if (P.notClassCache.has(b) || P.applyClassCache.has(b))
        continue;
      if (P.classCache.has(b)) {
        P.applyClassCache.set(b, P.classCache.get(b).map(([N, T]) => [
          N,
          T.clone()
        ]));
        continue;
      }
      let A = Array.from((0, r.resolveMatches)(b, P));
      if (A.length === 0) {
        P.notClassCache.add(b);
        continue;
      }
      P.applyClassCache.set(b, A);
    }
    return P.applyClassCache;
  }
  function S(D) {
    let P = null;
    return {
      get: (b) => (P = P || D(), P.get(b)),
      has: (b) => (P = P || D(), P.has(b))
    };
  }
  function k(D) {
    return {
      get: (P) => D.flatMap((b) => b.get(P) || []),
      has: (P) => D.some((b) => b.has(P))
    };
  }
  function O(D) {
    let P = D.split(/[\s\t\n]+/g);
    return P[P.length - 1] === "!important" ? [
      P.slice(0, -1),
      !0
    ] : [
      P,
      !1
    ];
  }
  function E(D, P, b) {
    let A = /* @__PURE__ */ new Set(), N = [];
    if (D.walkAtRules("apply", (g) => {
      let [v] = O(g.params);
      for (let y of v)
        A.add(y);
      N.push(g);
    }), N.length === 0)
      return;
    let T = k([
      b,
      C(A, P)
    ]);
    function V(g, v, y) {
      let R = f(g), F = f(v), z = f(`.${(0, n.default)(y)}`).nodes[0].nodes[0];
      return R.each((j) => {
        let W = /* @__PURE__ */ new Set();
        F.each((I) => {
          let G = !1;
          I = I.clone(), I.walkClasses((re) => {
            re.value === z.value && (G || (re.replaceWith(...j.nodes.map((w) => w.clone())), W.add(I), G = !0));
          });
        });
        for (let I of W) {
          let G = [
            []
          ];
          for (let re of I.nodes)
            re.type === "combinator" ? (G.push(re), G.push([])) : G[G.length - 1].push(re);
          I.nodes = [];
          for (let re of G)
            Array.isArray(re) && re.sort((w, L) => w.type === "tag" && L.type === "class" ? -1 : w.type === "class" && L.type === "tag" ? 1 : w.type === "class" && L.type === "pseudo" && L.value.startsWith("::") ? -1 : w.type === "pseudo" && w.value.startsWith("::") && L.type === "class" ? 1 : 0), I.nodes = I.nodes.concat(re);
        }
        j.replaceWith(...W);
      }), R.toString();
    }
    let d = /* @__PURE__ */ new Map();
    for (let g of N) {
      let [v] = d.get(g.parent) || [
        [],
        g.source
      ];
      d.set(g.parent, [
        v,
        g.source
      ]);
      let [y, R] = O(g.params);
      if (g.parent.type === "atrule") {
        if (g.parent.name === "screen") {
          let F = g.parent.params;
          throw g.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${y.map(($) => `${F}:${$}`).join(" ")} instead.`);
        }
        throw g.error(`@apply is not supported within nested at-rules like @${g.parent.name}. You can fix this by un-nesting @${g.parent.name}.`);
      }
      for (let F of y) {
        if ([
          p(P, "group"),
          p(P, "peer")
        ].includes(F))
          throw g.error(`@apply should not be used with the '${F}' utility`);
        if (!T.has(F))
          throw g.error(`The \`${F}\` class does not exist. If \`${F}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
        let $ = T.get(F);
        for (let [, z] of $)
          z.type !== "atrule" && z.walkRules(() => {
            throw g.error([
              `The \`${F}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
              "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
              "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
            ].join(`
`));
          });
        v.push([
          F,
          R,
          $
        ]);
      }
    }
    for (let [g, [v, y]] of d) {
      let R = [];
      for (let [$, z, j] of v) {
        let W = [
          $,
          ...u([
            $
          ], P.tailwindConfig.separator)
        ];
        for (let [I, G] of j) {
          let re = a(g), w = a(G);
          if (w = w.groups.filter((Y) => Y.some((J) => W.includes(J))).flat(), w = w.concat(u(w, P.tailwindConfig.separator)), re.some((Y) => w.includes(Y)))
            throw G.error(`You cannot \`@apply\` the \`${$}\` utility here because it creates a circular dependency.`);
          let B = e.default.root({
            nodes: [
              G.clone()
            ]
          });
          B.walk((Y) => {
            Y.source = y;
          }), (G.type !== "atrule" || G.type === "atrule" && G.name !== "keyframes") && B.walkRules((Y) => {
            if (!a(Y).some((ye) => ye === $)) {
              Y.remove();
              return;
            }
            let J = typeof P.tailwindConfig.important == "string" ? P.tailwindConfig.important : null, Q = g.raws.tailwind !== void 0 && J && g.selector.indexOf(J) === 0 ? g.selector.slice(J.length) : g.selector;
            Q === "" && (Q = g.selector), Y.selector = V(Q, Y.selector, $), J && Q !== g.selector && (Y.selector = (0, l.applyImportantSelector)(Y.selector, J)), Y.walkDecls((ye) => {
              ye.important = I.important || z;
            });
            let le = (0, t.default)().astSync(Y.selector);
            le.each((ye) => (0, i.movePseudos)(ye)), Y.selector = le.toString();
          }), B.nodes[0] && R.push([
            I.sort,
            B.nodes[0]
          ]);
        }
      }
      let F = P.offsets.sort(R).map(($) => $[1]);
      g.after(F);
    }
    for (let g of N)
      g.parent.nodes.length > 1 ? g.remove() : g.parent.remove();
    E(D, P, b);
  }
  function M(D) {
    return (P) => {
      let b = S(() => m(P, D));
      E(P, D, b);
    };
  }
})(Pa);
const _c = /* @__PURE__ */ Qe(Pa);
var ls = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(p, _) {
    for (var x in _)
      Object.defineProperty(p, x, {
        enumerable: !0,
        get: _[x]
      });
  }
  e(s, {
    elementSelectorParser: function() {
      return a;
    },
    default: function() {
      return u;
    }
  });
  const t = /* @__PURE__ */ l(qe), r = /* @__PURE__ */ l(Ke), n = it;
  function l(p) {
    return p && p.__esModule ? p : {
      default: p
    };
  }
  let i = {
    id(p) {
      return r.default.attribute({
        attribute: "id",
        operator: "=",
        value: p.value,
        quoteMark: '"'
      });
    }
  };
  function c(p) {
    let _ = p.filter((k) => k.type !== "pseudo" || k.nodes.length > 0 ? !0 : k.value.startsWith("::") || [
      ":before",
      ":after",
      ":first-line",
      ":first-letter"
    ].includes(k.value)).reverse(), x = /* @__PURE__ */ new Set([
      "tag",
      "class",
      "id",
      "attribute"
    ]), h = _.findIndex((k) => x.has(k.type));
    if (h === -1)
      return _.reverse().join("").trim();
    let m = _[h], C = i[m.type] ? i[m.type](m) : m;
    _ = _.slice(0, h);
    let S = _.findIndex((k) => k.type === "combinator" && k.value === ">");
    return S !== -1 && (_.splice(0, S), _.unshift(r.default.universal())), [
      C,
      ..._.reverse()
    ].join("").trim();
  }
  let a = (0, r.default)((p) => p.map((_) => {
    let x = _.split((h) => h.type === "combinator" && h.value === " ").pop();
    return c(x);
  })), o = /* @__PURE__ */ new Map();
  function f(p) {
    return o.has(p) || o.set(p, a.transformSync(p)), o.get(p);
  }
  function u({ tailwindConfig: p }) {
    return (_) => {
      let x = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Set();
      if (_.walkAtRules("defaults", (S) => {
        if (S.nodes && S.nodes.length > 0) {
          h.add(S);
          return;
        }
        let k = S.params;
        x.has(k) || x.set(k, /* @__PURE__ */ new Set()), x.get(k).add(S.parent), S.remove();
      }), (0, n.flagEnabled)(p, "optimizeUniversalDefaults"))
        for (let S of h) {
          let k = /* @__PURE__ */ new Map();
          var m;
          let O = (m = x.get(S.params)) !== null && m !== void 0 ? m : [];
          for (let E of O)
            for (let M of f(E.selector)) {
              let D = M.includes(":-") || M.includes("::-") || M.includes(":has") ? M : "__DEFAULT__";
              var C;
              let P = (C = k.get(D)) !== null && C !== void 0 ? C : /* @__PURE__ */ new Set();
              k.set(D, P), P.add(M);
            }
          if ((0, n.flagEnabled)(p, "optimizeUniversalDefaults")) {
            if (k.size === 0) {
              S.remove();
              continue;
            }
            for (let [, E] of k) {
              let M = t.default.rule({
                source: S.source
              });
              M.selectors = [
                ...E
              ], M.append(S.nodes.map((D) => D.clone())), S.before(M);
            }
          }
          S.remove();
        }
      else if (h.size) {
        let S = t.default.rule({
          selectors: [
            "*",
            "::before",
            "::after"
          ]
        });
        for (let O of h)
          S.append(O.nodes), S.parent || O.before(S), S.source || (S.source = O.source), O.remove();
        let k = S.clone({
          selectors: [
            "::backdrop"
          ]
        });
        S.after(k);
      }
    };
  }
})(ls);
const Sc = /* @__PURE__ */ Qe(ls);
var Oc = fr(), us = {};
class kc {
  constructor(e = {}) {
    if (!(e.maxSize && e.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof e.maxAge == "number" && e.maxAge === 0)
      throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = e.maxSize, this.maxAge = e.maxAge || 1 / 0, this.onEviction = e.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _emitEvictions(e) {
    if (typeof this.onEviction == "function")
      for (const [t, r] of e)
        this.onEviction(t, r.value);
  }
  _deleteIfExpired(e, t) {
    return typeof t.expiry == "number" && t.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e, t.value), this.delete(e)) : !1;
  }
  _getOrDeleteIfExpired(e, t) {
    if (this._deleteIfExpired(e, t) === !1)
      return t.value;
  }
  _getItemValue(e, t) {
    return t.expiry ? this._getOrDeleteIfExpired(e, t) : t.value;
  }
  _peek(e, t) {
    const r = t.get(e);
    return this._getItemValue(e, r);
  }
  _set(e, t) {
    this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(e, t) {
    this.oldCache.delete(e), this._set(e, t);
  }
  *_entriesAscending() {
    for (const e of this.oldCache) {
      const [t, r] = e;
      this.cache.has(t) || this._deleteIfExpired(t, r) === !1 && (yield e);
    }
    for (const e of this.cache) {
      const [t, r] = e;
      this._deleteIfExpired(t, r) === !1 && (yield e);
    }
  }
  get(e) {
    if (this.cache.has(e)) {
      const t = this.cache.get(e);
      return this._getItemValue(e, t);
    }
    if (this.oldCache.has(e)) {
      const t = this.oldCache.get(e);
      if (this._deleteIfExpired(e, t) === !1)
        return this._moveToRecent(e, t), t.value;
    }
  }
  set(e, t, { maxAge: r = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
    this.cache.has(e) ? this.cache.set(e, {
      value: t,
      maxAge: r
    }) : this._set(e, { value: t, expiry: r });
  }
  has(e) {
    return this.cache.has(e) ? !this._deleteIfExpired(e, this.cache.get(e)) : this.oldCache.has(e) ? !this._deleteIfExpired(e, this.oldCache.get(e)) : !1;
  }
  peek(e) {
    if (this.cache.has(e))
      return this._peek(e, this.cache);
    if (this.oldCache.has(e))
      return this._peek(e, this.oldCache);
  }
  delete(e) {
    const t = this.cache.delete(e);
    return t && this._size--, this.oldCache.delete(e) || t;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(e) {
    if (!(e && e > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    const t = [...this._entriesAscending()], r = t.length - e;
    r < 0 ? (this.cache = new Map(t), this.oldCache = /* @__PURE__ */ new Map(), this._size = t.length) : (r > 0 && this._emitEvictions(t.slice(0, r)), this.oldCache = new Map(t.slice(r)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e;
  }
  *keys() {
    for (const [e] of this)
      yield e;
  }
  *values() {
    for (const [, e] of this)
      yield e;
  }
  *[Symbol.iterator]() {
    for (const e of this.cache) {
      const [t, r] = e;
      this._deleteIfExpired(t, r) === !1 && (yield [t, r.value]);
    }
    for (const e of this.oldCache) {
      const [t, r] = e;
      this.cache.has(t) || this._deleteIfExpired(t, r) === !1 && (yield [t, r.value]);
    }
  }
  *entriesDescending() {
    let e = [...this.cache];
    for (let t = e.length - 1; t >= 0; --t) {
      const r = e[t], [n, l] = r;
      this._deleteIfExpired(n, l) === !1 && (yield [n, l.value]);
    }
    e = [...this.oldCache];
    for (let t = e.length - 1; t >= 0; --t) {
      const r = e[t], [n, l] = r;
      this.cache.has(n) || this._deleteIfExpired(n, l) === !1 && (yield [n, l.value]);
    }
  }
  *entriesAscending() {
    for (const [e, t] of this._entriesAscending())
      yield [e, t.value];
  }
  get size() {
    if (!this._size)
      return this.oldCache.size;
    let e = 0;
    for (const t of this.oldCache.keys())
      this.cache.has(t) || e++;
    return Math.min(this._size + e, this.maxSize);
  }
}
var Ac = kc, fs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(r, n = void 0, l = void 0) {
    return r.map((i) => {
      let c = i.clone();
      return l !== void 0 && (c.raws.tailwind = {
        ...c.raws.tailwind,
        ...l
      }), n !== void 0 && t(c, (a) => {
        var o;
        if (((o = a.raws.tailwind) === null || o === void 0 ? void 0 : o.preserveSource) === !0 && a.source)
          return !1;
        a.source = n;
      }), c;
    });
  }
  function t(r, n) {
    if (n(r) !== !1) {
      var l;
      (l = r.each) === null || l === void 0 || l.call(r, (i) => t(i, n));
    }
  }
})(fs);
var cs = {}, ds = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  });
  function e(p, _) {
    for (var x in _)
      Object.defineProperty(p, x, {
        enumerable: !0,
        get: _[x]
      });
  }
  e(s, {
    pattern: function() {
      return l;
    },
    withoutCapturing: function() {
      return i;
    },
    any: function() {
      return c;
    },
    optional: function() {
      return a;
    },
    zeroOrMore: function() {
      return o;
    },
    nestedBrackets: function() {
      return f;
    },
    escape: function() {
      return u;
    }
  });
  const t = /[\\^$.*+?()[\]{}|]/g, r = RegExp(t.source);
  function n(p) {
    return p = Array.isArray(p) ? p : [
      p
    ], p = p.map((_) => _ instanceof RegExp ? _.source : _), p.join("");
  }
  function l(p) {
    return new RegExp(n(p), "g");
  }
  function i(p) {
    return new RegExp(`(?:${n(p)})`, "g");
  }
  function c(p) {
    return `(?:${p.map(n).join("|")})`;
  }
  function a(p) {
    return `(?:${n(p)})?`;
  }
  function o(p) {
    return `(?:${n(p)})*`;
  }
  function f(p, _, x = 1) {
    return i([
      u(p),
      /[^\s]*/,
      x === 1 ? `[^${u(p)}${u(_)}s]*` : c([
        `[^${u(p)}${u(_)}s]*`,
        f(p, _, x - 1)
      ]),
      /[^\s]*/,
      u(_)
    ]);
  }
  function u(p) {
    return p && r.test(p) ? p.replace(t, "\\$&") : p || "";
  }
})(ds);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "defaultExtractor", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = /* @__PURE__ */ n(ds), t = ot;
  function r(f) {
    if (typeof WeakMap != "function")
      return null;
    var u = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap();
    return (r = function(_) {
      return _ ? p : u;
    })(f);
  }
  function n(f, u) {
    if (f && f.__esModule)
      return f;
    if (f === null || typeof f != "object" && typeof f != "function")
      return {
        default: f
      };
    var p = r(u);
    if (p && p.has(f))
      return p.get(f);
    var _ = {}, x = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h in f)
      if (h !== "default" && Object.prototype.hasOwnProperty.call(f, h)) {
        var m = x ? Object.getOwnPropertyDescriptor(f, h) : null;
        m && (m.get || m.set) ? Object.defineProperty(_, h, m) : _[h] = f[h];
      }
    return _.default = f, p && p.set(f, _), _;
  }
  function l(f) {
    let u = Array.from(i(f));
    return (p) => {
      let _ = [];
      for (let h of u) {
        var x;
        for (let m of (x = p.match(h)) !== null && x !== void 0 ? x : [])
          _.push(o(m));
      }
      for (let h of _.slice()) {
        let m = (0, t.splitAtTopLevelOnly)(h, ".");
        for (let C = 0; C < m.length; C++) {
          let S = m[C];
          if (C >= m.length - 1) {
            _.push(S);
            continue;
          }
          let k = Number(m[C + 1]);
          isNaN(k) ? _.push(S) : C++;
        }
      }
      return _;
    };
  }
  function* i(f) {
    let u = f.tailwindConfig.separator, p = f.tailwindConfig.prefix !== "" ? e.optional(e.pattern([
      /-?/,
      e.escape(f.tailwindConfig.prefix)
    ])) : "", _ = e.any([
      // Arbitrary properties (without square brackets)
      /\[[^\s:'"`]+:[^\s\[\]]+\]/,
      // Arbitrary properties with balanced square brackets
      // This is a targeted fix to continue to allow theme()
      // with square brackets to work in arbitrary properties
      // while fixing a problem with the regex matching too much
      /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
      // Utilities
      e.pattern([
        // Utility Name / Group Name
        e.any([
          /-?(?:\w+)/,
          // This is here to make sure @container supports everything that other utilities do
          /@(?:\w+)/
        ]),
        // Normal/Arbitrary values
        e.optional(e.any([
          e.pattern([
            // Arbitrary values
            e.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
            ]),
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\><$]*)?/
          ]),
          e.pattern([
            // Arbitrary values
            e.any([
              /-(?:\w+-)*\['[^\s]+'\]/,
              /-(?:\w+-)*\["[^\s]+"\]/,
              /-(?:\w+-)*\[`[^\s]+`\]/,
              /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
            ]),
            // Not immediately followed by an `{[(`
            /(?![{([]])/,
            // optionally followed by an opacity modifier
            /(?:\/[^\s'"`\\$]*)?/
          ]),
          // Normal values w/o quotes — may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/
        ]))
      ])
    ]), x = [
      // Without quotes
      e.any([
        // This is here to provide special support for the `@` variant
        e.pattern([
          /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
          u
        ]),
        // With variant modifier (e.g.: group-[..]/modifier)
        e.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/,
          u
        ]),
        e.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
          u
        ]),
        e.pattern([
          /[^\s"'`\[\\]+/,
          u
        ])
      ]),
      // With quotes allowed
      e.any([
        // With variant modifier (e.g.: group-[..]/modifier)
        e.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/,
          u
        ]),
        e.pattern([
          /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
          u
        ]),
        e.pattern([
          /[^\s`\[\\]+/,
          u
        ])
      ])
    ];
    for (const h of x)
      yield e.pattern([
        // Variants
        "((?=((",
        h,
        ")+))\\2)?",
        // Important (optional)
        /!?/,
        p,
        _
      ]);
    yield /[^<>"'`\s.(){}[\]#=%$][^<>"'`\s(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  let c = /([\[\]'"`])([^\[\]'"`])?/g, a = /[^"'`\s<>\]]+/;
  function o(f) {
    if (!f.includes("-["))
      return f;
    let u = 0, p = [], _ = f.matchAll(c);
    _ = Array.from(_).flatMap((x) => {
      const [, ...h] = x;
      return h.map((m, C) => Object.assign([], x, {
        index: x.index + C,
        0: m
      }));
    });
    for (let x of _) {
      let h = x[0], m = p[p.length - 1];
      if (h === m ? p.pop() : (h === "'" || h === '"' || h === "`") && p.push(h), !m) {
        if (h === "[") {
          u++;
          continue;
        } else if (h === "]") {
          u--;
          continue;
        }
        if (u < 0)
          return f.substring(0, x.index - 1);
        if (u === 0 && !a.test(h))
          return f.substring(0, x.index);
      }
    }
    return f;
  }
})(cs);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return k;
    }
  });
  const e = /* @__PURE__ */ a(Le), t = /* @__PURE__ */ a(Ac), r = /* @__PURE__ */ f(Et), n = fr(), l = /* @__PURE__ */ a(et), i = /* @__PURE__ */ a(fs), c = cs;
  function a(O) {
    return O && O.__esModule ? O : {
      default: O
    };
  }
  function o(O) {
    if (typeof WeakMap != "function")
      return null;
    var E = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap();
    return (o = function(D) {
      return D ? M : E;
    })(O);
  }
  function f(O, E) {
    if (O && O.__esModule)
      return O;
    if (O === null || typeof O != "object" && typeof O != "function")
      return {
        default: O
      };
    var M = o(E);
    if (M && M.has(O))
      return M.get(O);
    var D = {}, P = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var b in O)
      if (b !== "default" && Object.prototype.hasOwnProperty.call(O, b)) {
        var A = P ? Object.getOwnPropertyDescriptor(O, b) : null;
        A && (A.get || A.set) ? Object.defineProperty(D, b, A) : D[b] = O[b];
      }
    return D.default = O, M && M.set(O, D), D;
  }
  let u = r.env;
  const p = {
    DEFAULT: c.defaultExtractor
  }, _ = {
    DEFAULT: (O) => O,
    svelte: (O) => O.replace(/(?:^|\s)class:/g, " ")
  };
  function x(O, E) {
    let M = O.tailwindConfig.content.extract;
    return M[E] || M.DEFAULT || p[E] || p.DEFAULT(O);
  }
  function h(O, E) {
    let M = O.content.transform;
    return M[E] || M.DEFAULT || _[E] || _.DEFAULT;
  }
  let m = /* @__PURE__ */ new WeakMap();
  function C(O, E, M, D) {
    m.has(E) || m.set(E, new t.default({
      maxSize: 25e3
    }));
    for (let P of O.split(`
`))
      if (P = P.trim(), !D.has(P))
        if (D.add(P), m.get(E).has(P))
          for (let b of m.get(E).get(P))
            M.add(b);
        else {
          let b = E(P).filter((N) => N !== "!*"), A = new Set(b);
          for (let N of A)
            M.add(N);
          m.get(E).set(P, A);
        }
  }
  function S(O, E) {
    let M = E.offsets.sort(O), D = {
      base: /* @__PURE__ */ new Set(),
      defaults: /* @__PURE__ */ new Set(),
      components: /* @__PURE__ */ new Set(),
      utilities: /* @__PURE__ */ new Set(),
      variants: /* @__PURE__ */ new Set()
    };
    for (let [P, b] of M)
      D[P.layer].add(b);
    return D;
  }
  function k(O) {
    return async (E) => {
      let M = {
        base: null,
        components: null,
        utilities: null,
        variants: null
      };
      if (E.walkAtRules((j) => {
        j.name === "tailwind" && Object.keys(M).includes(j.params) && (M[j.params] = j);
      }), Object.values(M).every((j) => j === null))
        return E;
      var D;
      let P = /* @__PURE__ */ new Set([
        ...(D = O.candidates) !== null && D !== void 0 ? D : [],
        r.NOT_ON_DEMAND
      ]), b = /* @__PURE__ */ new Set();
      u.DEBUG && console.time("Reading changed files");
      let A = [];
      for (let j of O.changedContent) {
        let W = h(O.tailwindConfig, j.extension), I = x(O, j.extension);
        A.push([
          j,
          {
            transformer: W,
            extractor: I
          }
        ]);
      }
      const N = 500;
      for (let j = 0; j < A.length; j += N) {
        let W = A.slice(j, j + N);
        await Promise.all(W.map(async ([{ file: I, content: G }, { transformer: re, extractor: w }]) => {
          G = I ? await e.default.promises.readFile(I, "utf8") : G, C(re(G), w, P, b);
        }));
      }
      u.DEBUG && console.timeEnd("Reading changed files");
      let T = O.classCache.size;
      u.DEBUG && console.time("Generate rules"), u.DEBUG && console.time("Sorting candidates");
      let V = new Set([
        ...P
      ].sort((j, W) => j === W ? 0 : j < W ? -1 : 1));
      u.DEBUG && console.timeEnd("Sorting candidates"), (0, n.generateRules)(V, O), u.DEBUG && console.timeEnd("Generate rules"), u.DEBUG && console.time("Build stylesheet"), (O.stylesheetCache === null || O.classCache.size !== T) && (O.stylesheetCache = S([
        ...O.ruleCache
      ], O)), u.DEBUG && console.timeEnd("Build stylesheet");
      let { defaults: d, base: g, components: v, utilities: y, variants: R } = O.stylesheetCache;
      M.base && (M.base.before((0, i.default)([
        ...g,
        ...d
      ], M.base.source, {
        layer: "base"
      })), M.base.remove()), M.components && (M.components.before((0, i.default)([
        ...v
      ], M.components.source, {
        layer: "components"
      })), M.components.remove()), M.utilities && (M.utilities.before((0, i.default)([
        ...y
      ], M.utilities.source, {
        layer: "utilities"
      })), M.utilities.remove());
      const F = Array.from(R).filter((j) => {
        var W;
        const I = (W = j.raws.tailwind) === null || W === void 0 ? void 0 : W.parentLayer;
        return I === "components" ? M.components !== null : I === "utilities" ? M.utilities !== null : !0;
      });
      M.variants ? (M.variants.before((0, i.default)(F, M.variants.source, {
        layer: "variants"
      })), M.variants.remove()) : F.length > 0 && E.append((0, i.default)(F, E.source, {
        layer: "variants"
      }));
      var $;
      E.source.end = ($ = E.source.end) !== null && $ !== void 0 ? $ : E.source.start;
      const z = F.some((j) => {
        var W;
        return ((W = j.raws.tailwind) === null || W === void 0 ? void 0 : W.parentLayer) === "utilities";
      });
      M.utilities && y.size === 0 && !z && l.default.warn("content-problems", [
        "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
        "https://tailwindcss.com/docs/content-configuration"
      ]), u.DEBUG && (console.log("Potential classes: ", P.size), console.log("Active contexts: ", r.contextSourcesMap.size)), O.changedContent = [], E.walkAtRules("layer", (j) => {
        Object.keys(M).includes(j.params) && j.remove();
      });
    };
  }
})(us);
const Cc = /* @__PURE__ */ Qe(us);
var ps = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return t;
    }
  });
  function e(r) {
    if (!r.walkAtRules)
      return;
    let n = /* @__PURE__ */ new Set();
    if (r.walkAtRules("apply", (l) => {
      n.add(l.parent);
    }), n.size !== 0)
      for (let l of n) {
        let i = [], c = [];
        for (let a of l.nodes)
          a.type === "atrule" && a.name === "apply" ? (c.length > 0 && (i.push(c), c = []), i.push([
            a
          ])) : c.push(a);
        if (c.length > 0 && i.push(c), i.length !== 1) {
          for (let a of [
            ...i
          ].reverse()) {
            let o = l.clone({
              nodes: []
            });
            o.append(a), l.after(o);
          }
          l.remove();
        }
      }
  }
  function t() {
    return (r) => {
      e(r);
    };
  }
})(ps);
const Ri = /* @__PURE__ */ Qe(ps);
var hs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = rr, t = /* @__PURE__ */ r(nr);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n({ tailwindConfig: { theme: l } }) {
    return function(i) {
      i.walkAtRules("screen", (c) => {
        let a = c.params, f = (0, e.normalizeScreens)(l.screens).find(({ name: u }) => u === a);
        if (!f)
          throw c.error(`No \`${a}\` screen found.`);
        c.name = "media", c.params = (0, t.default)(f);
      });
    };
  }
})(hs);
const Ec = /* @__PURE__ */ Qe(hs);
var ms = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return r;
    }
  });
  let e = {
    atrule: [
      "name",
      "params"
    ],
    rule: [
      "selector"
    ]
  }, t = new Set(Object.keys(e));
  function r() {
    function n(l) {
      let i = null;
      l.each((c) => {
        if (!t.has(c.type)) {
          i = null;
          return;
        }
        if (i === null) {
          i = c;
          return;
        }
        let a = e[c.type];
        var o, f;
        c.type === "atrule" && c.name === "font-face" ? i = c : a.every((u) => ((o = c[u]) !== null && o !== void 0 ? o : "").replace(/\s+/g, " ") === ((f = i[u]) !== null && f !== void 0 ? f : "").replace(/\s+/g, " ")) ? (c.nodes && i.append(c.nodes), c.remove()) : i = c;
      }), l.each((c) => {
        c.type === "atrule" && n(c);
      });
    }
    return (l) => {
      n(l);
    };
  }
})(ms);
const Pc = /* @__PURE__ */ Qe(ms);
var gs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e() {
    return (n) => {
      n.walkRules((l) => {
        let i = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set([]), a = /* @__PURE__ */ new Map();
        l.walkDecls((o) => {
          if (o.parent === l) {
            if (i.has(o.prop)) {
              if (i.get(o.prop).value === o.value) {
                c.add(i.get(o.prop)), i.set(o.prop, o);
                return;
              }
              a.has(o.prop) || a.set(o.prop, /* @__PURE__ */ new Set()), a.get(o.prop).add(i.get(o.prop)), a.get(o.prop).add(o);
            }
            i.set(o.prop, o);
          }
        });
        for (let o of c)
          o.remove();
        for (let o of a.values()) {
          let f = /* @__PURE__ */ new Map();
          for (let u of o) {
            let p = r(u.value);
            p !== null && (f.has(p) || f.set(p, /* @__PURE__ */ new Set()), f.get(p).add(u));
          }
          for (let u of f.values()) {
            let p = Array.from(u).slice(0, -1);
            for (let _ of p)
              _.remove();
          }
        }
      });
    };
  }
  let t = Symbol("unitless-number");
  function r(n) {
    let l = /^-?\d*.?\d+([\w%]+)?$/g.exec(n);
    if (l) {
      var i;
      return (i = l[1]) !== null && i !== void 0 ? i : t;
    }
    return null;
  }
})(gs);
const Tc = /* @__PURE__ */ Qe(gs), Zn = (s) => {
  if (s.first === void 0) {
    const e = s.parent;
    e && (s.remove(), Zn(e));
  }
}, Mc = (s, e) => s instanceof xi && e instanceof xi ? s.selector === e.selector || e.selector.includes("*") || e.selector.includes(":root") : s === e, Ic = (s) => (s.walkRules((e) => {
  const t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  e.walkDecls((n) => {
    if (/var\(--[^\s)]+\)/.test(n.value)) {
      const l = /var\(--[^\s)]+\)/gm.exec(n.value);
      s.walkDecls((i) => {
        var c;
        if (/--[^\s]+/.test(i.prop)) {
          const a = `var(${i.prop})`;
          if (l && l.includes(a) && Mc(n.parent, i.parent)) {
            if (((c = i.parent) == null ? void 0 : c.parent) instanceof kl && i.parent !== n.parent) {
              const o = i.parent.parent, f = Ol();
              f.prop = n.prop, f.value = n.value.replaceAll(
                a,
                i.value
              ), f.important = n.important;
              const u = t.get(o);
              u ? u.add(f) : t.set(
                i.parent.parent,
                /* @__PURE__ */ new Set([f])
              );
              return;
            }
            r.add({
              declaration: n,
              newValue: n.value.replaceAll(a, i.value)
            });
          }
        }
      });
    }
  });
  for (const { declaration: n, newValue: l } of r)
    n.value = l;
  for (const [n, l] of t.entries()) {
    const i = Sl();
    i.selector = e.selector, i.append(...l), n.append(i);
  }
}), s.walkDecls((e) => {
  if (/--[^\s]+/.test(e.prop)) {
    const t = e.parent;
    e.remove(), t && Zn(t);
  }
}), s);
var Rc = Kn(), vs = {}, ys = {}, ws = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  const e = [
    "preflight",
    "container",
    "accessibility",
    "pointerEvents",
    "visibility",
    "position",
    "inset",
    "isolation",
    "zIndex",
    "order",
    "gridColumn",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRow",
    "gridRowStart",
    "gridRowEnd",
    "float",
    "clear",
    "margin",
    "boxSizing",
    "lineClamp",
    "display",
    "aspectRatio",
    "size",
    "height",
    "maxHeight",
    "minHeight",
    "width",
    "minWidth",
    "maxWidth",
    "flex",
    "flexShrink",
    "flexGrow",
    "flexBasis",
    "tableLayout",
    "captionSide",
    "borderCollapse",
    "borderSpacing",
    "transformOrigin",
    "translate",
    "rotate",
    "skew",
    "scale",
    "transform",
    "animation",
    "cursor",
    "touchAction",
    "userSelect",
    "resize",
    "scrollSnapType",
    "scrollSnapAlign",
    "scrollSnapStop",
    "scrollMargin",
    "scrollPadding",
    "listStylePosition",
    "listStyleType",
    "listStyleImage",
    "appearance",
    "columns",
    "breakBefore",
    "breakInside",
    "breakAfter",
    "gridAutoColumns",
    "gridAutoFlow",
    "gridAutoRows",
    "gridTemplateColumns",
    "gridTemplateRows",
    "flexDirection",
    "flexWrap",
    "placeContent",
    "placeItems",
    "alignContent",
    "alignItems",
    "justifyContent",
    "justifyItems",
    "gap",
    "space",
    "divideWidth",
    "divideStyle",
    "divideColor",
    "divideOpacity",
    "placeSelf",
    "alignSelf",
    "justifySelf",
    "overflow",
    "overscrollBehavior",
    "scrollBehavior",
    "textOverflow",
    "hyphens",
    "whitespace",
    "textWrap",
    "wordBreak",
    "borderRadius",
    "borderWidth",
    "borderStyle",
    "borderColor",
    "borderOpacity",
    "backgroundColor",
    "backgroundOpacity",
    "backgroundImage",
    "gradientColorStops",
    "boxDecorationBreak",
    "backgroundSize",
    "backgroundAttachment",
    "backgroundClip",
    "backgroundPosition",
    "backgroundRepeat",
    "backgroundOrigin",
    "fill",
    "stroke",
    "strokeWidth",
    "objectFit",
    "objectPosition",
    "padding",
    "textAlign",
    "textIndent",
    "verticalAlign",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "textTransform",
    "fontStyle",
    "fontVariantNumeric",
    "lineHeight",
    "letterSpacing",
    "textColor",
    "textOpacity",
    "textDecoration",
    "textDecorationColor",
    "textDecorationStyle",
    "textDecorationThickness",
    "textUnderlineOffset",
    "fontSmoothing",
    "placeholderColor",
    "placeholderOpacity",
    "caretColor",
    "accentColor",
    "opacity",
    "backgroundBlendMode",
    "mixBlendMode",
    "boxShadow",
    "boxShadowColor",
    "outlineStyle",
    "outlineWidth",
    "outlineOffset",
    "outlineColor",
    "ringWidth",
    "ringColor",
    "ringOpacity",
    "ringOffsetWidth",
    "ringOffsetColor",
    "blur",
    "brightness",
    "contrast",
    "dropShadow",
    "grayscale",
    "hueRotate",
    "invert",
    "saturate",
    "sepia",
    "filter",
    "backdropBlur",
    "backdropBrightness",
    "backdropContrast",
    "backdropGrayscale",
    "backdropHueRotate",
    "backdropInvert",
    "backdropOpacity",
    "backdropSaturate",
    "backdropSepia",
    "backdropFilter",
    "transitionProperty",
    "transitionDelay",
    "transitionDuration",
    "transitionTimingFunction",
    "willChange",
    "contain",
    "content",
    "forcedColorAdjust"
  ];
})(ws);
var bs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t, r) {
    return t === void 0 ? r : Array.isArray(t) ? t : [
      ...new Set(r.filter((l) => t !== !1 && t[l] !== !1).concat(Object.keys(t).filter((l) => t[l] !== !1)))
    ];
  }
})(bs);
var xs = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ t(et);
  function t(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function r({ version: l, from: i, to: c }) {
    e.default.warn(`${i}-color-renamed`, [
      `As of Tailwind CSS ${l}, \`${i}\` has been renamed to \`${c}\`.`,
      "Update your configuration file to silence this warning."
    ]);
  }
  const n = {
    inherit: "inherit",
    current: "currentColor",
    transparent: "transparent",
    black: "#000",
    white: "#fff",
    slate: {
      50: "#f8fafc",
      100: "#f1f5f9",
      200: "#e2e8f0",
      300: "#cbd5e1",
      400: "#94a3b8",
      500: "#64748b",
      600: "#475569",
      700: "#334155",
      800: "#1e293b",
      900: "#0f172a",
      950: "#020617"
    },
    gray: {
      50: "#f9fafb",
      100: "#f3f4f6",
      200: "#e5e7eb",
      300: "#d1d5db",
      400: "#9ca3af",
      500: "#6b7280",
      600: "#4b5563",
      700: "#374151",
      800: "#1f2937",
      900: "#111827",
      950: "#030712"
    },
    zinc: {
      50: "#fafafa",
      100: "#f4f4f5",
      200: "#e4e4e7",
      300: "#d4d4d8",
      400: "#a1a1aa",
      500: "#71717a",
      600: "#52525b",
      700: "#3f3f46",
      800: "#27272a",
      900: "#18181b",
      950: "#09090b"
    },
    neutral: {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#e5e5e5",
      300: "#d4d4d4",
      400: "#a3a3a3",
      500: "#737373",
      600: "#525252",
      700: "#404040",
      800: "#262626",
      900: "#171717",
      950: "#0a0a0a"
    },
    stone: {
      50: "#fafaf9",
      100: "#f5f5f4",
      200: "#e7e5e4",
      300: "#d6d3d1",
      400: "#a8a29e",
      500: "#78716c",
      600: "#57534e",
      700: "#44403c",
      800: "#292524",
      900: "#1c1917",
      950: "#0c0a09"
    },
    red: {
      50: "#fef2f2",
      100: "#fee2e2",
      200: "#fecaca",
      300: "#fca5a5",
      400: "#f87171",
      500: "#ef4444",
      600: "#dc2626",
      700: "#b91c1c",
      800: "#991b1b",
      900: "#7f1d1d",
      950: "#450a0a"
    },
    orange: {
      50: "#fff7ed",
      100: "#ffedd5",
      200: "#fed7aa",
      300: "#fdba74",
      400: "#fb923c",
      500: "#f97316",
      600: "#ea580c",
      700: "#c2410c",
      800: "#9a3412",
      900: "#7c2d12",
      950: "#431407"
    },
    amber: {
      50: "#fffbeb",
      100: "#fef3c7",
      200: "#fde68a",
      300: "#fcd34d",
      400: "#fbbf24",
      500: "#f59e0b",
      600: "#d97706",
      700: "#b45309",
      800: "#92400e",
      900: "#78350f",
      950: "#451a03"
    },
    yellow: {
      50: "#fefce8",
      100: "#fef9c3",
      200: "#fef08a",
      300: "#fde047",
      400: "#facc15",
      500: "#eab308",
      600: "#ca8a04",
      700: "#a16207",
      800: "#854d0e",
      900: "#713f12",
      950: "#422006"
    },
    lime: {
      50: "#f7fee7",
      100: "#ecfccb",
      200: "#d9f99d",
      300: "#bef264",
      400: "#a3e635",
      500: "#84cc16",
      600: "#65a30d",
      700: "#4d7c0f",
      800: "#3f6212",
      900: "#365314",
      950: "#1a2e05"
    },
    green: {
      50: "#f0fdf4",
      100: "#dcfce7",
      200: "#bbf7d0",
      300: "#86efac",
      400: "#4ade80",
      500: "#22c55e",
      600: "#16a34a",
      700: "#15803d",
      800: "#166534",
      900: "#14532d",
      950: "#052e16"
    },
    emerald: {
      50: "#ecfdf5",
      100: "#d1fae5",
      200: "#a7f3d0",
      300: "#6ee7b7",
      400: "#34d399",
      500: "#10b981",
      600: "#059669",
      700: "#047857",
      800: "#065f46",
      900: "#064e3b",
      950: "#022c22"
    },
    teal: {
      50: "#f0fdfa",
      100: "#ccfbf1",
      200: "#99f6e4",
      300: "#5eead4",
      400: "#2dd4bf",
      500: "#14b8a6",
      600: "#0d9488",
      700: "#0f766e",
      800: "#115e59",
      900: "#134e4a",
      950: "#042f2e"
    },
    cyan: {
      50: "#ecfeff",
      100: "#cffafe",
      200: "#a5f3fc",
      300: "#67e8f9",
      400: "#22d3ee",
      500: "#06b6d4",
      600: "#0891b2",
      700: "#0e7490",
      800: "#155e75",
      900: "#164e63",
      950: "#083344"
    },
    sky: {
      50: "#f0f9ff",
      100: "#e0f2fe",
      200: "#bae6fd",
      300: "#7dd3fc",
      400: "#38bdf8",
      500: "#0ea5e9",
      600: "#0284c7",
      700: "#0369a1",
      800: "#075985",
      900: "#0c4a6e",
      950: "#082f49"
    },
    blue: {
      50: "#eff6ff",
      100: "#dbeafe",
      200: "#bfdbfe",
      300: "#93c5fd",
      400: "#60a5fa",
      500: "#3b82f6",
      600: "#2563eb",
      700: "#1d4ed8",
      800: "#1e40af",
      900: "#1e3a8a",
      950: "#172554"
    },
    indigo: {
      50: "#eef2ff",
      100: "#e0e7ff",
      200: "#c7d2fe",
      300: "#a5b4fc",
      400: "#818cf8",
      500: "#6366f1",
      600: "#4f46e5",
      700: "#4338ca",
      800: "#3730a3",
      900: "#312e81",
      950: "#1e1b4b"
    },
    violet: {
      50: "#f5f3ff",
      100: "#ede9fe",
      200: "#ddd6fe",
      300: "#c4b5fd",
      400: "#a78bfa",
      500: "#8b5cf6",
      600: "#7c3aed",
      700: "#6d28d9",
      800: "#5b21b6",
      900: "#4c1d95",
      950: "#2e1065"
    },
    purple: {
      50: "#faf5ff",
      100: "#f3e8ff",
      200: "#e9d5ff",
      300: "#d8b4fe",
      400: "#c084fc",
      500: "#a855f7",
      600: "#9333ea",
      700: "#7e22ce",
      800: "#6b21a8",
      900: "#581c87",
      950: "#3b0764"
    },
    fuchsia: {
      50: "#fdf4ff",
      100: "#fae8ff",
      200: "#f5d0fe",
      300: "#f0abfc",
      400: "#e879f9",
      500: "#d946ef",
      600: "#c026d3",
      700: "#a21caf",
      800: "#86198f",
      900: "#701a75",
      950: "#4a044e"
    },
    pink: {
      50: "#fdf2f8",
      100: "#fce7f3",
      200: "#fbcfe8",
      300: "#f9a8d4",
      400: "#f472b6",
      500: "#ec4899",
      600: "#db2777",
      700: "#be185d",
      800: "#9d174d",
      900: "#831843",
      950: "#500724"
    },
    rose: {
      50: "#fff1f2",
      100: "#ffe4e6",
      200: "#fecdd3",
      300: "#fda4af",
      400: "#fb7185",
      500: "#f43f5e",
      600: "#e11d48",
      700: "#be123c",
      800: "#9f1239",
      900: "#881337",
      950: "#4c0519"
    },
    get lightBlue() {
      return r({
        version: "v2.2",
        from: "lightBlue",
        to: "sky"
      }), this.sky;
    },
    get warmGray() {
      return r({
        version: "v3.0",
        from: "warmGray",
        to: "stone"
      }), this.stone;
    },
    get trueGray() {
      return r({
        version: "v3.0",
        from: "trueGray",
        to: "neutral"
      }), this.neutral;
    },
    get coolGray() {
      return r({
        version: "v3.0",
        from: "coolGray",
        to: "gray"
      }), this.gray;
    },
    get blueGray() {
      return r({
        version: "v3.0",
        from: "blueGray",
        to: "slate"
      }), this.slate;
    }
  };
})(xs);
var _s = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "defaults", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t, ...r) {
    for (let i of r) {
      for (let c in i) {
        var n;
        !(t == null || (n = t.hasOwnProperty) === null || n === void 0) && n.call(t, c) || (t[c] = i[c]);
      }
      for (let c of Object.getOwnPropertySymbols(i)) {
        var l;
        !(t == null || (l = t.hasOwnProperty) === null || l === void 0) && l.call(t, c) || (t[c] = i[c]);
      }
    }
    return t;
  }
})(_s);
var Ss = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "normalizeConfig", {
    enumerable: !0,
    get: function() {
      return l;
    }
  });
  const e = it, t = /* @__PURE__ */ n(et);
  function r(i) {
    if (typeof WeakMap != "function")
      return null;
    var c = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
    return (r = function(o) {
      return o ? a : c;
    })(i);
  }
  function n(i, c) {
    if (i && i.__esModule)
      return i;
    if (i === null || typeof i != "object" && typeof i != "function")
      return {
        default: i
      };
    var a = r(c);
    if (a && a.has(i))
      return a.get(i);
    var o = {}, f = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in i)
      if (u !== "default" && Object.prototype.hasOwnProperty.call(i, u)) {
        var p = f ? Object.getOwnPropertyDescriptor(i, u) : null;
        p && (p.get || p.set) ? Object.defineProperty(o, u, p) : o[u] = i[u];
      }
    return o.default = i, a && a.set(i, o), o;
  }
  function l(i) {
    if ((() => {
      if (i.purge || !i.content || !Array.isArray(i.content) && !(typeof i.content == "object" && i.content !== null))
        return !1;
      if (Array.isArray(i.content))
        return i.content.every((o) => typeof o == "string" ? !0 : !(typeof (o == null ? void 0 : o.raw) != "string" || o != null && o.extension && typeof (o == null ? void 0 : o.extension) != "string"));
      if (typeof i.content == "object" && i.content !== null) {
        if (Object.keys(i.content).some((o) => ![
          "files",
          "relative",
          "extract",
          "transform"
        ].includes(o)))
          return !1;
        if (Array.isArray(i.content.files)) {
          if (!i.content.files.every((o) => typeof o == "string" ? !0 : !(typeof (o == null ? void 0 : o.raw) != "string" || o != null && o.extension && typeof (o == null ? void 0 : o.extension) != "string")))
            return !1;
          if (typeof i.content.extract == "object") {
            for (let o of Object.values(i.content.extract))
              if (typeof o != "function")
                return !1;
          } else if (!(i.content.extract === void 0 || typeof i.content.extract == "function"))
            return !1;
          if (typeof i.content.transform == "object") {
            for (let o of Object.values(i.content.transform))
              if (typeof o != "function")
                return !1;
          } else if (!(i.content.transform === void 0 || typeof i.content.transform == "function"))
            return !1;
          if (typeof i.content.relative != "boolean" && typeof i.content.relative < "u")
            return !1;
        }
        return !0;
      }
      return !1;
    })() || t.default.warn("purge-deprecation", [
      "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
      "Update your configuration file to eliminate this warning.",
      "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
    ]), i.safelist = (() => {
      var o;
      let { content: f, purge: u, safelist: p } = i;
      return Array.isArray(p) ? p : Array.isArray(f == null ? void 0 : f.safelist) ? f.safelist : Array.isArray(u == null ? void 0 : u.safelist) ? u.safelist : Array.isArray(u == null || (o = u.options) === null || o === void 0 ? void 0 : o.safelist) ? u.options.safelist : [];
    })(), i.blocklist = (() => {
      let { blocklist: o } = i;
      if (Array.isArray(o)) {
        if (o.every((f) => typeof f == "string"))
          return o;
        t.default.warn("blocklist-invalid", [
          "The `blocklist` option must be an array of strings.",
          "https://tailwindcss.com/docs/content-configuration#discarding-classes"
        ]);
      }
      return [];
    })(), typeof i.prefix == "function")
      t.default.warn("prefix-function", [
        "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
        "Update `prefix` in your configuration to be a string to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
      ]), i.prefix = "";
    else {
      var a;
      i.prefix = (a = i.prefix) !== null && a !== void 0 ? a : "";
    }
    i.content = {
      relative: (() => {
        let { content: o } = i;
        return o != null && o.relative ? o.relative : (0, e.flagEnabled)(i, "relativeContentPathsByDefault");
      })(),
      files: (() => {
        let { content: o, purge: f } = i;
        return Array.isArray(f) ? f : Array.isArray(f == null ? void 0 : f.content) ? f.content : Array.isArray(o) ? o : Array.isArray(o == null ? void 0 : o.content) ? o.content : Array.isArray(o == null ? void 0 : o.files) ? o.files : [];
      })(),
      extract: (() => {
        let o = (() => {
          var p, _, x, h, m, C, S, k, O, E;
          return !((p = i.purge) === null || p === void 0) && p.extract ? i.purge.extract : !((_ = i.content) === null || _ === void 0) && _.extract ? i.content.extract : !((x = i.purge) === null || x === void 0 || (h = x.extract) === null || h === void 0) && h.DEFAULT ? i.purge.extract.DEFAULT : !((m = i.content) === null || m === void 0 || (C = m.extract) === null || C === void 0) && C.DEFAULT ? i.content.extract.DEFAULT : !((S = i.purge) === null || S === void 0 || (k = S.options) === null || k === void 0) && k.extractors ? i.purge.options.extractors : !((O = i.content) === null || O === void 0 || (E = O.options) === null || E === void 0) && E.extractors ? i.content.options.extractors : {};
        })(), f = {}, u = (() => {
          var p, _, x, h;
          if (!((p = i.purge) === null || p === void 0 || (_ = p.options) === null || _ === void 0) && _.defaultExtractor)
            return i.purge.options.defaultExtractor;
          if (!((x = i.content) === null || x === void 0 || (h = x.options) === null || h === void 0) && h.defaultExtractor)
            return i.content.options.defaultExtractor;
        })();
        if (u !== void 0 && (f.DEFAULT = u), typeof o == "function")
          f.DEFAULT = o;
        else if (Array.isArray(o))
          for (let { extensions: p, extractor: _ } of o ?? [])
            for (let x of p)
              f[x] = _;
        else
          typeof o == "object" && o !== null && Object.assign(f, o);
        return f;
      })(),
      transform: (() => {
        let o = (() => {
          var u, p, _, x, h, m;
          return !((u = i.purge) === null || u === void 0) && u.transform ? i.purge.transform : !((p = i.content) === null || p === void 0) && p.transform ? i.content.transform : !((_ = i.purge) === null || _ === void 0 || (x = _.transform) === null || x === void 0) && x.DEFAULT ? i.purge.transform.DEFAULT : !((h = i.content) === null || h === void 0 || (m = h.transform) === null || m === void 0) && m.DEFAULT ? i.content.transform.DEFAULT : {};
        })(), f = {};
        return typeof o == "function" ? f.DEFAULT = o : typeof o == "object" && o !== null && Object.assign(f, o), f;
      })()
    };
    for (let o of i.content.files)
      if (typeof o == "string" && /{([^,]*?)}/g.test(o)) {
        t.default.warn("invalid-glob-braces", [
          `The glob pattern ${(0, t.dim)(o)} in your Tailwind CSS configuration is invalid.`,
          `Update it to ${(0, t.dim)(o.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
        ]);
        break;
      }
    return i;
  }
})(Ss);
var Os = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "cloneDeep", {
    enumerable: !0,
    get: function() {
      return e;
    }
  });
  function e(t) {
    return Array.isArray(t) ? t.map((r) => e(r)) : typeof t == "object" && t !== null ? Object.fromEntries(Object.entries(t).map(([r, n]) => [
      r,
      e(n)
    ])) : t;
  }
})(Os);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return N;
    }
  });
  const e = /* @__PURE__ */ _(sr), t = /* @__PURE__ */ _(ws), r = /* @__PURE__ */ _(bs), n = /* @__PURE__ */ _(xs), l = _s, i = ir, c = Ss, a = /* @__PURE__ */ _(dt), o = Os, f = At, u = kt, p = /* @__PURE__ */ _(Qn);
  function _(T) {
    return T && T.__esModule ? T : {
      default: T
    };
  }
  function x(T) {
    return typeof T == "function";
  }
  function h(T, ...V) {
    let d = V.pop();
    for (let g of V)
      for (let v in g) {
        let y = d(T[v], g[v]);
        y === void 0 ? (0, a.default)(T[v]) && (0, a.default)(g[v]) ? T[v] = h({}, T[v], g[v], d) : T[v] = g[v] : T[v] = y;
      }
    return T;
  }
  const m = {
    colors: n.default,
    negative(T) {
      return Object.keys(T).filter((V) => T[V] !== "0").reduce((V, d) => {
        let g = (0, e.default)(T[d]);
        return g !== void 0 && (V[`-${d}`] = g), V;
      }, {});
    },
    breakpoints(T) {
      return Object.keys(T).filter((V) => typeof T[V] == "string").reduce((V, d) => ({
        ...V,
        [`screen-${d}`]: T[d]
      }), {});
    }
  };
  function C(T, ...V) {
    return x(T) ? T(...V) : T;
  }
  function S(T) {
    return T.reduce((V, { extend: d }) => h(V, d, (g, v) => g === void 0 ? [
      v
    ] : Array.isArray(g) ? [
      v,
      ...g
    ] : [
      v,
      g
    ]), {});
  }
  function k(T) {
    return {
      ...T.reduce((V, d) => (0, l.defaults)(V, d), {}),
      // In order to resolve n config objects, we combine all of their `extend` properties
      // into arrays instead of objects so they aren't overridden.
      extend: S(T)
    };
  }
  function O(T, V) {
    if (Array.isArray(T) && (0, a.default)(T[0]))
      return T.concat(V);
    if (Array.isArray(V) && (0, a.default)(V[0]) && (0, a.default)(T))
      return [
        T,
        ...V
      ];
    if (Array.isArray(V))
      return V;
  }
  function E({ extend: T, ...V }) {
    return h(V, T, (d, g) => !x(d) && !g.some(x) ? h({}, d, ...g, O) : (v, y) => h({}, ...[
      d,
      ...g
    ].map((R) => C(R, v, y)), O));
  }
  function* M(T) {
    let V = (0, i.toPath)(T);
    if (V.length === 0 || (yield V, Array.isArray(T)))
      return;
    let d = /^(.*?)\s*\/\s*([^/]+)$/, g = T.match(d);
    if (g !== null) {
      let [, v, y] = g, R = (0, i.toPath)(v);
      R.alpha = y, yield R;
    }
  }
  function D(T) {
    const V = (d, g) => {
      for (const v of M(d)) {
        let y = 0, R = T;
        for (; R != null && y < v.length; )
          R = R[v[y++]], R = x(R) && (v.alpha === void 0 || y <= v.length - 1) ? R(V, m) : R;
        if (R !== void 0) {
          if (v.alpha !== void 0) {
            let F = (0, f.parseColorFormat)(R);
            return (0, u.withAlphaValue)(F, v.alpha, (0, p.default)(F));
          }
          return (0, a.default)(R) ? (0, o.cloneDeep)(R) : R;
        }
      }
      return g;
    };
    return Object.assign(V, {
      theme: V,
      ...m
    }), Object.keys(T).reduce((d, g) => (d[g] = x(T[g]) ? T[g](V, m) : T[g], d), {});
  }
  function P(T) {
    let V = [];
    return T.forEach((d) => {
      V = [
        ...V,
        d
      ];
      var g;
      const v = (g = d == null ? void 0 : d.plugins) !== null && g !== void 0 ? g : [];
      v.length !== 0 && v.forEach((y) => {
        y.__isOptionsFunction && (y = y());
        var R;
        V = [
          ...V,
          ...P([
            (R = y == null ? void 0 : y.config) !== null && R !== void 0 ? R : {}
          ])
        ];
      });
    }), V;
  }
  function b(T) {
    return [
      ...T
    ].reduceRight((d, g) => x(g) ? g({
      corePlugins: d
    }) : (0, r.default)(g, d), t.default);
  }
  function A(T) {
    return [
      ...T
    ].reduceRight((d, g) => [
      ...d,
      ...g
    ], []);
  }
  function N(T) {
    let V = [
      ...P(T),
      {
        prefix: "",
        important: !1,
        separator: ":"
      }
    ];
    var d, g;
    return (0, c.normalizeConfig)((0, l.defaults)({
      theme: D(E(k(V.map((v) => (d = v == null ? void 0 : v.theme) !== null && d !== void 0 ? d : {})))),
      corePlugins: b(V.map((v) => v.corePlugins)),
      plugins: A(T.map((v) => (g = v == null ? void 0 : v.plugins) !== null && g !== void 0 ? g : []))
    }, ...V));
  }
})(ys);
var ks = {}, $c = {
  content: [],
  presets: [],
  darkMode: "media",
  // or 'class'
  theme: {
    accentColor: ({ theme: s }) => ({
      ...s("colors"),
      auto: "auto"
    }),
    animation: {
      none: "none",
      spin: "spin 1s linear infinite",
      ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
      pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      bounce: "bounce 1s infinite"
    },
    aria: {
      busy: 'busy="true"',
      checked: 'checked="true"',
      disabled: 'disabled="true"',
      expanded: 'expanded="true"',
      hidden: 'hidden="true"',
      pressed: 'pressed="true"',
      readonly: 'readonly="true"',
      required: 'required="true"',
      selected: 'selected="true"'
    },
    aspectRatio: {
      auto: "auto",
      square: "1 / 1",
      video: "16 / 9"
    },
    backdropBlur: ({ theme: s }) => s("blur"),
    backdropBrightness: ({ theme: s }) => s("brightness"),
    backdropContrast: ({ theme: s }) => s("contrast"),
    backdropGrayscale: ({ theme: s }) => s("grayscale"),
    backdropHueRotate: ({ theme: s }) => s("hueRotate"),
    backdropInvert: ({ theme: s }) => s("invert"),
    backdropOpacity: ({ theme: s }) => s("opacity"),
    backdropSaturate: ({ theme: s }) => s("saturate"),
    backdropSepia: ({ theme: s }) => s("sepia"),
    backgroundColor: ({ theme: s }) => s("colors"),
    backgroundImage: {
      none: "none",
      "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
      "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
      "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
      "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
      "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
      "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
      "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
      "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
    },
    backgroundOpacity: ({ theme: s }) => s("opacity"),
    backgroundPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    backgroundSize: {
      auto: "auto",
      cover: "cover",
      contain: "contain"
    },
    blur: {
      0: "0",
      none: "",
      sm: "4px",
      DEFAULT: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    },
    borderColor: ({ theme: s }) => ({
      ...s("colors"),
      DEFAULT: s("colors.gray.200", "currentColor")
    }),
    borderOpacity: ({ theme: s }) => s("opacity"),
    borderRadius: {
      none: "0px",
      sm: "0.125rem",
      DEFAULT: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      full: "9999px"
    },
    borderSpacing: ({ theme: s }) => ({
      ...s("spacing")
    }),
    borderWidth: {
      DEFAULT: "1px",
      0: "0px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    boxShadow: {
      sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
      DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
      md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
      lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
      xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
      "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
      inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
      none: "none"
    },
    boxShadowColor: ({ theme: s }) => s("colors"),
    brightness: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    caretColor: ({ theme: s }) => s("colors"),
    colors: ({ colors: s }) => ({
      inherit: s.inherit,
      current: s.current,
      transparent: s.transparent,
      black: s.black,
      white: s.white,
      slate: s.slate,
      gray: s.gray,
      zinc: s.zinc,
      neutral: s.neutral,
      stone: s.stone,
      red: s.red,
      orange: s.orange,
      amber: s.amber,
      yellow: s.yellow,
      lime: s.lime,
      green: s.green,
      emerald: s.emerald,
      teal: s.teal,
      cyan: s.cyan,
      sky: s.sky,
      blue: s.blue,
      indigo: s.indigo,
      violet: s.violet,
      purple: s.purple,
      fuchsia: s.fuchsia,
      pink: s.pink,
      rose: s.rose
    }),
    columns: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      "3xs": "16rem",
      "2xs": "18rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem"
    },
    container: {},
    content: {
      none: "none"
    },
    contrast: {
      0: "0",
      50: ".5",
      75: ".75",
      100: "1",
      125: "1.25",
      150: "1.5",
      200: "2"
    },
    cursor: {
      auto: "auto",
      default: "default",
      pointer: "pointer",
      wait: "wait",
      text: "text",
      move: "move",
      help: "help",
      "not-allowed": "not-allowed",
      none: "none",
      "context-menu": "context-menu",
      progress: "progress",
      cell: "cell",
      crosshair: "crosshair",
      "vertical-text": "vertical-text",
      alias: "alias",
      copy: "copy",
      "no-drop": "no-drop",
      grab: "grab",
      grabbing: "grabbing",
      "all-scroll": "all-scroll",
      "col-resize": "col-resize",
      "row-resize": "row-resize",
      "n-resize": "n-resize",
      "e-resize": "e-resize",
      "s-resize": "s-resize",
      "w-resize": "w-resize",
      "ne-resize": "ne-resize",
      "nw-resize": "nw-resize",
      "se-resize": "se-resize",
      "sw-resize": "sw-resize",
      "ew-resize": "ew-resize",
      "ns-resize": "ns-resize",
      "nesw-resize": "nesw-resize",
      "nwse-resize": "nwse-resize",
      "zoom-in": "zoom-in",
      "zoom-out": "zoom-out"
    },
    divideColor: ({ theme: s }) => s("borderColor"),
    divideOpacity: ({ theme: s }) => s("borderOpacity"),
    divideWidth: ({ theme: s }) => s("borderWidth"),
    dropShadow: {
      sm: "0 1px 1px rgb(0 0 0 / 0.05)",
      DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
      md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
      lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
      xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
      "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
      none: "0 0 #0000"
    },
    fill: ({ theme: s }) => ({
      none: "none",
      ...s("colors")
    }),
    flex: {
      1: "1 1 0%",
      auto: "1 1 auto",
      initial: "0 1 auto",
      none: "none"
    },
    flexBasis: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%"
    }),
    flexGrow: {
      0: "0",
      DEFAULT: "1"
    },
    flexShrink: {
      0: "0",
      DEFAULT: "1"
    },
    fontFamily: {
      sans: [
        "ui-sans-serif",
        "system-ui",
        "sans-serif",
        '"Apple Color Emoji"',
        '"Segoe UI Emoji"',
        '"Segoe UI Symbol"',
        '"Noto Color Emoji"'
      ],
      serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
      mono: [
        "ui-monospace",
        "SFMono-Regular",
        "Menlo",
        "Monaco",
        "Consolas",
        '"Liberation Mono"',
        '"Courier New"',
        "monospace"
      ]
    },
    fontSize: {
      xs: ["0.75rem", { lineHeight: "1rem" }],
      sm: ["0.875rem", { lineHeight: "1.25rem" }],
      base: ["1rem", { lineHeight: "1.5rem" }],
      lg: ["1.125rem", { lineHeight: "1.75rem" }],
      xl: ["1.25rem", { lineHeight: "1.75rem" }],
      "2xl": ["1.5rem", { lineHeight: "2rem" }],
      "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
      "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
      "5xl": ["3rem", { lineHeight: "1" }],
      "6xl": ["3.75rem", { lineHeight: "1" }],
      "7xl": ["4.5rem", { lineHeight: "1" }],
      "8xl": ["6rem", { lineHeight: "1" }],
      "9xl": ["8rem", { lineHeight: "1" }]
    },
    fontWeight: {
      thin: "100",
      extralight: "200",
      light: "300",
      normal: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900"
    },
    gap: ({ theme: s }) => s("spacing"),
    gradientColorStops: ({ theme: s }) => s("colors"),
    gradientColorStopPositions: {
      "0%": "0%",
      "5%": "5%",
      "10%": "10%",
      "15%": "15%",
      "20%": "20%",
      "25%": "25%",
      "30%": "30%",
      "35%": "35%",
      "40%": "40%",
      "45%": "45%",
      "50%": "50%",
      "55%": "55%",
      "60%": "60%",
      "65%": "65%",
      "70%": "70%",
      "75%": "75%",
      "80%": "80%",
      "85%": "85%",
      "90%": "90%",
      "95%": "95%",
      "100%": "100%"
    },
    grayscale: {
      0: "0",
      DEFAULT: "100%"
    },
    gridAutoColumns: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridAutoRows: {
      auto: "auto",
      min: "min-content",
      max: "max-content",
      fr: "minmax(0, 1fr)"
    },
    gridColumn: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-7": "span 7 / span 7",
      "span-8": "span 8 / span 8",
      "span-9": "span 9 / span 9",
      "span-10": "span 10 / span 10",
      "span-11": "span 11 / span 11",
      "span-12": "span 12 / span 12",
      "span-full": "1 / -1"
    },
    gridColumnEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridColumnStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridRow: {
      auto: "auto",
      "span-1": "span 1 / span 1",
      "span-2": "span 2 / span 2",
      "span-3": "span 3 / span 3",
      "span-4": "span 4 / span 4",
      "span-5": "span 5 / span 5",
      "span-6": "span 6 / span 6",
      "span-7": "span 7 / span 7",
      "span-8": "span 8 / span 8",
      "span-9": "span 9 / span 9",
      "span-10": "span 10 / span 10",
      "span-11": "span 11 / span 11",
      "span-12": "span 12 / span 12",
      "span-full": "1 / -1"
    },
    gridRowEnd: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridRowStart: {
      auto: "auto",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12",
      13: "13"
    },
    gridTemplateColumns: {
      none: "none",
      subgrid: "subgrid",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))",
      7: "repeat(7, minmax(0, 1fr))",
      8: "repeat(8, minmax(0, 1fr))",
      9: "repeat(9, minmax(0, 1fr))",
      10: "repeat(10, minmax(0, 1fr))",
      11: "repeat(11, minmax(0, 1fr))",
      12: "repeat(12, minmax(0, 1fr))"
    },
    gridTemplateRows: {
      none: "none",
      subgrid: "subgrid",
      1: "repeat(1, minmax(0, 1fr))",
      2: "repeat(2, minmax(0, 1fr))",
      3: "repeat(3, minmax(0, 1fr))",
      4: "repeat(4, minmax(0, 1fr))",
      5: "repeat(5, minmax(0, 1fr))",
      6: "repeat(6, minmax(0, 1fr))",
      7: "repeat(7, minmax(0, 1fr))",
      8: "repeat(8, minmax(0, 1fr))",
      9: "repeat(9, minmax(0, 1fr))",
      10: "repeat(10, minmax(0, 1fr))",
      11: "repeat(11, minmax(0, 1fr))",
      12: "repeat(12, minmax(0, 1fr))"
    },
    height: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      full: "100%",
      screen: "100vh",
      svh: "100svh",
      lvh: "100lvh",
      dvh: "100dvh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    hueRotate: {
      0: "0deg",
      15: "15deg",
      30: "30deg",
      60: "60deg",
      90: "90deg",
      180: "180deg"
    },
    inset: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    invert: {
      0: "0",
      DEFAULT: "100%"
    },
    keyframes: {
      spin: {
        to: {
          transform: "rotate(360deg)"
        }
      },
      ping: {
        "75%, 100%": {
          transform: "scale(2)",
          opacity: "0"
        }
      },
      pulse: {
        "50%": {
          opacity: ".5"
        }
      },
      bounce: {
        "0%, 100%": {
          transform: "translateY(-25%)",
          animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
        },
        "50%": {
          transform: "none",
          animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
        }
      }
    },
    letterSpacing: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0em",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    lineHeight: {
      none: "1",
      tight: "1.25",
      snug: "1.375",
      normal: "1.5",
      relaxed: "1.625",
      loose: "2",
      3: ".75rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem"
    },
    listStyleType: {
      none: "none",
      disc: "disc",
      decimal: "decimal"
    },
    listStyleImage: {
      none: "none"
    },
    margin: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing")
    }),
    lineClamp: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6"
    },
    maxHeight: ({ theme: s }) => ({
      ...s("spacing"),
      none: "none",
      full: "100%",
      screen: "100vh",
      svh: "100svh",
      lvh: "100lvh",
      dvh: "100dvh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    maxWidth: ({ theme: s, breakpoints: e }) => ({
      ...s("spacing"),
      none: "none",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content",
      prose: "65ch",
      ...e(s("screens"))
    }),
    minHeight: ({ theme: s }) => ({
      ...s("spacing"),
      full: "100%",
      screen: "100vh",
      svh: "100svh",
      lvh: "100lvh",
      dvh: "100dvh",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    minWidth: ({ theme: s }) => ({
      ...s("spacing"),
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    objectPosition: {
      bottom: "bottom",
      center: "center",
      left: "left",
      "left-bottom": "left bottom",
      "left-top": "left top",
      right: "right",
      "right-bottom": "right bottom",
      "right-top": "right top",
      top: "top"
    },
    opacity: {
      0: "0",
      5: "0.05",
      10: "0.1",
      15: "0.15",
      20: "0.2",
      25: "0.25",
      30: "0.3",
      35: "0.35",
      40: "0.4",
      45: "0.45",
      50: "0.5",
      55: "0.55",
      60: "0.6",
      65: "0.65",
      70: "0.7",
      75: "0.75",
      80: "0.8",
      85: "0.85",
      90: "0.9",
      95: "0.95",
      100: "1"
    },
    order: {
      first: "-9999",
      last: "9999",
      none: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12"
    },
    outlineColor: ({ theme: s }) => s("colors"),
    outlineOffset: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    outlineWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    padding: ({ theme: s }) => s("spacing"),
    placeholderColor: ({ theme: s }) => s("colors"),
    placeholderOpacity: ({ theme: s }) => s("opacity"),
    ringColor: ({ theme: s }) => ({
      DEFAULT: s("colors.blue.500", "#3b82f6"),
      ...s("colors")
    }),
    ringOffsetColor: ({ theme: s }) => s("colors"),
    ringOffsetWidth: {
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    ringOpacity: ({ theme: s }) => ({
      DEFAULT: "0.5",
      ...s("opacity")
    }),
    ringWidth: {
      DEFAULT: "3px",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    rotate: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg",
      45: "45deg",
      90: "90deg",
      180: "180deg"
    },
    saturate: {
      0: "0",
      50: ".5",
      100: "1",
      150: "1.5",
      200: "2"
    },
    scale: {
      0: "0",
      50: ".5",
      75: ".75",
      90: ".9",
      95: ".95",
      100: "1",
      105: "1.05",
      110: "1.1",
      125: "1.25",
      150: "1.5"
    },
    screens: {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px",
      "2xl": "1536px"
    },
    scrollMargin: ({ theme: s }) => ({
      ...s("spacing")
    }),
    scrollPadding: ({ theme: s }) => s("spacing"),
    sepia: {
      0: "0",
      DEFAULT: "100%"
    },
    skew: {
      0: "0deg",
      1: "1deg",
      2: "2deg",
      3: "3deg",
      6: "6deg",
      12: "12deg"
    },
    space: ({ theme: s }) => ({
      ...s("spacing")
    }),
    spacing: {
      px: "1px",
      0: "0px",
      0.5: "0.125rem",
      1: "0.25rem",
      1.5: "0.375rem",
      2: "0.5rem",
      2.5: "0.625rem",
      3: "0.75rem",
      3.5: "0.875rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem",
      11: "2.75rem",
      12: "3rem",
      14: "3.5rem",
      16: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    stroke: ({ theme: s }) => ({
      none: "none",
      ...s("colors")
    }),
    strokeWidth: {
      0: "0",
      1: "1",
      2: "2"
    },
    supports: {},
    data: {},
    textColor: ({ theme: s }) => s("colors"),
    textDecorationColor: ({ theme: s }) => s("colors"),
    textDecorationThickness: {
      auto: "auto",
      "from-font": "from-font",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    textIndent: ({ theme: s }) => ({
      ...s("spacing")
    }),
    textOpacity: ({ theme: s }) => s("opacity"),
    textUnderlineOffset: {
      auto: "auto",
      0: "0px",
      1: "1px",
      2: "2px",
      4: "4px",
      8: "8px"
    },
    transformOrigin: {
      center: "center",
      top: "top",
      "top-right": "top right",
      right: "right",
      "bottom-right": "bottom right",
      bottom: "bottom",
      "bottom-left": "bottom left",
      left: "left",
      "top-left": "top left"
    },
    transitionDelay: {
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionDuration: {
      DEFAULT: "150ms",
      0: "0s",
      75: "75ms",
      100: "100ms",
      150: "150ms",
      200: "200ms",
      300: "300ms",
      500: "500ms",
      700: "700ms",
      1e3: "1000ms"
    },
    transitionProperty: {
      none: "none",
      all: "all",
      DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
      colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
      opacity: "opacity",
      shadow: "box-shadow",
      transform: "transform"
    },
    transitionTimingFunction: {
      DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
      linear: "linear",
      in: "cubic-bezier(0.4, 0, 1, 1)",
      out: "cubic-bezier(0, 0, 0.2, 1)",
      "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    },
    translate: ({ theme: s }) => ({
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      full: "100%"
    }),
    size: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    width: ({ theme: s }) => ({
      auto: "auto",
      ...s("spacing"),
      "1/2": "50%",
      "1/3": "33.333333%",
      "2/3": "66.666667%",
      "1/4": "25%",
      "2/4": "50%",
      "3/4": "75%",
      "1/5": "20%",
      "2/5": "40%",
      "3/5": "60%",
      "4/5": "80%",
      "1/6": "16.666667%",
      "2/6": "33.333333%",
      "3/6": "50%",
      "4/6": "66.666667%",
      "5/6": "83.333333%",
      "1/12": "8.333333%",
      "2/12": "16.666667%",
      "3/12": "25%",
      "4/12": "33.333333%",
      "5/12": "41.666667%",
      "6/12": "50%",
      "7/12": "58.333333%",
      "8/12": "66.666667%",
      "9/12": "75%",
      "10/12": "83.333333%",
      "11/12": "91.666667%",
      full: "100%",
      screen: "100vw",
      svw: "100svw",
      lvw: "100lvw",
      dvw: "100dvw",
      min: "min-content",
      max: "max-content",
      fit: "fit-content"
    }),
    willChange: {
      auto: "auto",
      scroll: "scroll-position",
      contents: "contents",
      transform: "transform"
    },
    zIndex: {
      auto: "auto",
      0: "0",
      10: "10",
      20: "20",
      30: "30",
      40: "40",
      50: "50"
    }
  },
  plugins: []
};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r($c), t = it;
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n(l) {
    var i;
    const c = ((i = l == null ? void 0 : l.presets) !== null && i !== void 0 ? i : [
      e.default
    ]).slice().reverse().flatMap((f) => n(f instanceof Function ? f() : f)), a = {
      // Add experimental configs here...
      respectDefaultRingColorOpacity: {
        theme: {
          ringColor: ({ theme: f }) => ({
            DEFAULT: "#3b82f67f",
            ...f("colors")
          })
        }
      },
      disableColorOpacityUtilitiesByDefault: {
        corePlugins: {
          backgroundOpacity: !1,
          borderOpacity: !1,
          divideOpacity: !1,
          placeholderOpacity: !1,
          ringOpacity: !1,
          textOpacity: !1
        }
      }
    }, o = Object.keys(a).filter((f) => (0, t.flagEnabled)(l, f)).map((f) => a[f]);
    return [
      l,
      ...o,
      ...c
    ];
  }
})(ks);
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), Object.defineProperty(s, "default", {
    enumerable: !0,
    get: function() {
      return n;
    }
  });
  const e = /* @__PURE__ */ r(ys), t = /* @__PURE__ */ r(ks);
  function r(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  function n(...l) {
    let [, ...i] = (0, t.default)(l[0]);
    return (0, e.default)([
      ...l,
      ...i
    ]);
  }
})(vs);
let $r = vs;
var Dc = ($r.__esModule ? $r : { default: $r }).default;
const Nc = /* @__PURE__ */ Qe(Dc), Lc = (s) => Rc.createContext(
  Nc({
    ...s,
    content: [],
    corePlugins: {
      preflight: !1
    }
  })
), Fc = _l(
  `
  @tailwind base;
  @tailwind components;
`
).root();
function zc(s) {
  const e = Lc(s);
  return {
    generateRootForClasses: (t) => {
      const r = Oc.generateRules(
        new Set(t),
        e
      ), n = Fc.clone().append(...r.map(([, l]) => l));
      return Ri()(n), Cc(e)(n), Ri()(n), _c(e)(n), zl(e)(n), Ec(e)(n), Sc(e)(n), Pc(e)(n), Tc(e)(n), Ic(n), n;
    }
  };
}
const As = (s) => typeof s.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
s.type.render !== void 0;
function Jt(s, e) {
  const t = react__WEBPACK_IMPORTED_MODULE_1__.Children.map(s, (r) => {
    if (react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(r)) {
      const n = { ...r.props };
      r.props.children && !As(r) && (n.children = Jt(r.props.children, e));
      const l = e(
        react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(r, n, n.children)
      );
      if (react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(l) && (typeof l.type == "function" || // @ts-expect-error - we know this is a component that may have a render function
      l.type.render)) {
        const c = (typeof l.type == "object" ? (
          // @ts-expect-error - we know this is a component with a render function
          l.type.render
        ) : l.type)(l.props);
        return Jt(c, e);
      }
      return l;
    }
    return e(r);
  });
  return t && t.length === 1 ? t[0] : t;
}
const Uc = (s) => {
  s.walkDecls((e) => {
    const t = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/g;
    e.value = e.value.replaceAll(
      t,
      (r, n, l, i, c) => {
        const a = c === "1" || typeof c > "u" ? "" : `,${c}`;
        return `rgb(${n},${l},${i}${a})`;
      }
    );
  });
}, jc = {
  0: "zero",
  1: "one",
  2: "two",
  3: "three",
  4: "four",
  5: "five",
  6: "six",
  7: "seven",
  8: "eight",
  9: "nine"
}, Cs = (s) => s.replaceAll("+", "plus").replaceAll("[", "").replaceAll("%", "pc").replaceAll("]", "").replaceAll("(", "").replaceAll(")", "").replaceAll("!", "imprtnt").replaceAll(">", "gt").replaceAll("<", "lt").replaceAll("=", "eq").replace(/^[0-9]/, (e) => jc[e]).replace(/[^a-zA-Z0-9\-_]/g, "_"), Vc = (s) => {
  const e = [], t = [];
  return s.walkAtRules((r) => {
    const n = r.clone();
    n.walkRules((i) => {
      let c = !1;
      i.selector = Qt((a) => {
        a.walkPseudos(() => {
          c = !0;
        }), c || a.walkClasses((o) => {
          t.push(o.value), o.replaceWith(
            Qt.className({
              ...o,
              value: Cs(o.value)
            })
          );
        });
      }).processSync(i.selector), c ? n.removeChild(i) : i.walkDecls((a) => {
        a.important = !0;
      });
    });
    const l = e.find(
      (i) => i.params === n.params
    );
    l ? l.append(n.nodes) : e.push(n);
  }), {
    mediaQueryClasses: t,
    sanitizedAtRules: e
  };
};
function Wc(s) {
  return s.replaceAll(/\\[0-9]|\\/g, "");
}
const $i = (s) => s.replace(/-(\w|$)/g, (e, t) => t.toUpperCase()), Bc = (s) => {
  const e = s.toLowerCase();
  return e.startsWith("--") ? e : e.startsWith("-ms-") ? $i(e.slice(1)) : $i(e);
}, qc = (s, e) => {
  s.walkRules((t) => {
    var r;
    ((r = t.parent) == null ? void 0 : r.type) !== "atrule" && Qt((n) => {
      let l = !1;
      n.walkPseudos(() => {
        l = !0;
      }), l || e(t);
    }).processSync(t.selector);
  });
};
function Gc(s, e) {
  let r = [...s.split(" ")];
  const n = {};
  return qc(e, (l) => {
    const i = [];
    Qt((c) => {
      c.walkClasses((a) => {
        i.push(Wc(a.value));
      });
    }).processSync(l.selector), r = r.filter((c) => !i.includes(c)), l.walkDecls((c) => {
      n[Bc(c.prop)] = c.value + (c.important ? "!important" : "");
    });
  }), {
    styles: n,
    residualClassName: r.join(" ")
  };
}
const Yc = (s, e) => {
  const t = {};
  let r = [], n = [];
  if (s.props.className) {
    const i = e.generateRootForClasses(
      s.props.className.split(" ")
    );
    Uc(i);
    const { sanitizedAtRules: c, mediaQueryClasses: a } = Vc(i);
    r = a, n = c;
    const { styles: o, residualClassName: f } = Gc(
      s.props.className,
      i
    );
    if (t.style = {
      ...o,
      ...s.props.style
    }, !As(s))
      if (f.trim().length > 0) {
        t.className = f;
        for (const u of a)
          t.className = t.className.replace(
            u,
            Cs(u)
          );
      } else
        t.className = void 0;
  }
  const l = {
    ...s.props,
    ...t
  };
  return {
    elementWithInlinedStyles: react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(
      s,
      l,
      l.children
    ),
    nonInlinableClasses: r,
    nonInlineStyleNodes: n
  };
}, Hc = (s) => {
  s.walkRules((e) => {
    s.walkRules(e.selector, (t) => {
      if (t === e)
        return;
      const r = t.parent;
      t.remove(), r && Zn(r);
    });
  });
}, pd = ({ children: s, config: e }) => {
  const t = zc(e ?? {}), r = new Al();
  let n = [], l = !1, i = Jt(s, (c) => {
    if (react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(c)) {
      const {
        elementWithInlinedStyles: a,
        nonInlinableClasses: o,
        nonInlineStyleNodes: f
      } = Yc(c, t);
      return n = n.concat(o), r.append(f), o.length > 0 && !l && (l = !0), a;
    }
    return c;
  });
  if (Hc(r), l) {
    let c = !1;
    if (i = Jt(i, (a) => {
      if (c)
        return a;
      if (react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(a) && a.type === "head") {
        c = !0;
        const o = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("style", { children: Cl(r.toString().trim()) });
        return react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(
          a,
          a.props,
          a.props.children,
          o
        );
      }
      return a;
    }), !c)
      throw new Error(
        `You are trying to use the following Tailwind classes that cannot be inlined: ${n.join(
          " "
        )}.
For the media queries to work properly on rendering, they need to be added into a <style> tag inside of a <head> tag,
the Tailwind component tried finding a <head> element but just wasn't able to find it.

Make sure that you have a <head> element at some point inside of the <Tailwind> component at any depth. 
This can also be our <Head> component.

If you do already have a <head> element at some depth, 
please file a bug https://github.com/resend/react-email/issues/new?assignees=&labels=Type%3A+Bug&projects=&template=1.bug_report.yml.`
      );
  }
  return i;
};



/***/ }),

/***/ 619730:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Text)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(922728);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(891069);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/text.tsx


var Text = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(
  (_a, ref) => {
    var _b = _a, { style } = _b, props = __objRest(_b, ["style"]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(
      "p",
      __spreadProps(__spreadValues({}, props), {
        ref,
        style: __spreadValues({
          fontSize: "14px",
          lineHeight: "24px",
          margin: "16px 0"
        }, style)
      })
    );
  }
);
Text.displayName = "Text";



/***/ }),

/***/ 551469:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (/* binding */ esm)
});

// UNUSED EXPORTS: deserialize, serialize

;// ../../node_modules/@ungap/structured-clone/esm/types.js
const VOID       = -1;
const PRIMITIVE  = 0;
const ARRAY      = 1;
const OBJECT     = 2;
const DATE       = 3;
const REGEXP     = 4;
const MAP        = 5;
const SET        = 6;
const ERROR      = 7;
const BIGINT     = 8;
// export const SYMBOL = 9;

;// ../../node_modules/@ungap/structured-clone/esm/deserialize.js


const env = typeof self === 'object' ? self : globalThis;

const deserializer = ($, _) => {
  const as = (out, index) => {
    $.set(index, out);
    return out;
  };

  const unpair = index => {
    if ($.has(index))
      return $.get(index);

    const [type, value] = _[index];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index);
      case ARRAY: {
        const arr = as([], index);
        for (const index of value)
          arr.push(unpair(index));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index);
        for (const [key, index] of value)
          object[unpair(key)] = unpair(index);
        return object;
      }
      case DATE:
        return as(new Date(value), index);
      case REGEXP: {
        const {source, flags} = value;
        return as(new RegExp(source, flags), index);
      }
      case MAP: {
        const map = as(new Map, index);
        for (const [key, index] of value)
          map.set(unpair(key), unpair(index));
        return map;
      }
      case SET: {
        const set = as(new Set, index);
        for (const index of value)
          set.add(unpair(index));
        return set;
      }
      case ERROR: {
        const {name, message} = value;
        return as(new env[name](message), index);
      }
      case BIGINT:
        return as(BigInt(value), index);
      case 'BigInt':
        return as(Object(BigInt(value)), index);
      case 'ArrayBuffer':
        return as(new Uint8Array(value).buffer, value);
      case 'DataView': {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index);
  };

  return unpair;
};

/**
 * @typedef {Array<string,any>} Record a type representation
 */

/**
 * Returns a deserialized value from a serialized array of Records.
 * @param {Record[]} serialized a previously serialized value.
 * @returns {any}
 */
const deserialize = serialized => deserializer(new Map, serialized)(0);

;// ../../node_modules/@ungap/structured-clone/esm/serialize.js


const EMPTY = '';

const {toString: serialize_toString} = {};
const {keys} = Object;

const typeOf = value => {
  const type = typeof value;
  if (type !== 'object' || !value)
    return [PRIMITIVE, type];

  const asString = serialize_toString.call(value).slice(8, -1);
  switch (asString) {
    case 'Array':
      return [ARRAY, EMPTY];
    case 'Object':
      return [OBJECT, EMPTY];
    case 'Date':
      return [DATE, EMPTY];
    case 'RegExp':
      return [REGEXP, EMPTY];
    case 'Map':
      return [MAP, EMPTY];
    case 'Set':
      return [SET, EMPTY];
    case 'DataView':
      return [ARRAY, asString];
  }

  if (asString.includes('Array'))
    return [ARRAY, asString];

  if (asString.includes('Error'))
    return [ERROR, asString];

  return [OBJECT, asString];
};

const shouldSkip = ([TYPE, type]) => (
  TYPE === PRIMITIVE &&
  (type === 'function' || type === 'symbol')
);

const serializer = (strict, json, $, _) => {

  const as = (out, value) => {
    const index = _.push(out) - 1;
    $.set(value, index);
    return index;
  };

  const pair = value => {
    if ($.has(value))
      return $.get(value);

    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case 'bigint':
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case 'function':
          case 'symbol':
            if (strict)
              throw new TypeError('unable to serialize ' + type);
            entry = null;
            break;
          case 'undefined':
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === 'DataView') {
            spread = new Uint8Array(value.buffer);
          }
          else if (type === 'ArrayBuffer') {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }

        const arr = [];
        const index = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case 'BigInt':
              return as([type, value.toString()], value);
            case 'Boolean':
            case 'Number':
            case 'String':
              return as([type, value.valueOf()], value);
          }
        }

        if (json && ('toJSON' in value))
          return pair(value.toJSON());

        const entries = [];
        const index = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const {source, flags} = value;
        return as([TYPE, {source, flags}], value);
      }
      case MAP: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index;
      }
      case SET: {
        const entries = [];
        const index = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index;
      }
    }

    const {message} = value;
    return as([TYPE, {name: type, message}], value);
  };

  return pair;
};

/**
 * @typedef {Array<string,any>} Record a type representation
 */

/**
 * Returns an array of serialized Records.
 * @param {any} value a serializable value.
 * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,
 *  if `true`, will not throw errors on incompatible types, and behave more
 *  like JSON stringify would behave. Symbol and Function will be discarded.
 * @returns {Record[]}
 */
 const serialize = (value, {json, lossy} = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, new Map, _)(value), _;
};

;// ../../node_modules/@ungap/structured-clone/esm/index.js



/**
 * @typedef {Array<string,any>} Record a type representation
 */

/**
 * Returns an array of serialized Records.
 * @param {any} any a serializable value.
 * @param {{transfer?: any[], json?: boolean, lossy?: boolean}?} options an object with
 * a transfer option (ignored when polyfilled) and/or non standard fields that
 * fallback to the polyfill if present.
 * @returns {Record[]}
 */
/* harmony default export */ const esm = (typeof structuredClone === "function" ?
  /* c8 ignore start */
  (any, options) => (
    options && ('json' in options || 'lossy' in options) ?
      deserialize(serialize(any, options)) : structuredClone(any)
  ) :
  (any, options) => deserialize(serialize(any, options)));
  /* c8 ignore stop */




/***/ }),

/***/ 111406:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"126":{"host":"smtp.126.com","port":465,"secure":true},"163":{"host":"smtp.163.com","port":465,"secure":true},"1und1":{"host":"smtp.1und1.de","port":465,"secure":true,"authMethod":"LOGIN"},"Aliyun":{"domains":["aliyun.com"],"host":"smtp.aliyun.com","port":465,"secure":true},"AOL":{"domains":["aol.com"],"host":"smtp.aol.com","port":587},"Bluewin":{"host":"smtpauths.bluewin.ch","domains":["bluewin.ch"],"port":465},"DebugMail":{"host":"debugmail.io","port":25},"DynectEmail":{"aliases":["Dynect"],"host":"smtp.dynect.net","port":25},"Ethereal":{"aliases":["ethereal.email"],"host":"smtp.ethereal.email","port":587},"FastMail":{"domains":["fastmail.fm"],"host":"smtp.fastmail.com","port":465,"secure":true},"Forward Email":{"aliases":["FE","ForwardEmail"],"domains":["forwardemail.net"],"host":"smtp.forwardemail.net","port":465,"secure":true},"Feishu Mail":{"aliases":["Feishu","FeishuMail"],"domains":["www.feishu.cn"],"host":"smtp.feishu.cn","port":465,"secure":true},"GandiMail":{"aliases":["Gandi","Gandi Mail"],"host":"mail.gandi.net","port":587},"Gmail":{"aliases":["Google Mail"],"domains":["gmail.com","googlemail.com"],"host":"smtp.gmail.com","port":465,"secure":true},"Godaddy":{"host":"smtpout.secureserver.net","port":25},"GodaddyAsia":{"host":"smtp.asia.secureserver.net","port":25},"GodaddyEurope":{"host":"smtp.europe.secureserver.net","port":25},"hot.ee":{"host":"mail.hot.ee"},"Hotmail":{"aliases":["Outlook","Outlook.com","Hotmail.com"],"domains":["hotmail.com","outlook.com"],"host":"smtp-mail.outlook.com","port":587},"iCloud":{"aliases":["Me","Mac"],"domains":["me.com","mac.com"],"host":"smtp.mail.me.com","port":587},"Infomaniak":{"host":"mail.infomaniak.com","domains":["ik.me","ikmail.com","etik.com"],"port":587},"Loopia":{"host":"mailcluster.loopia.se","port":465},"mail.ee":{"host":"smtp.mail.ee"},"Mail.ru":{"host":"smtp.mail.ru","port":465,"secure":true},"Mailcatch.app":{"host":"sandbox-smtp.mailcatch.app","port":2525},"Maildev":{"port":1025,"ignoreTLS":true},"Mailgun":{"host":"smtp.mailgun.org","port":465,"secure":true},"Mailjet":{"host":"in.mailjet.com","port":587},"Mailosaur":{"host":"mailosaur.io","port":25},"Mailtrap":{"host":"live.smtp.mailtrap.io","port":587},"Mandrill":{"host":"smtp.mandrillapp.com","port":587},"Naver":{"host":"smtp.naver.com","port":587},"One":{"host":"send.one.com","port":465,"secure":true},"OpenMailBox":{"aliases":["OMB","openmailbox.org"],"host":"smtp.openmailbox.org","port":465,"secure":true},"Outlook365":{"host":"smtp.office365.com","port":587,"secure":false},"OhMySMTP":{"host":"smtp.ohmysmtp.com","port":587,"secure":false},"Postmark":{"aliases":["PostmarkApp"],"host":"smtp.postmarkapp.com","port":2525},"qiye.aliyun":{"host":"smtp.mxhichina.com","port":"465","secure":true},"QQ":{"domains":["qq.com"],"host":"smtp.qq.com","port":465,"secure":true},"QQex":{"aliases":["QQ Enterprise"],"domains":["exmail.qq.com"],"host":"smtp.exmail.qq.com","port":465,"secure":true},"SendCloud":{"host":"smtp.sendcloud.net","port":2525},"SendGrid":{"host":"smtp.sendgrid.net","port":587},"SendinBlue":{"aliases":["Brevo"],"host":"smtp-relay.brevo.com","port":587},"SendPulse":{"host":"smtp-pulse.com","port":465,"secure":true},"SES":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-EAST-1":{"host":"email-smtp.us-east-1.amazonaws.com","port":465,"secure":true},"SES-US-WEST-2":{"host":"email-smtp.us-west-2.amazonaws.com","port":465,"secure":true},"SES-EU-WEST-1":{"host":"email-smtp.eu-west-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTH-1":{"host":"email-smtp.ap-south-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-1":{"host":"email-smtp.ap-northeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-2":{"host":"email-smtp.ap-northeast-2.amazonaws.com","port":465,"secure":true},"SES-AP-NORTHEAST-3":{"host":"email-smtp.ap-northeast-3.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-1":{"host":"email-smtp.ap-southeast-1.amazonaws.com","port":465,"secure":true},"SES-AP-SOUTHEAST-2":{"host":"email-smtp.ap-southeast-2.amazonaws.com","port":465,"secure":true},"Sparkpost":{"aliases":["SparkPost","SparkPost Mail"],"domains":["sparkpost.com"],"host":"smtp.sparkpostmail.com","port":587,"secure":false},"Tipimail":{"host":"smtp.tipimail.com","port":587},"Yahoo":{"domains":["yahoo.com"],"host":"smtp.mail.yahoo.com","port":465,"secure":true},"Yandex":{"domains":["yandex.ru"],"host":"smtp.yandex.ru","port":465,"secure":true},"Zoho":{"host":"smtp.zoho.com","port":465,"secure":true,"authMethod":"LOGIN"}}');

/***/ }),

/***/ 227761:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"nodemailer","version":"6.9.16","description":"Easy as cake e-mail sending from your Node.js applications","main":"lib/nodemailer.js","scripts":{"test":"node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","test:coverage":"c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js","lint":"eslint .","update":"rm -rf node_modules/ package-lock.json && ncu -u && npm install"},"repository":{"type":"git","url":"https://github.com/nodemailer/nodemailer.git"},"keywords":["Nodemailer"],"author":"Andris Reinman","license":"MIT-0","bugs":{"url":"https://github.com/nodemailer/nodemailer/issues"},"homepage":"https://nodemailer.com/","devDependencies":{"@aws-sdk/client-ses":"3.679.0","bunyan":"1.8.15","c8":"10.1.2","eslint":"8.57.0","eslint-config-nodemailer":"1.2.0","eslint-config-prettier":"9.1.0","libbase64":"1.3.0","libmime":"5.3.5","libqp":"2.1.0","nodemailer-ntlm-auth":"1.0.4","proxy":"1.0.2","proxy-test-server":"1.0.0","smtp-server":"3.13.6"},"engines":{"node":">=6.0.0"}}');

/***/ })

};
;