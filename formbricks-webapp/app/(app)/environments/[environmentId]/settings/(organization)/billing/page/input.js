(() => {
var exports = {};
exports.id = 1716;
exports.ids = [1716];
exports.modules = {

/***/ 191043:
/***/ ((module) => {

"use strict";
module.exports = require("@aws-sdk/client-s3");

/***/ }),

/***/ 741000:
/***/ ((module) => {

"use strict";
module.exports = require("@aws-sdk/s3-presigned-post");

/***/ }),

/***/ 531701:
/***/ ((module) => {

"use strict";
module.exports = require("@aws-sdk/s3-request-presigner");

/***/ }),

/***/ 896330:
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client");

/***/ }),

/***/ 560483:
/***/ ((module) => {

"use strict";
module.exports = require("@prisma/client/scripts/default-index.js");

/***/ }),

/***/ 710846:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.prod.js");

/***/ }),

/***/ 419121:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ 903295:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ 529294:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ 663033:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ 912412:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 979428:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 579646:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 455511:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 594735:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 629021:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 79748:
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ 781630:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 55591:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 491645:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 321820:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 333873:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 111723:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 927910:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 134631:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 583997:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 379551:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 328354:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 173566:
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ 74075:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 504573:
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),

/***/ 977598:
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ 973024:
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ 937067:
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),

/***/ 344708:
/***/ ((module) => {

"use strict";
module.exports = require("node:https");

/***/ }),

/***/ 777030:
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),

/***/ 176760:
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ 1708:
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ 157075:
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ 337830:
/***/ ((module) => {

"use strict";
module.exports = require("node:stream/web");

/***/ }),

/***/ 173136:
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ 257975:
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ 638522:
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),

/***/ 453781:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlobalError: () => (/* reexport default from dynamic */ next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2___default.a),
/* harmony export */   __next_app__: () => (/* binding */ __next_app__),
/* harmony export */   pages: () => (/* binding */ pages),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   tree: () => (/* binding */ tree)
/* harmony export */ });
/* harmony import */ var next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(290735);
/* harmony import */ var next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291232);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(272914);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(240085);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__) if(["default","tree","pages","GlobalError","__next_app__","routeModule"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
const module0 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 86397));
const module1 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 836653));
const module2 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 956791));
const module3 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 195335, 23));
const module4 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 544908, 23));
const module5 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 524160));
const module6 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 195335, 23));
const module7 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 544908, 23));
const module8 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 830691));
const module9 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 17753));
const module10 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 62083));
const page11 = () => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 389657));


// We inject the tree and pages here so that we can use them in the route
// module.
const tree = {
        children: [
        '',
        {
        children: [
        '(app)',
        {
        children: [
        'environments',
        {
        children: [
        '[environmentId]',
        {
        children: [
        'settings',
        {
        children: [
        '(organization)',
        {
        children: [
        'billing',
        {
        children: ['__PAGE__', {}, {
          page: [page11, "/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/settings/(organization)/billing/page.tsx"],
          
        }]
      },
        {
        'loading': [module10, "/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/settings/(organization)/billing/loading.tsx"],
        
      }
      ]
      },
        {
        'layout': [module9, "/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/settings/(organization)/layout.tsx"],
        
      }
      ]
      },
        {
        
        
      }
      ]
      },
        {
        'layout': [module8, "/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/layout.tsx"],
        
      }
      ]
      },
        {
        
        
      }
      ]
      },
        {
        'layout': [module5, "/Users/kdy1/projects/formbricks/apps/web/app/(app)/layout.tsx"],
'forbidden': [module6, "next/dist/client/components/forbidden-error"],
'unauthorized': [module7, "next/dist/client/components/unauthorized-error"],
        metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 170196))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
      }
      ]
      },
        {
        'layout': [module0, "/Users/kdy1/projects/formbricks/apps/web/app/layout.tsx"],
'error': [module1, "/Users/kdy1/projects/formbricks/apps/web/app/error.tsx"],
'not-found': [module2, "/Users/kdy1/projects/formbricks/apps/web/app/not-found.tsx"],
'forbidden': [module3, "next/dist/client/components/forbidden-error"],
'unauthorized': [module4, "next/dist/client/components/unauthorized-error"],
        metadata: {
    icon: [(async (props) => (await Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 170196))).default(props))],
    apple: [],
    openGraph: [],
    twitter: [],
    manifest: undefined
  }
      }
      ]
      }.children;
const pages = ["/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/settings/(organization)/billing/page.tsx"];


const __next_app_require__ = __webpack_require__
const __next_app_load_chunk__ = () => Promise.resolve()
const __next_app__ = {
    require: __next_app_require__,
    loadChunk: __next_app_load_chunk__
};

// Create and export the route module that will be consumed.
const routeModule = new next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppPageRouteModule({
    definition: {
        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_PAGE,
        page: "/(app)/environments/[environmentId]/settings/(organization)/billing/page",
        pathname: "/environments/[environmentId]/settings/billing",
        // The following aren't used in production.
        bundlePath: '',
        filename: '',
        appPaths: []
    },
    userland: {
        loaderTree: tree
    }
});

//# sourceMappingURL=app-page.js.map

/***/ }),

/***/ 721580:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "7f11f2efac37ac84796e6cb223722dbe2e808e177f": () => (/* reexport */ services/* getResponse */.mi),
  "7f12957c3365cc2950bdc48f0118f82439eb6c23ec": () => (/* reexport */ services/* getSurvey */.Dp),
  "7f15a06cafa02202d058a229589bc5849174431c21": () => (/* reexport */ upgradePlanAction),
  "7f20db167926d501ff62b9525526548773c8a436d4": () => (/* reexport */ services/* isTeamPartOfOrganization */.l5),
  "7f22bcd1cba0973c81b3501a43addbccaa9f8765f0": () => (/* reexport */ isSubscriptionCancelledAction),
  "7f2431fc3b8c6c124a1868f9a0b34d77983cdb9649": () => (/* reexport */ actions/* getLatestStableFbReleaseAction */.aX),
  "7f24b3d27813511aef08364975a20983e61a3dde87": () => (/* reexport */ actions/* getActiveInactiveSurveysAction */.bN),
  "7f36cf02b548a01d85112f587591e8c1e8390fa538": () => (/* reexport */ services/* isProjectPartOfOrganization */.Xj),
  "7f4f2c9c8b657cf906e9a25e65dafac6ec65967916": () => (/* reexport */ services/* getWebhook */.O0),
  "7f540889be00b7aa8c6ff1edc5cd79ece876954fd3": () => (/* reexport */ services/* getInvite */.I_),
  "7f60061b4b6be335eaa2facd1c5d8129b87f6923f4": () => (/* reexport */ services/* getActionClass */.Bx),
  "7f607ac975565ce495ac2952cf2bd35183ca9684ec": () => (/* reexport */ actions/* updateActionClassAction */.gn),
  "7f670a0537f96de8b5156e1b206124b2a990484370": () => (/* reexport */ services/* getApiKey */.CG),
  "7f74bd40a1f82de833915085152910f3ebd525b356": () => (/* reexport */ services/* getTeam */.Uo),
  "7f7d81830975711a8e55e0ea6784b77d5e43a02392": () => (/* reexport */ manageSubscriptionAction),
  "7f82763127a11eaaa934ce7fb0ffd1f148bfd60c06": () => (/* reexport */ actions/* deleteActionClassAction */.ir),
  "7fb9a3e6cbebea226c9a3678f31bfebf532ca7321e": () => (/* reexport */ services/* getResponseNote */.Wy),
  "7fc5117c6d27e507a6efd4e11ff01afa8b3c52f1a1": () => (/* reexport */ services/* getTag */.bH),
  "7fc6abb0838b6422ef7e81141fd6603883cd1990cf": () => (/* reexport */ services/* getDocument */.YE),
  "7fc856fe5dd5f698d2f54dacf4280d447336780427": () => (/* reexport */ services/* getLanguage */.Z0),
  "7fcda0e6bf50febdf861015e25ebdf74068a488dde": () => (/* reexport */ services/* getContact */.bl),
  "7fcfea9518c327899180b23cb3055005ba65cdef33": () => (/* reexport */ services/* getIntegration */.rg),
  "7fdb06c584a2145e0f48be9ead409fc7f774731fde": () => (/* reexport */ services/* getEnvironment */.uc),
  "7fdcbaf3445e783557d350b55d91be1398fafca7d3": () => (/* reexport */ services/* getInsight */.zv),
  "7fe763f2c0d5f307cc75c26f23c693a54ac24a3112": () => (/* reexport */ services/* getProject */.U1),
  "7ff27151c29d7402abd744ae983a2c25b016ccf26f": () => (/* reexport */ organization_actions/* createOrganizationAction */.s),
  "7ffb22c619704253744e9b5fea4eccca8b0808fb64": () => (/* reexport */ services/* getSegment */.kn)
});

// NAMESPACE OBJECT: ../../node_modules/stripe/esm/Error.js
var Error_namespaceObject = {};
__webpack_require__.r(Error_namespaceObject);
__webpack_require__.d(Error_namespaceObject, {
  StripeAPIError: () => (StripeAPIError),
  StripeAuthenticationError: () => (StripeAuthenticationError),
  StripeCardError: () => (StripeCardError),
  StripeConnectionError: () => (StripeConnectionError),
  StripeError: () => (StripeError),
  StripeIdempotencyError: () => (StripeIdempotencyError),
  StripeInvalidGrantError: () => (StripeInvalidGrantError),
  StripeInvalidRequestError: () => (StripeInvalidRequestError),
  StripePermissionError: () => (StripePermissionError),
  StripeRateLimitError: () => (StripeRateLimitError),
  StripeSignatureVerificationError: () => (StripeSignatureVerificationError),
  StripeUnknownError: () => (StripeUnknownError),
  generate: () => (generate)
});

// NAMESPACE OBJECT: ../../node_modules/stripe/esm/resources.js
var resources_namespaceObject = {};
__webpack_require__.r(resources_namespaceObject);
__webpack_require__.d(resources_namespaceObject, {
  Account: () => (Accounts_Accounts),
  AccountLinks: () => (AccountLinks),
  AccountSessions: () => (AccountSessions),
  Accounts: () => (Accounts_Accounts),
  ApplePayDomains: () => (ApplePayDomains),
  ApplicationFees: () => (ApplicationFees),
  Apps: () => (Apps),
  Balance: () => (Balance),
  BalanceTransactions: () => (BalanceTransactions),
  Billing: () => (Billing),
  BillingPortal: () => (BillingPortal),
  Charges: () => (Charges),
  Checkout: () => (Checkout),
  Climate: () => (Climate),
  ConfirmationTokens: () => (ConfirmationTokens_ConfirmationTokens),
  CountrySpecs: () => (CountrySpecs),
  Coupons: () => (Coupons),
  CreditNotes: () => (CreditNotes),
  CustomerSessions: () => (CustomerSessions),
  Customers: () => (Customers_Customers),
  Disputes: () => (Disputes_Disputes),
  Entitlements: () => (Entitlements),
  EphemeralKeys: () => (EphemeralKeys),
  Events: () => (Events),
  ExchangeRates: () => (ExchangeRates),
  FileLinks: () => (FileLinks),
  Files: () => (Files),
  FinancialConnections: () => (FinancialConnections),
  Forwarding: () => (Forwarding),
  Identity: () => (Identity),
  InvoiceItems: () => (InvoiceItems),
  Invoices: () => (Invoices),
  Issuing: () => (Issuing),
  Mandates: () => (Mandates),
  OAuth: () => (OAuth),
  PaymentIntents: () => (PaymentIntents),
  PaymentLinks: () => (PaymentLinks),
  PaymentMethodConfigurations: () => (PaymentMethodConfigurations),
  PaymentMethodDomains: () => (PaymentMethodDomains),
  PaymentMethods: () => (PaymentMethods),
  Payouts: () => (Payouts),
  Plans: () => (Plans),
  Prices: () => (Prices),
  Products: () => (Products_Products),
  PromotionCodes: () => (PromotionCodes),
  Quotes: () => (Quotes),
  Radar: () => (Radar),
  Refunds: () => (Refunds_Refunds),
  Reporting: () => (Reporting),
  Reviews: () => (Reviews),
  SetupAttempts: () => (SetupAttempts),
  SetupIntents: () => (SetupIntents),
  ShippingRates: () => (ShippingRates),
  Sigma: () => (Sigma),
  Sources: () => (Sources),
  SubscriptionItems: () => (SubscriptionItems),
  SubscriptionSchedules: () => (SubscriptionSchedules),
  Subscriptions: () => (Subscriptions),
  Tax: () => (Tax),
  TaxCodes: () => (TaxCodes),
  TaxIds: () => (TaxIds),
  TaxRates: () => (TaxRates),
  Terminal: () => (Terminal),
  TestHelpers: () => (TestHelpers),
  Tokens: () => (Tokens_Tokens),
  Topups: () => (Topups),
  Transfers: () => (Transfers),
  Treasury: () => (Treasury),
  WebhookEndpoints: () => (WebhookEndpoints)
});

// EXTERNAL MODULE: ./app/(app)/environments/[environmentId]/actions/actions.ts
var actions = __webpack_require__(933166);
// EXTERNAL MODULE: ./lib/utils/services.ts
var services = __webpack_require__(883212);
// EXTERNAL MODULE: ./modules/organization/actions.ts
var organization_actions = __webpack_require__(57841);
// EXTERNAL MODULE: ../../node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js
var server_reference = __webpack_require__(286055);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/app-render/encryption.js
var encryption = __webpack_require__(770767);
// EXTERNAL MODULE: ./lib/utils/action-client.ts
var action_client = __webpack_require__(308046);
// EXTERNAL MODULE: ./lib/utils/action-client-middleware.ts
var action_client_middleware = __webpack_require__(729455);
// EXTERNAL MODULE: ./lib/utils/helper.ts
var helper = __webpack_require__(440388);
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(455511);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(594735);
;// ../../node_modules/stripe/esm/crypto/CryptoProvider.js
/**
 * Interface encapsulating the various crypto computations used by the library,
 * allowing pluggable underlying crypto implementations.
 */
class CryptoProvider {
    /**
     * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
     * The output HMAC should be encoded in hexadecimal.
     *
     * Sample values for implementations:
     * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
     * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
     */
    computeHMACSignature(payload, secret) {
        throw new Error('computeHMACSignature not implemented.');
    }
    /**
     * Asynchronous version of `computeHMACSignature`. Some implementations may
     * only allow support async signature computation.
     *
     * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
     * The output HMAC should be encoded in hexadecimal.
     *
     * Sample values for implementations:
     * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
     * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
     */
    computeHMACSignatureAsync(payload, secret) {
        throw new Error('computeHMACSignatureAsync not implemented.');
    }
}
/**
 * If the crypto provider only supports asynchronous operations,
 * throw CryptoProviderOnlySupportsAsyncError instead of
 * a generic error so that the caller can choose to provide
 * a more helpful error message to direct the user to use
 * an asynchronous pathway.
 */
class CryptoProviderOnlySupportsAsyncError extends Error {
}

;// ../../node_modules/stripe/esm/crypto/NodeCryptoProvider.js


/**
 * `CryptoProvider which uses the Node `crypto` package for its computations.
 */
class NodeCryptoProvider extends CryptoProvider {
    /** @override */
    computeHMACSignature(payload, secret) {
        return external_crypto_.createHmac('sha256', secret)
            .update(payload, 'utf8')
            .digest('hex');
    }
    /** @override */
    async computeHMACSignatureAsync(payload, secret) {
        const signature = await this.computeHMACSignature(payload, secret);
        return signature;
    }
}

// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(781630);
var external_http_namespaceObject = /*#__PURE__*/__webpack_require__.t(external_http_, 2);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(55591);
var external_https_namespaceObject = /*#__PURE__*/__webpack_require__.t(external_https_, 2);
;// ../../node_modules/stripe/esm/net/HttpClient.js
/**
 * Encapsulates the logic for issuing a request to the Stripe API.
 *
 * A custom HTTP client should should implement:
 * 1. A response class which extends HttpClientResponse and wraps around their
 *    own internal representation of a response.
 * 2. A client class which extends HttpClient and implements all methods,
 *    returning their own response class when making requests.
 */
class HttpClient {
    /** The client name used for diagnostics. */
    getClientName() {
        throw new Error('getClientName not implemented.');
    }
    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        throw new Error('makeRequest not implemented.');
    }
    /** Helper to make a consistent timeout error across implementations. */
    static makeTimeoutError() {
        const timeoutErr = new TypeError(HttpClient.TIMEOUT_ERROR_CODE);
        timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;
        return timeoutErr;
    }
}
// Public API accessible via Stripe.HttpClient
HttpClient.CONNECTION_CLOSED_ERROR_CODES = ['ECONNRESET', 'EPIPE'];
HttpClient.TIMEOUT_ERROR_CODE = 'ETIMEDOUT';
class HttpClientResponse {
    constructor(statusCode, headers) {
        this._statusCode = statusCode;
        this._headers = headers;
    }
    getStatusCode() {
        return this._statusCode;
    }
    getHeaders() {
        return this._headers;
    }
    getRawResponse() {
        throw new Error('getRawResponse not implemented.');
    }
    toStream(streamCompleteCallback) {
        throw new Error('toStream not implemented.');
    }
    toJSON() {
        throw new Error('toJSON not implemented.');
    }
}

;// ../../node_modules/stripe/esm/net/NodeHttpClient.js



// `import * as http_ from 'http'` creates a "Module Namespace Exotic Object"
// which is immune to monkey-patching, whereas http_.default (in an ES Module context)
// will resolve to the same thing as require('http'), which is
// monkey-patchable. We care about this because users in their test
// suites might be using a library like "nock" which relies on the ability
// to monkey-patch and intercept calls to http.request.
const http = external_http_ || external_http_namespaceObject;
const https = external_https_ || external_https_namespaceObject;
const defaultHttpAgent = new http.Agent({ keepAlive: true });
const defaultHttpsAgent = new https.Agent({ keepAlive: true });
/**
 * HTTP client which uses the Node `http` and `https` packages to issue
 * requests.`
 */
class NodeHttpClient extends HttpClient {
    constructor(agent) {
        super();
        this._agent = agent;
    }
    /** @override. */
    getClientName() {
        return 'node';
    }
    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        const isInsecureConnection = protocol === 'http';
        let agent = this._agent;
        if (!agent) {
            agent = isInsecureConnection ? defaultHttpAgent : defaultHttpsAgent;
        }
        const requestPromise = new Promise((resolve, reject) => {
            const req = (isInsecureConnection ? http : https).request({
                host: host,
                port: port,
                path,
                method,
                agent,
                headers,
                ciphers: 'DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:!MD5',
            });
            req.setTimeout(timeout, () => {
                req.destroy(HttpClient.makeTimeoutError());
            });
            req.on('response', (res) => {
                resolve(new NodeHttpClientResponse(res));
            });
            req.on('error', (error) => {
                reject(error);
            });
            req.once('socket', (socket) => {
                if (socket.connecting) {
                    socket.once(isInsecureConnection ? 'connect' : 'secureConnect', () => {
                        // Send payload; we're safe:
                        req.write(requestData);
                        req.end();
                    });
                }
                else {
                    // we're already connected
                    req.write(requestData);
                    req.end();
                }
            });
        });
        return requestPromise;
    }
}
class NodeHttpClientResponse extends HttpClientResponse {
    constructor(res) {
        // @ts-ignore
        super(res.statusCode, res.headers || {});
        this._res = res;
    }
    getRawResponse() {
        return this._res;
    }
    toStream(streamCompleteCallback) {
        // The raw response is itself the stream, so we just return that. To be
        // backwards compatible, we should invoke the streamCompleteCallback only
        // once the stream has been fully consumed.
        this._res.once('end', () => streamCompleteCallback());
        return this._res;
    }
    toJSON() {
        return new Promise((resolve, reject) => {
            let response = '';
            this._res.setEncoding('utf8');
            this._res.on('data', (chunk) => {
                response += chunk;
            });
            this._res.once('end', () => {
                try {
                    resolve(JSON.parse(response));
                }
                catch (e) {
                    reject(e);
                }
            });
        });
    }
}

;// ../../node_modules/stripe/esm/net/FetchHttpClient.js

/**
 * HTTP client which uses a `fetch` function to issue requests.
 *
 * By default relies on the global `fetch` function, but an optional function
 * can be passed in. If passing in a function, it is expected to match the Web
 * Fetch API. As an example, this could be the function provided by the
 * node-fetch package (https://github.com/node-fetch/node-fetch).
 */
class FetchHttpClient extends HttpClient {
    constructor(fetchFn) {
        super();
        // Default to global fetch if available
        if (!fetchFn) {
            if (!globalThis.fetch) {
                throw new Error('fetch() function not provided and is not defined in the global scope. ' +
                    'You must provide a fetch implementation.');
            }
            fetchFn = globalThis.fetch;
        }
        // Both timeout behaviors differs from Node:
        // - Fetch uses a single timeout for the entire length of the request.
        // - Node is more fine-grained and resets the timeout after each stage of the request.
        if (globalThis.AbortController) {
            // Utilise native AbortController if available
            // AbortController was added in Node v15.0.0, v14.17.0
            this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);
        }
        else {
            // Fall back to racing against a timeout promise if not available in the runtime
            // This does not actually cancel the underlying fetch operation or resources
            this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);
        }
    }
    static makeFetchWithRaceTimeout(fetchFn) {
        return (url, init, timeout) => {
            let pendingTimeoutId;
            const timeoutPromise = new Promise((_, reject) => {
                pendingTimeoutId = setTimeout(() => {
                    pendingTimeoutId = null;
                    reject(HttpClient.makeTimeoutError());
                }, timeout);
            });
            const fetchPromise = fetchFn(url, init);
            return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
                if (pendingTimeoutId) {
                    clearTimeout(pendingTimeoutId);
                }
            });
        };
    }
    static makeFetchWithAbortTimeout(fetchFn) {
        return async (url, init, timeout) => {
            // Use AbortController because AbortSignal.timeout() was added later in Node v17.3.0, v16.14.0
            const abort = new AbortController();
            let timeoutId = setTimeout(() => {
                timeoutId = null;
                abort.abort(HttpClient.makeTimeoutError());
            }, timeout);
            try {
                return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));
            }
            catch (err) {
                // Some implementations, like node-fetch, do not respect the reason passed to AbortController.abort()
                // and instead it always throws an AbortError
                // We catch this case to normalise all timeout errors
                if (err.name === 'AbortError') {
                    throw HttpClient.makeTimeoutError();
                }
                else {
                    throw err;
                }
            }
            finally {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
            }
        };
    }
    /** @override. */
    getClientName() {
        return 'fetch';
    }
    async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
        const isInsecureConnection = protocol === 'http';
        const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);
        url.port = port;
        // For methods which expect payloads, we should always pass a body value
        // even when it is empty. Without this, some JS runtimes (eg. Deno) will
        // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519
        // for more details.
        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';
        const body = requestData || (methodHasPayload ? '' : undefined);
        const res = await this._fetchFn(url.toString(), {
            method,
            // @ts-ignore
            headers,
            // @ts-ignore
            body,
        }, timeout);
        return new FetchHttpClientResponse(res);
    }
}
class FetchHttpClientResponse extends HttpClientResponse {
    constructor(res) {
        super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));
        this._res = res;
    }
    getRawResponse() {
        return this._res;
    }
    toStream(streamCompleteCallback) {
        // Unfortunately `fetch` does not have event handlers for when the stream is
        // completely read. We therefore invoke the streamCompleteCallback right
        // away. This callback emits a response event with metadata and completes
        // metrics, so it's ok to do this without waiting for the stream to be
        // completely read.
        streamCompleteCallback();
        // Fetch's `body` property is expected to be a readable stream of the body.
        return this._res.body;
    }
    toJSON() {
        return this._res.json();
    }
    static _transformHeadersToObject(headers) {
        // Fetch uses a Headers instance so this must be converted to a barebones
        // JS object to meet the HttpClient interface.
        const headersObj = {};
        for (const entry of headers) {
            if (!Array.isArray(entry) || entry.length != 2) {
                throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');
            }
            headersObj[entry[0]] = entry[1];
        }
        return headersObj;
    }
}

;// ../../node_modules/stripe/esm/crypto/SubtleCryptoProvider.js

/**
 * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
 *
 * This only supports asynchronous operations.
 */
class SubtleCryptoProvider extends CryptoProvider {
    constructor(subtleCrypto) {
        super();
        // If no subtle crypto is interface, default to the global namespace. This
        // is to allow custom interfaces (eg. using the Node webcrypto interface in
        // tests).
        this.subtleCrypto = subtleCrypto || crypto.subtle;
    }
    /** @override */
    computeHMACSignature(payload, secret) {
        throw new CryptoProviderOnlySupportsAsyncError('SubtleCryptoProvider cannot be used in a synchronous context.');
    }
    /** @override */
    async computeHMACSignatureAsync(payload, secret) {
        const encoder = new TextEncoder();
        const key = await this.subtleCrypto.importKey('raw', encoder.encode(secret), {
            name: 'HMAC',
            hash: { name: 'SHA-256' },
        }, false, ['sign']);
        const signatureBuffer = await this.subtleCrypto.sign('hmac', key, encoder.encode(payload));
        // crypto.subtle returns the signature in base64 format. This must be
        // encoded in hex to match the CryptoProvider contract. We map each byte in
        // the buffer to its corresponding hex octet and then combine into a string.
        const signatureBytes = new Uint8Array(signatureBuffer);
        const signatureHexCodes = new Array(signatureBytes.length);
        for (let i = 0; i < signatureBytes.length; i++) {
            signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];
        }
        return signatureHexCodes.join('');
    }
}
// Cached mapping of byte to hex representation. We do this once to avoid re-
// computing every time we need to convert the result of a signature to hex.
const byteHexMapping = new Array(256);
for (let i = 0; i < byteHexMapping.length; i++) {
    byteHexMapping[i] = i.toString(16).padStart(2, '0');
}

;// ../../node_modules/stripe/esm/platform/PlatformFunctions.js


/**
 * Interface encapsulating various utility functions whose
 * implementations depend on the platform / JS runtime.
 */
class PlatformFunctions {
    constructor() {
        this._fetchFn = null;
        this._agent = null;
    }
    /**
     * Gets uname with Node's built-in `exec` function, if available.
     */
    getUname() {
        throw new Error('getUname not implemented.');
    }
    /**
     * Generates a v4 UUID. See https://stackoverflow.com/a/2117523
     */
    uuid4() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            const r = (Math.random() * 16) | 0;
            const v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }
    /**
     * Compares strings in constant time.
     */
    secureCompare(a, b) {
        // return early here if buffer lengths are not equal
        if (a.length !== b.length) {
            return false;
        }
        const len = a.length;
        let result = 0;
        for (let i = 0; i < len; ++i) {
            result |= a.charCodeAt(i) ^ b.charCodeAt(i);
        }
        return result === 0;
    }
    /**
     * Creates an event emitter.
     */
    createEmitter() {
        throw new Error('createEmitter not implemented.');
    }
    /**
     * Checks if the request data is a stream. If so, read the entire stream
     * to a buffer and return the buffer.
     */
    tryBufferData(data) {
        throw new Error('tryBufferData not implemented.');
    }
    /**
     * Creates an HTTP client which uses the Node `http` and `https` packages
     * to issue requests.
     */
    createNodeHttpClient(agent) {
        throw new Error('createNodeHttpClient not implemented.');
    }
    /**
     * Creates an HTTP client for issuing Stripe API requests which uses the Web
     * Fetch API.
     *
     * A fetch function can optionally be passed in as a parameter. If none is
     * passed, will default to the default `fetch` function in the global scope.
     */
    createFetchHttpClient(fetchFn) {
        return new FetchHttpClient(fetchFn);
    }
    /**
     * Creates an HTTP client using runtime-specific APIs.
     */
    createDefaultHttpClient() {
        throw new Error('createDefaultHttpClient not implemented.');
    }
    /**
     * Creates a CryptoProvider which uses the Node `crypto` package for its computations.
     */
    createNodeCryptoProvider() {
        throw new Error('createNodeCryptoProvider not implemented.');
    }
    /**
     * Creates a CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
     */
    createSubtleCryptoProvider(subtleCrypto) {
        return new SubtleCryptoProvider(subtleCrypto);
    }
    createDefaultCryptoProvider() {
        throw new Error('createDefaultCryptoProvider not implemented.');
    }
}

;// ../../node_modules/stripe/esm/Error.js
/* eslint-disable camelcase */
const generate = (rawStripeError) => {
    switch (rawStripeError.type) {
        case 'card_error':
            return new StripeCardError(rawStripeError);
        case 'invalid_request_error':
            return new StripeInvalidRequestError(rawStripeError);
        case 'api_error':
            return new StripeAPIError(rawStripeError);
        case 'authentication_error':
            return new StripeAuthenticationError(rawStripeError);
        case 'rate_limit_error':
            return new StripeRateLimitError(rawStripeError);
        case 'idempotency_error':
            return new StripeIdempotencyError(rawStripeError);
        case 'invalid_grant':
            return new StripeInvalidGrantError(rawStripeError);
        default:
            return new StripeUnknownError(rawStripeError);
    }
};
/**
 * StripeError is the base error from which all other more specific Stripe errors derive.
 * Specifically for errors returned from Stripe's REST API.
 */
class StripeError extends Error {
    constructor(raw = {}, type = null) {
        super(raw.message);
        this.type = type || this.constructor.name;
        this.raw = raw;
        this.rawType = raw.type;
        this.code = raw.code;
        this.doc_url = raw.doc_url;
        this.param = raw.param;
        this.detail = raw.detail;
        this.headers = raw.headers;
        this.requestId = raw.requestId;
        this.statusCode = raw.statusCode;
        // @ts-ignore
        this.message = raw.message;
        this.charge = raw.charge;
        this.decline_code = raw.decline_code;
        this.payment_intent = raw.payment_intent;
        this.payment_method = raw.payment_method;
        this.payment_method_type = raw.payment_method_type;
        this.setup_intent = raw.setup_intent;
        this.source = raw.source;
    }
}
/**
 * Helper factory which takes raw stripe errors and outputs wrapping instances
 */
StripeError.generate = generate;
// Specific Stripe Error types:
/**
 * CardError is raised when a user enters a card that can't be charged for
 * some reason.
 */
class StripeCardError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeCardError');
    }
}
/**
 * InvalidRequestError is raised when a request is initiated with invalid
 * parameters.
 */
class StripeInvalidRequestError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeInvalidRequestError');
    }
}
/**
 * APIError is a generic error that may be raised in cases where none of the
 * other named errors cover the problem. It could also be raised in the case
 * that a new error has been introduced in the API, but this version of the
 * Node.JS SDK doesn't know how to handle it.
 */
class StripeAPIError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeAPIError');
    }
}
/**
 * AuthenticationError is raised when invalid credentials are used to connect
 * to Stripe's servers.
 */
class StripeAuthenticationError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeAuthenticationError');
    }
}
/**
 * PermissionError is raised in cases where access was attempted on a resource
 * that wasn't allowed.
 */
class StripePermissionError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripePermissionError');
    }
}
/**
 * RateLimitError is raised in cases where an account is putting too much load
 * on Stripe's API servers (usually by performing too many requests). Please
 * back off on request rate.
 */
class StripeRateLimitError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeRateLimitError');
    }
}
/**
 * StripeConnectionError is raised in the event that the SDK can't connect to
 * Stripe's servers. That can be for a variety of different reasons from a
 * downed network to a bad TLS certificate.
 */
class StripeConnectionError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeConnectionError');
    }
}
/**
 * SignatureVerificationError is raised when the signature verification for a
 * webhook fails
 */
class StripeSignatureVerificationError extends StripeError {
    constructor(header, payload, raw = {}) {
        super(raw, 'StripeSignatureVerificationError');
        this.header = header;
        this.payload = payload;
    }
}
/**
 * IdempotencyError is raised in cases where an idempotency key was used
 * improperly.
 */
class StripeIdempotencyError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeIdempotencyError');
    }
}
/**
 * InvalidGrantError is raised when a specified code doesn't exist, is
 * expired, has been used, or doesn't belong to you; a refresh token doesn't
 * exist, or doesn't belong to you; or if an API key's mode (live or test)
 * doesn't match the mode of a code or refresh token.
 */
class StripeInvalidGrantError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeInvalidGrantError');
    }
}
/**
 * Any other error from Stripe not specifically captured above
 */
class StripeUnknownError extends StripeError {
    constructor(raw = {}) {
        super(raw, 'StripeUnknownError');
    }
}

// EXTERNAL MODULE: ../../node_modules/qs/lib/index.js
var lib = __webpack_require__(250601);
;// ../../node_modules/stripe/esm/utils.js

const OPTIONS_KEYS = [
    'apiKey',
    'idempotencyKey',
    'stripeAccount',
    'apiVersion',
    'maxNetworkRetries',
    'timeout',
    'host',
];
function isOptionsHash(o) {
    return (o &&
        typeof o === 'object' &&
        OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o, prop)));
}
/**
 * Stringifies an Object, accommodating nested objects
 * (forming the conventional key 'parent[child]=value')
 */
function stringifyRequestData(data) {
    return (lib.stringify(data, {
        serializeDate: (d) => Math.floor(d.getTime() / 1000).toString(),
    })
        // Don't use strict form encoding by changing the square bracket control
        // characters back to their literals. This is fine by the server, and
        // makes these parameter strings easier to read.
        .replace(/%5B/g, '[')
        .replace(/%5D/g, ']'));
}
/**
 * Outputs a new function with interpolated object property values.
 * Use like so:
 *   const fn = makeURLInterpolator('some/url/{param1}/{param2}');
 *   fn({ param1: 123, param2: 456 }); // => 'some/url/123/456'
 */
const makeURLInterpolator = (() => {
    const rc = {
        '\n': '\\n',
        '"': '\\"',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
    };
    return (str) => {
        const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc[$0]);
        return (outputs) => {
            return cleanString.replace(/\{([\s\S]+?)\}/g, ($0, $1) => 
            // @ts-ignore
            encodeURIComponent(outputs[$1] || ''));
        };
    };
})();
function extractUrlParams(path) {
    const params = path.match(/\{\w+\}/g);
    if (!params) {
        return [];
    }
    return params.map((param) => param.replace(/[{}]/g, ''));
}
/**
 * Return the data argument from a list of arguments
 *
 * @param {object[]} args
 * @returns {object}
 */
function getDataFromArgs(args) {
    if (!Array.isArray(args) || !args[0] || typeof args[0] !== 'object') {
        return {};
    }
    if (!isOptionsHash(args[0])) {
        return args.shift();
    }
    const argKeys = Object.keys(args[0]);
    const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
    // In some cases options may be the provided as the first argument.
    // Here we're detecting a case where there are two distinct arguments
    // (the first being args and the second options) and with known
    // option keys in the first so that we can warn the user about it.
    if (optionKeysInArgs.length > 0 &&
        optionKeysInArgs.length !== argKeys.length) {
        emitWarning(`Options found in arguments (${optionKeysInArgs.join(', ')}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.`);
    }
    return {};
}
/**
 * Return the options hash from a list of arguments
 */
function getOptionsFromArgs(args) {
    const opts = {
        auth: null,
        host: null,
        headers: {},
        settings: {},
    };
    if (args.length > 0) {
        const arg = args[args.length - 1];
        if (typeof arg === 'string') {
            opts.auth = args.pop();
        }
        else if (isOptionsHash(arg)) {
            const params = Object.assign({}, args.pop());
            const extraKeys = Object.keys(params).filter((key) => !OPTIONS_KEYS.includes(key));
            if (extraKeys.length) {
                emitWarning(`Invalid options found (${extraKeys.join(', ')}); ignoring.`);
            }
            if (params.apiKey) {
                opts.auth = params.apiKey;
            }
            if (params.idempotencyKey) {
                opts.headers['Idempotency-Key'] = params.idempotencyKey;
            }
            if (params.stripeAccount) {
                opts.headers['Stripe-Account'] = params.stripeAccount;
            }
            if (params.apiVersion) {
                opts.headers['Stripe-Version'] = params.apiVersion;
            }
            if (Number.isInteger(params.maxNetworkRetries)) {
                opts.settings.maxNetworkRetries = params.maxNetworkRetries;
            }
            if (Number.isInteger(params.timeout)) {
                opts.settings.timeout = params.timeout;
            }
            if (params.host) {
                opts.host = params.host;
            }
        }
    }
    return opts;
}
/**
 * Provide simple "Class" extension mechanism.
 * <!-- Public API accessible via Stripe.StripeResource.extend -->
 */
function protoExtend(sub) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const Super = this;
    const Constructor = Object.prototype.hasOwnProperty.call(sub, 'constructor')
        ? sub.constructor
        : function (...args) {
            Super.apply(this, args);
        };
    // This initialization logic is somewhat sensitive to be compatible with
    // divergent JS implementations like the one found in Qt. See here for more
    // context:
    //
    // https://github.com/stripe/stripe-node/pull/334
    Object.assign(Constructor, Super);
    Constructor.prototype = Object.create(Super.prototype);
    Object.assign(Constructor.prototype, sub);
    return Constructor;
}
/**
 * Remove empty values from an object
 */
function removeNullish(obj) {
    if (typeof obj !== 'object') {
        throw new Error('Argument must be an object');
    }
    return Object.keys(obj).reduce((result, key) => {
        if (obj[key] != null) {
            result[key] = obj[key];
        }
        return result;
    }, {});
}
/**
 * Normalize standard HTTP Headers:
 * {'foo-bar': 'hi'}
 * becomes
 * {'Foo-Bar': 'hi'}
 */
function normalizeHeaders(obj) {
    if (!(obj && typeof obj === 'object')) {
        return obj;
    }
    return Object.keys(obj).reduce((result, header) => {
        result[normalizeHeader(header)] = obj[header];
        return result;
    }, {});
}
/**
 * Stolen from https://github.com/marten-de-vries/header-case-normalizer/blob/master/index.js#L36-L41
 * without the exceptions which are irrelevant to us.
 */
function normalizeHeader(header) {
    return header
        .split('-')
        .map((text) => text.charAt(0).toUpperCase() + text.substr(1).toLowerCase())
        .join('-');
}
function callbackifyPromiseWithTimeout(promise, callback) {
    if (callback) {
        // Ensure callback is called outside of promise stack.
        return promise.then((res) => {
            setTimeout(() => {
                callback(null, res);
            }, 0);
        }, (err) => {
            setTimeout(() => {
                callback(err, null);
            }, 0);
        });
    }
    return promise;
}
/**
 * Allow for special capitalization cases (such as OAuth)
 */
function pascalToCamelCase(name) {
    if (name === 'OAuth') {
        return 'oauth';
    }
    else {
        return name[0].toLowerCase() + name.substring(1);
    }
}
function emitWarning(warning) {
    if (typeof process.emitWarning !== 'function') {
        return console.warn(`Stripe: ${warning}`); /* eslint-disable-line no-console */
    }
    return process.emitWarning(warning, 'Stripe');
}
function isObject(obj) {
    const type = typeof obj;
    return (type === 'function' || type === 'object') && !!obj;
}
// For use in multipart requests
function flattenAndStringify(data) {
    const result = {};
    const step = (obj, prevKey) => {
        Object.keys(obj).forEach((key) => {
            // @ts-ignore
            const value = obj[key];
            const newKey = prevKey ? `${prevKey}[${key}]` : key;
            if (isObject(value)) {
                if (!(value instanceof Uint8Array) &&
                    !Object.prototype.hasOwnProperty.call(value, 'data')) {
                    // Non-buffer non-file Objects are recursively flattened
                    return step(value, newKey);
                }
                else {
                    // Buffers and file objects are stored without modification
                    result[newKey] = value;
                }
            }
            else {
                // Primitives are converted to strings
                result[newKey] = String(value);
            }
        });
    };
    step(data, null);
    return result;
}
function validateInteger(name, n, defaultVal) {
    if (!Number.isInteger(n)) {
        if (defaultVal !== undefined) {
            return defaultVal;
        }
        else {
            throw new Error(`${name} must be an integer`);
        }
    }
    return n;
}
function determineProcessUserAgentProperties() {
    return typeof process === 'undefined'
        ? {}
        : {
            lang_version: process.version,
            platform: process.platform,
        };
}
/**
 * Joins an array of Uint8Arrays into a single Uint8Array
 */
function concat(arrays) {
    const totalLength = arrays.reduce((len, array) => len + array.length, 0);
    const merged = new Uint8Array(totalLength);
    let offset = 0;
    arrays.forEach((array) => {
        merged.set(array, offset);
        offset += array.length;
    });
    return merged;
}

// EXTERNAL MODULE: external "child_process"
var external_child_process_ = __webpack_require__(579646);
;// ../../node_modules/stripe/esm/platform/NodePlatformFunctions.js








class StreamProcessingError extends StripeError {
}
/**
 * Specializes WebPlatformFunctions using APIs available in Node.js.
 */
class NodePlatformFunctions extends PlatformFunctions {
    constructor() {
        super();
        this._exec = external_child_process_.exec;
        this._UNAME_CACHE = null;
    }
    /** @override */
    uuid4() {
        // available in: v14.17.x+
        if (external_crypto_.randomUUID) {
            return external_crypto_.randomUUID();
        }
        return super.uuid4();
    }
    /**
     * @override
     * Node's built in `exec` function sometimes throws outright,
     * and sometimes has a callback with an error,
     * depending on the type of error.
     *
     * This unifies that interface by resolving with a null uname
     * if an error is encountered.
     */
    getUname() {
        if (!this._UNAME_CACHE) {
            this._UNAME_CACHE = new Promise((resolve, reject) => {
                try {
                    this._exec('uname -a', (err, uname) => {
                        if (err) {
                            return resolve(null);
                        }
                        resolve(uname);
                    });
                }
                catch (e) {
                    resolve(null);
                }
            });
        }
        return this._UNAME_CACHE;
    }
    /**
     * @override
     * Secure compare, from https://github.com/freewil/scmp
     */
    secureCompare(a, b) {
        if (!a || !b) {
            throw new Error('secureCompare must receive two arguments');
        }
        // return early here if buffer lengths are not equal since timingSafeEqual
        // will throw if buffer lengths are not equal
        if (a.length !== b.length) {
            return false;
        }
        // use crypto.timingSafeEqual if available (since Node.js v6.6.0),
        // otherwise use our own scmp-internal function.
        if (external_crypto_.timingSafeEqual) {
            const textEncoder = new TextEncoder();
            const aEncoded = textEncoder.encode(a);
            const bEncoded = textEncoder.encode(b);
            return external_crypto_.timingSafeEqual(aEncoded, bEncoded);
        }
        return super.secureCompare(a, b);
    }
    createEmitter() {
        return new external_events_.EventEmitter();
    }
    /** @override */
    tryBufferData(data) {
        if (!(data.file.data instanceof external_events_.EventEmitter)) {
            return Promise.resolve(data);
        }
        const bufferArray = [];
        return new Promise((resolve, reject) => {
            data.file.data
                .on('data', (line) => {
                bufferArray.push(line);
            })
                .once('end', () => {
                // @ts-ignore
                const bufferData = Object.assign({}, data);
                bufferData.file.data = concat(bufferArray);
                resolve(bufferData);
            })
                .on('error', (err) => {
                reject(new StreamProcessingError({
                    message: 'An error occurred while attempting to process the file for upload.',
                    detail: err,
                }));
            });
        });
    }
    /** @override */
    createNodeHttpClient(agent) {
        return new NodeHttpClient(agent);
    }
    /** @override */
    createDefaultHttpClient() {
        return new NodeHttpClient();
    }
    /** @override */
    createNodeCryptoProvider() {
        return new NodeCryptoProvider();
    }
    /** @override */
    createDefaultCryptoProvider() {
        return this.createNodeCryptoProvider();
    }
}

;// ../../node_modules/stripe/esm/RequestSender.js



const MAX_RETRY_AFTER_WAIT = 60;
class RequestSender {
    constructor(stripe, maxBufferedRequestMetric) {
        this._stripe = stripe;
        this._maxBufferedRequestMetric = maxBufferedRequestMetric;
    }
    _addHeadersDirectlyToObject(obj, headers) {
        // For convenience, make some headers easily accessible on
        // lastResponse.
        // NOTE: Stripe responds with lowercase header names/keys.
        obj.requestId = headers['request-id'];
        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];
        obj.apiVersion = obj.apiVersion || headers['stripe-version'];
        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];
    }
    _makeResponseEvent(requestEvent, statusCode, headers) {
        const requestEndTime = Date.now();
        const requestDurationMs = requestEndTime - requestEvent.request_start_time;
        return removeNullish({
            api_version: headers['stripe-version'],
            account: headers['stripe-account'],
            idempotency_key: headers['idempotency-key'],
            method: requestEvent.method,
            path: requestEvent.path,
            status: statusCode,
            request_id: this._getRequestId(headers),
            elapsed: requestDurationMs,
            request_start_time: requestEvent.request_start_time,
            request_end_time: requestEndTime,
        });
    }
    _getRequestId(headers) {
        return headers['request-id'];
    }
    /**
     * Used by methods with spec.streaming === true. For these methods, we do not
     * buffer successful responses into memory or do parse them into stripe
     * objects, we delegate that all of that to the user and pass back the raw
     * http.Response object to the callback.
     *
     * (Unsuccessful responses shouldn't make it here, they should
     * still be buffered/parsed and handled by _jsonResponseHandler -- see
     * makeRequest)
     */
    _streamingResponseHandler(requestEvent, usage, callback) {
        return (res) => {
            const headers = res.getHeaders();
            const streamCompleteCallback = () => {
                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
                this._stripe._emitter.emit('response', responseEvent);
                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);
            };
            const stream = res.toStream(streamCompleteCallback);
            // This is here for backwards compatibility, as the stream is a raw
            // HTTP response in Node and the legacy behavior was to mutate this
            // response.
            this._addHeadersDirectlyToObject(stream, headers);
            return callback(null, stream);
        };
    }
    /**
     * Default handler for Stripe responses. Buffers the response into memory,
     * parses the JSON and returns it (i.e. passes it to the callback) if there
     * is no "error" field. Otherwise constructs/passes an appropriate Error.
     */
    _jsonResponseHandler(requestEvent, usage, callback) {
        return (res) => {
            const headers = res.getHeaders();
            const requestId = this._getRequestId(headers);
            const statusCode = res.getStatusCode();
            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);
            this._stripe._emitter.emit('response', responseEvent);
            res
                .toJSON()
                .then((jsonResponse) => {
                if (jsonResponse.error) {
                    let err;
                    // Convert OAuth error responses into a standard format
                    // so that the rest of the error logic can be shared
                    if (typeof jsonResponse.error === 'string') {
                        jsonResponse.error = {
                            type: jsonResponse.error,
                            message: jsonResponse.error_description,
                        };
                    }
                    jsonResponse.error.headers = headers;
                    jsonResponse.error.statusCode = statusCode;
                    jsonResponse.error.requestId = requestId;
                    if (statusCode === 401) {
                        err = new StripeAuthenticationError(jsonResponse.error);
                    }
                    else if (statusCode === 403) {
                        err = new StripePermissionError(jsonResponse.error);
                    }
                    else if (statusCode === 429) {
                        err = new StripeRateLimitError(jsonResponse.error);
                    }
                    else {
                        err = StripeError.generate(jsonResponse.error);
                    }
                    throw err;
                }
                return jsonResponse;
            }, (e) => {
                throw new StripeAPIError({
                    message: 'Invalid JSON received from the Stripe API',
                    exception: e,
                    requestId: headers['request-id'],
                });
            })
                .then((jsonResponse) => {
                this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);
                // Expose raw response object.
                const rawResponse = res.getRawResponse();
                this._addHeadersDirectlyToObject(rawResponse, headers);
                Object.defineProperty(jsonResponse, 'lastResponse', {
                    enumerable: false,
                    writable: false,
                    value: rawResponse,
                });
                callback(null, jsonResponse);
            }, (e) => callback(e, null));
        };
    }
    static _generateConnectionErrorMessage(requestRetries) {
        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;
    }
    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency
    static _shouldRetry(res, numRetries, maxRetries, error) {
        if (error &&
            numRetries === 0 &&
            HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {
            return true;
        }
        // Do not retry if we are out of retries.
        if (numRetries >= maxRetries) {
            return false;
        }
        // Retry on connection error.
        if (!res) {
            return true;
        }
        // The API may ask us not to retry (e.g., if doing so would be a no-op)
        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.
        if (res.getHeaders()['stripe-should-retry'] === 'false') {
            return false;
        }
        if (res.getHeaders()['stripe-should-retry'] === 'true') {
            return true;
        }
        // Retry on conflict errors.
        if (res.getStatusCode() === 409) {
            return true;
        }
        // Retry on 500, 503, and other internal errors.
        //
        // Note that we expect the stripe-should-retry header to be false
        // in most cases when a 500 is returned, since our idempotency framework
        // would typically replay it anyway.
        if (res.getStatusCode() >= 500) {
            return true;
        }
        return false;
    }
    _getSleepTimeInMS(numRetries, retryAfter = null) {
        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
        // Apply exponential backoff with initialNetworkRetryDelay on the
        // number of numRetries so far as inputs. Do not allow the number to exceed
        // maxNetworkRetryDelay.
        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);
        // Apply some jitter by randomizing the value in the range of
        // (sleepSeconds / 2) to (sleepSeconds).
        sleepSeconds *= 0.5 * (1 + Math.random());
        // But never sleep less than the base sleep seconds.
        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.
        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
            sleepSeconds = Math.max(sleepSeconds, retryAfter);
        }
        return sleepSeconds * 1000;
    }
    // Max retries can be set on a per request basis. Favor those over the global setting
    _getMaxNetworkRetries(settings = {}) {
        return settings.maxNetworkRetries !== undefined &&
            Number.isInteger(settings.maxNetworkRetries)
            ? settings.maxNetworkRetries
            : this._stripe.getMaxNetworkRetries();
    }
    _defaultIdempotencyKey(method, settings) {
        // If this is a POST and we allow multiple retries, ensure an idempotency key.
        const maxRetries = this._getMaxNetworkRetries(settings);
        if (method === 'POST' && maxRetries > 0) {
            return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;
        }
        return null;
    }
    _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {
        const defaultHeaders = {
            // Use specified auth token or use default from this stripe instance:
            Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),
            Accept: 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            'User-Agent': this._getUserAgentString(),
            'X-Stripe-Client-User-Agent': clientUserAgent,
            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),
            'Stripe-Version': apiVersion,
            'Stripe-Account': this._stripe.getApiField('stripeAccount'),
            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings),
        };
        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:
        //   A user agent SHOULD send a Content-Length in a request message when
        //   no Transfer-Encoding is sent and the request method defines a meaning
        //   for an enclosed payload body.  For example, a Content-Length header
        //   field is normally sent in a POST request even when the value is 0
        //   (indicating an empty payload body).  A user agent SHOULD NOT send a
        //   Content-Length header field when the request message does not contain
        //   a payload body and the method semantics do not anticipate such a
        //   body.
        //
        // These method types are expected to have bodies and so we should always
        // include a Content-Length.
        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';
        // If a content length was specified, we always include it regardless of
        // whether the method semantics anticipate such a body. This keeps us
        // consistent with historical behavior. We do however want to warn on this
        // and fix these cases as they are semantically incorrect.
        if (methodHasPayload || contentLength) {
            if (!methodHasPayload) {
                emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);
            }
            defaultHeaders['Content-Length'] = contentLength;
        }
        return Object.assign(removeNullish(defaultHeaders), 
        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.
        normalizeHeaders(userSuppliedHeaders));
    }
    _getUserAgentString() {
        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');
        const appInfo = this._stripe._appInfo
            ? this._stripe.getAppInfoAsString()
            : '';
        return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();
    }
    _getTelemetryHeader() {
        if (this._stripe.getTelemetryEnabled() &&
            this._stripe._prevRequestMetrics.length > 0) {
            const metrics = this._stripe._prevRequestMetrics.shift();
            return JSON.stringify({
                last_request_metrics: metrics,
            });
        }
    }
    _recordRequestMetrics(requestId, requestDurationMs, usage) {
        if (this._stripe.getTelemetryEnabled() && requestId) {
            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
                emitWarning('Request metrics buffer is full, dropping telemetry message.');
            }
            else {
                const m = {
                    request_id: requestId,
                    request_duration_ms: requestDurationMs,
                };
                if (usage && usage.length > 0) {
                    m.usage = usage;
                }
                this._stripe._prevRequestMetrics.push(m);
            }
        }
    }
    _request(method, host, path, data, auth, options = {}, usage = [], callback, requestDataProcessor = null) {
        let requestData;
        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {
            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
        };
        const makeRequest = (apiVersion, headers, numRetries) => {
            // timeout can be set on a per-request basis. Favor that over the global setting
            const timeout = options.settings &&
                options.settings.timeout &&
                Number.isInteger(options.settings.timeout) &&
                options.settings.timeout >= 0
                ? options.settings.timeout
                : this._stripe.getApiField('timeout');
            const req = this._stripe
                .getApiField('httpClient')
                .makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);
            const requestStartTime = Date.now();
            // @ts-ignore
            const requestEvent = removeNullish({
                api_version: apiVersion,
                account: headers['Stripe-Account'],
                idempotency_key: headers['Idempotency-Key'],
                method,
                path,
                request_start_time: requestStartTime,
            });
            const requestRetries = numRetries || 0;
            const maxRetries = this._getMaxNetworkRetries(options.settings || {});
            this._stripe._emitter.emit('request', requestEvent);
            req
                .then((res) => {
                if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, 
                    // @ts-ignore
                    res.getHeaders()['retry-after']);
                }
                else if (options.streaming && res.getStatusCode() < 400) {
                    return this._streamingResponseHandler(requestEvent, usage, callback)(res);
                }
                else {
                    return this._jsonResponseHandler(requestEvent, usage, callback)(res);
                }
            })
                .catch((error) => {
                if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {
                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
                }
                else {
                    const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;
                    return callback(new StripeConnectionError({
                        message: isTimeoutError
                            ? `Request aborted due to timeout being reached (${timeout}ms)`
                            : RequestSender._generateConnectionErrorMessage(requestRetries),
                        // @ts-ignore
                        detail: error,
                    }));
                }
            });
        };
        const prepareAndMakeRequest = (error, data) => {
            if (error) {
                return callback(error);
            }
            requestData = data;
            this._stripe.getClientUserAgent((clientUserAgent) => {
                var _a, _b;
                const apiVersion = this._stripe.getApiField('version');
                const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});
                makeRequest(apiVersion, headers, 0);
            });
        };
        if (requestDataProcessor) {
            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
        }
        else {
            prepareAndMakeRequest(null, stringifyRequestData(data || {}));
        }
    }
}

;// ../../node_modules/stripe/esm/autoPagination.js

class StripeIterator {
    constructor(firstPagePromise, requestArgs, spec, stripeResource) {
        this.index = 0;
        this.pagePromise = firstPagePromise;
        this.promiseCache = { currentPromise: null };
        this.requestArgs = requestArgs;
        this.spec = spec;
        this.stripeResource = stripeResource;
    }
    async iterate(pageResult) {
        if (!(pageResult &&
            pageResult.data &&
            typeof pageResult.data.length === 'number')) {
            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');
        }
        const reverseIteration = isReverseIteration(this.requestArgs);
        if (this.index < pageResult.data.length) {
            const idx = reverseIteration
                ? pageResult.data.length - 1 - this.index
                : this.index;
            const value = pageResult.data[idx];
            this.index += 1;
            return { value, done: false };
        }
        else if (pageResult.has_more) {
            // Reset counter, request next page, and recurse.
            this.index = 0;
            this.pagePromise = this.getNextPage(pageResult);
            const nextPageResult = await this.pagePromise;
            return this.iterate(nextPageResult);
        }
        return { done: true, value: undefined };
    }
    /** @abstract */
    getNextPage(_pageResult) {
        throw new Error('Unimplemented');
    }
    async _next() {
        return this.iterate(await this.pagePromise);
    }
    next() {
        /**
         * If a user calls `.next()` multiple times in parallel,
         * return the same result until something has resolved
         * to prevent page-turning race conditions.
         */
        if (this.promiseCache.currentPromise) {
            return this.promiseCache.currentPromise;
        }
        const nextPromise = (async () => {
            const ret = await this._next();
            this.promiseCache.currentPromise = null;
            return ret;
        })();
        this.promiseCache.currentPromise = nextPromise;
        return nextPromise;
    }
}
class ListIterator extends StripeIterator {
    getNextPage(pageResult) {
        const reverseIteration = isReverseIteration(this.requestArgs);
        const lastId = getLastId(pageResult, reverseIteration);
        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
            [reverseIteration ? 'ending_before' : 'starting_after']: lastId,
        });
    }
}
class SearchIterator extends StripeIterator {
    getNextPage(pageResult) {
        if (!pageResult.next_page) {
            throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');
        }
        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
            page: pageResult.next_page,
        });
    }
}
const makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {
    if (spec.methodType === 'search') {
        return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));
    }
    if (spec.methodType === 'list') {
        return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
    }
    return null;
};
const makeAutoPaginationMethodsFromIterator = (iterator) => {
    const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));
    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
    const autoPaginationMethods = {
        autoPagingEach,
        autoPagingToArray,
        // Async iterator functions:
        next: () => iterator.next(),
        return: () => {
            // This is required for `break`.
            return {};
        },
        [getAsyncIteratorSymbol()]: () => {
            return autoPaginationMethods;
        },
    };
    return autoPaginationMethods;
};
/**
 * ----------------
 * Private Helpers:
 * ----------------
 */
function getAsyncIteratorSymbol() {
    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {
        return Symbol.asyncIterator;
    }
    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1
    return '@@asyncIterator';
}
function getDoneCallback(args) {
    if (args.length < 2) {
        return null;
    }
    const onDone = args[1];
    if (typeof onDone !== 'function') {
        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);
    }
    return onDone;
}
/**
 * We allow four forms of the `onItem` callback (the middle two being equivalent),
 *
 *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`
 *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`
 *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`
 *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`
 *
 * In addition to standard validation, this helper
 * coalesces the former forms into the latter form.
 */
function getItemCallback(args) {
    if (args.length === 0) {
        return undefined;
    }
    const onItem = args[0];
    if (typeof onItem !== 'function') {
        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);
    }
    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`
    if (onItem.length === 2) {
        return onItem;
    }
    if (onItem.length > 2) {
        throw Error(`The \`onItem\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);
    }
    // This magically handles all three of these usecases (the latter two being functionally identical):
    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`
    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`
    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`
    return function _onItem(item, next) {
        const shouldContinue = onItem(item);
        next(shouldContinue);
    };
}
function getLastId(listResult, reverseIteration) {
    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
    const lastItem = listResult.data[lastIdx];
    const lastId = lastItem && lastItem.id;
    if (!lastId) {
        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');
    }
    return lastId;
}
function makeAutoPagingEach(asyncIteratorNext) {
    return function autoPagingEach( /* onItem?, onDone? */) {
        const args = [].slice.call(arguments);
        const onItem = getItemCallback(args);
        const onDone = getDoneCallback(args);
        if (args.length > 2) {
            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);
        }
        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, 
        // @ts-ignore we might need a null check
        onItem);
        return callbackifyPromiseWithTimeout(autoPagePromise, onDone);
    };
}
function makeAutoPagingToArray(autoPagingEach) {
    return function autoPagingToArray(opts, onDone) {
        const limit = opts && opts.limit;
        if (!limit) {
            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');
        }
        if (limit > 10000) {
            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');
        }
        const promise = new Promise((resolve, reject) => {
            const items = [];
            autoPagingEach((item) => {
                items.push(item);
                if (items.length >= limit) {
                    return false;
                }
            })
                .then(() => {
                resolve(items);
            })
                .catch(reject);
        });
        // @ts-ignore
        return callbackifyPromiseWithTimeout(promise, onDone);
    };
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
    return new Promise((resolve, reject) => {
        function handleIteration(iterResult) {
            if (iterResult.done) {
                resolve();
                return;
            }
            const item = iterResult.value;
            return new Promise((next) => {
                // Bit confusing, perhaps; we pass a `resolve` fn
                // to the user, so they can decide when and if to continue.
                // They can return false, or a promise which resolves to false, to break.
                onItem(item, next);
            }).then((shouldContinue) => {
                if (shouldContinue === false) {
                    return handleIteration({ done: true, value: undefined });
                }
                else {
                    return asyncIteratorNext().then(handleIteration);
                }
            });
        }
        asyncIteratorNext()
            .then(handleIteration)
            .catch(reject);
    });
}
function isReverseIteration(requestArgs) {
    const args = [].slice.call(requestArgs);
    const dataFromArgs = getDataFromArgs(args);
    return !!dataFromArgs.ending_before;
}

;// ../../node_modules/stripe/esm/StripeMethod.js


/**
 * Create an API method from the declared spec.
 *
 * @param [spec.method='GET'] Request Method (POST, GET, DELETE, PUT)
 * @param [spec.path=''] Path to be appended to the API BASE_PATH, joined with
 *  the instance's path (e.g. 'charges' or 'customers')
 * @param [spec.fullPath=''] Fully qualified path to the method (eg. /v1/a/b/c).
 *  If this is specified, path should not be specified.
 * @param [spec.urlParams=[]] Array of required arguments in the order that they
 *  must be passed by the consumer of the API. Subsequent optional arguments are
 *  optionally passed through a hash (Object) as the penultimate argument
 *  (preceding the also-optional callback argument
 * @param [spec.encode] Function for mutating input parameters to a method.
 *  Usefully for applying transforms to data on a per-method basis.
 * @param [spec.host] Hostname for the request.
 *
 * <!-- Public API accessible via Stripe.StripeResource.method -->
 */
function stripeMethod(spec) {
    if (spec.path !== undefined && spec.fullPath !== undefined) {
        throw new Error(`Method spec specified both a 'path' (${spec.path}) and a 'fullPath' (${spec.fullPath}).`);
    }
    return function (...args) {
        const callback = typeof args[args.length - 1] == 'function' && args.pop();
        spec.urlParams = extractUrlParams(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ''));
        const requestPromise = callbackifyPromiseWithTimeout(this._makeRequest(args, spec, {}), callback);
        Object.assign(requestPromise, makeAutoPaginationMethods(this, args, spec, requestPromise));
        return requestPromise;
    };
}

;// ../../node_modules/stripe/esm/StripeResource.js


// Provide extension mechanism for Stripe Resource Sub-Classes
StripeResource.extend = protoExtend;
// Expose method-creator
StripeResource.method = stripeMethod;
StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
/**
 * Encapsulates request logic for a Stripe Resource
 */
function StripeResource(stripe, deprecatedUrlData) {
    this._stripe = stripe;
    if (deprecatedUrlData) {
        throw new Error('Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.');
    }
    this.basePath = makeURLInterpolator(
    // @ts-ignore changing type of basePath
    this.basePath || stripe.getApiField('basePath'));
    // @ts-ignore changing type of path
    this.resourcePath = this.path;
    // @ts-ignore changing type of path
    this.path = makeURLInterpolator(this.path);
    this.initialize(...arguments);
}
StripeResource.prototype = {
    _stripe: null,
    // @ts-ignore the type of path changes in ctor
    path: '',
    resourcePath: '',
    // Methods that don't use the API's default '/v1' path can override it with this setting.
    basePath: null,
    initialize() { },
    // Function to override the default data processor. This allows full control
    // over how a StripeResource's request data will get converted into an HTTP
    // body. This is useful for non-standard HTTP requests. The function should
    // take method name, data, and headers as arguments.
    requestDataProcessor: null,
    // Function to add a validation checks before sending the request, errors should
    // be thrown, and they will be passed to the callback/promise.
    validateRequest: null,
    createFullPath(commandPath, urlData) {
        const urlParts = [this.basePath(urlData), this.path(urlData)];
        if (typeof commandPath === 'function') {
            const computedCommandPath = commandPath(urlData);
            // If we have no actual command path, we just omit it to avoid adding a
            // trailing slash. This is important for top-level listing requests, which
            // do not have a command path.
            if (computedCommandPath) {
                urlParts.push(computedCommandPath);
            }
        }
        else {
            urlParts.push(commandPath);
        }
        return this._joinUrlParts(urlParts);
    },
    // Creates a relative resource path with symbols left in (unlike
    // createFullPath which takes some data to replace them with). For example it
    // might produce: /invoices/{id}
    createResourcePathWithSymbols(pathWithSymbols) {
        // If there is no path beyond the resource path, we want to produce just
        // /<resource path> rather than /<resource path>/.
        if (pathWithSymbols) {
            return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;
        }
        else {
            return `/${this.resourcePath}`;
        }
    },
    _joinUrlParts(parts) {
        // Replace any accidentally doubled up slashes. This previously used
        // path.join, which would do this as well. Unfortunately we need to do this
        // as the functions for creating paths are technically part of the public
        // interface and so we need to preserve backwards compatibility.
        return parts.join('/').replace(/\/{2,}/g, '/');
    },
    _getRequestOpts(requestArgs, spec, overrideData) {
        // Extract spec values with defaults.
        const requestMethod = (spec.method || 'GET').toUpperCase();
        const usage = spec.usage || [];
        const urlParams = spec.urlParams || [];
        const encode = spec.encode || ((data) => data);
        const isUsingFullPath = !!spec.fullPath;
        const commandPath = makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || '');
        // When using fullPath, we ignore the resource path as it should already be
        // fully qualified.
        const path = isUsingFullPath
            ? spec.fullPath
            : this.createResourcePathWithSymbols(spec.path);
        // Don't mutate args externally.
        const args = [].slice.call(requestArgs);
        // Generate and validate url params.
        const urlData = urlParams.reduce((urlData, param) => {
            const arg = args.shift();
            if (typeof arg !== 'string') {
                throw new Error(`Stripe: Argument "${param}" must be a string, but got: ${arg} (on API request to \`${requestMethod} ${path}\`)`);
            }
            urlData[param] = arg;
            return urlData;
        }, {});
        // Pull request data and options (headers, auth) from args.
        const dataFromArgs = getDataFromArgs(args);
        const data = encode(Object.assign({}, dataFromArgs, overrideData));
        const options = getOptionsFromArgs(args);
        const host = options.host || spec.host;
        const streaming = !!spec.streaming;
        // Validate that there are no more args.
        if (args.filter((x) => x != null).length) {
            throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \`${path}\`)`);
        }
        // When using full path, we can just invoke the URL interpolator directly
        // as we don't need to use the resource to create a full path.
        const requestPath = isUsingFullPath
            ? commandPath(urlData)
            : this.createFullPath(commandPath, urlData);
        const headers = Object.assign(options.headers, spec.headers);
        if (spec.validator) {
            spec.validator(data, { headers });
        }
        const dataInQuery = spec.method === 'GET' || spec.method === 'DELETE';
        const bodyData = dataInQuery ? {} : data;
        const queryData = dataInQuery ? data : {};
        return {
            requestMethod,
            requestPath,
            bodyData,
            queryData,
            auth: options.auth,
            headers,
            host: host !== null && host !== void 0 ? host : null,
            streaming,
            settings: options.settings,
            usage,
        };
    },
    _makeRequest(requestArgs, spec, overrideData) {
        return new Promise((resolve, reject) => {
            var _a;
            let opts;
            try {
                opts = this._getRequestOpts(requestArgs, spec, overrideData);
            }
            catch (err) {
                reject(err);
                return;
            }
            function requestCallback(err, response) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(spec.transformResponseData
                        ? spec.transformResponseData(response)
                        : response);
                }
            }
            const emptyQuery = Object.keys(opts.queryData).length === 0;
            const path = [
                opts.requestPath,
                emptyQuery ? '' : '?',
                stringifyRequestData(opts.queryData),
            ].join('');
            const { headers, settings } = opts;
            this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.auth, { headers, settings, streaming: opts.streaming }, opts.usage, requestCallback, (_a = this.requestDataProcessor) === null || _a === void 0 ? void 0 : _a.bind(this));
        });
    },
};


;// ../../node_modules/stripe/esm/Webhooks.js


function createWebhooks(platformFunctions) {
    const Webhook = {
        DEFAULT_TOLERANCE: 300,
        // @ts-ignore
        signature: null,
        constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
            try {
                this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
            }
            catch (e) {
                if (e instanceof CryptoProviderOnlySupportsAsyncError) {
                    e.message +=
                        '\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`';
                }
                throw e;
            }
            const jsonPayload = payload instanceof Uint8Array
                ? JSON.parse(new TextDecoder('utf8').decode(payload))
                : JSON.parse(payload);
            return jsonPayload;
        },
        async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
            await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
            const jsonPayload = payload instanceof Uint8Array
                ? JSON.parse(new TextDecoder('utf8').decode(payload))
                : JSON.parse(payload);
            return jsonPayload;
        },
        /**
         * Generates a header to be used for webhook mocking
         *
         * @typedef {object} opts
         * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()
         * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters
         * @property {string} secret - Stripe webhook secret 'whsec_...'
         * @property {string} scheme - Version of API to hit. Defaults to 'v1'.
         * @property {string} signature - Computed webhook signature
         * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.
         */
        generateTestHeaderString: function (opts) {
            const preparedOpts = prepareOptions(opts);
            const signature = preparedOpts.signature ||
                preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);
            return preparedOpts.generateHeaderString(signature);
        },
        generateTestHeaderStringAsync: async function (opts) {
            const preparedOpts = prepareOptions(opts);
            const signature = preparedOpts.signature ||
                (await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret));
            return preparedOpts.generateHeaderString(signature);
        },
    };
    const signature = {
        EXPECTED_SCHEME: 'v1',
        verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
            const secretContainsWhitespace = /\s/.test(secret);
            cryptoProvider = cryptoProvider || getCryptoProvider();
            const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
            validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
            return true;
        },
        async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
            const secretContainsWhitespace = /\s/.test(secret);
            cryptoProvider = cryptoProvider || getCryptoProvider();
            const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);
            return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
        },
    };
    function makeHMACContent(payload, details) {
        return `${details.timestamp}.${payload}`;
    }
    function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
        if (!encodedPayload) {
            throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
                message: 'No webhook payload was provided.',
            });
        }
        const suspectPayloadType = typeof encodedPayload != 'string' &&
            !(encodedPayload instanceof Uint8Array);
        const textDecoder = new TextDecoder('utf8');
        const decodedPayload = encodedPayload instanceof Uint8Array
            ? textDecoder.decode(encodedPayload)
            : encodedPayload;
        // Express's type for `Request#headers` is `string | []string`
        // which is because the `set-cookie` header is an array,
        // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)
        // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)
        if (Array.isArray(encodedHeader)) {
            throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');
        }
        if (encodedHeader == null || encodedHeader == '') {
            throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
                message: 'No stripe-signature header value was provided.',
            });
        }
        const decodedHeader = encodedHeader instanceof Uint8Array
            ? textDecoder.decode(encodedHeader)
            : encodedHeader;
        const details = parseHeader(decodedHeader, expectedScheme);
        if (!details || details.timestamp === -1) {
            throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
                message: 'Unable to extract timestamp and signatures from header',
            });
        }
        if (!details.signatures.length) {
            throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
                message: 'No signatures found with expected scheme',
            });
        }
        return {
            decodedPayload,
            decodedHeader,
            details,
            suspectPayloadType,
        };
    }
    function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {
        const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
        const docsLocation = '\nLearn more about webhook signing and explore webhook integration examples for various frameworks at ' +
            'https://github.com/stripe/stripe-node#webhook-signing';
        const whitespaceMessage = secretContainsWhitespace
            ? '\n\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value'
            : '';
        if (!signatureFound) {
            if (suspectPayloadType) {
                throw new StripeSignatureVerificationError(header, payload, {
                    message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' +
                        'Payload was provided as a parsed JavaScript object instead. \n' +
                        'Signature verification is impossible without access to the original signed material. \n' +
                        docsLocation +
                        '\n' +
                        whitespaceMessage,
                });
            }
            throw new StripeSignatureVerificationError(header, payload, {
                message: 'No signatures found matching the expected signature for payload.' +
                    ' Are you passing the raw request body you received from Stripe? \n' +
                    ' If a webhook request is being forwarded by a third-party tool,' +
                    ' ensure that the exact request body, including JSON formatting and new line style, is preserved.\n' +
                    docsLocation +
                    '\n' +
                    whitespaceMessage,
            });
        }
        const timestampAge = Math.floor((typeof receivedAt === 'number' ? receivedAt : Date.now()) / 1000) - details.timestamp;
        if (tolerance > 0 && timestampAge > tolerance) {
            // @ts-ignore
            throw new StripeSignatureVerificationError(header, payload, {
                message: 'Timestamp outside the tolerance zone',
            });
        }
        return true;
    }
    function parseHeader(header, scheme) {
        if (typeof header !== 'string') {
            return null;
        }
        return header.split(',').reduce((accum, item) => {
            const kv = item.split('=');
            if (kv[0] === 't') {
                accum.timestamp = parseInt(kv[1], 10);
            }
            if (kv[0] === scheme) {
                accum.signatures.push(kv[1]);
            }
            return accum;
        }, {
            timestamp: -1,
            signatures: [],
        });
    }
    let webhooksCryptoProviderInstance = null;
    /**
     * Lazily instantiate a CryptoProvider instance. This is a stateless object
     * so a singleton can be used here.
     */
    function getCryptoProvider() {
        if (!webhooksCryptoProviderInstance) {
            webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
        }
        return webhooksCryptoProviderInstance;
    }
    function prepareOptions(opts) {
        if (!opts) {
            throw new StripeError({
                message: 'Options are required',
            });
        }
        const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);
        const scheme = opts.scheme || signature.EXPECTED_SCHEME;
        const cryptoProvider = opts.cryptoProvider || getCryptoProvider();
        const payloadString = `${timestamp}.${opts.payload}`;
        const generateHeaderString = (signature) => {
            return `t=${timestamp},${scheme}=${signature}`;
        };
        return Object.assign(Object.assign({}, opts), { timestamp,
            scheme,
            cryptoProvider,
            payloadString,
            generateHeaderString });
    }
    Webhook.signature = signature;
    return Webhook;
}

;// ../../node_modules/stripe/esm/apiVersion.js
// File generated from our OpenAPI spec
const ApiVersion = '2024-06-20';

;// ../../node_modules/stripe/esm/ResourceNamespace.js
// ResourceNamespace allows you to create nested resources, i.e. `stripe.issuing.cards`.
// It also works recursively, so you could do i.e. `stripe.billing.invoicing.pay`.
function ResourceNamespace(stripe, resources) {
    for (const name in resources) {
        if (!Object.prototype.hasOwnProperty.call(resources, name)) {
            continue;
        }
        const camelCaseName = name[0].toLowerCase() + name.substring(1);
        const resource = new resources[name](stripe);
        this[camelCaseName] = resource;
    }
}
function resourceNamespace(namespace, resources) {
    return function (stripe) {
        return new ResourceNamespace(stripe, resources);
    };
}

;// ../../node_modules/stripe/esm/resources/FinancialConnections/Accounts.js
// File generated from our OpenAPI spec

const Accounts_stripeMethod = StripeResource.method;
const Accounts = StripeResource.extend({
    retrieve: Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts/{account}',
    }),
    list: Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts',
        methodType: 'list',
    }),
    disconnect: Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/disconnect',
    }),
    listOwners: Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/accounts/{account}/owners',
        methodType: 'list',
    }),
    refresh: Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/refresh',
    }),
    subscribe: Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/subscribe',
    }),
    unsubscribe: Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/accounts/{account}/unsubscribe',
    }),
});

;// ../../node_modules/stripe/esm/resources/Entitlements/ActiveEntitlements.js
// File generated from our OpenAPI spec

const ActiveEntitlements_stripeMethod = StripeResource.method;
const ActiveEntitlements = StripeResource.extend({
    retrieve: ActiveEntitlements_stripeMethod({
        method: 'GET',
        fullPath: '/v1/entitlements/active_entitlements/{id}',
    }),
    list: ActiveEntitlements_stripeMethod({
        method: 'GET',
        fullPath: '/v1/entitlements/active_entitlements',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Billing/Alerts.js
// File generated from our OpenAPI spec

const Alerts_stripeMethod = StripeResource.method;
const Alerts = StripeResource.extend({
    create: Alerts_stripeMethod({ method: 'POST', fullPath: '/v1/billing/alerts' }),
    retrieve: Alerts_stripeMethod({ method: 'GET', fullPath: '/v1/billing/alerts/{id}' }),
    list: Alerts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing/alerts',
        methodType: 'list',
    }),
    activate: Alerts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/alerts/{id}/activate',
    }),
    archive: Alerts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/alerts/{id}/archive',
    }),
    deactivate: Alerts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/alerts/{id}/deactivate',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Issuing/Authorizations.js
// File generated from our OpenAPI spec

const Authorizations_stripeMethod = StripeResource.method;
const Authorizations = StripeResource.extend({
    create: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations',
    }),
    capture: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations/{authorization}/capture',
    }),
    expire: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations/{authorization}/expire',
    }),
    finalizeAmount: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations/{authorization}/finalize_amount',
    }),
    increment: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations/{authorization}/increment',
    }),
    reverse: Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/authorizations/{authorization}/reverse',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Authorizations.js
// File generated from our OpenAPI spec

const Issuing_Authorizations_stripeMethod = StripeResource.method;
const Authorizations_Authorizations = StripeResource.extend({
    retrieve: Issuing_Authorizations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/authorizations/{authorization}',
    }),
    update: Issuing_Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}',
    }),
    list: Issuing_Authorizations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/authorizations',
        methodType: 'list',
    }),
    approve: Issuing_Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}/approve',
    }),
    decline: Issuing_Authorizations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/authorizations/{authorization}/decline',
    }),
});

;// ../../node_modules/stripe/esm/resources/Tax/Calculations.js
// File generated from our OpenAPI spec

const Calculations_stripeMethod = StripeResource.method;
const Calculations = StripeResource.extend({
    create: Calculations_stripeMethod({ method: 'POST', fullPath: '/v1/tax/calculations' }),
    retrieve: Calculations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/calculations/{calculation}',
    }),
    listLineItems: Calculations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/calculations/{calculation}/line_items',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Cardholders.js
// File generated from our OpenAPI spec

const Cardholders_stripeMethod = StripeResource.method;
const Cardholders = StripeResource.extend({
    create: Cardholders_stripeMethod({ method: 'POST', fullPath: '/v1/issuing/cardholders' }),
    retrieve: Cardholders_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cardholders/{cardholder}',
    }),
    update: Cardholders_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/cardholders/{cardholder}',
    }),
    list: Cardholders_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cardholders',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Issuing/Cards.js
// File generated from our OpenAPI spec

const Cards_stripeMethod = StripeResource.method;
const Cards = StripeResource.extend({
    deliverCard: Cards_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/deliver',
    }),
    failCard: Cards_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/fail',
    }),
    returnCard: Cards_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/return',
    }),
    shipCard: Cards_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/cards/{card}/shipping/ship',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Cards.js
// File generated from our OpenAPI spec

const Issuing_Cards_stripeMethod = StripeResource.method;
const Cards_Cards = StripeResource.extend({
    create: Issuing_Cards_stripeMethod({ method: 'POST', fullPath: '/v1/issuing/cards' }),
    retrieve: Issuing_Cards_stripeMethod({ method: 'GET', fullPath: '/v1/issuing/cards/{card}' }),
    update: Issuing_Cards_stripeMethod({ method: 'POST', fullPath: '/v1/issuing/cards/{card}' }),
    list: Issuing_Cards_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/cards',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/BillingPortal/Configurations.js
// File generated from our OpenAPI spec

const Configurations_stripeMethod = StripeResource.method;
const Configurations = StripeResource.extend({
    create: Configurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/configurations',
    }),
    retrieve: Configurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing_portal/configurations/{configuration}',
    }),
    update: Configurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/configurations/{configuration}',
    }),
    list: Configurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing_portal/configurations',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Terminal/Configurations.js
// File generated from our OpenAPI spec

const Terminal_Configurations_stripeMethod = StripeResource.method;
const Configurations_Configurations = StripeResource.extend({
    create: Terminal_Configurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/configurations',
    }),
    retrieve: Terminal_Configurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/configurations/{configuration}',
    }),
    update: Terminal_Configurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/configurations/{configuration}',
    }),
    list: Terminal_Configurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/configurations',
        methodType: 'list',
    }),
    del: Terminal_Configurations_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/configurations/{configuration}',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/ConfirmationTokens.js
// File generated from our OpenAPI spec

const ConfirmationTokens_stripeMethod = StripeResource.method;
const ConfirmationTokens = StripeResource.extend({
    create: ConfirmationTokens_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/confirmation_tokens',
    }),
});

;// ../../node_modules/stripe/esm/resources/Terminal/ConnectionTokens.js
// File generated from our OpenAPI spec

const ConnectionTokens_stripeMethod = StripeResource.method;
const ConnectionTokens = StripeResource.extend({
    create: ConnectionTokens_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/connection_tokens',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/CreditReversals.js
// File generated from our OpenAPI spec

const CreditReversals_stripeMethod = StripeResource.method;
const CreditReversals = StripeResource.extend({
    create: CreditReversals_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/credit_reversals',
    }),
    retrieve: CreditReversals_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/credit_reversals/{credit_reversal}',
    }),
    list: CreditReversals_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/credit_reversals',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Customers.js
// File generated from our OpenAPI spec

const Customers_stripeMethod = StripeResource.method;
const Customers = StripeResource.extend({
    fundCashBalance: Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/customers/{customer}/fund_cash_balance',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/DebitReversals.js
// File generated from our OpenAPI spec

const DebitReversals_stripeMethod = StripeResource.method;
const DebitReversals = StripeResource.extend({
    create: DebitReversals_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/debit_reversals',
    }),
    retrieve: DebitReversals_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/debit_reversals/{debit_reversal}',
    }),
    list: DebitReversals_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/debit_reversals',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Disputes.js
// File generated from our OpenAPI spec

const Disputes_stripeMethod = StripeResource.method;
const Disputes = StripeResource.extend({
    create: Disputes_stripeMethod({ method: 'POST', fullPath: '/v1/issuing/disputes' }),
    retrieve: Disputes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/disputes/{dispute}',
    }),
    update: Disputes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/disputes/{dispute}',
    }),
    list: Disputes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/disputes',
        methodType: 'list',
    }),
    submit: Disputes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/disputes/{dispute}/submit',
    }),
});

;// ../../node_modules/stripe/esm/resources/Radar/EarlyFraudWarnings.js
// File generated from our OpenAPI spec

const EarlyFraudWarnings_stripeMethod = StripeResource.method;
const EarlyFraudWarnings = StripeResource.extend({
    retrieve: EarlyFraudWarnings_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/early_fraud_warnings/{early_fraud_warning}',
    }),
    list: EarlyFraudWarnings_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/early_fraud_warnings',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Entitlements/Features.js
// File generated from our OpenAPI spec

const Features_stripeMethod = StripeResource.method;
const Features = StripeResource.extend({
    create: Features_stripeMethod({ method: 'POST', fullPath: '/v1/entitlements/features' }),
    retrieve: Features_stripeMethod({
        method: 'GET',
        fullPath: '/v1/entitlements/features/{id}',
    }),
    update: Features_stripeMethod({
        method: 'POST',
        fullPath: '/v1/entitlements/features/{id}',
    }),
    list: Features_stripeMethod({
        method: 'GET',
        fullPath: '/v1/entitlements/features',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/FinancialAccounts.js
// File generated from our OpenAPI spec

const FinancialAccounts_stripeMethod = StripeResource.method;
const FinancialAccounts = StripeResource.extend({
    create: FinancialAccounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts',
    }),
    retrieve: FinancialAccounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}',
    }),
    update: FinancialAccounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}',
    }),
    list: FinancialAccounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts',
        methodType: 'list',
    }),
    retrieveFeatures: FinancialAccounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}/features',
    }),
    updateFeatures: FinancialAccounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/financial_accounts/{financial_account}/features',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Treasury/InboundTransfers.js
// File generated from our OpenAPI spec

const InboundTransfers_stripeMethod = StripeResource.method;
const InboundTransfers = StripeResource.extend({
    fail: InboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/fail',
    }),
    returnInboundTransfer: InboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/return',
    }),
    succeed: InboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/inbound_transfers/{id}/succeed',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/InboundTransfers.js
// File generated from our OpenAPI spec

const Treasury_InboundTransfers_stripeMethod = StripeResource.method;
const InboundTransfers_InboundTransfers = StripeResource.extend({
    create: Treasury_InboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/inbound_transfers',
    }),
    retrieve: Treasury_InboundTransfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/inbound_transfers/{id}',
    }),
    list: Treasury_InboundTransfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/inbound_transfers',
        methodType: 'list',
    }),
    cancel: Treasury_InboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/inbound_transfers/{inbound_transfer}/cancel',
    }),
});

;// ../../node_modules/stripe/esm/resources/Terminal/Locations.js
// File generated from our OpenAPI spec

const Locations_stripeMethod = StripeResource.method;
const Locations = StripeResource.extend({
    create: Locations_stripeMethod({ method: 'POST', fullPath: '/v1/terminal/locations' }),
    retrieve: Locations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/locations/{location}',
    }),
    update: Locations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/locations/{location}',
    }),
    list: Locations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/locations',
        methodType: 'list',
    }),
    del: Locations_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/locations/{location}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Billing/MeterEventAdjustments.js
// File generated from our OpenAPI spec

const MeterEventAdjustments_stripeMethod = StripeResource.method;
const MeterEventAdjustments = StripeResource.extend({
    create: MeterEventAdjustments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/meter_event_adjustments',
    }),
});

;// ../../node_modules/stripe/esm/resources/Billing/MeterEvents.js
// File generated from our OpenAPI spec

const MeterEvents_stripeMethod = StripeResource.method;
const MeterEvents = StripeResource.extend({
    create: MeterEvents_stripeMethod({ method: 'POST', fullPath: '/v1/billing/meter_events' }),
});

;// ../../node_modules/stripe/esm/resources/Billing/Meters.js
// File generated from our OpenAPI spec

const Meters_stripeMethod = StripeResource.method;
const Meters = StripeResource.extend({
    create: Meters_stripeMethod({ method: 'POST', fullPath: '/v1/billing/meters' }),
    retrieve: Meters_stripeMethod({ method: 'GET', fullPath: '/v1/billing/meters/{id}' }),
    update: Meters_stripeMethod({ method: 'POST', fullPath: '/v1/billing/meters/{id}' }),
    list: Meters_stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing/meters',
        methodType: 'list',
    }),
    deactivate: Meters_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/meters/{id}/deactivate',
    }),
    listEventSummaries: Meters_stripeMethod({
        method: 'GET',
        fullPath: '/v1/billing/meters/{id}/event_summaries',
        methodType: 'list',
    }),
    reactivate: Meters_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing/meters/{id}/reactivate',
    }),
});

;// ../../node_modules/stripe/esm/resources/Climate/Orders.js
// File generated from our OpenAPI spec

const Orders_stripeMethod = StripeResource.method;
const Orders = StripeResource.extend({
    create: Orders_stripeMethod({ method: 'POST', fullPath: '/v1/climate/orders' }),
    retrieve: Orders_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/orders/{order}',
    }),
    update: Orders_stripeMethod({
        method: 'POST',
        fullPath: '/v1/climate/orders/{order}',
    }),
    list: Orders_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/orders',
        methodType: 'list',
    }),
    cancel: Orders_stripeMethod({
        method: 'POST',
        fullPath: '/v1/climate/orders/{order}/cancel',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundPayments.js
// File generated from our OpenAPI spec

const OutboundPayments_stripeMethod = StripeResource.method;
const OutboundPayments = StripeResource.extend({
    update: OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}',
    }),
    fail: OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/fail',
    }),
    post: OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/post',
    }),
    returnOutboundPayment: OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_payments/{id}/return',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/OutboundPayments.js
// File generated from our OpenAPI spec

const Treasury_OutboundPayments_stripeMethod = StripeResource.method;
const OutboundPayments_OutboundPayments = StripeResource.extend({
    create: Treasury_OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_payments',
    }),
    retrieve: Treasury_OutboundPayments_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_payments/{id}',
    }),
    list: Treasury_OutboundPayments_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_payments',
        methodType: 'list',
    }),
    cancel: Treasury_OutboundPayments_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_payments/{id}/cancel',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Treasury/OutboundTransfers.js
// File generated from our OpenAPI spec

const OutboundTransfers_stripeMethod = StripeResource.method;
const OutboundTransfers = StripeResource.extend({
    update: OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}',
    }),
    fail: OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail',
    }),
    post: OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post',
    }),
    returnOutboundTransfer: OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/OutboundTransfers.js
// File generated from our OpenAPI spec

const Treasury_OutboundTransfers_stripeMethod = StripeResource.method;
const OutboundTransfers_OutboundTransfers = StripeResource.extend({
    create: Treasury_OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_transfers',
    }),
    retrieve: Treasury_OutboundTransfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_transfers/{outbound_transfer}',
    }),
    list: Treasury_OutboundTransfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/outbound_transfers',
        methodType: 'list',
    }),
    cancel: Treasury_OutboundTransfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/treasury/outbound_transfers/{outbound_transfer}/cancel',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Issuing/PersonalizationDesigns.js
// File generated from our OpenAPI spec

const PersonalizationDesigns_stripeMethod = StripeResource.method;
const PersonalizationDesigns = StripeResource.extend({
    activate: PersonalizationDesigns_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/personalization_designs/{personalization_design}/activate',
    }),
    deactivate: PersonalizationDesigns_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/personalization_designs/{personalization_design}/deactivate',
    }),
    reject: PersonalizationDesigns_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/personalization_designs/{personalization_design}/reject',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/PersonalizationDesigns.js
// File generated from our OpenAPI spec

const Issuing_PersonalizationDesigns_stripeMethod = StripeResource.method;
const PersonalizationDesigns_PersonalizationDesigns = StripeResource.extend({
    create: Issuing_PersonalizationDesigns_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/personalization_designs',
    }),
    retrieve: Issuing_PersonalizationDesigns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/personalization_designs/{personalization_design}',
    }),
    update: Issuing_PersonalizationDesigns_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/personalization_designs/{personalization_design}',
    }),
    list: Issuing_PersonalizationDesigns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/personalization_designs',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/PhysicalBundles.js
// File generated from our OpenAPI spec

const PhysicalBundles_stripeMethod = StripeResource.method;
const PhysicalBundles = StripeResource.extend({
    retrieve: PhysicalBundles_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/physical_bundles/{physical_bundle}',
    }),
    list: PhysicalBundles_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/physical_bundles',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Climate/Products.js
// File generated from our OpenAPI spec

const Products_stripeMethod = StripeResource.method;
const Products = StripeResource.extend({
    retrieve: Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/products/{product}',
    }),
    list: Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/products',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Terminal/Readers.js
// File generated from our OpenAPI spec

const Readers_stripeMethod = StripeResource.method;
const Readers = StripeResource.extend({
    presentPaymentMethod: Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/terminal/readers/{reader}/present_payment_method',
    }),
});

;// ../../node_modules/stripe/esm/resources/Terminal/Readers.js
// File generated from our OpenAPI spec

const Terminal_Readers_stripeMethod = StripeResource.method;
const Readers_Readers = StripeResource.extend({
    create: Terminal_Readers_stripeMethod({ method: 'POST', fullPath: '/v1/terminal/readers' }),
    retrieve: Terminal_Readers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/readers/{reader}',
    }),
    update: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}',
    }),
    list: Terminal_Readers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/terminal/readers',
        methodType: 'list',
    }),
    del: Terminal_Readers_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/terminal/readers/{reader}',
    }),
    cancelAction: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/cancel_action',
    }),
    processPaymentIntent: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/process_payment_intent',
    }),
    processSetupIntent: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/process_setup_intent',
    }),
    refundPayment: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/refund_payment',
    }),
    setReaderDisplay: Terminal_Readers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/terminal/readers/{reader}/set_reader_display',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedCredits.js
// File generated from our OpenAPI spec

const ReceivedCredits_stripeMethod = StripeResource.method;
const ReceivedCredits = StripeResource.extend({
    create: ReceivedCredits_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/received_credits',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/ReceivedCredits.js
// File generated from our OpenAPI spec

const Treasury_ReceivedCredits_stripeMethod = StripeResource.method;
const ReceivedCredits_ReceivedCredits = StripeResource.extend({
    retrieve: Treasury_ReceivedCredits_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_credits/{id}',
    }),
    list: Treasury_ReceivedCredits_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_credits',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Treasury/ReceivedDebits.js
// File generated from our OpenAPI spec

const ReceivedDebits_stripeMethod = StripeResource.method;
const ReceivedDebits = StripeResource.extend({
    create: ReceivedDebits_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/treasury/received_debits',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/ReceivedDebits.js
// File generated from our OpenAPI spec

const Treasury_ReceivedDebits_stripeMethod = StripeResource.method;
const ReceivedDebits_ReceivedDebits = StripeResource.extend({
    retrieve: Treasury_ReceivedDebits_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_debits/{id}',
    }),
    list: Treasury_ReceivedDebits_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/received_debits',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Refunds.js
// File generated from our OpenAPI spec

const Refunds_stripeMethod = StripeResource.method;
const Refunds = StripeResource.extend({
    expire: Refunds_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/refunds/{refund}/expire',
    }),
});

;// ../../node_modules/stripe/esm/resources/Tax/Registrations.js
// File generated from our OpenAPI spec

const Registrations_stripeMethod = StripeResource.method;
const Registrations = StripeResource.extend({
    create: Registrations_stripeMethod({ method: 'POST', fullPath: '/v1/tax/registrations' }),
    retrieve: Registrations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/registrations/{id}',
    }),
    update: Registrations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/tax/registrations/{id}',
    }),
    list: Registrations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/registrations',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Reporting/ReportRuns.js
// File generated from our OpenAPI spec

const ReportRuns_stripeMethod = StripeResource.method;
const ReportRuns = StripeResource.extend({
    create: ReportRuns_stripeMethod({ method: 'POST', fullPath: '/v1/reporting/report_runs' }),
    retrieve: ReportRuns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_runs/{report_run}',
    }),
    list: ReportRuns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_runs',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Reporting/ReportTypes.js
// File generated from our OpenAPI spec

const ReportTypes_stripeMethod = StripeResource.method;
const ReportTypes = StripeResource.extend({
    retrieve: ReportTypes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_types/{report_type}',
    }),
    list: ReportTypes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/reporting/report_types',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Forwarding/Requests.js
// File generated from our OpenAPI spec

const Requests_stripeMethod = StripeResource.method;
const Requests = StripeResource.extend({
    create: Requests_stripeMethod({ method: 'POST', fullPath: '/v1/forwarding/requests' }),
    retrieve: Requests_stripeMethod({
        method: 'GET',
        fullPath: '/v1/forwarding/requests/{id}',
    }),
    list: Requests_stripeMethod({
        method: 'GET',
        fullPath: '/v1/forwarding/requests',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Sigma/ScheduledQueryRuns.js
// File generated from our OpenAPI spec

const ScheduledQueryRuns_stripeMethod = StripeResource.method;
const ScheduledQueryRuns = StripeResource.extend({
    retrieve: ScheduledQueryRuns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/sigma/scheduled_query_runs/{scheduled_query_run}',
    }),
    list: ScheduledQueryRuns_stripeMethod({
        method: 'GET',
        fullPath: '/v1/sigma/scheduled_query_runs',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Apps/Secrets.js
// File generated from our OpenAPI spec

const Secrets_stripeMethod = StripeResource.method;
const Secrets = StripeResource.extend({
    create: Secrets_stripeMethod({ method: 'POST', fullPath: '/v1/apps/secrets' }),
    list: Secrets_stripeMethod({
        method: 'GET',
        fullPath: '/v1/apps/secrets',
        methodType: 'list',
    }),
    deleteWhere: Secrets_stripeMethod({
        method: 'POST',
        fullPath: '/v1/apps/secrets/delete',
    }),
    find: Secrets_stripeMethod({ method: 'GET', fullPath: '/v1/apps/secrets/find' }),
});

;// ../../node_modules/stripe/esm/resources/BillingPortal/Sessions.js
// File generated from our OpenAPI spec

const Sessions_stripeMethod = StripeResource.method;
const Sessions = StripeResource.extend({
    create: Sessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/billing_portal/sessions',
    }),
});

;// ../../node_modules/stripe/esm/resources/Checkout/Sessions.js
// File generated from our OpenAPI spec

const Checkout_Sessions_stripeMethod = StripeResource.method;
const Sessions_Sessions = StripeResource.extend({
    create: Checkout_Sessions_stripeMethod({ method: 'POST', fullPath: '/v1/checkout/sessions' }),
    retrieve: Checkout_Sessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions/{session}',
    }),
    update: Checkout_Sessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/checkout/sessions/{session}',
    }),
    list: Checkout_Sessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions',
        methodType: 'list',
    }),
    expire: Checkout_Sessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/checkout/sessions/{session}/expire',
    }),
    listLineItems: Checkout_Sessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/checkout/sessions/{session}/line_items',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/FinancialConnections/Sessions.js
// File generated from our OpenAPI spec

const FinancialConnections_Sessions_stripeMethod = StripeResource.method;
const FinancialConnections_Sessions_Sessions = StripeResource.extend({
    create: FinancialConnections_Sessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/financial_connections/sessions',
    }),
    retrieve: FinancialConnections_Sessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/sessions/{session}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Tax/Settings.js
// File generated from our OpenAPI spec

const Settings_stripeMethod = StripeResource.method;
const Settings = StripeResource.extend({
    retrieve: Settings_stripeMethod({ method: 'GET', fullPath: '/v1/tax/settings' }),
    update: Settings_stripeMethod({ method: 'POST', fullPath: '/v1/tax/settings' }),
});

;// ../../node_modules/stripe/esm/resources/Climate/Suppliers.js
// File generated from our OpenAPI spec

const Suppliers_stripeMethod = StripeResource.method;
const Suppliers = StripeResource.extend({
    retrieve: Suppliers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/suppliers/{supplier}',
    }),
    list: Suppliers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/climate/suppliers',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/TestClocks.js
// File generated from our OpenAPI spec

const TestClocks_stripeMethod = StripeResource.method;
const TestClocks = StripeResource.extend({
    create: TestClocks_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/test_clocks',
    }),
    retrieve: TestClocks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}',
    }),
    list: TestClocks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/test_helpers/test_clocks',
        methodType: 'list',
    }),
    del: TestClocks_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}',
    }),
    advance: TestClocks_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/test_clocks/{test_clock}/advance',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Tokens.js
// File generated from our OpenAPI spec

const Tokens_stripeMethod = StripeResource.method;
const Tokens = StripeResource.extend({
    retrieve: Tokens_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/tokens/{token}',
    }),
    update: Tokens_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/tokens/{token}',
    }),
    list: Tokens_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/tokens',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/TransactionEntries.js
// File generated from our OpenAPI spec

const TransactionEntries_stripeMethod = StripeResource.method;
const TransactionEntries = StripeResource.extend({
    retrieve: TransactionEntries_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transaction_entries/{id}',
    }),
    list: TransactionEntries_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transaction_entries',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TestHelpers/Issuing/Transactions.js
// File generated from our OpenAPI spec

const Transactions_stripeMethod = StripeResource.method;
const Transactions = StripeResource.extend({
    createForceCapture: Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/transactions/create_force_capture',
    }),
    createUnlinkedRefund: Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/transactions/create_unlinked_refund',
    }),
    refund: Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/test_helpers/issuing/transactions/{transaction}/refund',
    }),
});

;// ../../node_modules/stripe/esm/resources/FinancialConnections/Transactions.js
// File generated from our OpenAPI spec

const FinancialConnections_Transactions_stripeMethod = StripeResource.method;
const Transactions_Transactions = StripeResource.extend({
    retrieve: FinancialConnections_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/transactions/{transaction}',
    }),
    list: FinancialConnections_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/financial_connections/transactions',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Issuing/Transactions.js
// File generated from our OpenAPI spec

const Issuing_Transactions_stripeMethod = StripeResource.method;
const Issuing_Transactions_Transactions = StripeResource.extend({
    retrieve: Issuing_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/transactions/{transaction}',
    }),
    update: Issuing_Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/issuing/transactions/{transaction}',
    }),
    list: Issuing_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/issuing/transactions',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Tax/Transactions.js
// File generated from our OpenAPI spec

const Tax_Transactions_stripeMethod = StripeResource.method;
const Tax_Transactions_Transactions = StripeResource.extend({
    retrieve: Tax_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/transactions/{transaction}',
    }),
    createFromCalculation: Tax_Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/tax/transactions/create_from_calculation',
    }),
    createReversal: Tax_Transactions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/tax/transactions/create_reversal',
    }),
    listLineItems: Tax_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax/transactions/{transaction}/line_items',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Treasury/Transactions.js
// File generated from our OpenAPI spec

const Treasury_Transactions_stripeMethod = StripeResource.method;
const Treasury_Transactions_Transactions = StripeResource.extend({
    retrieve: Treasury_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transactions/{id}',
    }),
    list: Treasury_Transactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/treasury/transactions',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Radar/ValueListItems.js
// File generated from our OpenAPI spec

const ValueListItems_stripeMethod = StripeResource.method;
const ValueListItems = StripeResource.extend({
    create: ValueListItems_stripeMethod({
        method: 'POST',
        fullPath: '/v1/radar/value_list_items',
    }),
    retrieve: ValueListItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_list_items/{item}',
    }),
    list: ValueListItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_list_items',
        methodType: 'list',
    }),
    del: ValueListItems_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/radar/value_list_items/{item}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Radar/ValueLists.js
// File generated from our OpenAPI spec

const ValueLists_stripeMethod = StripeResource.method;
const ValueLists = StripeResource.extend({
    create: ValueLists_stripeMethod({ method: 'POST', fullPath: '/v1/radar/value_lists' }),
    retrieve: ValueLists_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_lists/{value_list}',
    }),
    update: ValueLists_stripeMethod({
        method: 'POST',
        fullPath: '/v1/radar/value_lists/{value_list}',
    }),
    list: ValueLists_stripeMethod({
        method: 'GET',
        fullPath: '/v1/radar/value_lists',
        methodType: 'list',
    }),
    del: ValueLists_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/radar/value_lists/{value_list}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Identity/VerificationReports.js
// File generated from our OpenAPI spec

const VerificationReports_stripeMethod = StripeResource.method;
const VerificationReports = StripeResource.extend({
    retrieve: VerificationReports_stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_reports/{report}',
    }),
    list: VerificationReports_stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_reports',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Identity/VerificationSessions.js
// File generated from our OpenAPI spec

const VerificationSessions_stripeMethod = StripeResource.method;
const VerificationSessions = StripeResource.extend({
    create: VerificationSessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions',
    }),
    retrieve: VerificationSessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_sessions/{session}',
    }),
    update: VerificationSessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}',
    }),
    list: VerificationSessions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/identity/verification_sessions',
        methodType: 'list',
    }),
    cancel: VerificationSessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}/cancel',
    }),
    redact: VerificationSessions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/identity/verification_sessions/{session}/redact',
    }),
});

;// ../../node_modules/stripe/esm/resources/Accounts.js
// File generated from our OpenAPI spec

const resources_Accounts_stripeMethod = StripeResource.method;
// Since path can either be `account` or `accounts`, support both through stripeMethod path
const Accounts_Accounts = StripeResource.extend({
    create: resources_Accounts_stripeMethod({ method: 'POST', fullPath: '/v1/accounts' }),
    retrieve(id, ...args) {
        // No longer allow an api key to be passed as the first string to this function due to ambiguity between
        // old account ids and api keys. To request the account for an api key, send null as the id
        if (typeof id === 'string') {
            return resources_Accounts_stripeMethod({
                method: 'GET',
                fullPath: '/v1/accounts/{id}',
            }).apply(this, [id, ...args]);
        }
        else {
            if (id === null || id === undefined) {
                // Remove id as stripeMethod would complain of unexpected argument
                [].shift.apply([id, ...args]);
            }
            return resources_Accounts_stripeMethod({
                method: 'GET',
                fullPath: '/v1/account',
            }).apply(this, [id, ...args]);
        }
    },
    update: resources_Accounts_stripeMethod({ method: 'POST', fullPath: '/v1/accounts/{account}' }),
    list: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts',
        methodType: 'list',
    }),
    del: resources_Accounts_stripeMethod({ method: 'DELETE', fullPath: '/v1/accounts/{account}' }),
    createExternalAccount: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/external_accounts',
    }),
    createLoginLink: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/login_links',
    }),
    createPerson: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/persons',
    }),
    deleteExternalAccount: resources_Accounts_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}',
    }),
    deletePerson: resources_Accounts_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/accounts/{account}/persons/{person}',
    }),
    listCapabilities: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/capabilities',
        methodType: 'list',
    }),
    listExternalAccounts: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/external_accounts',
        methodType: 'list',
    }),
    listPersons: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/persons',
        methodType: 'list',
    }),
    reject: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/reject',
    }),
    retrieveCurrent: resources_Accounts_stripeMethod({ method: 'GET', fullPath: '/v1/account' }),
    retrieveCapability: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/capabilities/{capability}',
    }),
    retrieveExternalAccount: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}',
    }),
    retrievePerson: resources_Accounts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/accounts/{account}/persons/{person}',
    }),
    updateCapability: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/capabilities/{capability}',
    }),
    updateExternalAccount: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/external_accounts/{id}',
    }),
    updatePerson: resources_Accounts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/accounts/{account}/persons/{person}',
    }),
});

;// ../../node_modules/stripe/esm/resources/AccountLinks.js
// File generated from our OpenAPI spec

const AccountLinks_stripeMethod = StripeResource.method;
const AccountLinks = StripeResource.extend({
    create: AccountLinks_stripeMethod({ method: 'POST', fullPath: '/v1/account_links' }),
});

;// ../../node_modules/stripe/esm/resources/AccountSessions.js
// File generated from our OpenAPI spec

const AccountSessions_stripeMethod = StripeResource.method;
const AccountSessions = StripeResource.extend({
    create: AccountSessions_stripeMethod({ method: 'POST', fullPath: '/v1/account_sessions' }),
});

;// ../../node_modules/stripe/esm/resources/ApplePayDomains.js
// File generated from our OpenAPI spec

const ApplePayDomains_stripeMethod = StripeResource.method;
const ApplePayDomains = StripeResource.extend({
    create: ApplePayDomains_stripeMethod({ method: 'POST', fullPath: '/v1/apple_pay/domains' }),
    retrieve: ApplePayDomains_stripeMethod({
        method: 'GET',
        fullPath: '/v1/apple_pay/domains/{domain}',
    }),
    list: ApplePayDomains_stripeMethod({
        method: 'GET',
        fullPath: '/v1/apple_pay/domains',
        methodType: 'list',
    }),
    del: ApplePayDomains_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/apple_pay/domains/{domain}',
    }),
});

;// ../../node_modules/stripe/esm/resources/ApplicationFees.js
// File generated from our OpenAPI spec

const ApplicationFees_stripeMethod = StripeResource.method;
const ApplicationFees = StripeResource.extend({
    retrieve: ApplicationFees_stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{id}',
    }),
    list: ApplicationFees_stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees',
        methodType: 'list',
    }),
    createRefund: ApplicationFees_stripeMethod({
        method: 'POST',
        fullPath: '/v1/application_fees/{id}/refunds',
    }),
    listRefunds: ApplicationFees_stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{id}/refunds',
        methodType: 'list',
    }),
    retrieveRefund: ApplicationFees_stripeMethod({
        method: 'GET',
        fullPath: '/v1/application_fees/{fee}/refunds/{id}',
    }),
    updateRefund: ApplicationFees_stripeMethod({
        method: 'POST',
        fullPath: '/v1/application_fees/{fee}/refunds/{id}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Balance.js
// File generated from our OpenAPI spec

const Balance_stripeMethod = StripeResource.method;
const Balance = StripeResource.extend({
    retrieve: Balance_stripeMethod({ method: 'GET', fullPath: '/v1/balance' }),
});

;// ../../node_modules/stripe/esm/resources/BalanceTransactions.js
// File generated from our OpenAPI spec

const BalanceTransactions_stripeMethod = StripeResource.method;
const BalanceTransactions = StripeResource.extend({
    retrieve: BalanceTransactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/balance_transactions/{id}',
    }),
    list: BalanceTransactions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/balance_transactions',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Charges.js
// File generated from our OpenAPI spec

const Charges_stripeMethod = StripeResource.method;
const Charges = StripeResource.extend({
    create: Charges_stripeMethod({ method: 'POST', fullPath: '/v1/charges' }),
    retrieve: Charges_stripeMethod({ method: 'GET', fullPath: '/v1/charges/{charge}' }),
    update: Charges_stripeMethod({ method: 'POST', fullPath: '/v1/charges/{charge}' }),
    list: Charges_stripeMethod({
        method: 'GET',
        fullPath: '/v1/charges',
        methodType: 'list',
    }),
    capture: Charges_stripeMethod({
        method: 'POST',
        fullPath: '/v1/charges/{charge}/capture',
    }),
    search: Charges_stripeMethod({
        method: 'GET',
        fullPath: '/v1/charges/search',
        methodType: 'search',
    }),
});

;// ../../node_modules/stripe/esm/resources/ConfirmationTokens.js
// File generated from our OpenAPI spec

const resources_ConfirmationTokens_stripeMethod = StripeResource.method;
const ConfirmationTokens_ConfirmationTokens = StripeResource.extend({
    retrieve: resources_ConfirmationTokens_stripeMethod({
        method: 'GET',
        fullPath: '/v1/confirmation_tokens/{confirmation_token}',
    }),
});

;// ../../node_modules/stripe/esm/resources/CountrySpecs.js
// File generated from our OpenAPI spec

const CountrySpecs_stripeMethod = StripeResource.method;
const CountrySpecs = StripeResource.extend({
    retrieve: CountrySpecs_stripeMethod({
        method: 'GET',
        fullPath: '/v1/country_specs/{country}',
    }),
    list: CountrySpecs_stripeMethod({
        method: 'GET',
        fullPath: '/v1/country_specs',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Coupons.js
// File generated from our OpenAPI spec

const Coupons_stripeMethod = StripeResource.method;
const Coupons = StripeResource.extend({
    create: Coupons_stripeMethod({ method: 'POST', fullPath: '/v1/coupons' }),
    retrieve: Coupons_stripeMethod({ method: 'GET', fullPath: '/v1/coupons/{coupon}' }),
    update: Coupons_stripeMethod({ method: 'POST', fullPath: '/v1/coupons/{coupon}' }),
    list: Coupons_stripeMethod({
        method: 'GET',
        fullPath: '/v1/coupons',
        methodType: 'list',
    }),
    del: Coupons_stripeMethod({ method: 'DELETE', fullPath: '/v1/coupons/{coupon}' }),
});

;// ../../node_modules/stripe/esm/resources/CreditNotes.js
// File generated from our OpenAPI spec

const CreditNotes_stripeMethod = StripeResource.method;
const CreditNotes = StripeResource.extend({
    create: CreditNotes_stripeMethod({ method: 'POST', fullPath: '/v1/credit_notes' }),
    retrieve: CreditNotes_stripeMethod({ method: 'GET', fullPath: '/v1/credit_notes/{id}' }),
    update: CreditNotes_stripeMethod({ method: 'POST', fullPath: '/v1/credit_notes/{id}' }),
    list: CreditNotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes',
        methodType: 'list',
    }),
    listLineItems: CreditNotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/{credit_note}/lines',
        methodType: 'list',
    }),
    listPreviewLineItems: CreditNotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/credit_notes/preview/lines',
        methodType: 'list',
    }),
    preview: CreditNotes_stripeMethod({ method: 'GET', fullPath: '/v1/credit_notes/preview' }),
    voidCreditNote: CreditNotes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/credit_notes/{id}/void',
    }),
});

;// ../../node_modules/stripe/esm/resources/CustomerSessions.js
// File generated from our OpenAPI spec

const CustomerSessions_stripeMethod = StripeResource.method;
const CustomerSessions = StripeResource.extend({
    create: CustomerSessions_stripeMethod({ method: 'POST', fullPath: '/v1/customer_sessions' }),
});

;// ../../node_modules/stripe/esm/resources/Customers.js
// File generated from our OpenAPI spec

const resources_Customers_stripeMethod = StripeResource.method;
const Customers_Customers = StripeResource.extend({
    create: resources_Customers_stripeMethod({ method: 'POST', fullPath: '/v1/customers' }),
    retrieve: resources_Customers_stripeMethod({ method: 'GET', fullPath: '/v1/customers/{customer}' }),
    update: resources_Customers_stripeMethod({ method: 'POST', fullPath: '/v1/customers/{customer}' }),
    list: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers',
        methodType: 'list',
    }),
    del: resources_Customers_stripeMethod({ method: 'DELETE', fullPath: '/v1/customers/{customer}' }),
    createBalanceTransaction: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/balance_transactions',
    }),
    createFundingInstructions: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/funding_instructions',
    }),
    createSource: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources',
    }),
    createTaxId: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/tax_ids',
    }),
    deleteDiscount: resources_Customers_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/discount',
    }),
    deleteSource: resources_Customers_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/sources/{id}',
    }),
    deleteTaxId: resources_Customers_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/customers/{customer}/tax_ids/{id}',
    }),
    listBalanceTransactions: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/balance_transactions',
        methodType: 'list',
    }),
    listCashBalanceTransactions: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance_transactions',
        methodType: 'list',
    }),
    listPaymentMethods: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/payment_methods',
        methodType: 'list',
    }),
    listSources: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/sources',
        methodType: 'list',
    }),
    listTaxIds: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/tax_ids',
        methodType: 'list',
    }),
    retrieveBalanceTransaction: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/balance_transactions/{transaction}',
    }),
    retrieveCashBalance: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance',
    }),
    retrieveCashBalanceTransaction: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/cash_balance_transactions/{transaction}',
    }),
    retrievePaymentMethod: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/payment_methods/{payment_method}',
    }),
    retrieveSource: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/sources/{id}',
    }),
    retrieveTaxId: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/{customer}/tax_ids/{id}',
    }),
    search: resources_Customers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/customers/search',
        methodType: 'search',
    }),
    updateBalanceTransaction: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/balance_transactions/{transaction}',
    }),
    updateCashBalance: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/cash_balance',
    }),
    updateSource: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources/{id}',
    }),
    verifySource: resources_Customers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/customers/{customer}/sources/{id}/verify',
    }),
});

;// ../../node_modules/stripe/esm/resources/Disputes.js
// File generated from our OpenAPI spec

const resources_Disputes_stripeMethod = StripeResource.method;
const Disputes_Disputes = StripeResource.extend({
    retrieve: resources_Disputes_stripeMethod({ method: 'GET', fullPath: '/v1/disputes/{dispute}' }),
    update: resources_Disputes_stripeMethod({ method: 'POST', fullPath: '/v1/disputes/{dispute}' }),
    list: resources_Disputes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/disputes',
        methodType: 'list',
    }),
    close: resources_Disputes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/disputes/{dispute}/close',
    }),
});

;// ../../node_modules/stripe/esm/resources/EphemeralKeys.js
// File generated from our OpenAPI spec

const EphemeralKeys_stripeMethod = StripeResource.method;
const EphemeralKeys = StripeResource.extend({
    create: EphemeralKeys_stripeMethod({
        method: 'POST',
        fullPath: '/v1/ephemeral_keys',
        validator: (data, options) => {
            if (!options.headers || !options.headers['Stripe-Version']) {
                throw new Error('Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node');
            }
        },
    }),
    del: EphemeralKeys_stripeMethod({ method: 'DELETE', fullPath: '/v1/ephemeral_keys/{key}' }),
});

;// ../../node_modules/stripe/esm/resources/Events.js
// File generated from our OpenAPI spec

const Events_stripeMethod = StripeResource.method;
const Events = StripeResource.extend({
    retrieve: Events_stripeMethod({ method: 'GET', fullPath: '/v1/events/{id}' }),
    list: Events_stripeMethod({
        method: 'GET',
        fullPath: '/v1/events',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/ExchangeRates.js
// File generated from our OpenAPI spec

const ExchangeRates_stripeMethod = StripeResource.method;
const ExchangeRates = StripeResource.extend({
    retrieve: ExchangeRates_stripeMethod({
        method: 'GET',
        fullPath: '/v1/exchange_rates/{rate_id}',
    }),
    list: ExchangeRates_stripeMethod({
        method: 'GET',
        fullPath: '/v1/exchange_rates',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/FileLinks.js
// File generated from our OpenAPI spec

const FileLinks_stripeMethod = StripeResource.method;
const FileLinks = StripeResource.extend({
    create: FileLinks_stripeMethod({ method: 'POST', fullPath: '/v1/file_links' }),
    retrieve: FileLinks_stripeMethod({ method: 'GET', fullPath: '/v1/file_links/{link}' }),
    update: FileLinks_stripeMethod({ method: 'POST', fullPath: '/v1/file_links/{link}' }),
    list: FileLinks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/file_links',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/multipart.js

// Method for formatting HTTP body for the multipart/form-data specification
// Mostly taken from Fermata.js
// https://github.com/natevw/fermata/blob/5d9732a33d776ce925013a265935facd1626cc88/fermata.js#L315-L343
const multipartDataGenerator = (method, data, headers) => {
    const segno = (Math.round(Math.random() * 1e16) + Math.round(Math.random() * 1e16)).toString();
    headers['Content-Type'] = `multipart/form-data; boundary=${segno}`;
    const textEncoder = new TextEncoder();
    let buffer = new Uint8Array(0);
    const endBuffer = textEncoder.encode('\r\n');
    function push(l) {
        const prevBuffer = buffer;
        const newBuffer = l instanceof Uint8Array ? l : new Uint8Array(textEncoder.encode(l));
        buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
        buffer.set(prevBuffer);
        buffer.set(newBuffer, prevBuffer.length);
        buffer.set(endBuffer, buffer.length - 2);
    }
    function q(s) {
        return `"${s.replace(/"|"/g, '%22').replace(/\r\n|\r|\n/g, ' ')}"`;
    }
    const flattenedData = flattenAndStringify(data);
    for (const k in flattenedData) {
        if (!Object.prototype.hasOwnProperty.call(flattenedData, k)) {
            continue;
        }
        const v = flattenedData[k];
        push(`--${segno}`);
        if (Object.prototype.hasOwnProperty.call(v, 'data')) {
            const typedEntry = v;
            push(`Content-Disposition: form-data; name=${q(k)}; filename=${q(typedEntry.name || 'blob')}`);
            push(`Content-Type: ${typedEntry.type || 'application/octet-stream'}`);
            push('');
            push(typedEntry.data);
        }
        else {
            push(`Content-Disposition: form-data; name=${q(k)}`);
            push('');
            push(v);
        }
    }
    push(`--${segno}--`);
    return buffer;
};
function multipartRequestDataProcessor(method, data, headers, callback) {
    data = data || {};
    if (method !== 'POST') {
        return callback(null, stringifyRequestData(data));
    }
    this._stripe._platformFunctions
        .tryBufferData(data)
        .then((bufferedData) => {
        const buffer = multipartDataGenerator(method, bufferedData, headers);
        return callback(null, buffer);
    })
        .catch((err) => callback(err, null));
}

;// ../../node_modules/stripe/esm/resources/Files.js
// File generated from our OpenAPI spec


const Files_stripeMethod = StripeResource.method;
const Files = StripeResource.extend({
    create: Files_stripeMethod({
        method: 'POST',
        fullPath: '/v1/files',
        headers: {
            'Content-Type': 'multipart/form-data',
        },
        host: 'files.stripe.com',
    }),
    retrieve: Files_stripeMethod({ method: 'GET', fullPath: '/v1/files/{file}' }),
    list: Files_stripeMethod({
        method: 'GET',
        fullPath: '/v1/files',
        methodType: 'list',
    }),
    requestDataProcessor: multipartRequestDataProcessor,
});

;// ../../node_modules/stripe/esm/resources/InvoiceItems.js
// File generated from our OpenAPI spec

const InvoiceItems_stripeMethod = StripeResource.method;
const InvoiceItems = StripeResource.extend({
    create: InvoiceItems_stripeMethod({ method: 'POST', fullPath: '/v1/invoiceitems' }),
    retrieve: InvoiceItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoiceitems/{invoiceitem}',
    }),
    update: InvoiceItems_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoiceitems/{invoiceitem}',
    }),
    list: InvoiceItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoiceitems',
        methodType: 'list',
    }),
    del: InvoiceItems_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/invoiceitems/{invoiceitem}',
    }),
});

;// ../../node_modules/stripe/esm/resources/Invoices.js
// File generated from our OpenAPI spec

const Invoices_stripeMethod = StripeResource.method;
const Invoices = StripeResource.extend({
    create: Invoices_stripeMethod({ method: 'POST', fullPath: '/v1/invoices' }),
    retrieve: Invoices_stripeMethod({ method: 'GET', fullPath: '/v1/invoices/{invoice}' }),
    update: Invoices_stripeMethod({ method: 'POST', fullPath: '/v1/invoices/{invoice}' }),
    list: Invoices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices',
        methodType: 'list',
    }),
    del: Invoices_stripeMethod({ method: 'DELETE', fullPath: '/v1/invoices/{invoice}' }),
    addLines: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/add_lines',
    }),
    createPreview: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/create_preview',
    }),
    finalizeInvoice: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/finalize',
    }),
    listLineItems: Invoices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/{invoice}/lines',
        methodType: 'list',
    }),
    listUpcomingLines: Invoices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/upcoming/lines',
        methodType: 'list',
    }),
    markUncollectible: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/mark_uncollectible',
    }),
    pay: Invoices_stripeMethod({ method: 'POST', fullPath: '/v1/invoices/{invoice}/pay' }),
    removeLines: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/remove_lines',
    }),
    retrieveUpcoming: Invoices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/upcoming',
    }),
    search: Invoices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/invoices/search',
        methodType: 'search',
    }),
    sendInvoice: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/send',
    }),
    updateLines: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/update_lines',
    }),
    updateLineItem: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/lines/{line_item_id}',
    }),
    voidInvoice: Invoices_stripeMethod({
        method: 'POST',
        fullPath: '/v1/invoices/{invoice}/void',
    }),
});

;// ../../node_modules/stripe/esm/resources/Mandates.js
// File generated from our OpenAPI spec

const Mandates_stripeMethod = StripeResource.method;
const Mandates = StripeResource.extend({
    retrieve: Mandates_stripeMethod({ method: 'GET', fullPath: '/v1/mandates/{mandate}' }),
});

;// ../../node_modules/stripe/esm/resources/OAuth.js



const OAuth_stripeMethod = StripeResource.method;
const oAuthHost = 'connect.stripe.com';
const OAuth = StripeResource.extend({
    basePath: '/',
    authorizeUrl(params, options) {
        params = params || {};
        options = options || {};
        let path = 'oauth/authorize';
        // For Express accounts, the path changes
        if (options.express) {
            path = `express/${path}`;
        }
        if (!params.response_type) {
            params.response_type = 'code';
        }
        if (!params.client_id) {
            params.client_id = this._stripe.getClientId();
        }
        if (!params.scope) {
            params.scope = 'read_write';
        }
        return `https://${oAuthHost}/${path}?${stringifyRequestData(params)}`;
    },
    token: OAuth_stripeMethod({
        method: 'POST',
        path: 'oauth/token',
        host: oAuthHost,
    }),
    deauthorize(spec, ...args) {
        if (!spec.client_id) {
            spec.client_id = this._stripe.getClientId();
        }
        return OAuth_stripeMethod({
            method: 'POST',
            path: 'oauth/deauthorize',
            host: oAuthHost,
        }).apply(this, [spec, ...args]);
    },
});

;// ../../node_modules/stripe/esm/resources/PaymentIntents.js
// File generated from our OpenAPI spec

const PaymentIntents_stripeMethod = StripeResource.method;
const PaymentIntents = StripeResource.extend({
    create: PaymentIntents_stripeMethod({ method: 'POST', fullPath: '/v1/payment_intents' }),
    retrieve: PaymentIntents_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents/{intent}',
    }),
    update: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}',
    }),
    list: PaymentIntents_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents',
        methodType: 'list',
    }),
    applyCustomerBalance: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/apply_customer_balance',
    }),
    cancel: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/cancel',
    }),
    capture: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/capture',
    }),
    confirm: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/confirm',
    }),
    incrementAuthorization: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/increment_authorization',
    }),
    search: PaymentIntents_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_intents/search',
        methodType: 'search',
    }),
    verifyMicrodeposits: PaymentIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_intents/{intent}/verify_microdeposits',
    }),
});

;// ../../node_modules/stripe/esm/resources/PaymentLinks.js
// File generated from our OpenAPI spec

const PaymentLinks_stripeMethod = StripeResource.method;
const PaymentLinks = StripeResource.extend({
    create: PaymentLinks_stripeMethod({ method: 'POST', fullPath: '/v1/payment_links' }),
    retrieve: PaymentLinks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links/{payment_link}',
    }),
    update: PaymentLinks_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_links/{payment_link}',
    }),
    list: PaymentLinks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links',
        methodType: 'list',
    }),
    listLineItems: PaymentLinks_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_links/{payment_link}/line_items',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/PaymentMethodConfigurations.js
// File generated from our OpenAPI spec

const PaymentMethodConfigurations_stripeMethod = StripeResource.method;
const PaymentMethodConfigurations = StripeResource.extend({
    create: PaymentMethodConfigurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_method_configurations',
    }),
    retrieve: PaymentMethodConfigurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_method_configurations/{configuration}',
    }),
    update: PaymentMethodConfigurations_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_method_configurations/{configuration}',
    }),
    list: PaymentMethodConfigurations_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_method_configurations',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/PaymentMethodDomains.js
// File generated from our OpenAPI spec

const PaymentMethodDomains_stripeMethod = StripeResource.method;
const PaymentMethodDomains = StripeResource.extend({
    create: PaymentMethodDomains_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_method_domains',
    }),
    retrieve: PaymentMethodDomains_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_method_domains/{payment_method_domain}',
    }),
    update: PaymentMethodDomains_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_method_domains/{payment_method_domain}',
    }),
    list: PaymentMethodDomains_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_method_domains',
        methodType: 'list',
    }),
    validate: PaymentMethodDomains_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_method_domains/{payment_method_domain}/validate',
    }),
});

;// ../../node_modules/stripe/esm/resources/PaymentMethods.js
// File generated from our OpenAPI spec

const PaymentMethods_stripeMethod = StripeResource.method;
const PaymentMethods = StripeResource.extend({
    create: PaymentMethods_stripeMethod({ method: 'POST', fullPath: '/v1/payment_methods' }),
    retrieve: PaymentMethods_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_methods/{payment_method}',
    }),
    update: PaymentMethods_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}',
    }),
    list: PaymentMethods_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payment_methods',
        methodType: 'list',
    }),
    attach: PaymentMethods_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}/attach',
    }),
    detach: PaymentMethods_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payment_methods/{payment_method}/detach',
    }),
});

;// ../../node_modules/stripe/esm/resources/Payouts.js
// File generated from our OpenAPI spec

const Payouts_stripeMethod = StripeResource.method;
const Payouts = StripeResource.extend({
    create: Payouts_stripeMethod({ method: 'POST', fullPath: '/v1/payouts' }),
    retrieve: Payouts_stripeMethod({ method: 'GET', fullPath: '/v1/payouts/{payout}' }),
    update: Payouts_stripeMethod({ method: 'POST', fullPath: '/v1/payouts/{payout}' }),
    list: Payouts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/payouts',
        methodType: 'list',
    }),
    cancel: Payouts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts/{payout}/cancel',
    }),
    reverse: Payouts_stripeMethod({
        method: 'POST',
        fullPath: '/v1/payouts/{payout}/reverse',
    }),
});

;// ../../node_modules/stripe/esm/resources/Plans.js
// File generated from our OpenAPI spec

const Plans_stripeMethod = StripeResource.method;
const Plans = StripeResource.extend({
    create: Plans_stripeMethod({ method: 'POST', fullPath: '/v1/plans' }),
    retrieve: Plans_stripeMethod({ method: 'GET', fullPath: '/v1/plans/{plan}' }),
    update: Plans_stripeMethod({ method: 'POST', fullPath: '/v1/plans/{plan}' }),
    list: Plans_stripeMethod({
        method: 'GET',
        fullPath: '/v1/plans',
        methodType: 'list',
    }),
    del: Plans_stripeMethod({ method: 'DELETE', fullPath: '/v1/plans/{plan}' }),
});

;// ../../node_modules/stripe/esm/resources/Prices.js
// File generated from our OpenAPI spec

const Prices_stripeMethod = StripeResource.method;
const Prices = StripeResource.extend({
    create: Prices_stripeMethod({ method: 'POST', fullPath: '/v1/prices' }),
    retrieve: Prices_stripeMethod({ method: 'GET', fullPath: '/v1/prices/{price}' }),
    update: Prices_stripeMethod({ method: 'POST', fullPath: '/v1/prices/{price}' }),
    list: Prices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/prices',
        methodType: 'list',
    }),
    search: Prices_stripeMethod({
        method: 'GET',
        fullPath: '/v1/prices/search',
        methodType: 'search',
    }),
});

;// ../../node_modules/stripe/esm/resources/Products.js
// File generated from our OpenAPI spec

const resources_Products_stripeMethod = StripeResource.method;
const Products_Products = StripeResource.extend({
    create: resources_Products_stripeMethod({ method: 'POST', fullPath: '/v1/products' }),
    retrieve: resources_Products_stripeMethod({ method: 'GET', fullPath: '/v1/products/{id}' }),
    update: resources_Products_stripeMethod({ method: 'POST', fullPath: '/v1/products/{id}' }),
    list: resources_Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/products',
        methodType: 'list',
    }),
    del: resources_Products_stripeMethod({ method: 'DELETE', fullPath: '/v1/products/{id}' }),
    createFeature: resources_Products_stripeMethod({
        method: 'POST',
        fullPath: '/v1/products/{product}/features',
    }),
    deleteFeature: resources_Products_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/products/{product}/features/{id}',
    }),
    listFeatures: resources_Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/products/{product}/features',
        methodType: 'list',
    }),
    retrieveFeature: resources_Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/products/{product}/features/{id}',
    }),
    search: resources_Products_stripeMethod({
        method: 'GET',
        fullPath: '/v1/products/search',
        methodType: 'search',
    }),
});

;// ../../node_modules/stripe/esm/resources/PromotionCodes.js
// File generated from our OpenAPI spec

const PromotionCodes_stripeMethod = StripeResource.method;
const PromotionCodes = StripeResource.extend({
    create: PromotionCodes_stripeMethod({ method: 'POST', fullPath: '/v1/promotion_codes' }),
    retrieve: PromotionCodes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/promotion_codes/{promotion_code}',
    }),
    update: PromotionCodes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/promotion_codes/{promotion_code}',
    }),
    list: PromotionCodes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/promotion_codes',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Quotes.js
// File generated from our OpenAPI spec

const Quotes_stripeMethod = StripeResource.method;
const Quotes = StripeResource.extend({
    create: Quotes_stripeMethod({ method: 'POST', fullPath: '/v1/quotes' }),
    retrieve: Quotes_stripeMethod({ method: 'GET', fullPath: '/v1/quotes/{quote}' }),
    update: Quotes_stripeMethod({ method: 'POST', fullPath: '/v1/quotes/{quote}' }),
    list: Quotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes',
        methodType: 'list',
    }),
    accept: Quotes_stripeMethod({ method: 'POST', fullPath: '/v1/quotes/{quote}/accept' }),
    cancel: Quotes_stripeMethod({ method: 'POST', fullPath: '/v1/quotes/{quote}/cancel' }),
    finalizeQuote: Quotes_stripeMethod({
        method: 'POST',
        fullPath: '/v1/quotes/{quote}/finalize',
    }),
    listComputedUpfrontLineItems: Quotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/computed_upfront_line_items',
        methodType: 'list',
    }),
    listLineItems: Quotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/line_items',
        methodType: 'list',
    }),
    pdf: Quotes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/quotes/{quote}/pdf',
        host: 'files.stripe.com',
        streaming: true,
    }),
});

;// ../../node_modules/stripe/esm/resources/Refunds.js
// File generated from our OpenAPI spec

const resources_Refunds_stripeMethod = StripeResource.method;
const Refunds_Refunds = StripeResource.extend({
    create: resources_Refunds_stripeMethod({ method: 'POST', fullPath: '/v1/refunds' }),
    retrieve: resources_Refunds_stripeMethod({ method: 'GET', fullPath: '/v1/refunds/{refund}' }),
    update: resources_Refunds_stripeMethod({ method: 'POST', fullPath: '/v1/refunds/{refund}' }),
    list: resources_Refunds_stripeMethod({
        method: 'GET',
        fullPath: '/v1/refunds',
        methodType: 'list',
    }),
    cancel: resources_Refunds_stripeMethod({
        method: 'POST',
        fullPath: '/v1/refunds/{refund}/cancel',
    }),
});

;// ../../node_modules/stripe/esm/resources/Reviews.js
// File generated from our OpenAPI spec

const Reviews_stripeMethod = StripeResource.method;
const Reviews = StripeResource.extend({
    retrieve: Reviews_stripeMethod({ method: 'GET', fullPath: '/v1/reviews/{review}' }),
    list: Reviews_stripeMethod({
        method: 'GET',
        fullPath: '/v1/reviews',
        methodType: 'list',
    }),
    approve: Reviews_stripeMethod({
        method: 'POST',
        fullPath: '/v1/reviews/{review}/approve',
    }),
});

;// ../../node_modules/stripe/esm/resources/SetupAttempts.js
// File generated from our OpenAPI spec

const SetupAttempts_stripeMethod = StripeResource.method;
const SetupAttempts = StripeResource.extend({
    list: SetupAttempts_stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_attempts',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/SetupIntents.js
// File generated from our OpenAPI spec

const SetupIntents_stripeMethod = StripeResource.method;
const SetupIntents = StripeResource.extend({
    create: SetupIntents_stripeMethod({ method: 'POST', fullPath: '/v1/setup_intents' }),
    retrieve: SetupIntents_stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_intents/{intent}',
    }),
    update: SetupIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}',
    }),
    list: SetupIntents_stripeMethod({
        method: 'GET',
        fullPath: '/v1/setup_intents',
        methodType: 'list',
    }),
    cancel: SetupIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/cancel',
    }),
    confirm: SetupIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/confirm',
    }),
    verifyMicrodeposits: SetupIntents_stripeMethod({
        method: 'POST',
        fullPath: '/v1/setup_intents/{intent}/verify_microdeposits',
    }),
});

;// ../../node_modules/stripe/esm/resources/ShippingRates.js
// File generated from our OpenAPI spec

const ShippingRates_stripeMethod = StripeResource.method;
const ShippingRates = StripeResource.extend({
    create: ShippingRates_stripeMethod({ method: 'POST', fullPath: '/v1/shipping_rates' }),
    retrieve: ShippingRates_stripeMethod({
        method: 'GET',
        fullPath: '/v1/shipping_rates/{shipping_rate_token}',
    }),
    update: ShippingRates_stripeMethod({
        method: 'POST',
        fullPath: '/v1/shipping_rates/{shipping_rate_token}',
    }),
    list: ShippingRates_stripeMethod({
        method: 'GET',
        fullPath: '/v1/shipping_rates',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Sources.js
// File generated from our OpenAPI spec

const Sources_stripeMethod = StripeResource.method;
const Sources = StripeResource.extend({
    create: Sources_stripeMethod({ method: 'POST', fullPath: '/v1/sources' }),
    retrieve: Sources_stripeMethod({ method: 'GET', fullPath: '/v1/sources/{source}' }),
    update: Sources_stripeMethod({ method: 'POST', fullPath: '/v1/sources/{source}' }),
    listSourceTransactions: Sources_stripeMethod({
        method: 'GET',
        fullPath: '/v1/sources/{source}/source_transactions',
        methodType: 'list',
    }),
    verify: Sources_stripeMethod({
        method: 'POST',
        fullPath: '/v1/sources/{source}/verify',
    }),
});

;// ../../node_modules/stripe/esm/resources/SubscriptionItems.js
// File generated from our OpenAPI spec

const SubscriptionItems_stripeMethod = StripeResource.method;
const SubscriptionItems = StripeResource.extend({
    create: SubscriptionItems_stripeMethod({ method: 'POST', fullPath: '/v1/subscription_items' }),
    retrieve: SubscriptionItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items/{item}',
    }),
    update: SubscriptionItems_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_items/{item}',
    }),
    list: SubscriptionItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items',
        methodType: 'list',
    }),
    del: SubscriptionItems_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscription_items/{item}',
    }),
    createUsageRecord: SubscriptionItems_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_items/{subscription_item}/usage_records',
    }),
    listUsageRecordSummaries: SubscriptionItems_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_items/{subscription_item}/usage_record_summaries',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/SubscriptionSchedules.js
// File generated from our OpenAPI spec

const SubscriptionSchedules_stripeMethod = StripeResource.method;
const SubscriptionSchedules = StripeResource.extend({
    create: SubscriptionSchedules_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules',
    }),
    retrieve: SubscriptionSchedules_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_schedules/{schedule}',
    }),
    update: SubscriptionSchedules_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}',
    }),
    list: SubscriptionSchedules_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscription_schedules',
        methodType: 'list',
    }),
    cancel: SubscriptionSchedules_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}/cancel',
    }),
    release: SubscriptionSchedules_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscription_schedules/{schedule}/release',
    }),
});

;// ../../node_modules/stripe/esm/resources/Subscriptions.js
// File generated from our OpenAPI spec

const Subscriptions_stripeMethod = StripeResource.method;
const Subscriptions = StripeResource.extend({
    create: Subscriptions_stripeMethod({ method: 'POST', fullPath: '/v1/subscriptions' }),
    retrieve: Subscriptions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}',
    }),
    update: Subscriptions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}',
    }),
    list: Subscriptions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions',
        methodType: 'list',
    }),
    cancel: Subscriptions_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}',
    }),
    deleteDiscount: Subscriptions_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/subscriptions/{subscription_exposed_id}/discount',
    }),
    resume: Subscriptions_stripeMethod({
        method: 'POST',
        fullPath: '/v1/subscriptions/{subscription}/resume',
    }),
    search: Subscriptions_stripeMethod({
        method: 'GET',
        fullPath: '/v1/subscriptions/search',
        methodType: 'search',
    }),
});

;// ../../node_modules/stripe/esm/resources/TaxCodes.js
// File generated from our OpenAPI spec

const TaxCodes_stripeMethod = StripeResource.method;
const TaxCodes = StripeResource.extend({
    retrieve: TaxCodes_stripeMethod({ method: 'GET', fullPath: '/v1/tax_codes/{id}' }),
    list: TaxCodes_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_codes',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/TaxIds.js
// File generated from our OpenAPI spec

const TaxIds_stripeMethod = StripeResource.method;
const TaxIds = StripeResource.extend({
    create: TaxIds_stripeMethod({ method: 'POST', fullPath: '/v1/tax_ids' }),
    retrieve: TaxIds_stripeMethod({ method: 'GET', fullPath: '/v1/tax_ids/{id}' }),
    list: TaxIds_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_ids',
        methodType: 'list',
    }),
    del: TaxIds_stripeMethod({ method: 'DELETE', fullPath: '/v1/tax_ids/{id}' }),
});

;// ../../node_modules/stripe/esm/resources/TaxRates.js
// File generated from our OpenAPI spec

const TaxRates_stripeMethod = StripeResource.method;
const TaxRates = StripeResource.extend({
    create: TaxRates_stripeMethod({ method: 'POST', fullPath: '/v1/tax_rates' }),
    retrieve: TaxRates_stripeMethod({ method: 'GET', fullPath: '/v1/tax_rates/{tax_rate}' }),
    update: TaxRates_stripeMethod({ method: 'POST', fullPath: '/v1/tax_rates/{tax_rate}' }),
    list: TaxRates_stripeMethod({
        method: 'GET',
        fullPath: '/v1/tax_rates',
        methodType: 'list',
    }),
});

;// ../../node_modules/stripe/esm/resources/Tokens.js
// File generated from our OpenAPI spec

const resources_Tokens_stripeMethod = StripeResource.method;
const Tokens_Tokens = StripeResource.extend({
    create: resources_Tokens_stripeMethod({ method: 'POST', fullPath: '/v1/tokens' }),
    retrieve: resources_Tokens_stripeMethod({ method: 'GET', fullPath: '/v1/tokens/{token}' }),
});

;// ../../node_modules/stripe/esm/resources/Topups.js
// File generated from our OpenAPI spec

const Topups_stripeMethod = StripeResource.method;
const Topups = StripeResource.extend({
    create: Topups_stripeMethod({ method: 'POST', fullPath: '/v1/topups' }),
    retrieve: Topups_stripeMethod({ method: 'GET', fullPath: '/v1/topups/{topup}' }),
    update: Topups_stripeMethod({ method: 'POST', fullPath: '/v1/topups/{topup}' }),
    list: Topups_stripeMethod({
        method: 'GET',
        fullPath: '/v1/topups',
        methodType: 'list',
    }),
    cancel: Topups_stripeMethod({ method: 'POST', fullPath: '/v1/topups/{topup}/cancel' }),
});

;// ../../node_modules/stripe/esm/resources/Transfers.js
// File generated from our OpenAPI spec

const Transfers_stripeMethod = StripeResource.method;
const Transfers = StripeResource.extend({
    create: Transfers_stripeMethod({ method: 'POST', fullPath: '/v1/transfers' }),
    retrieve: Transfers_stripeMethod({ method: 'GET', fullPath: '/v1/transfers/{transfer}' }),
    update: Transfers_stripeMethod({ method: 'POST', fullPath: '/v1/transfers/{transfer}' }),
    list: Transfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers',
        methodType: 'list',
    }),
    createReversal: Transfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers/{id}/reversals',
    }),
    listReversals: Transfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers/{id}/reversals',
        methodType: 'list',
    }),
    retrieveReversal: Transfers_stripeMethod({
        method: 'GET',
        fullPath: '/v1/transfers/{transfer}/reversals/{id}',
    }),
    updateReversal: Transfers_stripeMethod({
        method: 'POST',
        fullPath: '/v1/transfers/{transfer}/reversals/{id}',
    }),
});

;// ../../node_modules/stripe/esm/resources/WebhookEndpoints.js
// File generated from our OpenAPI spec

const WebhookEndpoints_stripeMethod = StripeResource.method;
const WebhookEndpoints = StripeResource.extend({
    create: WebhookEndpoints_stripeMethod({ method: 'POST', fullPath: '/v1/webhook_endpoints' }),
    retrieve: WebhookEndpoints_stripeMethod({
        method: 'GET',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}',
    }),
    update: WebhookEndpoints_stripeMethod({
        method: 'POST',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}',
    }),
    list: WebhookEndpoints_stripeMethod({
        method: 'GET',
        fullPath: '/v1/webhook_endpoints',
        methodType: 'list',
    }),
    del: WebhookEndpoints_stripeMethod({
        method: 'DELETE',
        fullPath: '/v1/webhook_endpoints/{webhook_endpoint}',
    }),
});

;// ../../node_modules/stripe/esm/resources.js
// File generated from our OpenAPI spec






















































































































const Apps = resourceNamespace('apps', { Secrets: Secrets });
const Billing = resourceNamespace('billing', {
    Alerts: Alerts,
    MeterEventAdjustments: MeterEventAdjustments,
    MeterEvents: MeterEvents,
    Meters: Meters,
});
const BillingPortal = resourceNamespace('billingPortal', {
    Configurations: Configurations,
    Sessions: Sessions,
});
const Checkout = resourceNamespace('checkout', {
    Sessions: Sessions_Sessions,
});
const Climate = resourceNamespace('climate', {
    Orders: Orders,
    Products: Products,
    Suppliers: Suppliers,
});
const Entitlements = resourceNamespace('entitlements', {
    ActiveEntitlements: ActiveEntitlements,
    Features: Features,
});
const FinancialConnections = resourceNamespace('financialConnections', {
    Accounts: Accounts,
    Sessions: FinancialConnections_Sessions_Sessions,
    Transactions: Transactions_Transactions,
});
const Forwarding = resourceNamespace('forwarding', {
    Requests: Requests,
});
const Identity = resourceNamespace('identity', {
    VerificationReports: VerificationReports,
    VerificationSessions: VerificationSessions,
});
const Issuing = resourceNamespace('issuing', {
    Authorizations: Authorizations_Authorizations,
    Cardholders: Cardholders,
    Cards: Cards_Cards,
    Disputes: Disputes,
    PersonalizationDesigns: PersonalizationDesigns_PersonalizationDesigns,
    PhysicalBundles: PhysicalBundles,
    Tokens: Tokens,
    Transactions: Issuing_Transactions_Transactions,
});
const Radar = resourceNamespace('radar', {
    EarlyFraudWarnings: EarlyFraudWarnings,
    ValueListItems: ValueListItems,
    ValueLists: ValueLists,
});
const Reporting = resourceNamespace('reporting', {
    ReportRuns: ReportRuns,
    ReportTypes: ReportTypes,
});
const Sigma = resourceNamespace('sigma', {
    ScheduledQueryRuns: ScheduledQueryRuns,
});
const Tax = resourceNamespace('tax', {
    Calculations: Calculations,
    Registrations: Registrations,
    Settings: Settings,
    Transactions: Tax_Transactions_Transactions,
});
const Terminal = resourceNamespace('terminal', {
    Configurations: Configurations_Configurations,
    ConnectionTokens: ConnectionTokens,
    Locations: Locations,
    Readers: Readers_Readers,
});
const TestHelpers = resourceNamespace('testHelpers', {
    ConfirmationTokens: ConfirmationTokens,
    Customers: Customers,
    Refunds: Refunds,
    TestClocks: TestClocks,
    Issuing: resourceNamespace('issuing', {
        Authorizations: Authorizations,
        Cards: Cards,
        PersonalizationDesigns: PersonalizationDesigns,
        Transactions: Transactions,
    }),
    Terminal: resourceNamespace('terminal', {
        Readers: Readers,
    }),
    Treasury: resourceNamespace('treasury', {
        InboundTransfers: InboundTransfers,
        OutboundPayments: OutboundPayments,
        OutboundTransfers: OutboundTransfers,
        ReceivedCredits: ReceivedCredits,
        ReceivedDebits: ReceivedDebits,
    }),
});
const Treasury = resourceNamespace('treasury', {
    CreditReversals: CreditReversals,
    DebitReversals: DebitReversals,
    FinancialAccounts: FinancialAccounts,
    InboundTransfers: InboundTransfers_InboundTransfers,
    OutboundPayments: OutboundPayments_OutboundPayments,
    OutboundTransfers: OutboundTransfers_OutboundTransfers,
    ReceivedCredits: ReceivedCredits_ReceivedCredits,
    ReceivedDebits: ReceivedDebits_ReceivedDebits,
    TransactionEntries: TransactionEntries,
    Transactions: Treasury_Transactions_Transactions,
});

;// ../../node_modules/stripe/esm/stripe.core.js









const DEFAULT_HOST = 'api.stripe.com';
const DEFAULT_PORT = '443';
const DEFAULT_BASE_PATH = '/v1/';
const DEFAULT_API_VERSION = ApiVersion;
const DEFAULT_TIMEOUT = 80000;
const MAX_NETWORK_RETRY_DELAY_SEC = 2;
const INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
const APP_INFO_PROPERTIES = ['name', 'version', 'url', 'partner_id'];
const ALLOWED_CONFIG_PROPERTIES = [
    'apiVersion',
    'typescript',
    'maxNetworkRetries',
    'httpAgent',
    'httpClient',
    'timeout',
    'host',
    'port',
    'protocol',
    'telemetry',
    'appInfo',
    'stripeAccount',
];
const defaultRequestSenderFactory = (stripe) => new RequestSender(stripe, StripeResource.MAX_BUFFERED_REQUEST_METRICS);
function createStripe(platformFunctions, requestSender = defaultRequestSenderFactory) {
    Stripe.PACKAGE_VERSION = '16.7.0';
    Stripe.USER_AGENT = Object.assign({ bindings_version: Stripe.PACKAGE_VERSION, lang: 'node', publisher: 'stripe', uname: null, typescript: false }, determineProcessUserAgentProperties());
    Stripe.StripeResource = StripeResource;
    Stripe.resources = resources_namespaceObject;
    Stripe.HttpClient = HttpClient;
    Stripe.HttpClientResponse = HttpClientResponse;
    Stripe.CryptoProvider = CryptoProvider;
    // Previously Stripe.webhooks was just the createWebhooks() factory function
    // however going forward it will be a WebhookObject instance. To maintain
    // backwards compatibility it is currently a factory function that also
    // complies to the WebhookObject signature. The factory function signature
    // will be removed as a breaking change in the next major release.
    // See https://github.com/stripe/stripe-node/issues/1956
    function createWebhooksDefault(fns = platformFunctions) {
        return createWebhooks(fns);
    }
    Stripe.webhooks = Object.assign(createWebhooksDefault, createWebhooks(platformFunctions));
    function Stripe(key, config = {}) {
        if (!(this instanceof Stripe)) {
            return new Stripe(key, config);
        }
        const props = this._getPropsFromConfig(config);
        this._platformFunctions = platformFunctions;
        Object.defineProperty(this, '_emitter', {
            value: this._platformFunctions.createEmitter(),
            enumerable: false,
            configurable: false,
            writable: false,
        });
        this.VERSION = Stripe.PACKAGE_VERSION;
        this.on = this._emitter.on.bind(this._emitter);
        this.once = this._emitter.once.bind(this._emitter);
        this.off = this._emitter.removeListener.bind(this._emitter);
        const agent = props.httpAgent || null;
        this._api = {
            auth: null,
            host: props.host || DEFAULT_HOST,
            port: props.port || DEFAULT_PORT,
            protocol: props.protocol || 'https',
            basePath: DEFAULT_BASE_PATH,
            version: props.apiVersion || DEFAULT_API_VERSION,
            timeout: validateInteger('timeout', props.timeout, DEFAULT_TIMEOUT),
            maxNetworkRetries: validateInteger('maxNetworkRetries', props.maxNetworkRetries, 1),
            agent: agent,
            httpClient: props.httpClient ||
                (agent
                    ? this._platformFunctions.createNodeHttpClient(agent)
                    : this._platformFunctions.createDefaultHttpClient()),
            dev: false,
            stripeAccount: props.stripeAccount || null,
        };
        const typescript = props.typescript || false;
        if (typescript !== Stripe.USER_AGENT.typescript) {
            // The mutation here is uncomfortable, but likely fastest;
            // serializing the user agent involves shelling out to the system,
            // and given some users may instantiate the library many times without switching between TS and non-TS,
            // we only want to incur the performance hit when that actually happens.
            Stripe.USER_AGENT.typescript = typescript;
        }
        if (props.appInfo) {
            this._setAppInfo(props.appInfo);
        }
        this._prepResources();
        this._setApiKey(key);
        this.errors = Error_namespaceObject;
        // Once Stripe.webhooks looses the factory function signature in a future release
        // then this should become this.webhooks = Stripe.webhooks
        this.webhooks = createWebhooksDefault();
        this._prevRequestMetrics = [];
        this._enableTelemetry = props.telemetry !== false;
        this._requestSender = requestSender(this);
        // Expose StripeResource on the instance too
        // @ts-ignore
        this.StripeResource = Stripe.StripeResource;
    }
    Stripe.errors = Error_namespaceObject;
    Stripe.createNodeHttpClient = platformFunctions.createNodeHttpClient;
    /**
     * Creates an HTTP client for issuing Stripe API requests which uses the Web
     * Fetch API.
     *
     * A fetch function can optionally be passed in as a parameter. If none is
     * passed, will default to the default `fetch` function in the global scope.
     */
    Stripe.createFetchHttpClient = platformFunctions.createFetchHttpClient;
    /**
     * Create a CryptoProvider which uses the built-in Node crypto libraries for
     * its crypto operations.
     */
    Stripe.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
    /**
     * Creates a CryptoProvider which uses the Subtle Crypto API from the Web
     * Crypto API spec for its crypto operations.
     *
     * A SubtleCrypto interface can optionally be passed in as a parameter. If none
     * is passed, will default to the default `crypto.subtle` object in the global
     * scope.
     */
    Stripe.createSubtleCryptoProvider =
        platformFunctions.createSubtleCryptoProvider;
    Stripe.prototype = {
        // Properties are set in the constructor above
        _appInfo: undefined,
        on: null,
        off: null,
        once: null,
        VERSION: null,
        StripeResource: null,
        webhooks: null,
        errors: null,
        _api: null,
        _prevRequestMetrics: null,
        _emitter: null,
        _enableTelemetry: null,
        _requestSender: null,
        _platformFunctions: null,
        /**
         * @private
         */
        _setApiKey(key) {
            if (key) {
                this._setApiField('auth', `Bearer ${key}`);
            }
        },
        /**
         * @private
         * This may be removed in the future.
         */
        _setAppInfo(info) {
            if (info && typeof info !== 'object') {
                throw new Error('AppInfo must be an object.');
            }
            if (info && !info.name) {
                throw new Error('AppInfo.name is required');
            }
            info = info || {};
            this._appInfo = APP_INFO_PROPERTIES.reduce((accum, prop) => {
                if (typeof info[prop] == 'string') {
                    accum = accum || {};
                    accum[prop] = info[prop];
                }
                return accum;
            }, 
            // @ts-ignore
            undefined);
        },
        /**
         * @private
         * This may be removed in the future.
         */
        _setApiField(key, value) {
            this._api[key] = value;
        },
        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getApiField(key) {
            return this._api[key];
        },
        setClientId(clientId) {
            this._clientId = clientId;
        },
        getClientId() {
            return this._clientId;
        },
        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getConstant: (c) => {
            switch (c) {
                case 'DEFAULT_HOST':
                    return DEFAULT_HOST;
                case 'DEFAULT_PORT':
                    return DEFAULT_PORT;
                case 'DEFAULT_BASE_PATH':
                    return DEFAULT_BASE_PATH;
                case 'DEFAULT_API_VERSION':
                    return DEFAULT_API_VERSION;
                case 'DEFAULT_TIMEOUT':
                    return DEFAULT_TIMEOUT;
                case 'MAX_NETWORK_RETRY_DELAY_SEC':
                    return MAX_NETWORK_RETRY_DELAY_SEC;
                case 'INITIAL_NETWORK_RETRY_DELAY_SEC':
                    return INITIAL_NETWORK_RETRY_DELAY_SEC;
            }
            return Stripe[c];
        },
        getMaxNetworkRetries() {
            return this.getApiField('maxNetworkRetries');
        },
        /**
         * @private
         * This may be removed in the future.
         */
        _setApiNumberField(prop, n, defaultVal) {
            const val = validateInteger(prop, n, defaultVal);
            this._setApiField(prop, val);
        },
        getMaxNetworkRetryDelay() {
            return MAX_NETWORK_RETRY_DELAY_SEC;
        },
        getInitialNetworkRetryDelay() {
            return INITIAL_NETWORK_RETRY_DELAY_SEC;
        },
        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         *
         * Gets a JSON version of a User-Agent and uses a cached version for a slight
         * speed advantage.
         */
        getClientUserAgent(cb) {
            return this.getClientUserAgentSeeded(Stripe.USER_AGENT, cb);
        },
        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         *
         * Gets a JSON version of a User-Agent by encoding a seeded object and
         * fetching a uname from the system.
         */
        getClientUserAgentSeeded(seed, cb) {
            this._platformFunctions.getUname().then((uname) => {
                var _a;
                const userAgent = {};
                for (const field in seed) {
                    if (!Object.prototype.hasOwnProperty.call(seed, field)) {
                        continue;
                    }
                    userAgent[field] = encodeURIComponent((_a = seed[field]) !== null && _a !== void 0 ? _a : 'null');
                }
                // URI-encode in case there are unusual characters in the system's uname.
                userAgent.uname = encodeURIComponent(uname || 'UNKNOWN');
                const client = this.getApiField('httpClient');
                if (client) {
                    userAgent.httplib = encodeURIComponent(client.getClientName());
                }
                if (this._appInfo) {
                    userAgent.application = this._appInfo;
                }
                cb(JSON.stringify(userAgent));
            });
        },
        /**
         * @private
         * Please open or upvote an issue at github.com/stripe/stripe-node
         * if you use this, detailing your use-case.
         *
         * It may be deprecated and removed in the future.
         */
        getAppInfoAsString() {
            if (!this._appInfo) {
                return '';
            }
            let formatted = this._appInfo.name;
            if (this._appInfo.version) {
                formatted += `/${this._appInfo.version}`;
            }
            if (this._appInfo.url) {
                formatted += ` (${this._appInfo.url})`;
            }
            return formatted;
        },
        getTelemetryEnabled() {
            return this._enableTelemetry;
        },
        /**
         * @private
         * This may be removed in the future.
         */
        _prepResources() {
            for (const name in resources_namespaceObject) {
                if (!Object.prototype.hasOwnProperty.call(resources_namespaceObject, name)) {
                    continue;
                }
                // @ts-ignore
                this[pascalToCamelCase(name)] = new resources_namespaceObject[name](this);
            }
        },
        /**
         * @private
         * This may be removed in the future.
         */
        _getPropsFromConfig(config) {
            // If config is null or undefined, just bail early with no props
            if (!config) {
                return {};
            }
            // config can be an object or a string
            const isString = typeof config === 'string';
            const isObject = config === Object(config) && !Array.isArray(config);
            if (!isObject && !isString) {
                throw new Error('Config must either be an object or a string');
            }
            // If config is a string, we assume the old behavior of passing in a string representation of the api version
            if (isString) {
                return {
                    apiVersion: config,
                };
            }
            // If config is an object, we assume the new behavior and make sure it doesn't contain any unexpected values
            const values = Object.keys(config).filter((value) => !ALLOWED_CONFIG_PROPERTIES.includes(value));
            if (values.length > 0) {
                throw new Error(`Config object may only contain the following: ${ALLOWED_CONFIG_PROPERTIES.join(', ')}`);
            }
            return config;
        },
    };
    return Stripe;
}

;// ../../node_modules/stripe/esm/stripe.esm.node.js


const Stripe = createStripe(new NodePlatformFunctions());
/* harmony default export */ const stripe_esm_node = (Stripe);

// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(711344);
// EXTERNAL MODULE: ../../packages/lib/env.ts
var env = __webpack_require__(333258);
;// ./modules/ee/billing/api/lib/create-customer-portal-session.ts



const createCustomerPortalSession = async (stripeCustomerId, returnUrl)=>{
    if (!env/* env */._.STRIPE_SECRET_KEY) throw new Error("Stripe is not enabled; STRIPE_SECRET_KEY is not set.");
    const stripe = new stripe_esm_node(env/* env */._.STRIPE_SECRET_KEY, {
        apiVersion: constants/* STRIPE_API_VERSION */.Qf
    });
    const session = await stripe.billingPortal.sessions.create({
        customer: stripeCustomerId,
        return_url: returnUrl
    });
    return session.url;
};

// EXTERNAL MODULE: ../../packages/lib/organization/service.ts
var service = __webpack_require__(167440);
;// ./modules/ee/billing/api/lib/create-subscription.ts




const stripe = new stripe_esm_node(env/* env */._.STRIPE_SECRET_KEY, {
    apiVersion: constants/* STRIPE_API_VERSION */.Qf
});
const createSubscription = async (organizationId, environmentId, priceLookupKey)=>{
    try {
        const organization = await (0,service/* getOrganization */.SA)(organizationId);
        if (!organization) throw new Error("Organization not found.");
        let isNewOrganization = !organization.billing.stripeCustomerId || !await stripe.customers.retrieve(organization.billing.stripeCustomerId);
        const priceObject = (await stripe.prices.list({
            lookup_keys: [
                priceLookupKey
            ],
            expand: [
                "data.product"
            ]
        })).data[0];
        if (!priceObject) throw new Error("Price not found");
        const responses = parseInt(priceObject.product.metadata.responses);
        const miu = parseInt(priceObject.product.metadata.miu);
        const checkoutSessionCreateParams = {
            mode: "subscription",
            line_items: [
                {
                    price: priceObject.id,
                    quantity: 1
                }
            ],
            success_url: `${constants/* WEBAPP_URL */.YW}/billing-confirmation?environmentId=${environmentId}`,
            cancel_url: `${constants/* WEBAPP_URL */.YW}/environments/${environmentId}/settings/billing`,
            allow_promotion_codes: true,
            subscription_data: {
                metadata: {
                    organizationId
                },
                trial_period_days: 30
            },
            metadata: {
                organizationId,
                responses,
                miu
            },
            billing_address_collection: "required",
            automatic_tax: {
                enabled: true
            },
            tax_id_collection: {
                enabled: true
            },
            payment_method_data: {
                allow_redisplay: "always"
            },
            ...!isNewOrganization && {
                customer: organization.billing.stripeCustomerId ?? undefined
            }
        };
        // if the organization has never purchased a plan then we just create a new session and store their stripe customer id
        if (isNewOrganization) {
            const session = await stripe.checkout.sessions.create(checkoutSessionCreateParams);
            return {
                status: 200,
                data: "Your Plan has been upgraded!",
                newPlan: true,
                url: session.url
            };
        }
        const existingSubscription = await stripe.subscriptions.list({
            customer: organization.billing.stripeCustomerId
        });
        if (existingSubscription.data?.length > 0) {
            const existingSubscriptionItem = existingSubscription.data[0].items.data[0];
            await stripe.subscriptions.update(existingSubscription.data[0].id, {
                items: [
                    {
                        id: existingSubscriptionItem.id,
                        deleted: true
                    },
                    {
                        price: priceObject.id
                    }
                ],
                cancel_at_period_end: false
            });
        } else {
            // Create a new checkout again if there is no active subscription
            const session = await stripe.checkout.sessions.create(checkoutSessionCreateParams);
            return {
                status: 200,
                data: "Your Plan has been upgraded!",
                newPlan: true,
                url: session.url
            };
        }
        return {
            status: 200,
            data: "Congrats! Added to your existing subscription!",
            newPlan: false,
            url: ""
        };
    } catch (err) {
        console.error(err);
        return {
            status: 500,
            newPlan: true,
            url: `${constants/* WEBAPP_URL */.YW}/environments/${environmentId}/settings/billing`
        };
    }
};

;// ./modules/ee/billing/api/lib/is-subscription-cancelled.ts




const is_subscription_cancelled_stripe = new stripe_esm_node(env/* env */._.STRIPE_SECRET_KEY, {
    apiVersion: constants/* STRIPE_API_VERSION */.Qf
});
const isSubscriptionCancelled = async (organizationId)=>{
    try {
        const organization = await (0,service/* getOrganization */.SA)(organizationId);
        if (!organization) throw new Error("Team not found.");
        let isNewTeam = !organization.billing.stripeCustomerId || !await is_subscription_cancelled_stripe.customers.retrieve(organization.billing.stripeCustomerId);
        if (!organization.billing.stripeCustomerId || isNewTeam) {
            return {
                cancelled: false,
                date: null
            };
        }
        const subscriptions = await is_subscription_cancelled_stripe.subscriptions.list({
            customer: organization.billing.stripeCustomerId
        });
        for (const subscription of subscriptions.data){
            if (subscription.cancel_at_period_end) {
                return {
                    cancelled: true,
                    date: new Date(subscription.current_period_end * 1000)
                };
            }
        }
        return {
            cancelled: false,
            date: null
        };
    } catch (err) {
        console.error(err);
        return {
            cancelled: false,
            date: null
        };
    }
};

// EXTERNAL MODULE: ../../node_modules/zod/lib/index.mjs
var zod_lib = __webpack_require__(283131);
// EXTERNAL MODULE: ../../packages/types/common.ts
var common = __webpack_require__(552224);
// EXTERNAL MODULE: ../../packages/types/errors.ts
var errors = __webpack_require__(207798);
// EXTERNAL MODULE: ../../node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-validate.js
var action_validate = __webpack_require__(429931);
;// ./modules/ee/billing/actions.ts
/* __next_internal_action_entry_do_not_use__ {"7f15a06cafa02202d058a229589bc5849174431c21":"upgradePlanAction","7f22bcd1cba0973c81b3501a43addbccaa9f8765f0":"isSubscriptionCancelledAction","7f7d81830975711a8e55e0ea6784b77d5e43a02392":"manageSubscriptionAction"} */ 













const ZUpgradePlanAction = zod_lib.z.object({
    environmentId: common/* ZId */.i4,
    priceLookupKey: zod_lib.z.nativeEnum(constants/* STRIPE_PRICE_LOOKUP_KEYS */.Ui)
});
const /*#__TURBOPACK_DISABLE_EXPORT_MERGING__*/ upgradePlanAction = action_client/* authenticatedActionClient */.D.schema(ZUpgradePlanAction).action(async ({ ctx, parsedInput })=>{
    const organizationId = await (0,helper/* getOrganizationIdFromEnvironmentId */.X_)(parsedInput.environmentId);
    await (0,action_client_middleware/* checkAuthorizationUpdated */.r)({
        userId: ctx.user.id,
        organizationId,
        access: [
            {
                type: "organization",
                roles: [
                    "owner",
                    "manager",
                    "billing"
                ]
            }
        ]
    });
    return await createSubscription(organizationId, parsedInput.environmentId, parsedInput.priceLookupKey);
});
const ZManageSubscriptionAction = zod_lib.z.object({
    environmentId: common/* ZId */.i4
});
const /*#__TURBOPACK_DISABLE_EXPORT_MERGING__*/ manageSubscriptionAction = action_client/* authenticatedActionClient */.D.schema(ZManageSubscriptionAction).action(async ({ ctx, parsedInput })=>{
    const organizationId = await (0,helper/* getOrganizationIdFromEnvironmentId */.X_)(parsedInput.environmentId);
    await (0,action_client_middleware/* checkAuthorizationUpdated */.r)({
        userId: ctx.user.id,
        organizationId,
        access: [
            {
                type: "organization",
                roles: [
                    "owner",
                    "manager",
                    "billing"
                ]
            }
        ]
    });
    const organization = await (0,service/* getOrganization */.SA)(organizationId);
    if (!organization) {
        throw new errors/* ResourceNotFoundError */.CE("organization", organizationId);
    }
    if (!organization.billing.stripeCustomerId) {
        throw new errors/* AuthorizationError */.yi("You do not have an associated Stripe CustomerId");
    }
    return await createCustomerPortalSession(organization.billing.stripeCustomerId, `${constants/* WEBAPP_URL */.YW}/environments/${parsedInput.environmentId}/settings/billing`);
});
const ZIsSubscriptionCancelledAction = zod_lib.z.object({
    organizationId: common/* ZId */.i4
});
const /*#__TURBOPACK_DISABLE_EXPORT_MERGING__*/ isSubscriptionCancelledAction = action_client/* authenticatedActionClient */.D.schema(ZIsSubscriptionCancelledAction).action(async ({ ctx, parsedInput })=>{
    await (0,action_client_middleware/* checkAuthorizationUpdated */.r)({
        userId: ctx.user.id,
        organizationId: parsedInput.organizationId,
        access: [
            {
                type: "organization",
                roles: [
                    "owner",
                    "manager",
                    "billing"
                ]
            }
        ]
    });
    return await isSubscriptionCancelled(parsedInput.organizationId);
});

(0,action_validate/* ensureServerEntryExports */.D)([
    upgradePlanAction,
    manageSubscriptionAction,
    isSubscriptionCancelledAction
]);
(0,server_reference/* registerServerReference */.A)(upgradePlanAction, "7f15a06cafa02202d058a229589bc5849174431c21", null);
(0,server_reference/* registerServerReference */.A)(manageSubscriptionAction, "7f7d81830975711a8e55e0ea6784b77d5e43a02392", null);
(0,server_reference/* registerServerReference */.A)(isSubscriptionCancelledAction, "7f22bcd1cba0973c81b3501a43addbccaa9f8765f0", null);

;// ../../node_modules/next/dist/build/webpack/loaders/next-flight-action-entry-loader.js?actions=%5B%5B%22%2FUsers%2Fkdy1%2Fprojects%2Fformbricks%2Fapps%2Fweb%2Fapp%2F(app)%2Fenvironments%2F%5BenvironmentId%5D%2Factions%2Factions.ts%22%2C%5B%5B%227f2431fc3b8c6c124a1868f9a0b34d77983cdb9649%22%2C%22getLatestStableFbReleaseAction%22%5D%2C%5B%227f24b3d27813511aef08364975a20983e61a3dde87%22%2C%22getActiveInactiveSurveysAction%22%5D%2C%5B%227f607ac975565ce495ac2952cf2bd35183ca9684ec%22%2C%22updateActionClassAction%22%5D%2C%5B%227f82763127a11eaaa934ce7fb0ffd1f148bfd60c06%22%2C%22deleteActionClassAction%22%5D%5D%5D%2C%5B%22%2FUsers%2Fkdy1%2Fprojects%2Fformbricks%2Fapps%2Fweb%2Flib%2Futils%2Fservices.ts%22%2C%5B%5B%227f11f2efac37ac84796e6cb223722dbe2e808e177f%22%2C%22getResponse%22%5D%2C%5B%227f12957c3365cc2950bdc48f0118f82439eb6c23ec%22%2C%22getSurvey%22%5D%2C%5B%227f20db167926d501ff62b9525526548773c8a436d4%22%2C%22isTeamPartOfOrganization%22%5D%2C%5B%227f36cf02b548a01d85112f587591e8c1e8390fa538%22%2C%22isProjectPartOfOrganization%22%5D%2C%5B%227f4f2c9c8b657cf906e9a25e65dafac6ec65967916%22%2C%22getWebhook%22%5D%2C%5B%227f540889be00b7aa8c6ff1edc5cd79ece876954fd3%22%2C%22getInvite%22%5D%2C%5B%227f60061b4b6be335eaa2facd1c5d8129b87f6923f4%22%2C%22getActionClass%22%5D%2C%5B%227f670a0537f96de8b5156e1b206124b2a990484370%22%2C%22getApiKey%22%5D%2C%5B%227f74bd40a1f82de833915085152910f3ebd525b356%22%2C%22getTeam%22%5D%2C%5B%227fb9a3e6cbebea226c9a3678f31bfebf532ca7321e%22%2C%22getResponseNote%22%5D%2C%5B%227fc5117c6d27e507a6efd4e11ff01afa8b3c52f1a1%22%2C%22getTag%22%5D%2C%5B%227fc6abb0838b6422ef7e81141fd6603883cd1990cf%22%2C%22getDocument%22%5D%2C%5B%227fc856fe5dd5f698d2f54dacf4280d447336780427%22%2C%22getLanguage%22%5D%2C%5B%227fcda0e6bf50febdf861015e25ebdf74068a488dde%22%2C%22getContact%22%5D%2C%5B%227fcfea9518c327899180b23cb3055005ba65cdef33%22%2C%22getIntegration%22%5D%2C%5B%227fdb06c584a2145e0f48be9ead409fc7f774731fde%22%2C%22getEnvironment%22%5D%2C%5B%227fdcbaf3445e783557d350b55d91be1398fafca7d3%22%2C%22getInsight%22%5D%2C%5B%227fe763f2c0d5f307cc75c26f23c693a54ac24a3112%22%2C%22getProject%22%5D%2C%5B%227ffb22c619704253744e9b5fea4eccca8b0808fb64%22%2C%22getSegment%22%5D%5D%5D%2C%5B%22%2FUsers%2Fkdy1%2Fprojects%2Fformbricks%2Fapps%2Fweb%2Fmodules%2Forganization%2Factions.ts%22%2C%5B%5B%227ff27151c29d7402abd744ae983a2c25b016ccf26f%22%2C%22createOrganizationAction%22%5D%5D%5D%2C%5B%22%2FUsers%2Fkdy1%2Fprojects%2Fformbricks%2Fapps%2Fweb%2Fmodules%2Fee%2Fbilling%2Factions.ts%22%2C%5B%5B%227f15a06cafa02202d058a229589bc5849174431c21%22%2C%22upgradePlanAction%22%5D%2C%5B%227f22bcd1cba0973c81b3501a43addbccaa9f8765f0%22%2C%22isSubscriptionCancelledAction%22%5D%2C%5B%227f7d81830975711a8e55e0ea6784b77d5e43a02392%22%2C%22manageSubscriptionAction%22%5D%5D%5D%5D&__client_imported__=true!






























/***/ }),

/***/ 199200:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 841068));
;
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 219668));


/***/ }),

/***/ 28576:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 928404));
;
Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 317381));


/***/ }),

/***/ 566567:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 841068));


/***/ }),

/***/ 348415:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 928404));


/***/ }),

/***/ 587032:
/***/ (() => {



/***/ }),

/***/ 580408:
/***/ (() => {



/***/ }),

/***/ 928404:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrganizationSettingsNavbar: () => (/* binding */ OrganizationSettingsNavbar)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642725);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_ui_components_secondary_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(630785);
/* harmony import */ var _tolgee_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(397674);
/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(470207);
/* harmony import */ var _formbricks_lib_membership_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100274);
/* __next_internal_client_entry_do_not_use__ OrganizationSettingsNavbar auto */ 




const OrganizationSettingsNavbar = ({ environmentId, isFormbricksCloud, membershipRole, activeId, loading })=>{
    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.usePathname)();
    const { isMember } = (0,_formbricks_lib_membership_utils__WEBPACK_IMPORTED_MODULE_3__/* .getAccessFlags */ .c)(membershipRole);
    const isPricingDisabled = isMember;
    const { t } = (0,_tolgee_react__WEBPACK_IMPORTED_MODULE_4__/* .useTranslate */ .WD)();
    const navigation = [
        {
            id: "general",
            label: t("common.general"),
            href: `/environments/${environmentId}/settings/general`,
            current: pathname?.includes("/general"),
            hidden: false
        },
        {
            id: "billing",
            label: t("common.billing"),
            href: `/environments/${environmentId}/settings/billing`,
            hidden: !isFormbricksCloud || loading,
            current: pathname?.includes("/billing")
        },
        {
            id: "teams",
            label: t("common.teams"),
            href: `/environments/${environmentId}/settings/teams`,
            current: pathname?.includes("/teams")
        },
        {
            id: "enterprise",
            label: t("common.enterprise_license"),
            href: `/environments/${environmentId}/settings/enterprise`,
            hidden: isFormbricksCloud || isPricingDisabled,
            current: pathname?.includes("/enterprise")
        }
    ];
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_modules_ui_components_secondary_navigation__WEBPACK_IMPORTED_MODULE_1__/* .SecondaryNavigation */ .N, {
        navigation: navigation,
        activeId: activeId,
        loading: loading
    });
};


/***/ }),

/***/ 317381:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  PricingTable: () => (/* binding */ PricingTable)
});

// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js
var react_jsx_runtime = __webpack_require__(642725);
// EXTERNAL MODULE: ./modules/ui/components/badge/index.tsx
var badge = __webpack_require__(661989);
// EXTERNAL MODULE: ./modules/ui/components/button/index.tsx
var components_button = __webpack_require__(248852);
// EXTERNAL MODULE: ../../node_modules/@tolgee/react/dist/tolgee-react.esm.js
var tolgee_react_esm = __webpack_require__(397674);
// EXTERNAL MODULE: ../../node_modules/next/dist/api/navigation.js
var navigation = __webpack_require__(470207);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js
var react = __webpack_require__(891616);
// EXTERNAL MODULE: ../../node_modules/react-hot-toast/dist/index.mjs + 1 modules
var dist = __webpack_require__(986090);
// EXTERNAL MODULE: ../../packages/lib/cn.ts
var cn = __webpack_require__(983773);
// EXTERNAL MODULE: ../../packages/lib/utils/strings.ts
var strings = __webpack_require__(92018);
// EXTERNAL MODULE: ../../node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js
var action_client_wrapper = __webpack_require__(308441);
;// ../../node_modules/next/dist/build/webpack/loaders/next-flight-server-reference-proxy-loader.js?id=7f22bcd1cba0973c81b3501a43addbccaa9f8765f0&name=isSubscriptionCancelledAction!

const isSubscriptionCancelledAction = /*#__PURE__*/(0,action_client_wrapper.createServerReference)("7f22bcd1cba0973c81b3501a43addbccaa9f8765f0", action_client_wrapper.callServer, undefined, action_client_wrapper.findSourceMapURL, "isSubscriptionCancelledAction")
;// ../../node_modules/next/dist/build/webpack/loaders/next-flight-server-reference-proxy-loader.js?id=7f7d81830975711a8e55e0ea6784b77d5e43a02392&name=manageSubscriptionAction!

const manageSubscriptionAction = /*#__PURE__*/(0,action_client_wrapper.createServerReference)("7f7d81830975711a8e55e0ea6784b77d5e43a02392", action_client_wrapper.callServer, undefined, action_client_wrapper.findSourceMapURL, "manageSubscriptionAction")
;// ../../node_modules/next/dist/build/webpack/loaders/next-flight-server-reference-proxy-loader.js?id=7f15a06cafa02202d058a229589bc5849174431c21&name=upgradePlanAction!

const upgradePlanAction = /*#__PURE__*/(0,action_client_wrapper.createServerReference)("7f15a06cafa02202d058a229589bc5849174431c21", action_client_wrapper.callServer, undefined, action_client_wrapper.findSourceMapURL, "upgradePlanAction")
;// ./modules/ee/billing/api/lib/constants.ts
const getCloudPricingData = (t)=>{
    return {
        plans: [
            {
                name: t("environments.settings.billing.free"),
                id: "free",
                featured: false,
                description: t("environments.settings.billing.free_description"),
                price: {
                    monthly: "$0",
                    yearly: "$0"
                },
                mainFeatures: [
                    t("environments.settings.billing.unlimited_surveys"),
                    t("environments.settings.billing.unlimited_team_members"),
                    t("environments.settings.billing.3_projects"),
                    t("environments.settings.billing.1500_monthly_responses"),
                    t("environments.settings.billing.2000_monthly_identified_users"),
                    t("environments.settings.billing.website_surveys"),
                    t("environments.settings.billing.app_surveys"),
                    t("environments.settings.billing.unlimited_apps_websites"),
                    t("environments.settings.billing.link_surveys"),
                    t("environments.settings.billing.email_embedded_surveys"),
                    t("environments.settings.billing.logic_jumps_hidden_fields_recurring_surveys"),
                    t("environments.settings.billing.api_webhooks"),
                    t("environments.settings.billing.all_integrations"),
                    t("environments.settings.billing.all_surveying_features")
                ],
                href: "https://app.formbricks.com/auth/signup?plan=free"
            },
            {
                name: t("environments.settings.billing.startup"),
                id: "startup",
                featured: false,
                description: t("environments.settings.billing.startup_description"),
                price: {
                    monthly: "$39",
                    yearly: "$390 "
                },
                mainFeatures: [
                    t("environments.settings.billing.everything_in_free"),
                    t("environments.settings.billing.unlimited_surveys"),
                    t("environments.settings.billing.remove_branding"),
                    t("environments.settings.billing.email_support"),
                    t("environments.settings.billing.3_projects"),
                    t("environments.settings.billing.5000_monthly_responses"),
                    t("environments.settings.billing.7500_monthly_identified_users")
                ],
                href: "https://app.formbricks.com/auth/signup?plan=startup"
            },
            {
                name: t("environments.settings.billing.scale"),
                id: "scale",
                featured: true,
                description: t("environments.settings.billing.scale_description"),
                price: {
                    monthly: "$149",
                    yearly: "$1,490"
                },
                mainFeatures: [
                    t("environments.settings.billing.everything_in_startup"),
                    t("environments.settings.billing.team_access_roles"),
                    t("environments.settings.billing.multi_language_surveys"),
                    t("environments.settings.billing.advanced_targeting"),
                    t("environments.settings.billing.priority_support"),
                    t("environments.settings.billing.5_projects"),
                    t("environments.settings.billing.10000_monthly_responses"),
                    t("environments.settings.billing.30000_monthly_identified_users")
                ],
                href: "https://app.formbricks.com/auth/signup?plan=scale"
            },
            {
                name: t("environments.settings.billing.enterprise"),
                id: "enterprise",
                featured: false,
                description: t("environments.settings.billing.enterprise_description"),
                price: {
                    monthly: t("environments.settings.billing.say_hi"),
                    yearly: t("environments.settings.billing.say_hi")
                },
                mainFeatures: [
                    t("environments.settings.billing.everything_in_scale"),
                    t("environments.settings.billing.custom_project_limit"),
                    t("environments.settings.billing.custom_miu_limit"),
                    t("environments.settings.billing.premium_support_with_slas"),
                    t("environments.settings.billing.uptime_sla_99"),
                    t("environments.settings.billing.customer_success_manager"),
                    t("environments.settings.billing.technical_onboarding")
                ],
                href: "https://cal.com/johannes/enterprise-cloud"
            }
        ]
    };
};

// EXTERNAL MODULE: ../../node_modules/@radix-ui/react-slider/dist/index.mjs
var react_slider_dist = __webpack_require__(90141);
;// ./modules/ee/billing/components/billing-slider.tsx
/* __next_internal_client_entry_do_not_use__ BillingSlider auto */ 




const BillingSlider = /*#__PURE__*/ react.forwardRef(({ className, value, max, freeTierLimit, metric, ...props }, ref)=>{
    const { t } = (0,tolgee_react_esm/* useTranslate */.WD)();
    return /*#__PURE__*/ (0,react_jsx_runtime.jsxs)(react_slider_dist/* Root */.bL, {
        ref: ref,
        className: (0,cn.cn)("relative flex w-full touch-none select-none items-center", className),
        ...props,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)(react_slider_dist/* Track */.CC, {
                className: "relative h-2 w-full grow overflow-hidden rounded-r-full bg-slate-300",
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                        style: {
                            width: `calc(${Math.min(value / max, 0.93) * 100}%)`
                        },
                        className: "absolute h-full bg-slate-800"
                    }),
                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                        style: {
                            width: `${(freeTierLimit - value) / max * 100}%`,
                            left: `${value / max * 100}%`
                        },
                        className: "absolute h-full bg-slate-400"
                    })
                ]
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                style: {
                    left: `calc(${Math.min(value / max, 0.93) * 100}%)`
                },
                className: "absolute mt-4 h-6 w-px bg-slate-400"
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                style: {
                    left: `calc(${Math.min(value / max, 0.93) * 100}% + 0.5rem)`
                },
                className: "absolute mt-16 text-sm text-slate-700 dark:text-slate-200",
                children: /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("p", {
                    className: "text-xs",
                    children: [
                        t("environments.settings.billing.current"),
                        ":",
                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)("br", {}),
                        value,
                        " ",
                        metric
                    ]
                })
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                style: {
                    left: `${freeTierLimit / max * 100}%`
                },
                className: "absolute mt-4 h-6 w-px bg-slate-300"
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                style: {
                    left: `calc(${freeTierLimit / max * 100}% + 0.5rem)`
                },
                className: "absolute mt-16 text-sm text-slate-700",
                children: /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("p", {
                    className: "text-xs",
                    children: [
                        t("environments.settings.billing.current_tier_limit"),
                        ":",
                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)("br", {}),
                        freeTierLimit,
                        " ",
                        metric
                    ]
                })
            })
        ]
    });
});
BillingSlider.displayName = react_slider_dist/* Root */.bL.displayName;

// EXTERNAL MODULE: ./modules/ui/components/confirmation-modal/index.tsx
var confirmation_modal = __webpack_require__(12199);
// EXTERNAL MODULE: ../../node_modules/lucide-react/dist/esm/icons/check.js
var check = __webpack_require__(129170);
;// ./modules/ee/billing/components/pricing-card.tsx
/* __next_internal_client_entry_do_not_use__ PricingCard auto */ 







const PricingCard = ({ planPeriod, plan, onUpgrade, onManageSubscription, organization, projectFeatureKeys })=>{
    const { t } = (0,tolgee_react_esm/* useTranslate */.WD)();
    const [loading, setLoading] = (0,react.useState)(false);
    const [upgradeModalOpen, setUpgradeModalOpen] = (0,react.useState)(false);
    const isCurrentPlan = (0,react.useMemo)(()=>{
        if (organization.billing.plan === projectFeatureKeys.FREE && plan.id === projectFeatureKeys.FREE) {
            return true;
        }
        if (organization.billing.plan === projectFeatureKeys.ENTERPRISE && plan.id === projectFeatureKeys.ENTERPRISE) {
            return true;
        }
        return organization.billing.plan === plan.id && organization.billing.period === planPeriod;
    }, [
        organization.billing.period,
        organization.billing.plan,
        plan.id,
        planPeriod,
        projectFeatureKeys.ENTERPRISE,
        projectFeatureKeys.FREE
    ]);
    const CTAButton = (0,react.useMemo)(()=>{
        if (isCurrentPlan) {
            return null;
        }
        if (plan.id !== projectFeatureKeys.ENTERPRISE && plan.id !== projectFeatureKeys.FREE) {
            if (organization.billing.plan === projectFeatureKeys.FREE) {
                return /*#__PURE__*/ (0,react_jsx_runtime.jsx)(components_button/* Button */.$, {
                    loading: loading,
                    onClick: async ()=>{
                        setLoading(true);
                        await onUpgrade();
                        setLoading(false);
                    },
                    className: "flex justify-center",
                    children: t("common.start_free_trial")
                });
            }
            return /*#__PURE__*/ (0,react_jsx_runtime.jsx)(components_button/* Button */.$, {
                loading: loading,
                onClick: ()=>{
                    setUpgradeModalOpen(true);
                },
                className: "flex justify-center",
                children: t("environments.settings.billing.switch_plan")
            });
        }
        return /*#__PURE__*/ (0,react_jsx_runtime.jsx)(react_jsx_runtime.Fragment, {});
    }, [
        isCurrentPlan,
        loading,
        onUpgrade,
        organization.billing.plan,
        plan.id,
        projectFeatureKeys.ENTERPRISE,
        projectFeatureKeys.FREE
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
        className: (0,cn.cn)(plan.featured ? "z-10 bg-white shadow-lg ring-1 ring-slate-900/10" : "bg-slate-100 ring-1 ring-white/10 lg:bg-transparent lg:pb-8 lg:ring-0", "relative rounded-xl"),
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                className: "p-8 lg:pt-12 xl:p-10 xl:pt-14",
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                        className: "flex gap-x-2",
                        children: [
                            /*#__PURE__*/ (0,react_jsx_runtime.jsx)("h2", {
                                id: plan.id,
                                className: (0,cn.cn)(plan.featured ? "text-slate-900" : "text-slate-800", "text-sm font-semibold leading-6"),
                                children: t(plan.name)
                            }),
                            isCurrentPlan && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(badge/* Badge */.E, {
                                type: "success",
                                size: "normal",
                                text: t("environments.settings.billing.current_plan")
                            })
                        ]
                    }),
                    /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                        className: "flex flex-col items-end gap-6 sm:flex-row sm:justify-between lg:flex-col lg:items-stretch",
                        children: [
                            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                className: "mt-2 flex items-end gap-x-1",
                                children: [
                                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("p", {
                                        className: (0,cn.cn)(plan.featured ? "text-slate-900" : "text-slate-800", "text-4xl font-bold tracking-tight"),
                                        children: plan.id !== projectFeatureKeys.ENTERPRISE ? planPeriod === "monthly" ? plan.price.monthly : plan.price.yearly : t(plan.price.monthly)
                                    }),
                                    plan.name !== "Enterprise" && /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                                        className: "text-sm leading-5",
                                        children: /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("p", {
                                            className: plan.featured ? "text-slate-700" : "text-slate-600",
                                            children: [
                                                "/ ",
                                                planPeriod === "monthly" ? "Month" : "Year"
                                            ]
                                        })
                                    })
                                ]
                            }),
                            CTAButton,
                            plan.id !== projectFeatureKeys.FREE && isCurrentPlan && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(components_button/* Button */.$, {
                                variant: "secondary",
                                loading: loading,
                                onClick: async ()=>{
                                    setLoading(true);
                                    await onManageSubscription();
                                    setLoading(false);
                                },
                                className: "flex justify-center",
                                children: t("environments.settings.billing.manage_subscription")
                            }),
                            organization.billing.plan !== plan.id && plan.id === projectFeatureKeys.ENTERPRISE && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(components_button/* Button */.$, {
                                loading: loading,
                                onClick: ()=>onUpgrade(),
                                className: "flex justify-center",
                                children: t("environments.settings.billing.contact_us")
                            })
                        ]
                    }),
                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                        className: "mt-8 flow-root sm:mt-10",
                        children: /*#__PURE__*/ (0,react_jsx_runtime.jsx)("ul", {
                            role: "list",
                            className: (0,cn.cn)(plan.featured ? "divide-slate-900/5 border-slate-900/5 text-slate-600" : "divide-white/5 border-white/5 text-slate-800", "-my-2 divide-y border-t text-sm leading-6 lg:border-t-0"),
                            children: plan.mainFeatures.map((mainFeature)=>/*#__PURE__*/ (0,react_jsx_runtime.jsxs)("li", {
                                    className: "flex gap-x-3 py-2",
                                    children: [
                                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)(check/* default */.A, {
                                            className: (0,cn.cn)(plan.featured ? "text-brand-dark" : "text-slate-500", "h-6 w-5 flex-none"),
                                            "aria-hidden": "true"
                                        }),
                                        t(mainFeature)
                                    ]
                                }, mainFeature))
                        })
                    })
                ]
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)(confirmation_modal/* ConfirmationModal */.R, {
                title: t("environments.settings.billing.switch_plan"),
                buttonText: t("common.confirm"),
                onConfirm: async ()=>{
                    setLoading(true);
                    await onUpgrade();
                    setLoading(false);
                    setUpgradeModalOpen(false);
                },
                open: upgradeModalOpen,
                setOpen: setUpgradeModalOpen,
                text: t("environments.settings.billing.switch_plan_confirmation_text", {
                    plan: t(plan.name),
                    price: planPeriod === "monthly" ? plan.price.monthly : plan.price.yearly
                }),
                buttonVariant: "default",
                buttonLoading: loading,
                closeOnOutsideClick: false,
                hideCloseButton: true
            })
        ]
    }, plan.id);
};

;// ./modules/ee/billing/components/pricing-table.tsx
/* __next_internal_client_entry_do_not_use__ PricingTable auto */ 












const PricingTable = ({ environmentId, organization, peopleCount, projectFeatureKeys, responseCount, projectCount, stripePriceLookupKeys, hasBillingRights })=>{
    const { t } = (0,tolgee_react_esm/* useTranslate */.WD)();
    const [planPeriod, setPlanPeriod] = (0,react.useState)(organization.billing.period ?? "monthly");
    const handleMonthlyToggle = (period)=>{
        setPlanPeriod(period);
    };
    const router = (0,navigation.useRouter)();
    const [cancellingOn, setCancellingOn] = (0,react.useState)(null);
    (0,react.useEffect)(()=>{
        const checkSubscriptionStatus = async ()=>{
            const isSubscriptionCancelledResponse = await isSubscriptionCancelledAction({
                organizationId: organization.id
            });
            if (isSubscriptionCancelledResponse?.data) {
                setCancellingOn(isSubscriptionCancelledResponse.data.date);
            }
        };
        checkSubscriptionStatus();
    }, [
        organization.id
    ]);
    const openCustomerPortal = async ()=>{
        const manageSubscriptionResponse = await manageSubscriptionAction({
            environmentId
        });
        if (manageSubscriptionResponse?.data) {
            router.push(manageSubscriptionResponse.data);
        }
    };
    const upgradePlan = async (priceLookupKey)=>{
        try {
            const upgradePlanResponse = await upgradePlanAction({
                environmentId,
                priceLookupKey
            });
            if (!upgradePlanResponse?.data) {
                throw new Error(t("common.something_went_wrong_please_try_again"));
            }
            const { status, newPlan, url } = upgradePlanResponse.data;
            if (status != 200) {
                throw new Error(t("common.something_went_wrong_please_try_again"));
            }
            if (!newPlan) {
                dist/* default */.Ay.success(t("environments.settings.billing.plan_upgraded_successfully"));
            } else if (newPlan && url) {
                router.push(url);
            } else {
                throw new Error(t("common.something_went_wrong_please_try_again"));
            }
        } catch (err) {
            dist/* default */.Ay.error(t("environments.settings.billing.unable_to_upgrade_plan"));
        }
    };
    const onUpgrade = async (planId)=>{
        if (planId === "scale") {
            await upgradePlan(planPeriod === "monthly" ? stripePriceLookupKeys.SCALE_MONTHLY : stripePriceLookupKeys.SCALE_YEARLY);
            return;
        }
        if (planId === "startup") {
            await upgradePlan(planPeriod === "monthly" ? stripePriceLookupKeys.STARTUP_MONTHLY : stripePriceLookupKeys.STARTUP_YEARLY);
            return;
        }
        if (planId === "enterprise") {
            window.location.href = "https://cal.com/johannes/license";
            return;
        }
        if (planId === "free") {
            dist/* default */.Ay.error(t("environments.settings.billing.everybody_has_the_free_plan_by_default"));
            return;
        }
    };
    const responsesUnlimitedCheck = organization.billing.plan === "enterprise" && organization.billing.limits.monthly.responses === null;
    const peopleUnlimitedCheck = organization.billing.plan === "enterprise" && organization.billing.limits.monthly.miu === null;
    const projectsUnlimitedCheck = organization.billing.plan === "enterprise" && organization.billing.limits.projects === null;
    return /*#__PURE__*/ (0,react_jsx_runtime.jsx)("main", {
        children: /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
            className: "flex flex-col gap-8",
            children: [
                /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                    className: "flex flex-col",
                    children: [
                        /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                            className: "flex w-full",
                            children: [
                                /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("h2", {
                                    className: "mb-3 mr-2 inline-flex w-full text-2xl font-bold text-slate-700",
                                    children: [
                                        t("environments.settings.billing.current_plan"),
                                        ":",
                                        " ",
                                        (0,strings/* capitalizeFirstLetter */.Zr)(organization.billing.plan),
                                        cancellingOn && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(badge/* Badge */.E, {
                                            className: "mx-2",
                                            size: "normal",
                                            type: "warning",
                                            text: `Cancelling: ${cancellingOn ? cancellingOn.toDateString() : ""}`
                                        })
                                    ]
                                }),
                                organization.billing.stripeCustomerId && organization.billing.plan === "free" && /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                                    className: "flex w-full justify-end",
                                    children: /*#__PURE__*/ (0,react_jsx_runtime.jsx)(components_button/* Button */.$, {
                                        size: "sm",
                                        variant: "secondary",
                                        className: "justify-center py-2 shadow-sm",
                                        onClick: openCustomerPortal,
                                        children: t("environments.settings.billing.manage_card_details")
                                    })
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                            className: "mt-2 flex flex-col rounded-xl border border-slate-200 bg-white py-4 capitalize shadow-sm dark:bg-slate-800",
                            children: [
                                /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                    className: (0,cn.cn)("relative mx-8 mb-8 flex flex-col gap-4", responsesUnlimitedCheck && "mb-0 flex-row"),
                                    children: [
                                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)("p", {
                                            className: "text-md font-semibold text-slate-700",
                                            children: t("common.responses")
                                        }),
                                        organization.billing.limits.monthly.responses && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(BillingSlider, {
                                            className: "slider-class mb-8",
                                            value: responseCount,
                                            max: organization.billing.limits.monthly.responses * 1.5,
                                            freeTierLimit: organization.billing.limits.monthly.responses,
                                            metric: t("common.responses")
                                        }),
                                        responsesUnlimitedCheck && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(badge/* Badge */.E, {
                                            type: "success",
                                            size: "normal",
                                            text: t("environments.settings.billing.unlimited_responses")
                                        })
                                    ]
                                }),
                                /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                    className: (0,cn.cn)("relative mx-8 mb-8 flex flex-col gap-4", peopleUnlimitedCheck && "mb-0 mt-4 flex-row pb-0"),
                                    children: [
                                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)("p", {
                                            className: "text-md font-semibold text-slate-700",
                                            children: t("environments.settings.billing.monthly_identified_users")
                                        }),
                                        organization.billing.limits.monthly.miu && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(BillingSlider, {
                                            className: "slider-class mb-8",
                                            value: peopleCount,
                                            max: organization.billing.limits.monthly.miu * 1.5,
                                            freeTierLimit: organization.billing.limits.monthly.miu,
                                            metric: "MIU"
                                        }),
                                        peopleUnlimitedCheck && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(badge/* Badge */.E, {
                                            type: "success",
                                            size: "normal",
                                            text: t("environments.settings.billing.unlimited_miu")
                                        })
                                    ]
                                }),
                                /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                    className: (0,cn.cn)("relative mx-8 flex flex-col gap-4 pb-12", projectsUnlimitedCheck && "mb-0 mt-4 flex-row pb-0"),
                                    children: [
                                        /*#__PURE__*/ (0,react_jsx_runtime.jsx)("p", {
                                            className: "text-md font-semibold text-slate-700",
                                            children: t("common.projects")
                                        }),
                                        organization.billing.limits.projects && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(BillingSlider, {
                                            className: "slider-class mb-8",
                                            value: projectCount,
                                            max: organization.billing.limits.projects * 1.5,
                                            freeTierLimit: organization.billing.limits.projects,
                                            metric: t("common.projects")
                                        }),
                                        projectsUnlimitedCheck && /*#__PURE__*/ (0,react_jsx_runtime.jsx)(badge/* Badge */.E, {
                                            type: "success",
                                            size: "normal",
                                            text: t("environments.settings.billing.unlimited_projects")
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                hasBillingRights && /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                    className: "mx-auto mb-12",
                    children: /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                        className: "gap-x-2",
                        children: [
                            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                className: "mb-4 flex w-fit cursor-pointer overflow-hidden rounded-lg border border-slate-200 p-1 lg:mb-0",
                                children: [
                                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                                        className: `flex-1 rounded-md px-4 py-0.5 text-center ${planPeriod === "monthly" ? "bg-slate-200 font-semibold" : "bg-transparent"}`,
                                        onClick: ()=>handleMonthlyToggle("monthly"),
                                        children: t("environments.settings.billing.monthly")
                                    }),
                                    /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                        className: `flex-1 items-center whitespace-nowrap rounded-md py-0.5 pl-4 pr-2 text-center ${planPeriod === "yearly" ? "bg-slate-200 font-semibold" : "bg-transparent"}`,
                                        onClick: ()=>handleMonthlyToggle("yearly"),
                                        children: [
                                            t("environments.settings.billing.annually"),
                                            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("span", {
                                                className: "ml-2 inline-flex items-center rounded-full border border-green-200 bg-green-100 px-2.5 py-0.5 text-xs font-medium text-green-800",
                                                children: [
                                                    t("environments.settings.billing.get_2_months_free"),
                                                    " \uD83D\uDD25"
                                                ]
                                            })
                                        ]
                                    })
                                ]
                            }),
                            /*#__PURE__*/ (0,react_jsx_runtime.jsxs)("div", {
                                className: "relative mx-auto grid max-w-md grid-cols-1 gap-y-8 lg:mx-0 lg:-mb-14 lg:max-w-none lg:grid-cols-4",
                                children: [
                                    /*#__PURE__*/ (0,react_jsx_runtime.jsx)("div", {
                                        className: "hidden lg:absolute lg:inset-x-px lg:bottom-0 lg:top-4 lg:block lg:rounded-xl lg:rounded-t-2xl lg:border lg:border-slate-200 lg:bg-slate-100 lg:pb-8 lg:ring-1 lg:ring-white/10",
                                        "aria-hidden": "true"
                                    }),
                                    getCloudPricingData(t).plans.map((plan)=>/*#__PURE__*/ (0,react_jsx_runtime.jsx)(PricingCard, {
                                            planPeriod: planPeriod,
                                            plan: plan,
                                            onUpgrade: async ()=>{
                                                await onUpgrade(plan.id);
                                            },
                                            organization: organization,
                                            projectFeatureKeys: projectFeatureKeys,
                                            onManageSubscription: openCustomerPortal
                                        }, plan.id))
                                ]
                            })
                        ]
                    })
                })
            ]
        })
    });
};


/***/ }),

/***/ 661989:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ Badge)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642725);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(983773);


const Badge = ({ text, type, size, className })=>{
    const bgColor = {
        warning: "bg-amber-100",
        success: "bg-emerald-100",
        error: "bg-red-100",
        gray: "bg-slate-100"
    };
    const borderColor = {
        warning: "border-amber-200",
        success: "border-emerald-200",
        error: "border-red-200",
        gray: "border-slate-200"
    };
    const textColor = {
        warning: "text-amber-800",
        success: "text-emerald-800",
        error: "text-red-800",
        gray: "text-slate-600"
    };
    const padding = {
        tiny: "px-1.5 py-0.5",
        normal: "px-2.5 py-0.5",
        large: "px-3.5 py-1"
    };
    const textSize = size === "large" ? "text-sm" : "text-xs";
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", {
        className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__.cn)("inline-flex cursor-default items-center rounded-full border font-medium", bgColor[type], borderColor[type], textColor[type], padding[size], textSize, className),
        children: text
    });
};


/***/ }),

/***/ 12199:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ ConfirmationModal)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642725);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_ui_components_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(248852);
/* harmony import */ var _modules_ui_components_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(383207);
/* harmony import */ var _tolgee_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(397674);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(891616);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* __next_internal_client_entry_do_not_use__ ConfirmationModal auto */ 




const ConfirmationModal = ({ title, onConfirm, open, setOpen, text, buttonText, isButtonDisabled = false, buttonVariant = "destructive", buttonLoading = false, closeOnOutsideClick = true, hideCloseButton })=>{
    const { t } = (0,_tolgee_react__WEBPACK_IMPORTED_MODULE_4__/* .useTranslate */ .WD)();
    const handleButtonAction = async ()=>{
        if (isButtonDisabled) return;
        await onConfirm();
    };
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_modules_ui_components_modal__WEBPACK_IMPORTED_MODULE_2__/* .Modal */ .a, {
        open: open,
        setOpen: setOpen,
        title: title,
        hideCloseButton: hideCloseButton,
        closeOnOutsideClick: closeOnOutsideClick,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                className: "text-slate-900",
                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", {
                    className: "mt-2 whitespace-pre-wrap",
                    children: text
                })
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                className: "mt-4 space-x-2 text-right",
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_modules_ui_components_button__WEBPACK_IMPORTED_MODULE_1__/* .Button */ .$, {
                        variant: "ghost",
                        onClick: ()=>setOpen(false),
                        children: t("common.cancel")
                    }),
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_modules_ui_components_button__WEBPACK_IMPORTED_MODULE_1__/* .Button */ .$, {
                        loading: buttonLoading,
                        disabled: isButtonDisabled,
                        variant: buttonVariant,
                        onClick: handleButtonAction,
                        children: buttonText
                    })
                ]
            })
        ]
    });
};


/***/ }),

/***/ 630785:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ SecondaryNavigation)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(642725);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36888);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(983773);



const SecondaryNavigation = ({ navigation, activeId, loading, ...props })=>{
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        ...props,
        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
            className: "grid h-10 w-full grid-cols-[auto,1fr]",
            children: [
                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("nav", {
                    className: "flex h-full min-w-full items-center space-x-4",
                    "aria-label": "Tabs",
                    children: loading ? navigation.map((navElem)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                            className: "group flex h-full flex-col",
                            children: [
                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    "aria-disabled": "true",
                                    className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__.cn)(navElem.id === activeId ? "font-semibold text-slate-900" : "text-slate-500", "flex h-full items-center px-3 text-sm font-medium", navElem.hidden && "hidden"),
                                    "aria-current": navElem.id === activeId ? "page" : undefined,
                                    children: navElem.label
                                }),
                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__.cn)("bottom-0 mt-auto h-[2px] w-full rounded-t-lg transition-all duration-150 ease-in-out", navElem.id === activeId ? "bg-slate-300" : "bg-transparent group-hover:bg-slate-300", navElem.hidden && "hidden")
                                })
                            ]
                        }, navElem.id)) : navigation.map((navElem)=>!navElem.hidden && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                            className: "group flex h-full flex-col",
                            children: [
                                navElem.href ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {
                                    href: navElem.href,
                                    ...navElem.onClick ? {
                                        onClick: navElem.onClick
                                    } : {},
                                    className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__.cn)(navElem.id === activeId ? "font-semibold text-slate-900" : "text-slate-500 hover:text-slate-700", "flex h-full items-center px-3 text-sm font-medium", navElem.hidden && "hidden"),
                                    "aria-current": navElem.id === activeId ? "page" : undefined,
                                    children: navElem.label
                                }) : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", {
                                    ...navElem.onClick ? {
                                        onClick: navElem.onClick
                                    } : {},
                                    className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__.cn)(navElem.id === activeId ? "font-semibold text-slate-900" : "text-slate-500 hover:text-slate-700", "grow items-center px-3 text-sm font-medium transition-all duration-150 ease-in-out", navElem.hidden && "hidden"),
                                    "aria-current": navElem.id === activeId ? "page" : undefined,
                                    children: navElem.label
                                }),
                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                                    className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_2__.cn)("bottom-0 mt-auto h-[2px] w-full rounded-t-lg transition-all duration-150 ease-in-out", navElem.id === activeId ? "bg-brand-dark" : "bg-transparent group-hover:bg-slate-300", navElem.hidden && "hidden")
                                })
                            ]
                        }, navElem.id))
                }),
                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                    className: "justify-self-end"
                })
            ]
        })
    });
};


/***/ }),

/***/ 844333:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

!function(e,t){if(true)module.exports=t(__webpack_require__(891616));else { var l, r; }}(this,(function(e){return function(e){var t={};function r(l){if(t[l])return t[l].exports;var i=t[l]={i:l,l:!1,exports:{}};return e[l].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,l){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:l})},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var l=Object.create(null);if(r.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(l,i,function(t){return e[t]}.bind(null,i));return l},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/",r(r.s=1)}([function(t,r){t.exports=e},function(e,t,r){e.exports=r(2)},function(e,t,r){"use strict";function l(e,t){if(null==e)return{};var r,l,i=function(e,t){if(null==e)return{};var r,l,i={},a=Object.keys(e);for(l=0;l<a.length;l++)r=a[l],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(l=0;l<a.length;l++)r=a[l],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}r.r(t);var i=r(0),a=r.n(i),n=function(e){for(var t=0,r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t}return Math.abs(t)},c=function(e,t){return Math.floor(e/Math.pow(10,t)%10)},h=function(e,t){return!(c(e,t)%2)},o=function(e,t,r){var l=e%t;return r&&c(e,r)%2===0?-l:l},s=function(e,t,r){return t[e%r]};var f=function(e){var t=e.name,r=e.colors,a=e.title,c=e.square,h=e.size,f=l(e,["name","colors","title","square","size"]),m=function(e,t){var r=n(e),l=t&&t.length;return Array.from({length:3},(function(e,i){return{color:s(r+i,t,l),translateX:o(r*(i+1),8,1),translateY:o(r*(i+1),8,2),scale:1.2+o(r*(i+1),4)/10,rotate:o(r*(i+1),360,1)}}))}(t,r),d=i.useId();return i.createElement("svg",Object.assign({viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:h,height:h},f),a&&i.createElement("title",null,t),i.createElement("mask",{id:d,maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},i.createElement("rect",{width:80,height:80,rx:c?void 0:160,fill:"#FFFFFF"})),i.createElement("g",{mask:"url(#".concat(d,")")},i.createElement("rect",{width:80,height:80,fill:m[0].color}),i.createElement("path",{filter:"url(#filter_".concat(d,")"),d:"M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z",fill:m[1].color,transform:"translate("+m[1].translateX+" "+m[1].translateY+") rotate("+m[1].rotate+" 40 40) scale("+m[2].scale+")"}),i.createElement("path",{filter:"url(#filter_".concat(d,")"),style:{mixBlendMode:"overlay"},d:"M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z",fill:m[2].color,transform:"translate("+m[2].translateX+" "+m[2].translateY+") rotate("+m[2].rotate+" 40 40) scale("+m[2].scale+")"})),i.createElement("defs",null,i.createElement("filter",{id:"filter_".concat(d),filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB"},i.createElement("feFlood",{floodOpacity:0,result:"BackgroundImageFix"}),i.createElement("feBlend",{in:"SourceGraphic",in2:"BackgroundImageFix",result:"shape"}),i.createElement("feGaussianBlur",{stdDeviation:7,result:"effect1_foregroundBlur"}))))},m={pixel:function(e){var t=e.name,r=e.colors,a=e.title,c=e.square,h=e.size,o=l(e,["name","colors","title","square","size"]),f=function(e,t){var r=n(e),l=t&&t.length;return Array.from({length:64},(function(e,i){return s(r%(i+1),t,l)}))}(t,r),m=i.useId();return i.createElement("svg",Object.assign({viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:h,height:h},o),a&&i.createElement("title",null,t),i.createElement("mask",{id:m,"mask-type":"alpha",maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},i.createElement("rect",{width:80,height:80,rx:c?void 0:160,fill:"#FFFFFF"})),i.createElement("g",{mask:"url(#".concat(m,")")},i.createElement("rect",{width:10,height:10,fill:f[0]}),i.createElement("rect",{x:20,width:10,height:10,fill:f[1]}),i.createElement("rect",{x:40,width:10,height:10,fill:f[2]}),i.createElement("rect",{x:60,width:10,height:10,fill:f[3]}),i.createElement("rect",{x:10,width:10,height:10,fill:f[4]}),i.createElement("rect",{x:30,width:10,height:10,fill:f[5]}),i.createElement("rect",{x:50,width:10,height:10,fill:f[6]}),i.createElement("rect",{x:70,width:10,height:10,fill:f[7]}),i.createElement("rect",{y:10,width:10,height:10,fill:f[8]}),i.createElement("rect",{y:20,width:10,height:10,fill:f[9]}),i.createElement("rect",{y:30,width:10,height:10,fill:f[10]}),i.createElement("rect",{y:40,width:10,height:10,fill:f[11]}),i.createElement("rect",{y:50,width:10,height:10,fill:f[12]}),i.createElement("rect",{y:60,width:10,height:10,fill:f[13]}),i.createElement("rect",{y:70,width:10,height:10,fill:f[14]}),i.createElement("rect",{x:20,y:10,width:10,height:10,fill:f[15]}),i.createElement("rect",{x:20,y:20,width:10,height:10,fill:f[16]}),i.createElement("rect",{x:20,y:30,width:10,height:10,fill:f[17]}),i.createElement("rect",{x:20,y:40,width:10,height:10,fill:f[18]}),i.createElement("rect",{x:20,y:50,width:10,height:10,fill:f[19]}),i.createElement("rect",{x:20,y:60,width:10,height:10,fill:f[20]}),i.createElement("rect",{x:20,y:70,width:10,height:10,fill:f[21]}),i.createElement("rect",{x:40,y:10,width:10,height:10,fill:f[22]}),i.createElement("rect",{x:40,y:20,width:10,height:10,fill:f[23]}),i.createElement("rect",{x:40,y:30,width:10,height:10,fill:f[24]}),i.createElement("rect",{x:40,y:40,width:10,height:10,fill:f[25]}),i.createElement("rect",{x:40,y:50,width:10,height:10,fill:f[26]}),i.createElement("rect",{x:40,y:60,width:10,height:10,fill:f[27]}),i.createElement("rect",{x:40,y:70,width:10,height:10,fill:f[28]}),i.createElement("rect",{x:60,y:10,width:10,height:10,fill:f[29]}),i.createElement("rect",{x:60,y:20,width:10,height:10,fill:f[30]}),i.createElement("rect",{x:60,y:30,width:10,height:10,fill:f[31]}),i.createElement("rect",{x:60,y:40,width:10,height:10,fill:f[32]}),i.createElement("rect",{x:60,y:50,width:10,height:10,fill:f[33]}),i.createElement("rect",{x:60,y:60,width:10,height:10,fill:f[34]}),i.createElement("rect",{x:60,y:70,width:10,height:10,fill:f[35]}),i.createElement("rect",{x:10,y:10,width:10,height:10,fill:f[36]}),i.createElement("rect",{x:10,y:20,width:10,height:10,fill:f[37]}),i.createElement("rect",{x:10,y:30,width:10,height:10,fill:f[38]}),i.createElement("rect",{x:10,y:40,width:10,height:10,fill:f[39]}),i.createElement("rect",{x:10,y:50,width:10,height:10,fill:f[40]}),i.createElement("rect",{x:10,y:60,width:10,height:10,fill:f[41]}),i.createElement("rect",{x:10,y:70,width:10,height:10,fill:f[42]}),i.createElement("rect",{x:30,y:10,width:10,height:10,fill:f[43]}),i.createElement("rect",{x:30,y:20,width:10,height:10,fill:f[44]}),i.createElement("rect",{x:30,y:30,width:10,height:10,fill:f[45]}),i.createElement("rect",{x:30,y:40,width:10,height:10,fill:f[46]}),i.createElement("rect",{x:30,y:50,width:10,height:10,fill:f[47]}),i.createElement("rect",{x:30,y:60,width:10,height:10,fill:f[48]}),i.createElement("rect",{x:30,y:70,width:10,height:10,fill:f[49]}),i.createElement("rect",{x:50,y:10,width:10,height:10,fill:f[50]}),i.createElement("rect",{x:50,y:20,width:10,height:10,fill:f[51]}),i.createElement("rect",{x:50,y:30,width:10,height:10,fill:f[52]}),i.createElement("rect",{x:50,y:40,width:10,height:10,fill:f[53]}),i.createElement("rect",{x:50,y:50,width:10,height:10,fill:f[54]}),i.createElement("rect",{x:50,y:60,width:10,height:10,fill:f[55]}),i.createElement("rect",{x:50,y:70,width:10,height:10,fill:f[56]}),i.createElement("rect",{x:70,y:10,width:10,height:10,fill:f[57]}),i.createElement("rect",{x:70,y:20,width:10,height:10,fill:f[58]}),i.createElement("rect",{x:70,y:30,width:10,height:10,fill:f[59]}),i.createElement("rect",{x:70,y:40,width:10,height:10,fill:f[60]}),i.createElement("rect",{x:70,y:50,width:10,height:10,fill:f[61]}),i.createElement("rect",{x:70,y:60,width:10,height:10,fill:f[62]}),i.createElement("rect",{x:70,y:70,width:10,height:10,fill:f[63]})))},bauhaus:function(e){var t=e.name,r=e.colors,a=e.title,c=e.square,f=e.size,m=l(e,["name","colors","title","square","size"]),d=function(e,t){var r=n(e),l=t&&t.length;return Array.from({length:4},(function(e,i){return{color:s(r+i,t,l),translateX:o(r*(i+1),40-(i+17),1),translateY:o(r*(i+1),40-(i+17),2),rotate:o(r*(i+1),360),isSquare:h(r,2)}}))}(t,r),u=i.useId();return i.createElement("svg",Object.assign({viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:f,height:f},m),a&&i.createElement("title",null,t),i.createElement("mask",{id:u,maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},i.createElement("rect",{width:80,height:80,rx:c?void 0:160,fill:"#FFFFFF"})),i.createElement("g",{mask:"url(#".concat(u,")")},i.createElement("rect",{width:80,height:80,fill:d[0].color}),i.createElement("rect",{x:10,y:30,width:80,height:d[1].isSquare?80:10,fill:d[1].color,transform:"translate("+d[1].translateX+" "+d[1].translateY+") rotate("+d[1].rotate+" 40 40)"}),i.createElement("circle",{cx:40,cy:40,fill:d[2].color,r:16,transform:"translate("+d[2].translateX+" "+d[2].translateY+")"}),i.createElement("line",{x1:0,y1:40,x2:80,y2:40,strokeWidth:2,stroke:d[3].color,transform:"translate("+d[3].translateX+" "+d[3].translateY+") rotate("+d[3].rotate+" 40 40)"})))},ring:function(e){var t=e.name,r=e.colors,i=e.title,c=e.square,h=e.size,o=l(e,["name","colors","title","square","size"]),f=function(e,t){var r=n(t),l=e&&e.length,i=Array.from({length:5},(function(t,i){return s(r+i,e,l)})),a=[];return a[0]=i[0],a[1]=i[1],a[2]=i[1],a[3]=i[2],a[4]=i[2],a[5]=i[3],a[6]=i[3],a[7]=i[0],a[8]=i[4],a}(r,t),m=a.a.useId();return a.a.createElement("svg",Object.assign({viewBox:"0 0 90 90",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:h,height:h},o),i&&a.a.createElement("title",null,t),a.a.createElement("mask",{id:m,maskUnits:"userSpaceOnUse",x:0,y:0,width:90,height:90},a.a.createElement("rect",{width:90,height:90,rx:c?void 0:180,fill:"#FFFFFF"})),a.a.createElement("g",{mask:"url(#".concat(m,")")},a.a.createElement("path",{d:"M0 0h90v45H0z",fill:f[0]}),a.a.createElement("path",{d:"M0 45h90v45H0z",fill:f[1]}),a.a.createElement("path",{d:"M83 45a38 38 0 00-76 0h76z",fill:f[2]}),a.a.createElement("path",{d:"M83 45a38 38 0 01-76 0h76z",fill:f[3]}),a.a.createElement("path",{d:"M77 45a32 32 0 10-64 0h64z",fill:f[4]}),a.a.createElement("path",{d:"M77 45a32 32 0 11-64 0h64z",fill:f[5]}),a.a.createElement("path",{d:"M71 45a26 26 0 00-52 0h52z",fill:f[6]}),a.a.createElement("path",{d:"M71 45a26 26 0 01-52 0h52z",fill:f[7]}),a.a.createElement("circle",{cx:45,cy:45,r:23,fill:f[8]})))},beam:function(e){var t=e.name,r=e.colors,a=e.title,c=e.square,f=e.size,m=l(e,["name","colors","title","square","size"]),d=function(e,t){var r,l=n(e),i=t&&t.length,a=s(l,t,i),c=o(l,10,1),f=c<5?c+4:c,m=o(l,10,2),d=m<5?m+4:m;return{wrapperColor:a,faceColor:(r=a,"#"===r.slice(0,1)&&(r=r.slice(1)),(299*parseInt(r.substr(0,2),16)+587*parseInt(r.substr(2,2),16)+114*parseInt(r.substr(4,2),16))/1e3>=128?"#000000":"#FFFFFF"),backgroundColor:s(l+13,t,i),wrapperTranslateX:f,wrapperTranslateY:d,wrapperRotate:o(l,360),wrapperScale:1+o(l,3)/10,isMouthOpen:h(l,2),isCircle:h(l,1),eyeSpread:o(l,5),mouthSpread:o(l,3),faceRotate:o(l,10,3),faceTranslateX:f>6?f/2:o(l,8,1),faceTranslateY:d>6?d/2:o(l,7,2)}}(t,r),u=i.useId();return i.createElement("svg",Object.assign({viewBox:"0 0 36 36",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:f,height:f},m),a&&i.createElement("title",null,t),i.createElement("mask",{id:u,maskUnits:"userSpaceOnUse",x:0,y:0,width:36,height:36},i.createElement("rect",{width:36,height:36,rx:c?void 0:72,fill:"#FFFFFF"})),i.createElement("g",{mask:"url(#".concat(u,")")},i.createElement("rect",{width:36,height:36,fill:d.backgroundColor}),i.createElement("rect",{x:"0",y:"0",width:36,height:36,transform:"translate("+d.wrapperTranslateX+" "+d.wrapperTranslateY+") rotate("+d.wrapperRotate+" 18 18) scale("+d.wrapperScale+")",fill:d.wrapperColor,rx:d.isCircle?36:6}),i.createElement("g",{transform:"translate("+d.faceTranslateX+" "+d.faceTranslateY+") rotate("+d.faceRotate+" 18 18)"},d.isMouthOpen?i.createElement("path",{d:"M15 "+(19+d.mouthSpread)+"c2 1 4 1 6 0",stroke:d.faceColor,fill:"none",strokeLinecap:"round"}):i.createElement("path",{d:"M13,"+(19+d.mouthSpread)+" a1,0.75 0 0,0 10,0",fill:d.faceColor}),i.createElement("rect",{x:14-d.eyeSpread,y:14,width:1.5,height:2,rx:1,stroke:"none",fill:d.faceColor}),i.createElement("rect",{x:20+d.eyeSpread,y:14,width:1.5,height:2,rx:1,stroke:"none",fill:d.faceColor}))))},sunset:function(e){var t=e.name,r=e.colors,a=e.title,c=e.square,h=e.size,o=l(e,["name","colors","title","square","size"]),f=function(e,t){var r=n(e),l=t&&t.length;return Array.from({length:4},(function(e,i){return s(r+i,t,l)}))}(t,r),m=t.replace(/\s/g,""),d=i.useId();return i.createElement("svg",Object.assign({viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:h,height:h},o),a&&i.createElement("title",null,t),i.createElement("mask",{id:d,maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},i.createElement("rect",{width:80,height:80,rx:c?void 0:160,fill:"#FFFFFF"})),i.createElement("g",{mask:"url(#".concat(d,")")},i.createElement("path",{fill:"url(#gradient_paint0_linear_"+m+")",d:"M0 0h80v40H0z"}),i.createElement("path",{fill:"url(#gradient_paint1_linear_"+m+")",d:"M0 40h80v40H0z"})),i.createElement("defs",null,i.createElement("linearGradient",{id:"gradient_paint0_linear_"+m,x1:40,y1:0,x2:40,y2:40,gradientUnits:"userSpaceOnUse"},i.createElement("stop",{stopColor:f[0]}),i.createElement("stop",{offset:1,stopColor:f[1]})),i.createElement("linearGradient",{id:"gradient_paint1_linear_"+m,x1:40,y1:40,x2:40,y2:80,gradientUnits:"userSpaceOnUse"},i.createElement("stop",{stopColor:f[2]}),i.createElement("stop",{offset:1,stopColor:f[3]}))))},marble:f},d={geometric:"beam",abstract:"bauhaus"},u=function(e){var t=e.variant,r=void 0===t?"marble":t,i=e.colors,n=void 0===i?["#92A1C6","#146A7C","#F0AB3D","#C271B4","#C20D90"]:i,c=e.name,h=void 0===c?"Clara Barton":c,o=e.title,s=void 0!==o&&o,u=e.size,g=e.square,w=void 0!==g&&g,E=l(e,["variant","colors","name","title","size","square"]),p=m[d[r]||r]||f;return a.a.createElement(p,Object.assign({colors:n,name:h,title:s,size:u,square:w},E))};t.default=u}])}));

/***/ }),

/***/ 537925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Blend)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const Blend = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("Blend", [
    [
        "circle",
        {
            cx: "9",
            cy: "9",
            r: "7",
            key: "p2h5vp"
        }
    ],
    [
        "circle",
        {
            cx: "15",
            cy: "15",
            r: "7",
            key: "19ennj"
        }
    ]
]);
 //# sourceMappingURL=blend.js.map


/***/ }),

/***/ 427434:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Blocks)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const Blocks = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("Blocks", [
    [
        "rect",
        {
            width: "7",
            height: "7",
            x: "14",
            y: "3",
            rx: "1",
            key: "6d4xhi"
        }
    ],
    [
        "path",
        {
            d: "M10 21V8a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1H3",
            key: "1fpvtg"
        }
    ]
]);
 //# sourceMappingURL=blocks.js.map


/***/ }),

/***/ 401633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CirclePlus)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const CirclePlus = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("CirclePlus", [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "10",
            key: "1mglay"
        }
    ],
    [
        "path",
        {
            d: "M8 12h8",
            key: "1wcyev"
        }
    ],
    [
        "path",
        {
            d: "M12 8v8",
            key: "napkw2"
        }
    ]
]);
 //# sourceMappingURL=circle-plus.js.map


/***/ }),

/***/ 990082:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CircleUser)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const CircleUser = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("CircleUser", [
    [
        "circle",
        {
            cx: "12",
            cy: "12",
            r: "10",
            key: "1mglay"
        }
    ],
    [
        "circle",
        {
            cx: "12",
            cy: "10",
            r: "3",
            key: "ilqhr7"
        }
    ],
    [
        "path",
        {
            d: "M7 20.662V19a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v1.662",
            key: "154egf"
        }
    ]
]);
 //# sourceMappingURL=circle-user.js.map


/***/ }),

/***/ 638817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Cog)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const Cog = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("Cog", [
    [
        "path",
        {
            d: "M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z",
            key: "sobvz5"
        }
    ],
    [
        "path",
        {
            d: "M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z",
            key: "11i496"
        }
    ],
    [
        "path",
        {
            d: "M12 2v2",
            key: "tus03m"
        }
    ],
    [
        "path",
        {
            d: "M12 22v-2",
            key: "1osdcq"
        }
    ],
    [
        "path",
        {
            d: "m17 20.66-1-1.73",
            key: "eq3orb"
        }
    ],
    [
        "path",
        {
            d: "M11 10.27 7 3.34",
            key: "16pf9h"
        }
    ],
    [
        "path",
        {
            d: "m20.66 17-1.73-1",
            key: "sg0v6f"
        }
    ],
    [
        "path",
        {
            d: "m3.34 7 1.73 1",
            key: "1ulond"
        }
    ],
    [
        "path",
        {
            d: "M14 12h8",
            key: "4f43i9"
        }
    ],
    [
        "path",
        {
            d: "M2 12h2",
            key: "1t8f8n"
        }
    ],
    [
        "path",
        {
            d: "m20.66 7-1.73 1",
            key: "1ow05n"
        }
    ],
    [
        "path",
        {
            d: "m3.34 17 1.73-1",
            key: "nuk764"
        }
    ],
    [
        "path",
        {
            d: "m17 3.34-1 1.73",
            key: "2wel8s"
        }
    ],
    [
        "path",
        {
            d: "m11 13.73-4 6.93",
            key: "794ttg"
        }
    ]
]);
 //# sourceMappingURL=cog.js.map


/***/ }),

/***/ 695164:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ CreditCard)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const CreditCard = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("CreditCard", [
    [
        "rect",
        {
            width: "20",
            height: "14",
            x: "2",
            y: "5",
            rx: "2",
            key: "ynyp8z"
        }
    ],
    [
        "line",
        {
            x1: "2",
            x2: "22",
            y1: "10",
            y2: "10",
            key: "1b3vmo"
        }
    ]
]);
 //# sourceMappingURL=credit-card.js.map


/***/ }),

/***/ 453779:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ GlobeLock)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const GlobeLock = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("GlobeLock", [
    [
        "path",
        {
            d: "M15.686 15A14.5 14.5 0 0 1 12 22a14.5 14.5 0 0 1 0-20 10 10 0 1 0 9.542 13",
            key: "qkt0x6"
        }
    ],
    [
        "path",
        {
            d: "M2 12h8.5",
            key: "ovaggd"
        }
    ],
    [
        "path",
        {
            d: "M20 6V4a2 2 0 1 0-4 0v2",
            key: "1of5e8"
        }
    ],
    [
        "rect",
        {
            width: "8",
            height: "5",
            x: "14",
            y: "6",
            rx: "1",
            key: "1fmf51"
        }
    ]
]);
 //# sourceMappingURL=globe-lock.js.map


/***/ }),

/***/ 415140:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Link)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const Link = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("Link", [
    [
        "path",
        {
            d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
            key: "1cjeqo"
        }
    ],
    [
        "path",
        {
            d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
            key: "19qd67"
        }
    ]
]);
 //# sourceMappingURL=link.js.map


/***/ }),

/***/ 65433:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ LogOut)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const LogOut = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("LogOut", [
    [
        "path",
        {
            d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
            key: "1uf3rs"
        }
    ],
    [
        "polyline",
        {
            points: "16 17 21 12 16 7",
            key: "1gabdz"
        }
    ],
    [
        "line",
        {
            x1: "21",
            x2: "9",
            y1: "12",
            y2: "12",
            key: "1uyos4"
        }
    ]
]);
 //# sourceMappingURL=log-out.js.map


/***/ }),

/***/ 117059:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MessageCircleQuestion)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const MessageCircleQuestion = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("MessageCircleQuestion", [
    [
        "path",
        {
            d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
            key: "vv11sd"
        }
    ],
    [
        "path",
        {
            d: "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3",
            key: "1u773s"
        }
    ],
    [
        "path",
        {
            d: "M12 17h.01",
            key: "p32p05"
        }
    ]
]);
 //# sourceMappingURL=message-circle-question.js.map


/***/ }),

/***/ 76446:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ MessageCircle)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const MessageCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("MessageCircle", [
    [
        "path",
        {
            d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
            key: "vv11sd"
        }
    ]
]);
 //# sourceMappingURL=message-circle.js.map


/***/ }),

/***/ 593517:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ PanelLeftClose)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const PanelLeftClose = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("PanelLeftClose", [
    [
        "rect",
        {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2",
            key: "afitv7"
        }
    ],
    [
        "path",
        {
            d: "M9 3v18",
            key: "fh3hqa"
        }
    ],
    [
        "path",
        {
            d: "m16 15-3-3 3-3",
            key: "14y99z"
        }
    ]
]);
 //# sourceMappingURL=panel-left-close.js.map


/***/ }),

/***/ 168185:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ PanelLeftOpen)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const PanelLeftOpen = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("PanelLeftOpen", [
    [
        "rect",
        {
            width: "18",
            height: "18",
            x: "3",
            y: "3",
            rx: "2",
            key: "afitv7"
        }
    ],
    [
        "path",
        {
            d: "M9 3v18",
            key: "fh3hqa"
        }
    ],
    [
        "path",
        {
            d: "m14 9 3 3-3 3",
            key: "8010ee"
        }
    ]
]);
 //# sourceMappingURL=panel-left-open.js.map


/***/ }),

/***/ 133328:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Rocket)
/* harmony export */ });
/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58303);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ 
const Rocket = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)("Rocket", [
    [
        "path",
        {
            d: "M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z",
            key: "m3kijz"
        }
    ],
    [
        "path",
        {
            d: "m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z",
            key: "1fmvmk"
        }
    ],
    [
        "path",
        {
            d: "M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0",
            key: "1f8sc4"
        }
    ],
    [
        "path",
        {
            d: "M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5",
            key: "qeys4"
        }
    ]
]);
 //# sourceMappingURL=rocket.js.map


/***/ }),

/***/ 62083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891069);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _app_app_environments_environmentId_settings_organization_components_OrganizationSettingsNavbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(841068);
/* harmony import */ var _modules_ui_components_page_content_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(746219);
/* harmony import */ var _modules_ui_components_page_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(109053);
/* harmony import */ var _tolgee_server__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(186184);
/* harmony import */ var _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(836919);






const Loading = async ()=>{
    const t = await (0,_tolgee_server__WEBPACK_IMPORTED_MODULE_4__/* .getTranslate */ .r)();
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(_modules_ui_components_page_content_wrapper__WEBPACK_IMPORTED_MODULE_2__/* .PageContentWrapper */ .s, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_modules_ui_components_page_header__WEBPACK_IMPORTED_MODULE_3__/* .PageHeader */ .z, {
                pageTitle: t("environments.settings.general.organization_settings"),
                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_app_app_environments_environmentId_settings_organization_components_OrganizationSettingsNavbar__WEBPACK_IMPORTED_MODULE_1__.OrganizationSettingsNavbar, {
                    isFormbricksCloud: _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_5__/* .IS_FORMBRICKS_CLOUD */ .Si,
                    activeId: "billing",
                    loading: true
                })
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                className: "my-8 h-64 animate-pulse rounded-xl bg-slate-200"
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
                className: "my-8 h-96 animate-pulse rounded-md bg-slate-200"
            })
        ]
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loading);


/***/ }),

/***/ 389657:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ page)
});

// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-runtime.js
var react_jsx_runtime = __webpack_require__(891069);
// EXTERNAL MODULE: ./app/(app)/environments/[environmentId]/settings/(organization)/components/OrganizationSettingsNavbar.tsx
var OrganizationSettingsNavbar = __webpack_require__(841068);
// EXTERNAL MODULE: ./modules/auth/lib/authOptions.ts + 8 modules
var authOptions = __webpack_require__(136015);
// EXTERNAL MODULE: ./modules/ui/components/page-content-wrapper/index.tsx
var page_content_wrapper = __webpack_require__(746219);
// EXTERNAL MODULE: ./modules/ui/components/page-header/index.tsx
var page_header = __webpack_require__(109053);
// EXTERNAL MODULE: ./tolgee/server.tsx + 2 modules
var server = __webpack_require__(186184);
// EXTERNAL MODULE: ../../node_modules/next-auth/index.js
var next_auth = __webpack_require__(963302);
// EXTERNAL MODULE: ../../node_modules/next/dist/api/navigation.react-server.js
var navigation_react_server = __webpack_require__(145796);
// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(836919);
// EXTERNAL MODULE: ../../packages/lib/membership/service.ts
var service = __webpack_require__(377968);
// EXTERNAL MODULE: ../../packages/lib/membership/utils.ts
var utils = __webpack_require__(159570);
// EXTERNAL MODULE: ../../packages/lib/organization/service.ts
var organization_service = __webpack_require__(353687);
// EXTERNAL MODULE: ../../packages/lib/project/service.ts
var project_service = __webpack_require__(529987);
// EXTERNAL MODULE: ./modules/ee/billing/components/pricing-table.tsx
var pricing_table = __webpack_require__(219668);
;// ./modules/ee/billing/page.tsx















const PricingPage = async (props)=>{
    const params = await props.params;
    const t = await (0,server/* getTranslate */.r)();
    const organization = await (0,organization_service/* getOrganizationByEnvironmentId */.TK)(params.environmentId);
    if (!constants/* IS_FORMBRICKS_CLOUD */.Si) {
        (0,navigation_react_server.notFound)();
    }
    if (!organization) {
        throw new Error(t("common.organization_not_found"));
    }
    const session = await (0,next_auth.getServerSession)(authOptions/* authOptions */.N);
    if (!session) {
        throw new Error(t("common.not_authorized"));
    }
    const [peopleCount, responseCount, projectCount] = await Promise.all([
        (0,organization_service/* getMonthlyActiveOrganizationPeopleCount */.P$)(organization.id),
        (0,organization_service/* getMonthlyOrganizationResponseCount */.XU)(organization.id),
        (0,project_service/* getOrganizationProjectsCount */.$v)(organization.id)
    ]);
    const currentUserMembership = await (0,service/* getMembershipByUserIdOrganizationId */.Y)(session?.user.id, organization.id);
    const { isMember } = (0,utils/* getAccessFlags */.c)(currentUserMembership?.role);
    const hasBillingRights = !isMember;
    return /*#__PURE__*/ (0,react_jsx_runtime.jsxs)(page_content_wrapper/* PageContentWrapper */.s, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)(page_header/* PageHeader */.z, {
                pageTitle: t("environments.settings.general.organization_settings"),
                children: /*#__PURE__*/ (0,react_jsx_runtime.jsx)(OrganizationSettingsNavbar.OrganizationSettingsNavbar, {
                    environmentId: params.environmentId,
                    isFormbricksCloud: constants/* IS_FORMBRICKS_CLOUD */.Si,
                    membershipRole: currentUserMembership?.role,
                    activeId: "billing"
                })
            }),
            /*#__PURE__*/ (0,react_jsx_runtime.jsx)(pricing_table.PricingTable, {
                organization: organization,
                environmentId: params.environmentId,
                peopleCount: peopleCount,
                responseCount: responseCount,
                projectCount: projectCount,
                stripePriceLookupKeys: constants/* STRIPE_PRICE_LOOKUP_KEYS */.Ui,
                projectFeatureKeys: constants/* PROJECT_FEATURE_KEYS */.mu,
                hasBillingRights: hasBillingRights
            })
        ]
    });
};

;// ./app/(app)/environments/[environmentId]/settings/(organization)/billing/page.tsx

/* harmony default export */ const page = (PricingPage);


/***/ }),

/***/ 841068:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrganizationSettingsNavbar: () => (/* binding */ OrganizationSettingsNavbar)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(672771);
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__);

const OrganizationSettingsNavbar = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call OrganizationSettingsNavbar() from the server but OrganizationSettingsNavbar is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/kdy1/projects/formbricks/apps/web/app/(app)/environments/[environmentId]/settings/(organization)/components/OrganizationSettingsNavbar.tsx",
"OrganizationSettingsNavbar",
);

/***/ }),

/***/ 17753:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891069);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _modules_auth_lib_authOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(136015);
/* harmony import */ var _tolgee_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186184);
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(963302);
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _formbricks_lib_organization_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(353687);
/* harmony import */ var _formbricks_lib_project_service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(529987);






const Layout = async (props)=>{
    const params = await props.params;
    const { children } = props;
    const t = await (0,_tolgee_server__WEBPACK_IMPORTED_MODULE_2__/* .getTranslate */ .r)();
    const [organization, project, session] = await Promise.all([
        (0,_formbricks_lib_organization_service__WEBPACK_IMPORTED_MODULE_4__/* .getOrganizationByEnvironmentId */ .TK)(params.environmentId),
        (0,_formbricks_lib_project_service__WEBPACK_IMPORTED_MODULE_5__/* .getProjectByEnvironmentId */ .bq)(params.environmentId),
        (0,next_auth__WEBPACK_IMPORTED_MODULE_3__.getServerSession)(_modules_auth_lib_authOptions__WEBPACK_IMPORTED_MODULE_1__/* .authOptions */ .N)
    ]);
    if (!organization) {
        throw new Error(t("common.organization_not_found"));
    }
    if (!project) {
        throw new Error(t("common.project_not_found"));
    }
    if (!session) {
        throw new Error(t("common.session_not_found"));
    }
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
        children: children
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Layout);


/***/ }),

/***/ 219668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PricingTable: () => (/* binding */ PricingTable)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(672771);
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__);

const PricingTable = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call PricingTable() from the server but PricingTable is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/Users/kdy1/projects/formbricks/apps/web/modules/ee/billing/components/pricing-table.tsx",
"PricingTable",
);

/***/ }),

/***/ 746219:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   s: () => (/* binding */ PageContentWrapper)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891069);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(598597);


const PageContentWrapper = ({ children, className })=>{
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", {
        className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__.cn)("h-full space-y-6 p-6", className),
        children: children
    });
};


/***/ }),

/***/ 109053:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ PageHeader)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891069);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(598597);


const PageHeader = ({ cta, pageTitle, children })=>{
    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
        className: "border-b border-slate-200",
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", {
                className: "flex items-center justify-between space-x-4 pb-4",
                children: [
                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h1", {
                        className: (0,_formbricks_lib_cn__WEBPACK_IMPORTED_MODULE_1__.cn)("text-3xl font-bold capitalize text-slate-800"),
                        children: pageTitle
                    }),
                    cta
                ]
            }),
            children
        ]
    });
};


/***/ }),

/***/ 598597:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cn: () => (/* binding */ cn)
/* harmony export */ });
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(966190);
/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(263798);


const cn = (...inputs)=>{
    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_0__/* .twMerge */ .QP)((0,clsx__WEBPACK_IMPORTED_MODULE_1__/* .clsx */ .$)(inputs));
};


/***/ }),

/***/ 95679:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ clamp)
/* harmony export */ });
// packages/core/number/src/number.ts
function clamp(value, [min, max]) {
  return Math.min(max, Math.max(min, value));
}

//# sourceMappingURL=index.mjs.map


/***/ }),

/***/ 90141:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CC: () => (/* binding */ Track),
/* harmony export */   Q6: () => (/* binding */ Range),
/* harmony export */   bL: () => (/* binding */ Root),
/* harmony export */   zi: () => (/* binding */ Thumb)
/* harmony export */ });
/* unused harmony exports Slider, SliderRange, SliderThumb, SliderTrack, createSliderScope */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891616);
/* harmony import */ var _radix_ui_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95679);
/* harmony import */ var _radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(763095);
/* harmony import */ var _radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(730613);
/* harmony import */ var _radix_ui_react_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(176235);
/* harmony import */ var _radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(409689);
/* harmony import */ var _radix_ui_react_direction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(506737);
/* harmony import */ var _radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(809391);
/* harmony import */ var _radix_ui_react_use_size__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(525611);
/* harmony import */ var _radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(832713);
/* harmony import */ var _radix_ui_react_collection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(882756);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(642725);
/* __next_internal_client_entry_do_not_use__ Range,Root,Slider,SliderRange,SliderThumb,SliderTrack,Thumb,Track,createSliderScope auto */ // packages/react/slider/src/Slider.tsx












var PAGE_KEYS = [
    "PageUp",
    "PageDown"
];
var ARROW_KEYS = [
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
];
var BACK_KEYS = {
    "from-left": [
        "Home",
        "PageDown",
        "ArrowDown",
        "ArrowLeft"
    ],
    "from-right": [
        "Home",
        "PageDown",
        "ArrowDown",
        "ArrowRight"
    ],
    "from-bottom": [
        "Home",
        "PageDown",
        "ArrowDown",
        "ArrowLeft"
    ],
    "from-top": [
        "Home",
        "PageDown",
        "ArrowUp",
        "ArrowLeft"
    ]
};
var SLIDER_NAME = "Slider";
var [Collection, useCollection, createCollectionScope] = (0,_radix_ui_react_collection__WEBPACK_IMPORTED_MODULE_2__/* .createCollection */ .N)(SLIDER_NAME);
var [createSliderContext, createSliderScope] = (0,_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_3__/* .createContextScope */ .A)(SLIDER_NAME, [
    createCollectionScope
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { name, min = 0, max = 100, step = 1, orientation = "horizontal", disabled = false, minStepsBetweenThumbs = 0, defaultValue = [
        min
    ], value, onValueChange = ()=>{}, onValueCommit = ()=>{}, inverted = false, form, ...sliderProps } = props;
    const thumbRefs = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = (0,_radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__/* .useControllableState */ .i)({
        prop: value,
        defaultProp: defaultValue,
        onChange: (value2)=>{
            const thumbs = [
                ...thumbRefs.current
            ];
            thumbs[valueIndexToChangeRef.current]?.focus();
            onValueChange(value2);
        }
    });
    const valuesBeforeSlideStartRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(values);
    function handleSlideStart(value2) {
        const closestIndex = getClosestValueIndex(values, value2);
        updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
        updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
        const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
        const nextValue = values[valueIndexToChangeRef.current];
        const hasChanged = nextValue !== prevValue;
        if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = {
        commit: false
    }) {
        const decimalCount = getDecimalCount(step);
        const snapToStep = roundValue(Math.round((value2 - min) / step) * step + min, decimalCount);
        const nextValue = (0,_radix_ui_number__WEBPACK_IMPORTED_MODULE_5__/* .clamp */ .q)(snapToStep, [
            min,
            max
        ]);
        setValues((prevValues = [])=>{
            const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
            if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
                valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
                const hasChanged = String(nextValues) !== String(prevValues);
                if (hasChanged && commit) onValueCommit(nextValues);
                return hasChanged ? nextValues : prevValues;
            } else {
                return prevValues;
            }
        });
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderProvider, {
        scope: props.__scopeSlider,
        name,
        disabled,
        min,
        max,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Collection.Provider, {
            scope: props.__scopeSlider,
            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Collection.Slot, {
                scope: props.__scopeSlider,
                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderOrientation, {
                    "aria-disabled": disabled,
                    "data-disabled": disabled ? "" : void 0,
                    ...sliderProps,
                    ref: forwardedRef,
                    onPointerDown: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(sliderProps.onPointerDown, ()=>{
                        if (!disabled) valuesBeforeSlideStartRef.current = values;
                    }),
                    min,
                    max,
                    inverted,
                    onSlideStart: disabled ? void 0 : handleSlideStart,
                    onSlideMove: disabled ? void 0 : handleSlideMove,
                    onSlideEnd: disabled ? void 0 : handleSlideEnd,
                    onHomeKeyDown: ()=>!disabled && updateValues(min, 0, {
                            commit: true
                        }),
                    onEndKeyDown: ()=>!disabled && updateValues(max, values.length - 1, {
                            commit: true
                        }),
                    onStepKeyDown: ({ event, direction: stepDirection })=>{
                        if (!disabled) {
                            const isPageKey = PAGE_KEYS.includes(event.key);
                            const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                            const multiplier = isSkipKey ? 10 : 1;
                            const atIndex = valueIndexToChangeRef.current;
                            const value2 = values[atIndex];
                            const stepInDirection = step * multiplier * stepDirection;
                            updateValues(value2 + stepInDirection, atIndex, {
                                commit: true
                            });
                        }
                    }
                })
            })
        })
    });
});
Slider.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
});
var SliderHorizontal = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { min, max, dir, inverted, onSlideStart, onSlideMove, onSlideEnd, onStepKeyDown, ...sliderProps } = props;
    const [slider, setSlider] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__/* .useComposedRefs */ .s)(forwardedRef, (node)=>setSlider(node));
    const rectRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);
    const direction = (0,_radix_ui_react_direction__WEBPACK_IMPORTED_MODULE_8__/* .useDirection */ .jH)(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || slider.getBoundingClientRect();
        const input = [
            0,
            rect.width
        ];
        const output = isSlidingFromLeft ? [
            min,
            max
        ] : [
            max,
            min
        ];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderOrientationProvider, {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderImpl, {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event)=>{
                const value = getValueFromPointer(event.clientX);
                onSlideStart?.(value);
            },
            onSlideMove: (event)=>{
                const value = getValueFromPointer(event.clientX);
                onSlideMove?.(value);
            },
            onSlideEnd: ()=>{
                rectRef.current = void 0;
                onSlideEnd?.();
            },
            onStepKeyDown: (event)=>{
                const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown?.({
                    event,
                    direction: isBackKey ? -1 : 1
                });
            }
        })
    });
});
var SliderVertical = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { min, max, inverted, onSlideStart, onSlideMove, onSlideEnd, onStepKeyDown, ...sliderProps } = props;
    const sliderRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const ref = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__/* .useComposedRefs */ .s)(forwardedRef, sliderRef);
    const rectRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
        const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
        const input = [
            0,
            rect.height
        ];
        const output = isSlidingFromBottom ? [
            max,
            min
        ] : [
            min,
            max
        ];
        const value = linearScale(input, output);
        rectRef.current = rect;
        return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderOrientationProvider, {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderImpl, {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
                ...sliderProps.style,
                ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event)=>{
                const value = getValueFromPointer(event.clientY);
                onSlideStart?.(value);
            },
            onSlideMove: (event)=>{
                const value = getValueFromPointer(event.clientY);
                onSlideMove?.(value);
            },
            onSlideEnd: ()=>{
                rectRef.current = void 0;
                onSlideEnd?.();
            },
            onStepKeyDown: (event)=>{
                const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
                const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
                onStepKeyDown?.({
                    event,
                    direction: isBackKey ? -1 : 1
                });
            }
        })
    });
});
var SliderImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { __scopeSlider, onSlideStart, onSlideMove, onSlideEnd, onHomeKeyDown, onEndKeyDown, onStepKeyDown, ...sliderProps } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_9__/* .Primitive */ .sG.span, {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(props.onKeyDown, (event)=>{
            if (event.key === "Home") {
                onHomeKeyDown(event);
                event.preventDefault();
            } else if (event.key === "End") {
                onEndKeyDown(event);
                event.preventDefault();
            } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
                onStepKeyDown(event);
                event.preventDefault();
            }
        }),
        onPointerDown: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(props.onPointerDown, (event)=>{
            const target = event.target;
            target.setPointerCapture(event.pointerId);
            event.preventDefault();
            if (context.thumbs.has(target)) {
                target.focus();
            } else {
                onSlideStart(event);
            }
        }),
        onPointerMove: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(props.onPointerMove, (event)=>{
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(props.onPointerUp, (event)=>{
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) {
                target.releasePointerCapture(event.pointerId);
                onSlideEnd(event);
            }
        })
    });
});
var TRACK_NAME = "SliderTrack";
var SliderTrack = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_9__/* .Primitive */ .sG.span, {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
    });
});
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__/* .useComposedRefs */ .s)(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map((value)=>convertValueToPercentage(value, context.min, context.max));
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_9__/* .Primitive */ .sG.span, {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
            ...props.style,
            [orientation.startEdge]: offsetStart + "%",
            [orientation.endEdge]: offsetEnd + "%"
        }
    });
});
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const getItems = useCollection(props.__scopeSlider);
    const [thumb, setThumb] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__/* .useComposedRefs */ .s)(forwardedRef, (node)=>setThumb(node));
    const index = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>thumb ? getItems().findIndex((item)=>item.ref.current === thumb) : -1, [
        getItems,
        thumb
    ]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SliderThumbImpl, {
        ...props,
        ref: composedRefs,
        index
    });
});
var SliderThumbImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, forwardedRef)=>{
    const { __scopeSlider, index, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);
    const composedRefs = (0,_radix_ui_react_compose_refs__WEBPACK_IMPORTED_MODULE_7__/* .useComposedRefs */ .s)(forwardedRef, (node)=>setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size = (0,_radix_ui_react_use_size__WEBPACK_IMPORTED_MODULE_10__/* .useSize */ .X)(thumb);
    const value = context.values[index];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index, context.values.length);
    const orientationSize = size?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{
        if (thumb) {
            context.thumbs.add(thumb);
            return ()=>{
                context.thumbs.delete(thumb);
            };
        }
    }, [
        thumb,
        context.thumbs
    ]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("span", {
        style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Collection.ItemSlot, {
                scope: props.__scopeSlider,
                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_9__/* .Primitive */ .sG.span, {
                    role: "slider",
                    "aria-label": props["aria-label"] || label,
                    "aria-valuemin": context.min,
                    "aria-valuenow": value,
                    "aria-valuemax": context.max,
                    "aria-orientation": context.orientation,
                    "data-orientation": context.orientation,
                    "data-disabled": context.disabled ? "" : void 0,
                    tabIndex: context.disabled ? void 0 : 0,
                    ...thumbProps,
                    ref: composedRefs,
                    style: value === void 0 ? {
                        display: "none"
                    } : props.style,
                    onFocus: (0,_radix_ui_primitive__WEBPACK_IMPORTED_MODULE_6__/* .composeEventHandlers */ .m)(props.onFocus, ()=>{
                        context.valueIndexToChangeRef.current = index;
                    })
                })
            }),
            isFormControl && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BubbleInput, {
                name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
                form: context.form,
                value
            }, index)
        ]
    });
});
SliderThumb.displayName = THUMB_NAME;
var BubbleInput = (props)=>{
    const { value, ...inputProps } = props;
    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
    const prevValue = (0,_radix_ui_react_use_previous__WEBPACK_IMPORTED_MODULE_11__/* .usePrevious */ .Z)(value);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{
        const input = ref.current;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
        const setValue = descriptor.set;
        if (prevValue !== value && setValue) {
            const event = new Event("input", {
                bubbles: true
            });
            setValue.call(input, value);
            input.dispatchEvent(event);
        }
    }, [
        prevValue,
        value
    ]);
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("input", {
        style: {
            display: "none"
        },
        ...inputProps,
        ref,
        defaultValue: value
    });
};
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
    const nextValues = [
        ...prevValues
    ];
    nextValues[atIndex] = nextValue;
    return nextValues.sort((a, b)=>a - b);
}
function convertValueToPercentage(value, min, max) {
    const maxSteps = max - min;
    const percentPerStep = 100 / maxSteps;
    const percentage = percentPerStep * (value - min);
    return (0,_radix_ui_number__WEBPACK_IMPORTED_MODULE_5__/* .clamp */ .q)(percentage, [
        0,
        100
    ]);
}
function getLabel(index, totalValues) {
    if (totalValues > 2) {
        return `Value ${index + 1} of ${totalValues}`;
    } else if (totalValues === 2) {
        return [
            "Minimum",
            "Maximum"
        ][index];
    } else {
        return void 0;
    }
}
function getClosestValueIndex(values, nextValue) {
    if (values.length === 1) return 0;
    const distances = values.map((value)=>Math.abs(value - nextValue));
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
    const halfWidth = width / 2;
    const halfPercent = 50;
    const offset = linearScale([
        0,
        halfPercent
    ], [
        0,
        halfWidth
    ]);
    return (halfWidth - offset(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
    return values.slice(0, -1).map((value, index)=>values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
    if (minStepsBetweenValues > 0) {
        const stepsBetweenValues = getStepsBetweenValues(values);
        const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
        return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
}
function linearScale(input, output) {
    return (value)=>{
        if (input[0] === input[1] || output[0] === output[1]) return output[0];
        const ratio = (output[1] - output[0]) / (input[1] - input[0]);
        return output[0] + ratio * (value - input[0]);
    };
}
function getDecimalCount(value) {
    return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
    const rounder = Math.pow(10, decimalCount);
    return Math.round(value * rounder) / rounder;
}
var Root = Slider;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb;
 //# sourceMappingURL=index.mjs.map


/***/ }),

/***/ 809391:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (/* binding */ usePrevious)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(891616);
// packages/react/use-previous/src/usePrevious.tsx

function usePrevious(value) {
  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef({ value, previous: value });
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}

//# sourceMappingURL=index.mjs.map


/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [8079,3073,7863,5069,255,9759,6626,5570,1238,2021,9069,2195,7762,1469,5294,4900,6911,2075,1659,5667,6689,2446,9726,497,4218,9325,8785,3798,1606,3687,7864,8046,8235,5752,3840,9160,4660,8310,1612], () => (__webpack_exec__(453781)));
module.exports = __webpack_exports__;

})();