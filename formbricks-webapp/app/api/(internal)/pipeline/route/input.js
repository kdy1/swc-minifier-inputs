"use strict";
(() => {
var exports = {};
exports.id = 335;
exports.ids = [335];
exports.modules = {

/***/ 191043:
/***/ ((module) => {

module.exports = require("@aws-sdk/client-s3");

/***/ }),

/***/ 741000:
/***/ ((module) => {

module.exports = require("@aws-sdk/s3-presigned-post");

/***/ }),

/***/ 531701:
/***/ ((module) => {

module.exports = require("@aws-sdk/s3-request-presigner");

/***/ }),

/***/ 896330:
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ 560483:
/***/ ((module) => {

module.exports = require("@prisma/client/scripts/default-index.js");

/***/ }),

/***/ 832325:
/***/ ((module) => {

module.exports = require("jsdom");

/***/ }),

/***/ 710846:
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.prod.js");

/***/ }),

/***/ 744870:
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.prod.js");

/***/ }),

/***/ 903295:
/***/ ((module) => {

module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ 529294:
/***/ ((module) => {

module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ 663033:
/***/ ((module) => {

module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ 912412:
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ 584297:
/***/ ((module) => {

module.exports = require("async_hooks");

/***/ }),

/***/ 979428:
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ 579646:
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ 455511:
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ 714985:
/***/ ((module) => {

module.exports = require("dns");

/***/ }),

/***/ 594735:
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ 629021:
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ 79748:
/***/ ((module) => {

module.exports = require("fs/promises");

/***/ }),

/***/ 781630:
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ 673496:
/***/ ((module) => {

module.exports = require("http2");

/***/ }),

/***/ 55591:
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ 491645:
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ 321820:
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ 333873:
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ 719771:
/***/ ((module) => {

module.exports = require("process");

/***/ }),

/***/ 11997:
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ 111723:
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ 927910:
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ 134631:
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ 583997:
/***/ ((module) => {

module.exports = require("tty");

/***/ }),

/***/ 379551:
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ 328354:
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ 173566:
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ 74075:
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ 504573:
/***/ ((module) => {

module.exports = require("node:buffer");

/***/ }),

/***/ 977598:
/***/ ((module) => {

module.exports = require("node:crypto");

/***/ }),

/***/ 973024:
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ 937067:
/***/ ((module) => {

module.exports = require("node:http");

/***/ }),

/***/ 344708:
/***/ ((module) => {

module.exports = require("node:https");

/***/ }),

/***/ 777030:
/***/ ((module) => {

module.exports = require("node:net");

/***/ }),

/***/ 176760:
/***/ ((module) => {

module.exports = require("node:path");

/***/ }),

/***/ 1708:
/***/ ((module) => {

module.exports = require("node:process");

/***/ }),

/***/ 157075:
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ 337830:
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ 173136:
/***/ ((module) => {

module.exports = require("node:url");

/***/ }),

/***/ 257975:
/***/ ((module) => {

module.exports = require("node:util");

/***/ }),

/***/ 638522:
/***/ ((module) => {

module.exports = require("node:zlib");

/***/ }),

/***/ 774837:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  patchFetch: () => (/* binding */ patchFetch),
  routeModule: () => (/* binding */ routeModule),
  serverHooks: () => (/* binding */ serverHooks),
  workAsyncStorage: () => (/* binding */ workAsyncStorage),
  workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)
});

// NAMESPACE OBJECT: ./app/api/(internal)/pipeline/route.ts
var route_namespaceObject = {};
__webpack_require__.r(route_namespaceObject);
__webpack_require__.d(route_namespaceObject, {
  POST: () => (POST)
});

// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-route/module.compiled.js
var module_compiled = __webpack_require__(831271);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-kind.js
var route_kind = __webpack_require__(291232);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/lib/patch-fetch.js
var patch_fetch = __webpack_require__(318079);
// EXTERNAL MODULE: ./app/api/(internal)/insights/lib/insights.ts + 3 modules
var lib_insights = __webpack_require__(949631);
// EXTERNAL MODULE: ./lib/cache/document.ts
var cache_document = __webpack_require__(735027);
// EXTERNAL MODULE: external "@prisma/client"
var client_ = __webpack_require__(896330);
// EXTERNAL MODULE: ../../node_modules/ai/dist/index.mjs + 37 modules
var dist = __webpack_require__(850910);
// EXTERNAL MODULE: ../../node_modules/zod/lib/index.mjs
var lib = __webpack_require__(545198);
// EXTERNAL MODULE: ../../packages/database/src/index.ts + 1 modules
var src = __webpack_require__(527610);
// EXTERNAL MODULE: ../../packages/database/zod/insights.ts
var zod_insights = __webpack_require__(748047);
// EXTERNAL MODULE: ../../packages/lib/aiModels.ts
var aiModels = __webpack_require__(709516);
// EXTERNAL MODULE: ../../packages/lib/utils/validate.ts
var validate = __webpack_require__(860988);
// EXTERNAL MODULE: ../../packages/types/documents.ts
var documents = __webpack_require__(927314);
// EXTERNAL MODULE: ../../packages/types/errors.ts
var errors = __webpack_require__(470641);
;// ./app/api/(internal)/pipeline/lib/documents.ts











const createDocumentAndAssignInsight = async (surveyName, documentInput)=>{
    (0,validate/* validateInputs */.C)([
        surveyName,
        lib.z.string()
    ], [
        documentInput,
        documents/* ZDocumentCreateInput */.mC
    ]);
    try {
        // Generate text embedding
        const { embedding } = await (0,dist/* embed */.E6)({
            model: aiModels/* embeddingsModel */.U,
            value: documentInput.text,
            experimental_telemetry: {
                isEnabled: true
            }
        });
        // generate sentiment and insights
        const { object } = await (0,dist/* generateObject */.pY)({
            model: aiModels/* llmModel */.V,
            schema: lib.z.object({
                sentiment: documents/* ZDocumentSentiment */.nT,
                insights: lib.z.array(lib.z.object({
                    title: lib.z.string().describe("insight title, very specific"),
                    description: lib.z.string().describe("very brief insight description"),
                    category: zod_insights/* ZInsight */.x.shape.category
                })),
                isSpam: lib.z.boolean()
            }),
            system: `You are an XM researcher. You analyse a survey response (survey name, question headline & user answer) and generate insights from it. The insight title (1-3 words) should concisely answer the question, e.g., "What type of people do you think would most benefit" -> "Developers". You are very objective. For the insights, split the feedback into the smallest parts possible and only use the feedback itself to draw conclusions. You must output at least one insight. Always generate insights and titles in English, regardless of the input language.`,
            prompt: `Survey: ${surveyName}\n${documentInput.text}`,
            temperature: 0,
            experimental_telemetry: {
                isEnabled: true
            }
        });
        const sentiment = object.sentiment;
        const isSpam = object.isSpam;
        const insights = object.insights;
        // create document
        const prismaDocument = await src/* prisma */.z.document.create({
            data: {
                ...documentInput,
                sentiment,
                isSpam
            }
        });
        const document = {
            ...prismaDocument,
            vector: embedding
        };
        // update document vector with the embedding
        const vectorString = `[${embedding.join(",")}]`;
        await src/* prisma */.z.$executeRaw`
          UPDATE "Document"
          SET "vector" = ${vectorString}::vector(512)
          WHERE "id" = ${document.id};
        `;
        // connect or create the insights
        const insightPromises = [];
        if (!isSpam) {
            for (const insight of insights){
                if (typeof insight.title !== "string" || typeof insight.description !== "string") {
                    throw new Error("Insight title and description must be a string");
                }
                // create or connect the insight
                insightPromises.push((0,lib_insights/* handleInsightAssignments */.B2)(documentInput.environmentId, document.id, insight));
            }
            await Promise.allSettled(insightPromises);
        }
        cache_document/* documentCache */.O.revalidate({
            id: document.id,
            environmentId: document.environmentId,
            surveyId: document.surveyId,
            responseId: document.responseId,
            questionId: document.questionId
        });
        return document;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};

// EXTERNAL MODULE: ./modules/email/index.tsx + 22 modules
var email = __webpack_require__(720302);
;// ./app/api/(internal)/pipeline/lib/survey-follow-up.ts


const evaluateFollowUp = async (followUpId, followUpAction, response, organization)=>{
    const { properties } = followUpAction;
    const { to, subject, body, replyTo } = properties;
    const toValueFromResponse = response.data[to];
    const logoUrl = organization.whitelabel?.logoUrl || "";
    if (!toValueFromResponse) {
        throw new Error(`"To" value not found in response data for followup: ${followUpId}`);
    }
    if (typeof toValueFromResponse === "string") {
        // parse this string to check for an email:
        const parsedResult = lib.z.string().email().safeParse(toValueFromResponse);
        if (parsedResult.data) {
            // send email to this email address
            await (0,email/* sendFollowUpEmail */.F0)(body, subject, parsedResult.data, replyTo, logoUrl);
        } else {
            throw new Error(`Email address is not valid for followup: ${followUpId}`);
        }
    } else if (Array.isArray(toValueFromResponse)) {
        const emailAddress = toValueFromResponse[2];
        if (!emailAddress) {
            throw new Error(`Email address not found in response data for followup: ${followUpId}`);
        }
        const parsedResult = lib.z.string().email().safeParse(emailAddress);
        if (parsedResult.data) {
            await (0,email/* sendFollowUpEmail */.F0)(body, subject, parsedResult.data, replyTo, logoUrl);
        } else {
            throw new Error(`Email address is not valid for followup: ${followUpId}`);
        }
    }
};
const sendSurveyFollowUps = async (survey, response, organization)=>{
    const followUpPromises = survey.followUps.map(async (followUp)=>{
        const { trigger } = followUp;
        // Check if we should skip this follow-up based on ending IDs
        if (trigger.properties) {
            const { endingIds } = trigger.properties;
            const { endingId } = response;
            if (!endingId || !endingIds.includes(endingId)) {
                return Promise.resolve({
                    followUpId: followUp.id,
                    status: "skipped"
                });
            }
        }
        return evaluateFollowUp(followUp.id, followUp.action, response, organization).then(()=>({
                followUpId: followUp.id,
                status: "success"
            })).catch((error)=>({
                followUpId: followUp.id,
                status: "error",
                error: error instanceof Error ? error.message : "Something went wrong"
            }));
    });
    const followUpResults = await Promise.all(followUpPromises);
    // Log all errors
    const errors = followUpResults.filter((result)=>result.status === "error").map((result)=>`FollowUp ${result.followUpId} failed: ${result.error}`);
    if (errors.length > 0) {
        console.error("Follow-up processing errors:", errors);
    }
};

// EXTERNAL MODULE: ../../packages/database/zod/webhooks.ts
var webhooks = __webpack_require__(347136);
// EXTERNAL MODULE: ../../packages/types/responses.ts + 1 modules
var responses = __webpack_require__(333418);
;// ./app/api/(internal)/pipeline/types/pipelines.ts



const ZPipelineInput = lib.z.object({
    event: webhooks/* ZWebhook */.Q.shape.triggers.element,
    response: responses/* ZResponse */.wc,
    environmentId: lib.z.string(),
    surveyId: lib.z.string()
});

// EXTERNAL MODULE: ./app/lib/api/response.ts
var api_response = __webpack_require__(328779);
// EXTERNAL MODULE: ./app/lib/api/validator.ts
var validator = __webpack_require__(105032);
// EXTERNAL MODULE: ./lib/cache/webhook.ts
var webhook = __webpack_require__(335381);
// EXTERNAL MODULE: ./modules/ee/license-check/lib/utils.ts + 1 modules
var utils = __webpack_require__(532077);
// EXTERNAL MODULE: ./modules/survey-follow-ups/lib/utils.ts
var lib_utils = __webpack_require__(234010);
// EXTERNAL MODULE: ../../node_modules/next/dist/api/headers.js
var headers = __webpack_require__(680255);
// EXTERNAL MODULE: ../../packages/lib/cache.ts
var cache = __webpack_require__(794356);
// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(836919);
// EXTERNAL MODULE: ../../packages/lib/integration/service.ts + 3 modules
var service = __webpack_require__(43684);
// EXTERNAL MODULE: ../../packages/lib/organization/service.ts
var organization_service = __webpack_require__(353687);
// EXTERNAL MODULE: ../../packages/lib/response/service.ts + 2 modules
var response_service = __webpack_require__(408478);
// EXTERNAL MODULE: ../../packages/lib/survey/service.ts
var survey_service = __webpack_require__(222118);
// EXTERNAL MODULE: ../../packages/lib/time.ts
var time = __webpack_require__(951925);
// EXTERNAL MODULE: ../../packages/lib/utils/ai.ts
var ai = __webpack_require__(483228);
// EXTERNAL MODULE: ../../packages/lib/utils/recall.ts + 1 modules
var recall = __webpack_require__(239949);
// EXTERNAL MODULE: ../../packages/lib/airtable/service.ts
var airtable_service = __webpack_require__(831040);
// EXTERNAL MODULE: ../../packages/types/common.ts
var common = __webpack_require__(733735);
// EXTERNAL MODULE: ../../packages/types/integration/google-sheet.ts
var google_sheet = __webpack_require__(816948);
// EXTERNAL MODULE: ../../packages/lib/utils/strings.ts
var strings = __webpack_require__(302722);
;// ../../packages/lib/googleSheet/service.ts











const { google } = __webpack_require__(380928);
const writeData = async (integrationData, spreadsheetId, values)=>{
    (0,validate/* validateInputs */.C)([
        integrationData,
        google_sheet/* ZIntegrationGoogleSheets */.Gl
    ], [
        spreadsheetId,
        common/* ZString */.eI
    ], [
        values,
        lib.z.array(lib.z.array(common/* ZString */.eI))
    ]);
    try {
        const authClient = await authorize(integrationData);
        const sheets = google.sheets({
            version: "v4",
            auth: authClient
        });
        const responses = {
            values: [
                values[0].map((value)=>value.length > constants/* GOOGLE_SHEET_MESSAGE_LIMIT */._N ? (0,strings/* truncateText */.EJ)(value, constants/* GOOGLE_SHEET_MESSAGE_LIMIT */._N) : value)
            ]
        };
        const question = {
            values: [
                values[1]
            ]
        };
        sheets.spreadsheets.values.update({
            spreadsheetId: spreadsheetId,
            range: "A1",
            valueInputOption: "RAW",
            resource: question
        }, (err)=>{
            if (err) {
                throw new errors/* UnknownError */.Bk(`Error while appending data: ${err.message}`);
            }
        });
        sheets.spreadsheets.values.append({
            spreadsheetId: spreadsheetId,
            range: "A2",
            valueInputOption: "RAW",
            resource: responses
        }, (err)=>{
            if (err) {
                throw new errors/* UnknownError */.Bk(`Error while appending data: ${err.message}`);
            }
        });
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};
const getSpreadsheetNameById = async (googleSheetIntegrationData, spreadsheetId)=>{
    validateInputs([
        googleSheetIntegrationData,
        ZIntegrationGoogleSheets
    ]);
    try {
        const authClient = await authorize(googleSheetIntegrationData);
        const sheets = google.sheets({
            version: "v4",
            auth: authClient
        });
        return new Promise((resolve, reject)=>{
            sheets.spreadsheets.get({
                spreadsheetId
            }, (err, response)=>{
                if (err) {
                    reject(new UnknownError(`Error while fetching spreadsheet data: ${err.message}`));
                    return;
                }
                const spreadsheetTitle = response.data.properties.title;
                resolve(spreadsheetTitle);
            });
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            throw new DatabaseError(error.message);
        }
        throw error;
    }
};
const authorize = async (googleSheetIntegrationData)=>{
    const client_id = constants/* GOOGLE_SHEETS_CLIENT_ID */.DR;
    const client_secret = constants/* GOOGLE_SHEETS_CLIENT_SECRET */.yg;
    const redirect_uri = constants/* GOOGLE_SHEETS_REDIRECT_URL */.SP;
    const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uri);
    const refresh_token = googleSheetIntegrationData.config.key.refresh_token;
    oAuth2Client.setCredentials({
        refresh_token
    });
    const { credentials } = await oAuth2Client.refreshAccessToken();
    await (0,service/* createOrUpdateIntegration */.d6)(googleSheetIntegrationData.environmentId, {
        type: "googleSheets",
        config: {
            data: googleSheetIntegrationData.config?.data ?? [],
            email: googleSheetIntegrationData.config?.email ?? "",
            key: credentials
        }
    });
    oAuth2Client.setCredentials(credentials);
    return oAuth2Client;
};

// EXTERNAL MODULE: ../../packages/lib/i18n/utils.ts
var i18n_utils = __webpack_require__(921418);
// EXTERNAL MODULE: ../../packages/lib/notion/service.ts
var notion_service = __webpack_require__(735609);
// EXTERNAL MODULE: ../../packages/lib/responses.ts
var lib_responses = __webpack_require__(328730);
;// ../../packages/lib/slack/service.ts





const fetchChannels = async (slackIntegration)=>{
    let channels = [];
    // `nextCursor` is a pagination token returned by the Slack API. It indicates the presence of additional pages of data.
    // When `nextCursor` is not empty, it should be included in subsequent requests to fetch the next page of data.
    let nextCursor = undefined;
    do {
        const url = new URL("https://slack.com/api/users.conversations");
        url.searchParams.append("limit", "200");
        url.searchParams.append("types", "private_channel,public_channel");
        if (nextCursor) {
            url.searchParams.append("cursor", nextCursor);
        }
        const response = await fetch(url.toString(), {
            method: "GET",
            headers: {
                Authorization: `Bearer ${slackIntegration.config.key.access_token}`,
                "Content-Type": "application/x-www-form-urlencoded"
            }
        });
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        const data = await response.json();
        if (!data.ok) {
            if (data.error === "token_expired") {
                // Temporary fix to reset integration if token rotation is enabled
                await deleteIntegration(slackIntegration.id);
            }
            throw new Error(data.error);
        }
        channels = channels.concat(data.channels.map((channel)=>({
                name: channel.name,
                id: channel.id
            })));
        nextCursor = data.response_metadata?.next_cursor;
    }while (nextCursor);
    return channels;
};
const getSlackChannels = async (environmentId)=>{
    let channels = [];
    try {
        const slackIntegration = await getIntegrationByType(environmentId, "slack");
        if (slackIntegration && slackIntegration.config?.key) {
            channels = await fetchChannels(slackIntegration);
        }
        return channels;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            throw new DatabaseError("Database operation failed");
        }
        throw new UnknownError(error);
    }
};
const writeDataToSlack = async (credentials, channelId, values, surveyName)=>{
    try {
        const [responses, questions] = values;
        let blockResponse = [
            {
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: `${surveyName}\n`
                }
            },
            {
                type: "divider"
            }
        ];
        for(let i = 0; i < values[0].length; i++){
            let questionSection = {
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: `*${questions[i]}*`
                }
            };
            const responseText = responses[i];
            const text = responseText.length > constants/* SLACK_MESSAGE_LIMIT */.Xu ? (0,strings/* truncateText */.EJ)(responseText, constants/* SLACK_MESSAGE_LIMIT */.Xu) : responseText;
            let responseSection = {
                type: "section",
                text: {
                    type: "mrkdwn",
                    text: `${text}\n`
                }
            };
            blockResponse.push(questionSection, responseSection);
        }
        const response = await fetch("https://slack.com/api/chat.postMessage", {
            method: "POST",
            headers: {
                Authorization: `Bearer ${credentials.access_token}`,
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                channel: channelId,
                blocks: blockResponse
            })
        });
        if (!response.ok) {
            throw new Error("Network response was not ok");
        }
        const data = await response.json();
        if (!data.ok) {
            throw new Error(data.error);
        }
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$("Database operation failed");
        }
        throw error;
    }
};

// EXTERNAL MODULE: ../../packages/lib/utils/datetime.ts
var datetime = __webpack_require__(722515);
// EXTERNAL MODULE: ../../packages/types/surveys/types.ts + 2 modules
var types = __webpack_require__(875863);
;// ./app/api/(internal)/pipeline/lib/handleIntegrations.ts











const convertMetaObjectToString = (metadata)=>{
    let result = [];
    if (metadata.source) result.push(`Source: ${metadata.source}`);
    if (metadata.url) result.push(`URL: ${metadata.url}`);
    if (metadata.userAgent?.browser) result.push(`Browser: ${metadata.userAgent.browser}`);
    if (metadata.userAgent?.os) result.push(`OS: ${metadata.userAgent.os}`);
    if (metadata.userAgent?.device) result.push(`Device: ${metadata.userAgent.device}`);
    if (metadata.country) result.push(`Country: ${metadata.country}`);
    if (metadata.action) result.push(`Action: ${metadata.action}`);
    // Join all the elements in the result array with a newline for formatting
    return result.join("\n");
};
const processDataForIntegration = async (integrationType, data, survey, includeVariables, includeMetadata, includeHiddenFields, includeCreatedAt, questionIds)=>{
    const ids = includeHiddenFields && survey.hiddenFields.fieldIds ? [
        ...questionIds,
        ...survey.hiddenFields.fieldIds
    ] : questionIds;
    const values = await extractResponses(integrationType, data, ids, survey);
    if (includeMetadata) {
        values[0].push(convertMetaObjectToString(data.response.meta));
        values[1].push("Metadata");
    }
    if (includeVariables) {
        survey.variables.forEach((variable)=>{
            const value = data.response.variables[variable.id];
            if (value !== undefined) {
                values[0].push(String(data.response.variables[variable.id]));
                values[1].push(variable.name);
            }
        });
    }
    if (includeCreatedAt) {
        const date = new Date(data.response.createdAt);
        values[0].push(`${(0,datetime/* getFormattedDateTimeString */.HJ)(date)}`);
        values[1].push("Created At");
    }
    return values;
};
const handleIntegrations = async (integrations, data, survey)=>{
    for (const integration of integrations){
        switch(integration.type){
            case "googleSheets":
                const googleResult = await handleGoogleSheetsIntegration(integration, data, survey);
                if (!googleResult.ok) {
                    console.error("Error in google sheets integration: ", googleResult.error);
                }
                break;
            case "slack":
                const slackResult = await handleSlackIntegration(integration, data, survey);
                if (!slackResult.ok) {
                    console.error("Error in slack integration: ", slackResult.error);
                }
                break;
            case "airtable":
                const airtableResult = await handleAirtableIntegration(integration, data, survey);
                if (!airtableResult.ok) {
                    console.error("Error in airtable integration: ", airtableResult.error);
                }
                break;
            case "notion":
                const notionResult = await handleNotionIntegration(integration, data, survey);
                if (!notionResult.ok) {
                    console.error("Error in notion integration: ", notionResult.error);
                }
                break;
        }
    }
};
const handleAirtableIntegration = async (integration, data, survey)=>{
    try {
        if (integration.config.data.length > 0) {
            for (const element of integration.config.data){
                if (element.surveyId === data.surveyId) {
                    const values = await processDataForIntegration("airtable", data, survey, !!element.includeVariables, !!element.includeMetadata, !!element.includeHiddenFields, !!element.includeCreatedAt, element.questionIds);
                    await (0,airtable_service/* writeData */.Mr)(integration.config.key, element, values);
                }
            }
        }
        return {
            ok: true,
            data: undefined
        };
    } catch (err) {
        return {
            ok: false,
            error: err
        };
    }
};
const handleGoogleSheetsIntegration = async (integration, data, survey)=>{
    try {
        if (integration.config.data.length > 0) {
            for (const element of integration.config.data){
                if (element.surveyId === data.surveyId) {
                    const values = await processDataForIntegration("googleSheets", data, survey, !!element.includeVariables, !!element.includeMetadata, !!element.includeHiddenFields, !!element.includeCreatedAt, element.questionIds);
                    const integrationData = structuredClone(integration);
                    integrationData.config.data.forEach((data)=>{
                        data.createdAt = new Date(data.createdAt);
                    });
                    await writeData(integrationData, element.spreadsheetId, values);
                }
            }
        }
        return {
            ok: true,
            data: undefined
        };
    } catch (err) {
        return {
            ok: false,
            error: err
        };
    }
};
const handleSlackIntegration = async (integration, data, survey)=>{
    try {
        if (integration.config.data.length > 0) {
            for (const element of integration.config.data){
                if (element.surveyId === data.surveyId) {
                    const values = await processDataForIntegration("slack", data, survey, !!element.includeVariables, !!element.includeMetadata, !!element.includeHiddenFields, !!element.includeCreatedAt, element.questionIds);
                    await writeDataToSlack(integration.config.key, element.channelId, values, survey?.name);
                }
            }
        }
        return {
            ok: true,
            data: undefined
        };
    } catch (err) {
        return {
            ok: false,
            error: err
        };
    }
};
const extractResponses = async (integrationType, pipelineData, questionIds, survey)=>{
    const responses = [];
    const questions = [];
    for (const questionId of questionIds){
        //check for hidden field Ids
        if (survey.hiddenFields.fieldIds?.includes(questionId)) {
            responses.push((0,lib_responses/* processResponseData */.fZ)(pipelineData.response.data[questionId]));
            questions.push(questionId);
            continue;
        }
        const question = survey?.questions.find((q)=>q.id === questionId);
        if (!question) {
            continue;
        }
        const responseValue = pipelineData.response.data[questionId];
        if (responseValue !== undefined) {
            let answer;
            if (question.type === types/* TSurveyQuestionTypeEnum */.wn.PictureSelection) {
                const selectedChoiceIds = responseValue;
                answer = question?.choices.filter((choice)=>selectedChoiceIds.includes(choice.id)).map((choice)=>choice.imageUrl).join("\n");
            } else {
                answer = responseValue;
            }
            responses.push((0,lib_responses/* processResponseData */.fZ)(answer));
        } else {
            responses.push("");
        }
        // Create emptyResponseObject with same keys but empty string values
        const emptyResponseObject = Object.keys(pipelineData.response.data).reduce((acc, key)=>{
            acc[key] = "";
            return acc;
        }, {});
        questions.push((0,recall/* parseRecallInfo */.VY)((0,i18n_utils/* getLocalizedValue */.bT)(question?.headline, "default"), integrationType === "slack" ? pipelineData.response.data : emptyResponseObject, integrationType === "slack" ? pipelineData.response.variables : {}) || "");
    }
    return [
        responses,
        questions
    ];
};
const handleNotionIntegration = async (integration, data, surveyData)=>{
    try {
        if (integration.config.data.length > 0) {
            for (const element of integration.config.data){
                if (element.surveyId === data.surveyId) {
                    const properties = buildNotionPayloadProperties(element.mapping, data, surveyData);
                    await (0,notion_service/* writeData */.M)(element.databaseId, properties, integration.config);
                }
            }
        }
        return {
            ok: true,
            data: undefined
        };
    } catch (err) {
        return {
            ok: false,
            error: err
        };
    }
};
const buildNotionPayloadProperties = (mapping, data, surveyData)=>{
    const properties = {};
    const responses = data.response.data;
    const mappingQIds = mapping.filter((m)=>m.question.type === types/* TSurveyQuestionTypeEnum */.wn.PictureSelection).map((m)=>m.question.id);
    Object.keys(responses).forEach((resp)=>{
        if (mappingQIds.find((qId)=>qId === resp)) {
            const selectedChoiceIds = responses[resp];
            const pictureQuestion = surveyData.questions.find((q)=>q.id === resp);
            responses[resp] = pictureQuestion?.choices.filter((choice)=>selectedChoiceIds.includes(choice.id)).map((choice)=>choice.imageUrl);
        }
    });
    mapping.forEach((map)=>{
        if (map.question.id === "metadata") {
            properties[map.column.name] = {
                [map.column.type]: getValue(map.column.type, convertMetaObjectToString(data.response.meta)) || null
            };
        } else if (map.question.id === "createdAt") {
            properties[map.column.name] = {
                [map.column.type]: getValue(map.column.type, data.response.createdAt) || null
            };
        } else {
            const value = responses[map.question.id];
            properties[map.column.name] = {
                [map.column.type]: getValue(map.column.type, value) || null
            };
        }
    });
    return properties;
};
// notion requires specific payload for each column type
// * TYPES NOT SUPPORTED BY NOTION API - rollup, created_by, created_time, last_edited_by, or last_edited_time
const getValue = (colType, value)=>{
    try {
        switch(colType){
            case "select":
                if (!value) return null;
                if (typeof value === "string") {
                    // Replace commas
                    const sanitizedValue = value.replace(/,/g, "");
                    return {
                        name: sanitizedValue
                    };
                }
            case "multi_select":
                if (Array.isArray(value)) {
                    return value.map((v)=>({
                            name: v.replace(/,/g, "")
                        }));
                }
            case "title":
                return [
                    {
                        text: {
                            content: value
                        }
                    }
                ];
            case "rich_text":
                if (typeof value === "string") {
                    return [
                        {
                            text: {
                                content: value.length > constants/* NOTION_RICH_TEXT_LIMIT */.Bx ? (0,strings/* truncateText */.EJ)(value, constants/* NOTION_RICH_TEXT_LIMIT */.Bx) : value
                            }
                        }
                    ];
                }
                return [
                    {
                        text: {
                            content: value
                        }
                    }
                ];
            case "status":
                return {
                    name: value
                };
            case "checkbox":
                return value === "accepted" || value === "clicked";
            case "date":
                return {
                    start: value
                };
            case "email":
                return value;
            case "number":
                return parseInt(value);
            case "phone_number":
                return value;
            case "url":
                return typeof value === "string" ? value : value.join(", ");
        }
    } catch (error) {
        console.error(error);
        throw new Error("Payload build failed!");
    }
};

;// ./app/api/(internal)/pipeline/route.ts





















const POST = async (request)=>{
    const requestHeaders = await (0,headers.headers)();
    // Check authentication
    if (requestHeaders.get("x-api-key") !== constants/* CRON_SECRET */.Kd) {
        return api_response/* responses */.n.notAuthenticatedResponse();
    }
    const jsonInput = await request.json();
    const convertedJsonInput = (0,time/* convertDatesInObject */.Rw)(jsonInput);
    const inputValidation = ZPipelineInput.safeParse(convertedJsonInput);
    if (!inputValidation.success) {
        console.error(inputValidation.error);
        return api_response/* responses */.n.badRequestResponse("Fields are missing or incorrectly formatted", (0,validator/* transformErrorToDetails */.m)(inputValidation.error), true);
    }
    const { environmentId, surveyId, event, response } = inputValidation.data;
    const organization = await (0,organization_service/* getOrganizationByEnvironmentId */.TK)(environmentId);
    if (!organization) {
        throw new Error("Organization not found");
    }
    // Fetch webhooks
    const getWebhooksForPipeline = (0,cache/* cache */.P)(async (environmentId, event, surveyId)=>{
        const webhooks = await src/* prisma */.z.webhook.findMany({
            where: {
                environmentId,
                triggers: {
                    has: event
                },
                OR: [
                    {
                        surveyIds: {
                            has: surveyId
                        }
                    },
                    {
                        surveyIds: {
                            isEmpty: true
                        }
                    }
                ]
            }
        });
        return webhooks;
    }, [
        `getWebhooksForPipeline-${environmentId}-${event}-${surveyId}`
    ], {
        tags: [
            webhook/* webhookCache */.Q.tag.byEnvironmentId(environmentId)
        ]
    });
    const webhooks = await getWebhooksForPipeline(environmentId, event, surveyId);
    // Prepare webhook and email promises
    // Fetch with timeout of 5 seconds to prevent hanging
    const fetchWithTimeout = (url, options, timeout = 5000)=>{
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject)=>setTimeout(()=>reject(new Error("Timeout")), timeout))
        ]);
    };
    const webhookPromises = webhooks.map((webhook)=>fetchWithTimeout(webhook.url, {
            method: "POST",
            headers: {
                "content-type": "application/json"
            },
            body: JSON.stringify({
                webhookId: webhook.id,
                event,
                data: response
            })
        }).catch((error)=>{
            console.error(`Webhook call to ${webhook.url} failed:`, error);
        }));
    if (event === "responseFinished") {
        // Fetch integrations, survey, and responseCount in parallel
        const [integrations, survey, responseCount] = await Promise.all([
            (0,service/* getIntegrations */.Yl)(environmentId),
            (0,survey_service/* getSurvey */.Dp)(surveyId),
            (0,response_service/* getResponseCountBySurveyId */.h4)(surveyId)
        ]);
        if (!survey) {
            console.error(`Survey with id ${surveyId} not found`);
            return new Response("Survey not found", {
                status: 404
            });
        }
        if (integrations.length > 0) {
            await handleIntegrations(integrations, inputValidation.data, survey);
        }
        // Fetch users with notifications in a single query
        // TODO: add cache for this query. Not possible at the moment since we can't get the membership cache by environmentId
        const usersWithNotifications = await src/* prisma */.z.user.findMany({
            where: {
                memberships: {
                    some: {
                        organization: {
                            projects: {
                                some: {
                                    environments: {
                                        some: {
                                            id: environmentId
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                OR: [
                    {
                        memberships: {
                            every: {
                                role: {
                                    in: [
                                        "owner",
                                        "manager"
                                    ]
                                }
                            }
                        }
                    },
                    {
                        teamUsers: {
                            some: {
                                team: {
                                    projectTeams: {
                                        some: {
                                            project: {
                                                environments: {
                                                    some: {
                                                        id: environmentId
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                ],
                notificationSettings: {
                    path: [
                        "alert",
                        surveyId
                    ],
                    equals: true
                }
            },
            select: {
                email: true,
                locale: true
            }
        });
        // send follow up emails
        const surveyFollowUpsPermission = await (0,lib_utils/* getSurveyFollowUpsPermission */.T)(organization);
        if (surveyFollowUpsPermission) {
            await sendSurveyFollowUps(survey, response, organization);
        }
        const emailPromises = usersWithNotifications.map((user)=>(0,email/* sendResponseFinishedEmail */.yx)(user.email, environmentId, survey, response, responseCount).catch((error)=>{
                console.error(`Failed to send email to ${user.email}:`, error);
            }));
        // Update survey status if necessary
        if (survey.autoComplete && responseCount >= survey.autoComplete) {
            await (0,survey_service/* updateSurvey */.cU)({
                ...survey,
                status: "completed"
            });
        }
        // Await webhook and email promises with allSettled to prevent early rejection
        const results = await Promise.allSettled([
            ...webhookPromises,
            ...emailPromises
        ]);
        results.forEach((result)=>{
            if (result.status === "rejected") {
                console.error("Promise rejected:", result.reason);
            }
        });
        // generate embeddings for all open text question responses for all paid plans
        const hasSurveyOpenTextQuestions = survey.questions.some((question)=>question.type === "openText");
        if (hasSurveyOpenTextQuestions) {
            const isAICofigured = constants/* IS_AI_CONFIGURED */.T1;
            if (hasSurveyOpenTextQuestions && isAICofigured) {
                const isAIEnabled = await (0,utils/* getIsAIEnabled */.KH)(organization);
                if (isAIEnabled) {
                    for (const question of survey.questions){
                        if (question.type === "openText" && question.insightsEnabled) {
                            const isQuestionAnswered = response.data[question.id] !== undefined && response.data[question.id] !== "";
                            if (!isQuestionAnswered) {
                                continue;
                            }
                            const headline = (0,recall/* parseRecallInfo */.VY)(question.headline[response.language ?? "default"], response.data, response.variables);
                            const text = (0,ai/* getPromptText */.W)(headline, response.data[question.id]);
                            // TODO: check if subheadline gives more context and better embeddings
                            try {
                                await createDocumentAndAssignInsight(survey.name, {
                                    environmentId,
                                    surveyId,
                                    responseId: response.id,
                                    questionId: question.id,
                                    text
                                });
                            } catch (e) {
                                console.error(e);
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Await webhook promises if no emails are sent (with allSettled to prevent early rejection)
        const results = await Promise.allSettled(webhookPromises);
        results.forEach((result)=>{
            if (result.status === "rejected") {
                console.error("Promise rejected:", result.reason);
            }
        });
    }
    return Response.json({
        data: {}
    });
};

;// ../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?page=%2Fapi%2F(internal)%2Fpipeline%2Froute&name=app%2Fapi%2F(internal)%2Fpipeline%2Froute&pagePath=private-next-app-dir%2Fapi%2F(internal)%2Fpipeline%2Froute.ts&appDir=%2FUsers%2Fkdy1%2Fprojects%2Fformbricks%2Fapps%2Fweb%2Fapp&appPaths=%2Fapi%2F(internal)%2Fpipeline%2Froute&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&basePath=&assetPrefix=&nextConfigOutput=standalone&nextConfigExperimentalUseEarlyImport=&preferredRegion=&middlewareConfig=e30%3D!




// We inject the nextConfigOutput here so that we can use them in the route
// module.
const nextConfigOutput = "standalone"
const routeModule = new module_compiled.AppRouteRouteModule({
    definition: {
        kind: route_kind.RouteKind.APP_ROUTE,
        page: "/api/(internal)/pipeline/route",
        pathname: "/api/pipeline",
        filename: "route",
        bundlePath: "app/api/(internal)/pipeline/route"
    },
    resolvedPagePath: "/Users/kdy1/projects/formbricks/apps/web/app/api/(internal)/pipeline/route.ts",
    nextConfigOutput,
    userland: route_namespaceObject
});
// Pull out the exports that we need to expose from the module. This should
// be eliminated when we've moved the other routes to the new format. These
// are used to hook into the route.
const { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;
function patchFetch() {
    return (0,patch_fetch.patchFetch)({
        workAsyncStorage,
        workUnitAsyncStorage
    });
}


//# sourceMappingURL=app-route.js.map

/***/ }),

/***/ 335381:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ webhookCache)
/* harmony export */ });
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87863);
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_cache__WEBPACK_IMPORTED_MODULE_0__);

const webhookCache = {
    tag: {
        byId (id) {
            return `webhooks-${id}`;
        },
        byEnvironmentId (environmentId) {
            return `environments-${environmentId}-webhooks`;
        },
        byEnvironmentIdAndSource (environmentId, source) {
            return `environments-${environmentId}-sources-${source}-webhooks`;
        }
    },
    revalidate ({ id, environmentId, source }) {
        if (id) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byId(id));
        }
        if (environmentId) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byEnvironmentId(environmentId));
        }
        if (environmentId && source) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byEnvironmentIdAndSource(environmentId, source));
        }
    }
};


/***/ }),

/***/ 136015:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  N: () => (/* binding */ authOptions)
});

// EXTERNAL MODULE: external "@prisma/client"
var client_ = __webpack_require__(896330);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js
var react = __webpack_require__(922728);
// EXTERNAL MODULE: ../../packages/database/src/index.ts + 1 modules
var src = __webpack_require__(527610);
// EXTERNAL MODULE: ../../packages/lib/cache.ts
var cache = __webpack_require__(794356);
// EXTERNAL MODULE: ../../packages/lib/user/cache.ts
var user_cache = __webpack_require__(323798);
// EXTERNAL MODULE: ../../packages/lib/utils/validate.ts
var validate = __webpack_require__(860988);
// EXTERNAL MODULE: ../../packages/types/common.ts
var common = __webpack_require__(733735);
// EXTERNAL MODULE: ../../packages/types/errors.ts
var errors = __webpack_require__(470641);
// EXTERNAL MODULE: ../../packages/types/user.ts
var user = __webpack_require__(354345);
;// ./modules/auth/lib/user.ts









const updateUser = async (id, data)=>{
    (0,validate/* validateInputs */.C)([
        id,
        common/* ZId */.i4
    ], [
        data,
        user/* ZUserUpdateInput */.rd.partial()
    ]);
    try {
        const updatedUser = await src/* prisma */.z.user.update({
            where: {
                id
            },
            data: data,
            select: {
                id: true,
                email: true,
                locale: true,
                emailVerified: true
            }
        });
        user_cache/* userCache */.g.revalidate({
            email: updatedUser.email,
            id: updatedUser.id
        });
        return updatedUser;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError && error.code === "P2016") {
            throw new errors/* ResourceNotFoundError */.CE("User", id);
        }
        throw error;
    }
};
const getUserByEmail = (0,react.cache)(async (email)=>(0,cache/* cache */.P)(async ()=>{
        (0,validate/* validateInputs */.C)([
            email,
            user/* ZUserEmail */.sO
        ]);
        try {
            const user = await src/* prisma */.z.user.findFirst({
                where: {
                    email
                },
                select: {
                    id: true,
                    locale: true,
                    email: true,
                    emailVerified: true
                }
            });
            return user;
        } catch (error) {
            if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
                throw new errors/* DatabaseError */.a$(error.message);
            }
            throw error;
        }
    }, [
        `getUserByEmail-${email}`
    ], {
        tags: [
            user_cache/* userCache */.g.tag.byEmail(email)
        ]
    })());
const getUser = (0,react.cache)(async (id)=>(0,cache/* cache */.P)(async ()=>{
        (0,validate/* validateInputs */.C)([
            id,
            common/* ZId */.i4
        ]);
        try {
            const user = await src/* prisma */.z.user.findUnique({
                where: {
                    id
                },
                select: {
                    id: true
                }
            });
            if (!user) {
                return null;
            }
            return user;
        } catch (error) {
            if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
                throw new errors/* DatabaseError */.a$(error.message);
            }
            throw error;
        }
    }, [
        `getUser-${id}`
    ], {
        tags: [
            user_cache/* userCache */.g.tag.byId(id)
        ]
    })());
const createUser = async (data)=>{
    (0,validate/* validateInputs */.C)([
        data,
        user/* ZUserUpdateInput */.rd
    ]);
    try {
        const user = await src/* prisma */.z.user.create({
            data: data,
            select: {
                name: true,
                notificationSettings: true,
                id: true,
                email: true,
                locale: true
            }
        });
        user_cache/* userCache */.g.revalidate({
            email: user.email,
            id: user.id,
            count: true
        });
        return user;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError && error.code === "P2002") {
            throw new errors/* InvalidInputError */.oC("User with this email already exists");
        }
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};

// EXTERNAL MODULE: ../../node_modules/bcryptjs/index.js
var bcryptjs = __webpack_require__(765737);
;// ./modules/auth/lib/utils.ts

const hashPassword = async (password)=>{
    const hashedPassword = await hash(password, 12);
    return hashedPassword;
};
const verifyPassword = async (password, hashedPassword)=>{
    const isValid = await (0,bcryptjs.compare)(password, hashedPassword);
    return isValid;
};

// EXTERNAL MODULE: ../../node_modules/next-auth/providers/azure-ad.js
var azure_ad = __webpack_require__(790780);
// EXTERNAL MODULE: ../../node_modules/next-auth/providers/github.js
var github = __webpack_require__(377888);
// EXTERNAL MODULE: ../../node_modules/next-auth/providers/google.js
var google = __webpack_require__(222736);
// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(836919);
;// ./modules/ee/sso/lib/providers.ts




const getSSOProviders = ()=>[
        (0,github/* default */.A)({
            clientId: constants/* GITHUB_ID */.gK || "",
            clientSecret: constants/* GITHUB_SECRET */.hP || ""
        }),
        (0,google/* default */.A)({
            clientId: constants/* GOOGLE_CLIENT_ID */.E5 || "",
            clientSecret: constants/* GOOGLE_CLIENT_SECRET */.n$ || "",
            allowDangerousEmailAccountLinking: true
        }),
        (0,azure_ad/* default */.A)({
            clientId: constants/* AZUREAD_CLIENT_ID */.RP || "",
            clientSecret: constants/* AZUREAD_CLIENT_SECRET */.mn || "",
            tenantId: constants/* AZUREAD_TENANT_ID */.kO || ""
        }),
        {
            id: "openid",
            name: constants/* OIDC_DISPLAY_NAME */.jP || "OpenId",
            type: "oauth",
            clientId: constants/* OIDC_CLIENT_ID */.kK || "",
            clientSecret: constants/* OIDC_CLIENT_SECRET */.r4 || "",
            wellKnown: `${constants/* OIDC_ISSUER */.Mo}/.well-known/openid-configuration`,
            authorization: {
                params: {
                    scope: "openid email profile"
                }
            },
            idToken: true,
            client: {
                id_token_signed_response_alg: constants/* OIDC_SIGNING_ALGORITHM */.CT || "RS256"
            },
            checks: [
                "pkce",
                "state"
            ],
            profile: (profile)=>{
                return {
                    id: profile.sub,
                    name: profile.name,
                    email: profile.email,
                    image: profile.picture
                };
            }
        }
    ];

;// ./modules/auth/lib/brevo.ts




const createBrevoCustomer = async ({ id, email })=>{
    if (!constants/* BREVO_API_KEY */.oz) {
        return;
    }
    (0,validate/* validateInputs */.C)([
        id,
        common/* ZId */.i4
    ], [
        email,
        user/* ZUserEmail */.sO
    ]);
    try {
        const requestBody = {
            email,
            ext_id: id,
            updateEnabled: false
        };
        // Add `listIds` only if `BREVO_LIST_ID` is defined
        const listId = constants/* BREVO_LIST_ID */.aS ? parseInt(constants/* BREVO_LIST_ID */.aS, 10) : null;
        if (listId && !Number.isNaN(listId)) {
            requestBody.listIds = [
                listId
            ];
        }
        const res = await fetch("https://api.brevo.com/v3/contacts", {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "api-key": constants/* BREVO_API_KEY */.oz
            },
            body: JSON.stringify(requestBody)
        });
        if (res.status !== 200) {
            console.error("Error sending user to Brevo:", await res.text());
        }
    } catch (error) {
        console.error("Error sending user to Brevo:", error);
    }
};

// EXTERNAL MODULE: ../../node_modules/zod/lib/index.mjs
var lib = __webpack_require__(545198);
;// ../../packages/types/account.ts

const ZAccountInput = lib.z.object({
    userId: lib.z.string(),
    type: lib.z.string(),
    provider: lib.z.string(),
    providerAccountId: lib.z.string(),
    access_token: lib.z.string().nullish(),
    refresh_token: lib.z.string().nullish(),
    expires_at: lib.z.number().nullish(),
    scope: lib.z.string().nullish(),
    token_type: lib.z.string().nullish(),
    id_token: lib.z.string().nullish()
});
const ZAccount = lib.z.object({
    id: lib.z.string(),
    createdAt: lib.z.date(),
    updatedAt: lib.z.date(),
    userId: lib.z.string(),
    type: lib.z.string(),
    provider: lib.z.string(),
    providerAccountId: lib.z.string(),
    access_token: lib.z.string().nullable(),
    refresh_token: lib.z.string().nullable().optional(),
    expires_at: lib.z.number().nullable(),
    scope: lib.z.string().nullable(),
    token_type: lib.z.string().nullable(),
    id_token: lib.z.string().nullable()
});

;// ../../packages/lib/account/utils.ts

const filterAccountInputData = (account)=>{
    const supportedProps = Object.keys(ZAccountInput.shape);
    return supportedProps.reduce((acc, prop)=>{
        if (account.hasOwnProperty(prop)) {
            acc[prop] = account[prop];
        }
        return acc;
    }, {});
};

;// ../../packages/lib/account/service.ts






const createAccount = async (accountData)=>{
    (0,validate/* validateInputs */.C)([
        accountData,
        ZAccountInput
    ]);
    try {
        const supportedAccountData = filterAccountInputData(accountData);
        const account = await src/* prisma */.z.account.create({
            data: supportedAccountData
        });
        return account;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};

// EXTERNAL MODULE: ../../packages/lib/membership/service.ts
var service = __webpack_require__(377968);
// EXTERNAL MODULE: ../../packages/lib/organization/service.ts
var organization_service = __webpack_require__(353687);
// EXTERNAL MODULE: ../../packages/lib/utils/locale.ts
var locale = __webpack_require__(615572);
;// ./modules/ee/sso/lib/sso-handlers.ts









const handleSSOCallback = async ({ user, account })=>{
    if (!user.email || account.type !== "oauth") {
        return false;
    }
    if (account.provider) {
        const provider = account.provider.toLowerCase().replace("-", "");
        // check if accounts for this provider / account Id already exists
        const existingUserWithAccount = await src/* prisma */.z.user.findFirst({
            include: {
                accounts: {
                    where: {
                        provider: account.provider
                    }
                }
            },
            where: {
                identityProvider: provider,
                identityProviderAccountId: account.providerAccountId
            }
        });
        if (existingUserWithAccount) {
            // User with this provider found
            // check if email still the same
            if (existingUserWithAccount.email === user.email) {
                return true;
            }
            // user seemed to change his email within the provider
            // check if user with this email already exist
            // if not found just update user with new email address
            // if found throw an error (TODO find better solution)
            const otherUserWithEmail = await getUserByEmail(user.email);
            if (!otherUserWithEmail) {
                await updateUser(existingUserWithAccount.id, {
                    email: user.email
                });
                return true;
            }
            throw new Error("Looks like you updated your email somewhere else. A user with this new email exists already.");
        }
        // There is no existing account for this identity provider / account id
        // check if user account with this email already exists
        // if user already exists throw error and request password login
        const existingUserWithEmail = await getUserByEmail(user.email);
        if (existingUserWithEmail) {
            // Sign in the user with the existing account
            return true;
        }
        const userProfile = await createUser({
            name: user.name || user.email.split("@")[0].replace(/[^'\p{L}\p{M}\s\d-]+/gu, " ").trim(),
            email: user.email,
            emailVerified: new Date(Date.now()),
            identityProvider: provider,
            identityProviderAccountId: account.providerAccountId,
            locale: await (0,locale/* findMatchingLocale */.$)()
        });
        // send new user to brevo
        createBrevoCustomer({
            id: user.id,
            email: user.email
        });
        // Default organization assignment if env variable is set
        if (constants/* DEFAULT_ORGANIZATION_ID */.ac && constants/* DEFAULT_ORGANIZATION_ID */.ac.length > 0) {
            // check if organization exists
            let organization = await (0,organization_service/* getOrganization */.SA)(constants/* DEFAULT_ORGANIZATION_ID */.ac);
            let isNewOrganization = false;
            if (!organization) {
                // create organization with id from env
                organization = await (0,organization_service/* createOrganization */.EC)({
                    id: constants/* DEFAULT_ORGANIZATION_ID */.ac,
                    name: userProfile.name + "'s Organization"
                });
                isNewOrganization = true;
            }
            const role = isNewOrganization ? "owner" : constants/* DEFAULT_ORGANIZATION_ROLE */.tE || "manager";
            await (0,service/* createMembership */.$)(organization.id, userProfile.id, {
                role: role,
                accepted: true
            });
            await createAccount({
                ...account,
                userId: userProfile.id
            });
            const updatedNotificationSettings = {
                ...userProfile.notificationSettings,
                alert: {
                    ...userProfile.notificationSettings?.alert
                },
                unsubscribedOrganizationIds: Array.from(new Set([
                    ...userProfile.notificationSettings?.unsubscribedOrganizationIds || [],
                    organization.id
                ])),
                weeklySummary: {
                    ...userProfile.notificationSettings?.weeklySummary
                }
            };
            await updateUser(userProfile.id, {
                notificationSettings: updatedNotificationSettings
            });
            return true;
        }
        // Without default organization assignment
        return true;
    }
    return true;
};

// EXTERNAL MODULE: ../../node_modules/next-auth/providers/credentials.js
var credentials = __webpack_require__(978357);
// EXTERNAL MODULE: ../../packages/lib/crypto.ts
var lib_crypto = __webpack_require__(549673);
// EXTERNAL MODULE: ../../packages/lib/jwt.ts
var jwt = __webpack_require__(360379);
;// ./modules/auth/lib/authOptions.ts










const authOptions = {
    providers: [
        (0,credentials/* default */.A)({
            id: "credentials",
            // The name to display on the sign in form (e.g. "Sign in with...")
            name: "Credentials",
            // The credentials is used to generate a suitable form on the sign in page.
            // You can specify whatever fields you are expecting to be submitted.
            // e.g. domain, username, password, 2FA token, etc.
            // You can pass any HTML attribute to the <input> tag through the object.
            credentials: {
                email: {
                    label: "Email Address",
                    type: "email",
                    placeholder: "Your email address"
                },
                password: {
                    label: "Password",
                    type: "password",
                    placeholder: "Your password"
                },
                totpCode: {
                    label: "Two-factor Code",
                    type: "input",
                    placeholder: "Code from authenticator app"
                },
                backupCode: {
                    label: "Backup Code",
                    type: "input",
                    placeholder: "Two-factor backup code"
                }
            },
            async authorize (credentials, _req) {
                if (!credentials) {
                    throw new Error("Invalid credentials");
                }
                let user;
                try {
                    user = await src/* prisma */.z.user.findUnique({
                        where: {
                            email: credentials?.email
                        }
                    });
                } catch (e) {
                    console.error(e);
                    throw Error("Internal server error. Please try again later");
                }
                if (!user) {
                    throw new Error("Invalid credentials");
                }
                if (!user.password) {
                    throw new Error("User has no password stored");
                }
                const isValid = await verifyPassword(credentials.password, user.password);
                if (!isValid) {
                    throw new Error("Invalid credentials");
                }
                if (user.twoFactorEnabled && credentials.backupCode) {
                    if (!constants/* ENCRYPTION_KEY */.o7) {
                        console.error("Missing encryption key; cannot proceed with backup code login.");
                        throw new Error("Internal Server Error");
                    }
                    if (!user.backupCodes) throw new Error("No backup codes found");
                    const backupCodes = JSON.parse((0,lib_crypto/* symmetricDecrypt */.zp)(user.backupCodes, constants/* ENCRYPTION_KEY */.o7));
                    // check if user-supplied code matches one
                    const index = backupCodes.indexOf(credentials.backupCode.replaceAll("-", ""));
                    if (index === -1) throw new Error("Invalid backup code");
                    // delete verified backup code and re-encrypt remaining
                    backupCodes[index] = null;
                    await src/* prisma */.z.user.update({
                        where: {
                            id: user.id
                        },
                        data: {
                            backupCodes: (0,lib_crypto/* symmetricEncrypt */.vX)(JSON.stringify(backupCodes), constants/* ENCRYPTION_KEY */.o7)
                        }
                    });
                } else if (user.twoFactorEnabled) {
                    if (!credentials.totpCode) {
                        throw new Error("second factor required");
                    }
                    if (!user.twoFactorSecret) {
                        throw new Error("Internal Server Error");
                    }
                    if (!constants/* ENCRYPTION_KEY */.o7) {
                        throw new Error("Internal Server Error");
                    }
                    const secret = (0,lib_crypto/* symmetricDecrypt */.zp)(user.twoFactorSecret, constants/* ENCRYPTION_KEY */.o7);
                    if (secret.length !== 32) {
                        throw new Error("Invalid two factor secret");
                    }
                    const isValidToken = (await __webpack_require__.e(/* import() */ 4081).then(__webpack_require__.bind(__webpack_require__, 134081))).totpAuthenticatorCheck(credentials.totpCode, secret);
                    if (!isValidToken) {
                        throw new Error("Invalid two factor code");
                    }
                }
                return {
                    id: user.id,
                    email: user.email,
                    emailVerified: user.emailVerified,
                    imageUrl: user.imageUrl
                };
            }
        }),
        (0,credentials/* default */.A)({
            id: "token",
            // The name to display on the sign in form (e.g. "Sign in with...")
            name: "Token",
            // The credentials is used to generate a suitable form on the sign in page.
            // You can specify whatever fields you are expecting to be submitted.
            // e.g. domain, username, password, 2FA token, etc.
            // You can pass any HTML attribute to the <input> tag through the object.
            credentials: {
                token: {
                    label: "Verification Token",
                    type: "string"
                }
            },
            async authorize (credentials, _req) {
                let user;
                try {
                    if (!credentials?.token) {
                        throw new Error("Token not found");
                    }
                    const { id } = await (0,jwt/* verifyToken */.nr)(credentials?.token);
                    user = await src/* prisma */.z.user.findUnique({
                        where: {
                            id: id
                        }
                    });
                } catch (e) {
                    throw new Error("Either a user does not match the provided token or the token is invalid");
                }
                if (!user) {
                    throw new Error("Either a user does not match the provided token or the token is invalid");
                }
                if (user.emailVerified) {
                    throw new Error("Email already verified");
                }
                user = await updateUser(user.id, {
                    emailVerified: new Date()
                });
                // send new user to brevo after email verification
                createBrevoCustomer({
                    id: user.id,
                    email: user.email
                });
                return user;
            }
        }),
        // Conditionally add enterprise SSO providers
        ...constants/* ENTERPRISE_LICENSE_KEY */.an ? getSSOProviders() : []
    ],
    callbacks: {
        async jwt ({ token }) {
            const existingUser = await getUserByEmail(token?.email);
            if (!existingUser) {
                return token;
            }
            return {
                ...token,
                profile: {
                    id: existingUser.id
                }
            };
        },
        async session ({ session, token }) {
            // @ts-expect-error
            session.user.id = token?.id;
            // @ts-expect-error
            session.user = token.profile;
            return session;
        },
        async signIn ({ user, account }) {
            if (account?.provider === "credentials" || account?.provider === "token") {
                // check if user's email is verified or not
                if (!user.emailVerified && !constants/* EMAIL_VERIFICATION_DISABLED */.Q$) {
                    throw new Error("Email Verification is Pending");
                }
                return true;
            }
            if (constants/* ENTERPRISE_LICENSE_KEY */.an) {
                return handleSSOCallback({
                    user,
                    account
                });
            }
            return true;
        }
    },
    pages: {
        signIn: "/auth/login",
        signOut: "/auth/logout",
        error: "/auth/login"
    }
};


/***/ }),

/***/ 532077:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AM: () => (/* binding */ getBiggerUploadFileSizePermission),
  Zd: () => (/* binding */ getEnterpriseLicense),
  KH: () => (/* binding */ getIsAIEnabled),
  dZ: () => (/* binding */ getIsContactsEnabled),
  pn: () => (/* binding */ getIsMultiOrgEnabled),
  PN: () => (/* binding */ getIsOrganizationAIReady),
  xT: () => (/* binding */ getIsSSOEnabled),
  LO: () => (/* binding */ getIsTwoFactorAuthEnabled),
  x: () => (/* binding */ getMultiLanguagePermission),
  Df: () => (/* binding */ getOrganizationProjectsLimit),
  rQ: () => (/* binding */ getRoleManagementPermission),
  nX: () => (/* binding */ getWhiteLabelPermission)
});

// UNUSED EXPORTS: fetchLicense, getLicenseFeatures, getRemoveBrandingPermission

// EXTERNAL MODULE: ../../node_modules/https-proxy-agent/dist/index.js
var dist = __webpack_require__(599069);
// EXTERNAL MODULE: ../../node_modules/next/dist/api/server.js
var server = __webpack_require__(861238);
// EXTERNAL MODULE: ./node_modules/node-fetch/src/index.js + 12 modules
var src = __webpack_require__(817762);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js
var react = __webpack_require__(922728);
// EXTERNAL MODULE: ../../packages/database/src/index.ts + 1 modules
var database_src = __webpack_require__(527610);
// EXTERNAL MODULE: ../../packages/lib/cache.ts
var cache = __webpack_require__(794356);
// EXTERNAL MODULE: ../../node_modules/next/cache.js
var next_cache = __webpack_require__(87863);
// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(836919);
// EXTERNAL MODULE: ../../packages/lib/env.ts
var env = __webpack_require__(162437);
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(455511);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// ../../packages/lib/hashString.ts

const hashString = (string)=>{
    return external_crypto_default().createHash("sha256").update(string).digest("hex");
};

;// ./modules/ee/license-check/lib/utils.ts










const hashedKey = constants/* ENTERPRISE_LICENSE_KEY */.an ? hashString(constants/* ENTERPRISE_LICENSE_KEY */.an) : undefined;
const PREVIOUS_RESULTS_CACHE_TAG_KEY = `getPreviousResult-${hashedKey}`;
// This function is used to get the previous result of the license check from the cache
// This might seem confusing at first since we only return the default value from this function,
// but since we are using a cache and the cache key is the same, the cache will return the previous result - so this function acts as a cache getter
const getPreviousResult = ()=>(0,cache/* cache */.P)(async ()=>({
            active: null,
            lastChecked: new Date(0),
            features: null
        }), [
        PREVIOUS_RESULTS_CACHE_TAG_KEY
    ], {
        tags: [
            PREVIOUS_RESULTS_CACHE_TAG_KEY
        ]
    })();
// This function is used to set the previous result of the license check to the cache so that we can use it in the next call
// Uses the same cache key as the getPreviousResult function
const setPreviousResult = async (previousResult)=>{
    const { lastChecked, active, features } = previousResult;
    await (0,cache/* cache */.P)(async ()=>({
            active,
            lastChecked,
            features
        }), [
        PREVIOUS_RESULTS_CACHE_TAG_KEY
    ], {
        tags: [
            PREVIOUS_RESULTS_CACHE_TAG_KEY
        ]
    })();
    (0,server.after)(()=>{
        (0,next_cache.revalidateTag)(PREVIOUS_RESULTS_CACHE_TAG_KEY);
    });
};
const fetchLicenseForE2ETesting = async ()=>{
    const currentTime = new Date();
    try {
        const previousResult = await getPreviousResult();
        if (previousResult.lastChecked.getTime() === new Date(0).getTime()) {
            // first call
            const newResult = {
                active: true,
                features: {
                    isMultiOrgEnabled: true,
                    twoFactorAuth: true,
                    sso: true,
                    contacts: true,
                    projects: 3,
                    whitelabel: true,
                    removeBranding: true,
                    ai: true
                },
                lastChecked: currentTime
            };
            await setPreviousResult(newResult);
            return newResult;
        } else if (currentTime.getTime() - previousResult.lastChecked.getTime() > 60 * 60 * 1000) {
            // Fail after 1 hour
            console.log("E2E_TESTING is enabled. Enterprise license was revoked after 1 hour.");
            return null;
        }
        return previousResult;
    } catch (error) {
        console.error("Error fetching license: ", error);
        return null;
    }
};
const getEnterpriseLicense = async ()=>{
    if (!constants/* ENTERPRISE_LICENSE_KEY */.an || constants/* ENTERPRISE_LICENSE_KEY */.an.length === 0) {
        return {
            active: false,
            features: null,
            lastChecked: new Date()
        };
    }
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return {
            active: previousResult?.active ?? false,
            features: previousResult ? previousResult.features : null,
            lastChecked: previousResult ? previousResult.lastChecked : new Date()
        };
    }
    // if the server responds with a boolean, we return it
    // if the server errors, we return null
    // null signifies an error
    const license = await fetchLicense();
    const isValid = license ? license.status === "active" : null;
    const threeDaysInMillis = 3 * 24 * 60 * 60 * 1000;
    const currentTime = new Date();
    const previousResult = await getPreviousResult();
    // Case: First time checking license and the server errors out
    if (previousResult.active === null) {
        if (isValid === null) {
            const newResult = {
                active: false,
                features: {
                    isMultiOrgEnabled: false,
                    projects: 3,
                    twoFactorAuth: false,
                    sso: false,
                    whitelabel: false,
                    removeBranding: false,
                    contacts: false,
                    ai: false
                },
                lastChecked: new Date()
            };
            await setPreviousResult(newResult);
            return newResult;
        }
    }
    if (isValid !== null && license) {
        const newResult = {
            active: isValid,
            features: license.features,
            lastChecked: new Date()
        };
        await setPreviousResult(newResult);
        return newResult;
    } else {
        // if result is undefined -> error
        // if the last check was less than 72 hours, return the previous value:
        const elapsedTime = currentTime.getTime() - previousResult.lastChecked.getTime();
        if (elapsedTime < threeDaysInMillis) {
            return {
                active: previousResult.active !== null ? previousResult.active : false,
                features: previousResult.features,
                lastChecked: previousResult.lastChecked,
                isPendingDowngrade: true
            };
        }
        // Log error only after 72 hours
        console.error("Error while checking license: The license check failed");
        return {
            active: false,
            features: null,
            lastChecked: previousResult.lastChecked,
            isPendingDowngrade: true
        };
    }
};
const getLicenseFeatures = async ()=>{
    const previousResult = await getPreviousResult();
    if (previousResult.features) {
        return previousResult.features;
    } else {
        const license = await fetchLicense();
        if (!license || !license.features) return null;
        return license.features;
    }
};
const fetchLicense = (0,react.cache)(async ()=>(0,cache/* cache */.P)(async ()=>{
        if (!env/* env */._.ENTERPRISE_LICENSE_KEY) return null;
        try {
            const now = new Date();
            const startOfYear = new Date(now.getFullYear(), 0, 1); // January 1st of the current year
            const endOfYear = new Date(now.getFullYear() + 1, 0, 0); // December 31st of the current year
            const responseCount = await database_src/* prisma */.z.response.count({
                where: {
                    createdAt: {
                        gte: startOfYear,
                        lt: endOfYear
                    }
                }
            });
            const proxyUrl = env/* env */._.HTTPS_PROXY || env/* env */._.HTTP_PROXY;
            const agent = proxyUrl ? new dist.HttpsProxyAgent(proxyUrl) : undefined;
            const res = await (0,src/* default */.Ay)("https://ee.formbricks.com/api/licenses/check", {
                body: JSON.stringify({
                    licenseKey: constants/* ENTERPRISE_LICENSE_KEY */.an,
                    usage: {
                        responseCount: responseCount
                    }
                }),
                headers: {
                    "Content-Type": "application/json"
                },
                method: "POST",
                agent
            });
            if (res.ok) {
                const responseJson = await res.json();
                return responseJson.data;
            }
            return null;
        } catch (error) {
            console.error("Error while checking license: ", error);
            return null;
        }
    }, [
        `fetchLicense-${hashedKey}`
    ], {
        revalidate: 60 * 60 * 24
    })());
const getRemoveBrandingPermission = async (organization)=>{
    if (E2E_TESTING) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult?.features?.removeBranding ?? false;
    }
    if (IS_FORMBRICKS_CLOUD && (await getEnterpriseLicense()).active) {
        return organization.billing.plan !== PROJECT_FEATURE_KEYS.FREE;
    } else {
        const licenseFeatures = await getLicenseFeatures();
        if (!licenseFeatures) return false;
        return licenseFeatures.removeBranding;
    }
};
const getWhiteLabelPermission = async (organization)=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult?.features?.whitelabel ?? false;
    }
    if (constants/* IS_FORMBRICKS_CLOUD */.Si && (await getEnterpriseLicense()).active) {
        return organization.billing.plan !== constants/* PROJECT_FEATURE_KEYS */.mu.FREE;
    } else {
        const licenseFeatures = await getLicenseFeatures();
        if (!licenseFeatures) return false;
        return licenseFeatures.whitelabel;
    }
};
const getRoleManagementPermission = async (organization)=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.active !== null ? previousResult.active : false;
    }
    if (constants/* IS_FORMBRICKS_CLOUD */.Si) return organization.billing.plan === constants/* PROJECT_FEATURE_KEYS */.mu.SCALE || organization.billing.plan === constants/* PROJECT_FEATURE_KEYS */.mu.ENTERPRISE;
    else if (!constants/* IS_FORMBRICKS_CLOUD */.Si) return (await getEnterpriseLicense()).active;
    return false;
};
const getBiggerUploadFileSizePermission = async (organization)=>{
    if (constants/* IS_FORMBRICKS_CLOUD */.Si) return organization.billing.plan !== constants/* PROJECT_FEATURE_KEYS */.mu.FREE;
    else if (!constants/* IS_FORMBRICKS_CLOUD */.Si) return (await getEnterpriseLicense()).active;
    return false;
};
const getMultiLanguagePermission = async (organization)=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.active !== null ? previousResult.active : false;
    }
    if (constants/* IS_FORMBRICKS_CLOUD */.Si) return organization.billing.plan === constants/* PROJECT_FEATURE_KEYS */.mu.SCALE || organization.billing.plan === constants/* PROJECT_FEATURE_KEYS */.mu.ENTERPRISE;
    else if (!constants/* IS_FORMBRICKS_CLOUD */.Si) return (await getEnterpriseLicense()).active;
    return false;
};
const getIsMultiOrgEnabled = async ()=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.isMultiOrgEnabled : false;
    }
    const licenseFeatures = await getLicenseFeatures();
    if (!licenseFeatures) return false;
    return licenseFeatures.isMultiOrgEnabled;
};
const getIsContactsEnabled = async ()=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.contacts : false;
    }
    const licenseFeatures = await getLicenseFeatures();
    if (!licenseFeatures) return false;
    return licenseFeatures.contacts;
};
const getIsTwoFactorAuthEnabled = async ()=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.twoFactorAuth : false;
    }
    const licenseFeatures = await getLicenseFeatures();
    if (!licenseFeatures) return false;
    return licenseFeatures.twoFactorAuth;
};
const getIsSSOEnabled = async ()=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.sso : false;
    }
    const licenseFeatures = await getLicenseFeatures();
    if (!licenseFeatures) return false;
    return licenseFeatures.sso;
};
const getIsOrganizationAIReady = async (billingPlan)=>{
    if (!constants/* IS_AI_CONFIGURED */.T1) return false;
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.ai : false;
    }
    const license = await getEnterpriseLicense();
    if (constants/* IS_FORMBRICKS_CLOUD */.Si) {
        return Boolean(license.features?.ai && billingPlan !== constants/* PROJECT_FEATURE_KEYS */.mu.FREE);
    }
    return Boolean(license.features?.ai);
};
const getIsAIEnabled = async (organization)=>{
    return organization.isAIEnabled && await getIsOrganizationAIReady(organization.billing.plan);
};
const getOrganizationProjectsLimit = async (organization)=>{
    if (constants/* E2E_TESTING */.oA) {
        const previousResult = await fetchLicenseForE2ETesting();
        return previousResult && previousResult.features ? previousResult.features.projects ?? Infinity : 3;
    }
    let limit;
    if (constants/* IS_FORMBRICKS_CLOUD */.Si && (await getEnterpriseLicense()).active) {
        limit = organization.billing.limits.projects ?? Infinity;
    } else {
        const licenseFeatures = await getLicenseFeatures();
        if (!licenseFeatures) {
            limit = 3;
        } else {
            limit = licenseFeatures.projects ?? Infinity;
        }
    }
    return limit;
};


/***/ }),

/***/ 234010:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ getSurveyFollowUpsPermission)
/* harmony export */ });
/* harmony import */ var _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(836919);

const getSurveyFollowUpsPermission = async (organization)=>{
    if (_formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_0__/* .IS_FORMBRICKS_CLOUD */ .Si) return organization.billing.plan !== _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_0__/* .PROJECT_FEATURE_KEYS */ .mu.FREE;
    return true;
};


/***/ }),

/***/ 556840:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   J: () => (/* binding */ getLocale)
/* harmony export */ });
/* harmony import */ var _modules_auth_lib_authOptions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136015);
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(963302);
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(836919);
/* harmony import */ var _formbricks_lib_user_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(184511);
/* harmony import */ var _formbricks_lib_utils_locale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(615572);





async function getLocale() {
    const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_modules_auth_lib_authOptions__WEBPACK_IMPORTED_MODULE_0__/* .authOptions */ .N);
    let locale = session ? await (0,_formbricks_lib_user_service__WEBPACK_IMPORTED_MODULE_2__/* .getUserLocale */ .YK)(session.user?.id) : await (0,_formbricks_lib_utils_locale__WEBPACK_IMPORTED_MODULE_3__/* .findMatchingLocale */ .$)();
    locale = locale ? locale : _formbricks_lib_constants__WEBPACK_IMPORTED_MODULE_4__/* .DEFAULT_LOCALE */ .Xn;
    return locale;
}


/***/ }),

/***/ 186184:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  T: () => (/* binding */ T),
  x: () => (/* binding */ getTolgee),
  r: () => (/* binding */ getTranslate)
});

// EXTERNAL MODULE: ../../node_modules/@tolgee/react/dist/tolgee-react-server.esm.js
var tolgee_react_server_esm = __webpack_require__(477270);
;// ../../branch.json
const branch_namespaceObject = {"a":"main"};
// EXTERNAL MODULE: ./tolgee/language.ts
var language = __webpack_require__(556840);
// EXTERNAL MODULE: ../../node_modules/@tolgee/format-icu/dist/tolgee-format-icu.esm.js
var tolgee_format_icu_esm = __webpack_require__(697926);
// EXTERNAL MODULE: ../../node_modules/@tolgee/web/dist/tolgee-web.production.esm.js
var tolgee_web_production_esm = __webpack_require__(306837);
;// ./tolgee/shared.ts


const apiKey = process.env.NEXT_PUBLIC_TOLGEE_API_KEY;
const apiUrl = process.env.NEXT_PUBLIC_TOLGEE_API_URL;
const ALL_LANGUAGES = (/* unused pure expression or super */ null && ([
    "en-US",
    "de-DE",
    "fr-FR",
    "pt-BR"
]));
const DEFAULT_LANGUAGE = "en-US";
function TolgeeBase() {
    return (0,tolgee_web_production_esm/* Tolgee */.H_)().use((0,tolgee_format_icu_esm/* FormatIcu */.X)()).use((0,tolgee_web_production_esm/* DevTools */.VD)()).updateDefaults({
        apiKey,
        apiUrl,
        staticData: {
            "en-US": ()=>__webpack_require__.e(/* import() */ 3170).then(__webpack_require__.t.bind(__webpack_require__, 683170, 19)),
            "de-DE": ()=>__webpack_require__.e(/* import() */ 4633).then(__webpack_require__.t.bind(__webpack_require__, 784633, 19)),
            "fr-FR": ()=>__webpack_require__.e(/* import() */ 1551).then(__webpack_require__.t.bind(__webpack_require__, 211551, 19)),
            "pt-BR": ()=>__webpack_require__.e(/* import() */ 5431).then(__webpack_require__.t.bind(__webpack_require__, 565431, 19))
        }
    });
}

;// ./tolgee/server.tsx




const { getTolgee, getTranslate, T } = (0,tolgee_react_server_esm/* createServerInstance */.RE)({
    getLocale: language/* getLocale */.J,
    createTolgee: async (language)=>{
        return TolgeeBase().init({
            tagNewKeys: [
                `draft: ${branch_namespaceObject.a}`
            ],
            observerOptions: {
                fullKeyEncode: true
            },
            language
        });
    }
});


/***/ }),

/***/ 347136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Q: () => (/* binding */ ZWebhook)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(545198);

const ZWebhook = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().cuid2(),
    name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    createdAt: zod__WEBPACK_IMPORTED_MODULE_0__.z.date(),
    updatedAt: zod__WEBPACK_IMPORTED_MODULE_0__.z.date(),
    url: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().url(),
    source: zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([
        "user",
        "zapier",
        "make",
        "n8n"
    ]),
    environmentId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().cuid2(),
    triggers: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([
        "responseFinished",
        "responseCreated",
        "responseUpdated"
    ])),
    surveyIds: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string().cuid2())
});


/***/ }),

/***/ 831040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mr: () => (/* binding */ writeData),
/* harmony export */   Wd: () => (/* binding */ fetchAirtableAuthToken),
/* harmony export */   eZ: () => (/* binding */ getAirtableTables),
/* harmony export */   oI: () => (/* binding */ getTables)
/* harmony export */ });
/* unused harmony exports getBases, getAirtableToken */
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(896330);
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(470641);
/* harmony import */ var _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(367365);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(836919);
/* harmony import */ var _integration_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43684);
/* harmony import */ var _utils_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(302722);






const getBases = async (key)=>{
    const req = await fetch("https://api.airtable.com/v0/meta/bases", {
        headers: {
            Authorization: `Bearer ${key}`
        }
    });
    const res = await req.json();
    return _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationAirtableBases */ .PH.parse(res);
};
const tableFetcher = async (key, baseId)=>{
    const req = await fetch(`https://api.airtable.com/v0/meta/bases/${baseId}/tables`, {
        headers: {
            Authorization: `Bearer ${key.access_token}`
        }
    });
    const res = await req.json();
    return res;
};
const getTables = async (key, baseId)=>{
    const res = await tableFetcher(key, baseId);
    return _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationAirtableTables */ .wh.parse(res);
};
const fetchAirtableAuthToken = async (formData)=>{
    const formBody = Object.keys(formData).map((key)=>`${encodeURIComponent(key)}=${encodeURIComponent(formData[key])}`).join("&");
    const tokenReq = await fetch("https://airtable.com/oauth2/v1/token", {
        headers: {
            "Content-Type": "application/x-www-form-urlencoded"
        },
        body: formBody,
        method: "POST"
    });
    const tokenRes = await tokenReq.json();
    const parsedToken = _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationAirtableTokenSchema */ .ho.safeParse(tokenRes);
    if (!parsedToken.success) {
        console.error(parsedToken.error);
        throw new Error(parsedToken.error.message);
    }
    const { access_token, refresh_token, expires_in } = parsedToken.data;
    const expiry_date = new Date();
    expiry_date.setSeconds(expiry_date.getSeconds() + expires_in);
    return {
        access_token,
        expiry_date: expiry_date.toISOString(),
        refresh_token
    };
};
const getAirtableToken = async (environmentId)=>{
    try {
        const airtableIntegration = await (0,_integration_service__WEBPACK_IMPORTED_MODULE_2__/* .getIntegrationByType */ .ks)(environmentId, "airtable");
        const { access_token, expiry_date, refresh_token } = _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationAirtableCredential */ .kx.parse(airtableIntegration?.config.key);
        const expiryDate = new Date(expiry_date);
        const currentDate = new Date();
        if (currentDate >= expiryDate) {
            const client_id = _constants__WEBPACK_IMPORTED_MODULE_3__/* .AIRTABLE_CLIENT_ID */ .JB;
            const newToken = await fetchAirtableAuthToken({
                grant_type: "refresh_token",
                refresh_token,
                client_id
            });
            if (!newToken) {
                throw new Error("Failed to create new token");
            }
            await (0,_integration_service__WEBPACK_IMPORTED_MODULE_2__/* .createOrUpdateIntegration */ .d6)(environmentId, {
                type: "airtable",
                config: {
                    data: airtableIntegration?.config?.data ?? [],
                    email: airtableIntegration?.config?.email ?? "",
                    key: newToken
                }
            });
            return newToken.access_token;
        }
        return access_token;
    } catch (error) {
        await (0,_integration_service__WEBPACK_IMPORTED_MODULE_2__/* .deleteIntegration */ .qo)(environmentId);
        throw new Error("invalid token");
    }
};
const getAirtableTables = async (environmentId)=>{
    let tables = [];
    try {
        const token = await getAirtableToken(environmentId);
        tables = (await getBases(token)).bases;
        return tables;
    } catch (error) {
        if (error instanceof _prisma_client__WEBPACK_IMPORTED_MODULE_0__.Prisma.PrismaClientKnownRequestError) {
            throw new _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_4__/* .DatabaseError */ .a$("Database operation failed");
        }
        throw error;
    }
};
const addRecords = async (key, baseId, tableId, data)=>{
    const req = await fetch(`https://api.airtable.com/v0/${baseId}/${tableId}`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${key.access_token}`,
            "Content-type": "application/json"
        },
        body: JSON.stringify({
            fields: data,
            typecast: true
        })
    });
    const res = await req.json();
    return res;
};
const addField = async (key, baseId, tableId, data)=>{
    const req = await fetch(`https://api.airtable.com/v0/meta/bases/${baseId}/tables/${tableId}/fields`, {
        method: "POST",
        headers: {
            Authorization: `Bearer ${key.access_token}`,
            "Content-type": "application/json"
        },
        body: JSON.stringify(data)
    });
    return await req.json();
};
const writeData = async (key, configData, values)=>{
    const responses = values[0];
    const questions = values[1];
    const data = {};
    for(let i = 0; i < questions.length; i++){
        data[questions[i]] = responses[i].length > _constants__WEBPACK_IMPORTED_MODULE_3__/* .AIRTABLE_MESSAGE_LIMIT */ .dq ? (0,_utils_strings__WEBPACK_IMPORTED_MODULE_5__/* .truncateText */ .EJ)(responses[i], _constants__WEBPACK_IMPORTED_MODULE_3__/* .AIRTABLE_MESSAGE_LIMIT */ .dq) : responses[i];
    }
    const req = await tableFetcher(key, configData.baseId);
    const tables = _formbricks_types_integration_airtable__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationAirtableTablesWithFields */ .jj.parse(req).tables;
    const currentTable = tables.find((table)=>table.id === configData.tableId);
    if (currentTable) {
        const currentFields = new Set(currentTable.fields.map((field)=>field.name));
        const fieldsToCreate = new Set();
        for (const field of questions){
            const hasField = currentFields.has(field);
            if (!hasField) {
                fieldsToCreate.add(field);
            }
        }
        if (fieldsToCreate.size > 0) {
            const createFieldPromise = [];
            fieldsToCreate.forEach((fieldName)=>{
                createFieldPromise.push(addField(key, configData.baseId, configData.tableId, {
                    name: fieldName,
                    type: "singleLineText"
                }));
            });
            await Promise.all(createFieldPromise);
        }
    }
    await addRecords(key, configData.baseId, configData.tableId, data);
};


/***/ }),

/***/ 549673:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   C7: () => (/* binding */ generateLocalSignedUrl),
/* harmony export */   Zd: () => (/* binding */ getHash),
/* harmony export */   gg: () => (/* binding */ decryptAES128),
/* harmony export */   jQ: () => (/* binding */ validateLocalSignedUrl),
/* harmony export */   vX: () => (/* binding */ symmetricEncrypt),
/* harmony export */   zp: () => (/* binding */ symmetricDecrypt)
/* harmony export */ });
/* unused harmony export encryptAES128 */
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(455511);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(836919);



const ALGORITHM = "aes256";
const INPUT_ENCODING = "utf8";
const OUTPUT_ENCODING = "hex";
const BUFFER_ENCODING = _constants__WEBPACK_IMPORTED_MODULE_1__/* .ENCRYPTION_KEY */ .o7.length === 32 ? "latin1" : "hex";
const IV_LENGTH = 16; // AES blocksize
/**
 *
 * @param text Value to be encrypted
 * @param key Key used to encrypt value must be 32 bytes for AES256 encryption algorithm
 *
 * @returns Encrypted value using key
 */ const symmetricEncrypt = (text, key)=>{
    const _key = Buffer.from(key, BUFFER_ENCODING);
    const iv = crypto__WEBPACK_IMPORTED_MODULE_0___default().randomBytes(IV_LENGTH);
    // @ts-ignore -- the package needs to be built
    const cipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createCipheriv(ALGORITHM, _key, iv);
    let ciphered = cipher.update(text, INPUT_ENCODING, OUTPUT_ENCODING);
    ciphered += cipher.final(OUTPUT_ENCODING);
    const ciphertext = iv.toString(OUTPUT_ENCODING) + ":" + ciphered;
    return ciphertext;
};
/**
 *
 * @param text Value to decrypt
 * @param key Key used to decrypt value must be 32 bytes for AES256 encryption algorithm
 */ const symmetricDecrypt = (text, key)=>{
    const _key = Buffer.from(key, BUFFER_ENCODING);
    const components = text.split(":");
    const iv_from_ciphertext = Buffer.from(components.shift() || "", OUTPUT_ENCODING);
    // @ts-ignore -- the package needs to be built
    const decipher = crypto__WEBPACK_IMPORTED_MODULE_0___default().createDecipheriv(ALGORITHM, _key, iv_from_ciphertext);
    let deciphered = decipher.update(components.join(":"), OUTPUT_ENCODING, INPUT_ENCODING);
    deciphered += decipher.final(INPUT_ENCODING);
    return deciphered;
};
const getHash = (key)=>(0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHash)("sha256").update(key).digest("hex");
// create an aes128 encryption function
const encryptAES128 = (encryptionKey, data)=>{
    // @ts-ignore -- the package needs to be built
    const cipher = createCipheriv("aes-128-ecb", Buffer.from(encryptionKey, "base64"), "");
    let encrypted = cipher.update(data, "utf-8", "hex");
    encrypted += cipher.final("hex");
    return encrypted;
};
// create an aes128 decryption function
const decryptAES128 = (encryptionKey, data)=>{
    // @ts-ignore -- the package needs to be built
    const cipher = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createDecipheriv)("aes-128-ecb", Buffer.from(encryptionKey, "base64"), "");
    let decrypted = cipher.update(data, "hex", "utf-8");
    decrypted += cipher.final("utf-8");
    return decrypted;
};
const generateLocalSignedUrl = (fileName, environmentId, fileType)=>{
    const uuid = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16).toString("hex");
    const timestamp = Date.now();
    const data = `${uuid}:${fileName}:${environmentId}:${fileType}:${timestamp}`;
    const signature = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac)("sha256", _constants__WEBPACK_IMPORTED_MODULE_1__/* .ENCRYPTION_KEY */ .o7).update(data).digest("hex");
    return {
        signature,
        uuid,
        timestamp
    };
};
const validateLocalSignedUrl = (uuid, fileName, environmentId, fileType, timestamp, signature, secret)=>{
    const data = `${uuid}:${fileName}:${environmentId}:${fileType}:${timestamp}`;
    const expectedSignature = (0,crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac)("sha256", secret).update(data).digest("hex");
    if (expectedSignature !== signature) {
        return false;
    }
    // valid for 5 minutes
    if (Date.now() - timestamp > 1000 * 60 * 5) {
        return false;
    }
    return true;
};


/***/ }),

/***/ 835093:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ integrationCache)
/* harmony export */ });
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87863);
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_cache__WEBPACK_IMPORTED_MODULE_0__);

const integrationCache = {
    tag: {
        byId (id) {
            return `integrations-${id}`;
        },
        byEnvironmentId (environmentId) {
            return `environments-${environmentId}-integrations`;
        },
        byEnvironmentIdAndType (environmentId, type) {
            return `environments-${environmentId}-type-${type}-integrations`;
        }
    },
    revalidate ({ id, environmentId, type }) {
        if (id) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byId(id));
        }
        if (environmentId) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byEnvironmentId(environmentId));
        }
        if (environmentId && type) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byEnvironmentIdAndType(environmentId, type));
        }
    }
};


/***/ }),

/***/ 43684:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d6: () => (/* binding */ createOrUpdateIntegration),
  qo: () => (/* binding */ deleteIntegration),
  ks: () => (/* binding */ getIntegrationByType),
  Yl: () => (/* binding */ getIntegrations)
});

// UNUSED EXPORTS: getIntegration

// EXTERNAL MODULE: external "@prisma/client"
var client_ = __webpack_require__(896330);
// EXTERNAL MODULE: ../../node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js
var react = __webpack_require__(922728);
// EXTERNAL MODULE: ../../packages/database/src/index.ts + 1 modules
var src = __webpack_require__(527610);
// EXTERNAL MODULE: ../../packages/types/common.ts
var common = __webpack_require__(733735);
// EXTERNAL MODULE: ../../packages/types/errors.ts
var errors = __webpack_require__(470641);
// EXTERNAL MODULE: ../../node_modules/zod/lib/index.mjs
var lib = __webpack_require__(545198);
// EXTERNAL MODULE: ../../packages/types/integration/airtable.ts
var airtable = __webpack_require__(367365);
// EXTERNAL MODULE: ../../packages/types/integration/google-sheet.ts
var google_sheet = __webpack_require__(816948);
// EXTERNAL MODULE: ../../packages/types/integration/shared-types.ts
var shared_types = __webpack_require__(965340);
;// ../../packages/types/integration/notion.ts


const ZIntegrationNotionCredential = lib.z.object({
    access_token: lib.z.string(),
    bot_id: lib.z.string(),
    token_type: lib.z.string(),
    duplicated_template_id: lib.z.string().nullable(),
    owner: lib.z.object({
        type: lib.z.string(),
        workspace: lib.z.boolean().nullish(),
        user: lib.z.object({
            id: lib.z.string(),
            name: lib.z.string().nullish(),
            type: lib.z.string().nullish(),
            object: lib.z.string(),
            person: lib.z.object({
                email: lib.z.string().email()
            }).nullish(),
            avatar_url: lib.z.string().nullish()
        }).nullable()
    }),
    workspace_icon: lib.z.string().nullable(),
    workspace_id: lib.z.string(),
    workspace_name: lib.z.string().nullable()
});
const ZIntegrationNotionConfigData = lib.z.object({
    // question -> notion database column mapping
    mapping: lib.z.array(lib.z.object({
        question: lib.z.object({
            id: lib.z.string(),
            name: lib.z.string(),
            type: lib.z.string()
        }),
        column: lib.z.object({
            id: lib.z.string(),
            name: lib.z.string(),
            type: lib.z.string()
        })
    })),
    databaseId: lib.z.string(),
    databaseName: lib.z.string()
}).merge(shared_types/* ZIntegrationBaseSurveyData */.g.omit({
    questionIds: true,
    questions: true
}));
const ZIntegrationNotionConfig = lib.z.object({
    key: ZIntegrationNotionCredential,
    data: lib.z.array(ZIntegrationNotionConfigData)
});
const ZIntegrationNotion = shared_types/* ZIntegrationBase */.U.extend({
    type: lib.z.literal("notion"),
    config: ZIntegrationNotionConfig
});
const ZIntegrationNotionInput = lib.z.object({
    type: lib.z.literal("notion"),
    config: ZIntegrationNotionConfig
});
const ZIntegrationNotionDatabase = lib.z.object({
    id: lib.z.string(),
    name: lib.z.string(),
    properties: lib.z.object({})
});

;// ../../packages/types/integration/slack.ts


const ZIntegrationSlackConfigData = lib.z.object({
    // Channel Mapped to a Particular Survey where we have to send the data from the above survey
    channelId: lib.z.string(),
    channelName: lib.z.string()
}).merge(shared_types/* ZIntegrationBaseSurveyData */.g);
const ZIntegrationSlackCredential = lib.z.object({
    app_id: lib.z.string(),
    authed_user: lib.z.object({
        id: lib.z.string()
    }),
    token_type: lib.z.literal("bot"),
    access_token: lib.z.string(),
    bot_user_id: lib.z.string(),
    team: lib.z.object({
        id: lib.z.string(),
        name: lib.z.string()
    })
});
const ZIntegrationSlackConfig = lib.z.object({
    key: ZIntegrationSlackCredential,
    data: lib.z.array(ZIntegrationSlackConfigData)
});
const ZIntegrationSlack = shared_types/* ZIntegrationBase */.U.extend({
    type: lib.z.literal("slack"),
    config: ZIntegrationSlackConfig
});
const ZIntegrationSlackInput = lib.z.object({
    type: lib.z.literal("slack"),
    config: ZIntegrationSlackConfig
});

;// ../../packages/types/integration/index.ts





const ZIntegrationType = lib.z.enum([
    "googleSheets",
    "n8n",
    "airtable",
    "notion",
    "slack"
]);
const ZIntegrationConfig = lib.z.union([
    google_sheet/* ZIntegrationGoogleSheetsConfig */.qO,
    airtable/* ZIntegrationAirtableConfig */.rO,
    ZIntegrationNotionConfig,
    ZIntegrationSlackConfig
]);
const ZIntegrationBase = lib.z.object({
    id: lib.z.string(),
    environmentId: lib.z.string()
});
const ZIntegration = ZIntegrationBase.extend({
    type: ZIntegrationType,
    config: ZIntegrationConfig
});
const ZIntegrationBaseSurveyData = lib.z.object({
    createdAt: lib.z.date(),
    questionIds: lib.z.array(lib.z.string()),
    questions: lib.z.string(),
    surveyId: lib.z.string(),
    surveyName: lib.z.string()
});
const ZIntegrationInput = lib.z.discriminatedUnion("type", [
    google_sheet/* ZIntegrationGoogleSheetsInput */.Q2,
    airtable/* ZIntegrationAirtableInput */.BZ,
    ZIntegrationNotionInput,
    ZIntegrationSlackInput
]);
const ZIntegrationItem = lib.z.object({
    name: lib.z.string(),
    id: lib.z.string()
});

// EXTERNAL MODULE: ../../packages/lib/cache.ts
var cache = __webpack_require__(794356);
// EXTERNAL MODULE: ../../packages/lib/constants.ts
var constants = __webpack_require__(836919);
// EXTERNAL MODULE: ../../packages/lib/utils/validate.ts
var validate = __webpack_require__(860988);
// EXTERNAL MODULE: ../../packages/lib/integration/cache.ts
var integration_cache = __webpack_require__(835093);
;// ../../packages/lib/integration/service.ts












const transformIntegration = (integration)=>{
    return {
        ...integration,
        config: {
            ...integration.config,
            data: integration.config.data.map((data)=>({
                    ...data,
                    createdAt: new Date(data.createdAt)
                }))
        }
    };
};
const createOrUpdateIntegration = async (environmentId, integrationData)=>{
    (0,validate/* validateInputs */.C)([
        environmentId,
        common/* ZId */.i4
    ]);
    try {
        const integration = await src/* prisma */.z.integration.upsert({
            where: {
                type_environmentId: {
                    environmentId,
                    type: integrationData.type
                }
            },
            update: {
                ...integrationData,
                environment: {
                    connect: {
                        id: environmentId
                    }
                }
            },
            create: {
                ...integrationData,
                environment: {
                    connect: {
                        id: environmentId
                    }
                }
            }
        });
        integration_cache/* integrationCache */.t.revalidate({
            environmentId,
            type: integrationData.type
        });
        return integration;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            console.error(error);
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};
const getIntegrations = (0,react.cache)(async (environmentId, page)=>(0,cache/* cache */.P)(async ()=>{
        (0,validate/* validateInputs */.C)([
            environmentId,
            common/* ZId */.i4
        ], [
            page,
            common/* ZOptionalNumber */.Wo
        ]);
        try {
            const integrations = await src/* prisma */.z.integration.findMany({
                where: {
                    environmentId
                },
                take: page ? constants/* ITEMS_PER_PAGE */.re : undefined,
                skip: page ? constants/* ITEMS_PER_PAGE */.re * (page - 1) : undefined
            });
            return integrations;
        } catch (error) {
            if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
                throw new errors/* DatabaseError */.a$(error.message);
            }
            throw error;
        }
    }, [
        `getIntegrations-${environmentId}-${page}`
    ], {
        tags: [
            integration_cache/* integrationCache */.t.tag.byEnvironmentId(environmentId)
        ]
    })().then((cachedIntegration)=>{
        return cachedIntegration.map((integration)=>transformIntegration(integration));
    }));
const getIntegration = (0,react.cache)(async (integrationId)=>(0,cache/* cache */.P)(async ()=>{
        try {
            const integration = await src/* prisma */.z.integration.findUnique({
                where: {
                    id: integrationId
                }
            });
            return integration;
        } catch (error) {
            if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
                throw new errors/* DatabaseError */.a$(error.message);
            }
            throw error;
        }
    }, [
        `getIntegration-${integrationId}`
    ], {
        tags: [
            integration_cache/* integrationCache */.t.tag.byId(integrationId)
        ]
    })());
const getIntegrationByType = (0,react.cache)(async (environmentId, type)=>(0,cache/* cache */.P)(async ()=>{
        (0,validate/* validateInputs */.C)([
            environmentId,
            common/* ZId */.i4
        ], [
            type,
            ZIntegrationType
        ]);
        try {
            const integration = await src/* prisma */.z.integration.findUnique({
                where: {
                    type_environmentId: {
                        environmentId,
                        type
                    }
                }
            });
            return integration;
        } catch (error) {
            if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
                throw new errors/* DatabaseError */.a$(error.message);
            }
            throw error;
        }
    }, [
        `getIntegrationByType-${environmentId}-${type}`
    ], {
        tags: [
            integration_cache/* integrationCache */.t.tag.byEnvironmentIdAndType(environmentId, type)
        ]
    })().then((cachedIntegration)=>{
        if (cachedIntegration) {
            return transformIntegration(cachedIntegration);
        } else return null;
    }));
const deleteIntegration = async (integrationId)=>{
    (0,validate/* validateInputs */.C)([
        integrationId,
        common/* ZString */.eI
    ]);
    try {
        const integrationData = await src/* prisma */.z.integration.delete({
            where: {
                id: integrationId
            }
        });
        integration_cache/* integrationCache */.t.revalidate({
            id: integrationData.id,
            environmentId: integrationData.environmentId,
            type: integrationData.type
        });
        return integrationData;
    } catch (error) {
        if (error instanceof client_.Prisma.PrismaClientKnownRequestError) {
            throw new errors/* DatabaseError */.a$(error.message);
        }
        throw error;
    }
};


/***/ }),

/***/ 360379:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CN: () => (/* binding */ verifyTokenForLinkSurvey),
/* harmony export */   Oj: () => (/* binding */ verifyInviteToken),
/* harmony export */   ao: () => (/* binding */ getEmailFromEmailToken),
/* harmony export */   nr: () => (/* binding */ verifyToken)
/* harmony export */ });
/* unused harmony exports createToken, createTokenForLinkSurvey, createEmailToken, createInviteToken */
/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(900365);
/* harmony import */ var jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsonwebtoken__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _formbricks_database__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(527610);
/* harmony import */ var _crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(549673);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(162437);




const createToken = (userId, userEmail, options = {})=>{
    const encryptedUserId = symmetricEncrypt(userId, env.ENCRYPTION_KEY);
    return jwt.sign({
        id: encryptedUserId
    }, env.NEXTAUTH_SECRET + userEmail, options);
};
const createTokenForLinkSurvey = (surveyId, userEmail)=>{
    const encryptedEmail = symmetricEncrypt(userEmail, env.ENCRYPTION_KEY);
    return jwt.sign({
        email: encryptedEmail
    }, env.NEXTAUTH_SECRET + surveyId);
};
const createEmailToken = (email)=>{
    const encryptedEmail = symmetricEncrypt(email, env.ENCRYPTION_KEY);
    return jwt.sign({
        email: encryptedEmail
    }, env.NEXTAUTH_SECRET);
};
const getEmailFromEmailToken = (token)=>{
    const payload = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().verify(token, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.NEXTAUTH_SECRET);
    try {
        // Try to decrypt first (for newer tokens)
        const decryptedEmail = (0,_crypto__WEBPACK_IMPORTED_MODULE_3__/* .symmetricDecrypt */ .zp)(payload.email, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.ENCRYPTION_KEY);
        return decryptedEmail;
    } catch  {
        // If decryption fails, return the original email (for older tokens)
        return payload.email;
    }
};
const createInviteToken = (inviteId, email, options = {})=>{
    const encryptedInviteId = symmetricEncrypt(inviteId, env.ENCRYPTION_KEY);
    const encryptedEmail = symmetricEncrypt(email, env.ENCRYPTION_KEY);
    return jwt.sign({
        inviteId: encryptedInviteId,
        email: encryptedEmail
    }, env.NEXTAUTH_SECRET, options);
};
const verifyTokenForLinkSurvey = (token, surveyId)=>{
    try {
        const { email } = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().verify(token, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.NEXTAUTH_SECRET + surveyId);
        try {
            // Try to decrypt first (for newer tokens)
            const decryptedEmail = (0,_crypto__WEBPACK_IMPORTED_MODULE_3__/* .symmetricDecrypt */ .zp)(email, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.ENCRYPTION_KEY);
            return decryptedEmail;
        } catch  {
            // If decryption fails, return the original email (for older tokens)
            return email;
        }
    } catch (err) {
        return null;
    }
};
const verifyToken = async (token)=>{
    // First decode to get the ID
    const decoded = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().decode(token);
    const payload = decoded;
    if (!payload) {
        throw new Error("Token is invalid");
    }
    const { id } = payload;
    if (!id) {
        throw new Error("Token missing required field: id");
    }
    // Try to decrypt the ID (for newer tokens), if it fails use the ID as-is (for older tokens)
    let decryptedId;
    try {
        decryptedId = (0,_crypto__WEBPACK_IMPORTED_MODULE_3__/* .symmetricDecrypt */ .zp)(id, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.ENCRYPTION_KEY);
    } catch  {
        decryptedId = id;
    }
    // If no email provided, look up the user
    const foundUser = await _formbricks_database__WEBPACK_IMPORTED_MODULE_1__/* .prisma */ .z.user.findUnique({
        where: {
            id: decryptedId
        }
    });
    if (!foundUser) {
        throw new Error("User not found");
    }
    const userEmail = foundUser.email;
    return {
        id: decryptedId,
        email: userEmail
    };
};
const verifyInviteToken = (token)=>{
    try {
        const decoded = jsonwebtoken__WEBPACK_IMPORTED_MODULE_0___default().decode(token);
        const payload = decoded;
        const { inviteId, email } = payload;
        let decryptedInviteId;
        let decryptedEmail;
        try {
            // Try to decrypt first (for newer tokens)
            decryptedInviteId = (0,_crypto__WEBPACK_IMPORTED_MODULE_3__/* .symmetricDecrypt */ .zp)(inviteId, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.ENCRYPTION_KEY);
            decryptedEmail = (0,_crypto__WEBPACK_IMPORTED_MODULE_3__/* .symmetricDecrypt */ .zp)(email, _env__WEBPACK_IMPORTED_MODULE_2__/* .env */ ._.ENCRYPTION_KEY);
        } catch  {
            // If decryption fails, use original values (for older tokens)
            decryptedInviteId = inviteId;
            decryptedEmail = email;
        }
        return {
            inviteId: decryptedInviteId,
            email: decryptedEmail
        };
    } catch (error) {
        console.error(`Error verifying invite token: ${error}`);
        throw new Error("Invalid or expired invite token");
    }
};


/***/ }),

/***/ 823609:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   r: () => (/* binding */ membershipCache)
/* harmony export */ });
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87863);
/* harmony import */ var next_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_cache__WEBPACK_IMPORTED_MODULE_0__);

const membershipCache = {
    tag: {
        byOrganizationId (organizationId) {
            return `organizations-${organizationId}-memberships`;
        },
        byUserId (userId) {
            return `users-${userId}-memberships`;
        }
    },
    revalidate ({ organizationId, userId }) {
        if (organizationId) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byOrganizationId(organizationId));
        }
        if (userId) {
            (0,next_cache__WEBPACK_IMPORTED_MODULE_0__.revalidateTag)(this.tag.byUserId(userId));
        }
    }
};


/***/ }),

/***/ 377968:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ createMembership),
/* harmony export */   Y: () => (/* binding */ getMembershipByUserIdOrganizationId)
/* harmony export */ });
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(896330);
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(922728);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _formbricks_database__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(527610);
/* harmony import */ var _formbricks_types_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(733735);
/* harmony import */ var _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(470641);
/* harmony import */ var _formbricks_types_memberships__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(715521);
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(794356);
/* harmony import */ var _membership_cache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(823609);
/* harmony import */ var _organization_cache__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(530190);
/* harmony import */ var _utils_validate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(860988);











const getMembershipByUserIdOrganizationId = (0,react__WEBPACK_IMPORTED_MODULE_1__.cache)(async (userId, organizationId)=>(0,_cache__WEBPACK_IMPORTED_MODULE_3__/* .cache */ .P)(async ()=>{
        (0,_utils_validate__WEBPACK_IMPORTED_MODULE_4__/* .validateInputs */ .C)([
            userId,
            _formbricks_types_common__WEBPACK_IMPORTED_MODULE_5__/* .ZString */ .eI
        ], [
            organizationId,
            _formbricks_types_common__WEBPACK_IMPORTED_MODULE_5__/* .ZString */ .eI
        ]);
        try {
            const membership = await _formbricks_database__WEBPACK_IMPORTED_MODULE_2__/* .prisma */ .z.membership.findUnique({
                where: {
                    userId_organizationId: {
                        userId,
                        organizationId
                    }
                }
            });
            if (!membership) return null;
            return membership;
        } catch (error) {
            if (error instanceof _prisma_client__WEBPACK_IMPORTED_MODULE_0__.Prisma.PrismaClientKnownRequestError) {
                console.error(error);
                throw new _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_6__/* .DatabaseError */ .a$(error.message);
            }
            throw new _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_6__/* .UnknownError */ .Bk("Error while fetching membership");
        }
    }, [
        `getMembershipByUserIdOrganizationId-${userId}-${organizationId}`
    ], {
        tags: [
            _membership_cache__WEBPACK_IMPORTED_MODULE_7__/* .membershipCache */ .r.tag.byUserId(userId),
            _membership_cache__WEBPACK_IMPORTED_MODULE_7__/* .membershipCache */ .r.tag.byOrganizationId(organizationId)
        ]
    })());
const createMembership = async (organizationId, userId, data)=>{
    (0,_utils_validate__WEBPACK_IMPORTED_MODULE_4__/* .validateInputs */ .C)([
        organizationId,
        _formbricks_types_common__WEBPACK_IMPORTED_MODULE_5__/* .ZString */ .eI
    ], [
        userId,
        _formbricks_types_common__WEBPACK_IMPORTED_MODULE_5__/* .ZString */ .eI
    ], [
        data,
        _formbricks_types_memberships__WEBPACK_IMPORTED_MODULE_8__/* .ZMembership */ .rl.partial()
    ]);
    try {
        const membership = await _formbricks_database__WEBPACK_IMPORTED_MODULE_2__/* .prisma */ .z.membership.create({
            data: {
                userId,
                organizationId,
                accepted: data.accepted,
                role: data.role
            }
        });
        _organization_cache__WEBPACK_IMPORTED_MODULE_9__/* .organizationCache */ .S.revalidate({
            userId
        });
        _membership_cache__WEBPACK_IMPORTED_MODULE_7__/* .membershipCache */ .r.revalidate({
            userId,
            organizationId
        });
        return membership;
    } catch (error) {
        if (error instanceof _prisma_client__WEBPACK_IMPORTED_MODULE_0__.Prisma.PrismaClientKnownRequestError) {
            throw new _formbricks_types_errors__WEBPACK_IMPORTED_MODULE_6__/* .DatabaseError */ .a$(error.message);
        }
        throw error;
    }
};


/***/ }),

/***/ 735609:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ writeData),
/* harmony export */   W: () => (/* binding */ getNotionDatabases)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(836919);
/* harmony import */ var _crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(549673);
/* harmony import */ var _integration_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43684);



const fetchPages = async (config)=>{
    try {
        const res = await fetch("https://api.notion.com/v1/search", {
            headers: getHeaders(config),
            method: "POST",
            body: JSON.stringify({
                page_size: 100,
                filter: {
                    value: "database",
                    property: "object"
                }
            })
        });
        return (await res.json()).results;
    } catch (error) {
        throw error;
    }
};
const getNotionDatabases = async (environmentId)=>{
    let results = [];
    try {
        const notionIntegration = await (0,_integration_service__WEBPACK_IMPORTED_MODULE_0__/* .getIntegrationByType */ .ks)(environmentId, "notion");
        if (notionIntegration && notionIntegration.config?.key.bot_id) {
            results = await fetchPages(notionIntegration.config);
        }
        return results;
    } catch (error) {
        throw error;
    }
};
const writeData = async (databaseId, properties, config)=>{
    try {
        await fetch(`https://api.notion.com/v1/pages`, {
            headers: getHeaders(config),
            method: "POST",
            body: JSON.stringify({
                parent: {
                    database_id: databaseId
                },
                properties: properties
            })
        });
    } catch (error) {
        throw error;
    }
};
const getHeaders = (config)=>{
    const decryptedToken = (0,_crypto__WEBPACK_IMPORTED_MODULE_1__/* .symmetricDecrypt */ .zp)(config.key.access_token, _constants__WEBPACK_IMPORTED_MODULE_2__/* .ENCRYPTION_KEY */ .o7);
    return {
        Accept: "application/json",
        "Content-Type": "application/json",
        Authorization: `Bearer ${decryptedToken}`,
        "Notion-Version": "2022-06-28"
    };
};


/***/ }),

/***/ 951925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rw: () => (/* binding */ convertDatesInObject),
/* harmony export */   _D: () => (/* binding */ timeSince)
/* harmony export */ });
/* unused harmony exports convertDateString, convertDateTimeString, convertDateTimeStringShort, convertTimeString, timeSinceDate, formatDate, getTodaysDateFormatted, getTodaysDateTimeFormatted */
/* harmony import */ var _barrel_optimize_names_formatDistance_intlFormat_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(662776);
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(265814);
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38202);
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(149745);
/* harmony import */ var date_fns_locale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(973846);


const convertDateString = (dateString)=>{
    if (!dateString) {
        return dateString;
    }
    const date = new Date(dateString);
    return intlFormat(date, {
        year: "numeric",
        month: "short",
        day: "numeric"
    }, {
        locale: "en"
    });
};
const convertDateTimeString = (dateString)=>{
    if (!dateString) {
        return dateString;
    }
    const date = new Date(dateString);
    return intlFormat(date, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit"
    }, {
        locale: "en"
    });
};
const convertDateTimeStringShort = (dateString)=>{
    if (!dateString) {
        return dateString;
    }
    const date = new Date(dateString);
    return intlFormat(date, {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit"
    }, {
        locale: "en"
    });
};
const convertTimeString = (dateString)=>{
    const date = new Date(dateString);
    return intlFormat(date, {
        hour: "numeric",
        minute: "2-digit",
        second: "2-digit"
    }, {
        locale: "en"
    });
};
const getLocaleForTimeSince = (locale)=>{
    switch(locale){
        case "de-DE":
            return date_fns_locale__WEBPACK_IMPORTED_MODULE_0__.de;
        case "en-US":
            return date_fns_locale__WEBPACK_IMPORTED_MODULE_1__/* .enUS */ .c;
        case "pt-BR":
            return date_fns_locale__WEBPACK_IMPORTED_MODULE_2__/* .ptBR */ .F;
        case "fr-FR":
            return date_fns_locale__WEBPACK_IMPORTED_MODULE_3__.fr;
    }
};
const timeSince = (dateString, locale)=>{
    const date = new Date(dateString);
    return (0,_barrel_optimize_names_formatDistance_intlFormat_date_fns__WEBPACK_IMPORTED_MODULE_4__/* .formatDistance */ .B)(date, new Date(), {
        addSuffix: true,
        locale: getLocaleForTimeSince(locale)
    });
};
const timeSinceDate = (date)=>{
    return formatDistance(date, new Date(), {
        addSuffix: true
    });
};
const formatDate = (date)=>{
    return intlFormat(date, {
        year: "numeric",
        month: "long",
        day: "numeric"
    });
};
const getTodaysDateFormatted = (seperator)=>{
    const date = new Date();
    const formattedDate = date.toISOString().split("T")[0].split("-").join(seperator);
    return formattedDate;
};
const getTodaysDateTimeFormatted = (seperator)=>{
    const date = new Date();
    const formattedDate = date.toISOString().split("T")[0].split("-").join(seperator);
    const formattedTime = date.toTimeString().split(" ")[0].split(":").join(seperator);
    return [
        formattedDate,
        formattedTime
    ].join(seperator);
};
const convertDatesInObject = (obj)=>{
    if (obj === null || typeof obj !== "object") {
        return obj; // Return if obj is not an object
    }
    if (Array.isArray(obj)) {
        // Handle arrays by mapping each element through the function
        return obj.map((item)=>convertDatesInObject(item));
    }
    const newObj = {};
    for(const key in obj){
        if ((key === "createdAt" || key === "updatedAt") && typeof obj[key] === "string" && !isNaN(Date.parse(obj[key]))) {
            newObj[key] = new Date(obj[key]);
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
            newObj[key] = convertDatesInObject(obj[key]);
        } else {
            newObj[key] = obj[key];
        }
    }
    return newObj;
};


/***/ }),

/***/ 615572:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ findMatchingLocale)
/* harmony export */ });
/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(680255);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(836919);


const findMatchingLocale = async ()=>{
    const headersList = await (0,next_headers__WEBPACK_IMPORTED_MODULE_0__.headers)();
    const acceptLanguage = headersList.get("accept-language");
    const userLocales = acceptLanguage?.split(",");
    if (!userLocales) {
        return _constants__WEBPACK_IMPORTED_MODULE_1__/* .DEFAULT_LOCALE */ .Xn;
    }
    // First, try to find an exact match without normalization
    for (const userLocale of userLocales){
        const exactMatch = _constants__WEBPACK_IMPORTED_MODULE_1__/* .AVAILABLE_LOCALES */ .SC.find((locale)=>locale === userLocale);
        if (exactMatch) return exactMatch;
    }
    // If no exact match is found, try matching with normalization
    const normalizedAvailableLocales = _constants__WEBPACK_IMPORTED_MODULE_1__/* .AVAILABLE_LOCALES */ .SC.map((locale)=>locale.toLowerCase().split("-")[0]);
    for (const userLocale of userLocales){
        const normalizedUserLocale = userLocale.toLowerCase().split("-")[0];
        const matchedIndex = normalizedAvailableLocales.findIndex((locale)=>locale.startsWith(normalizedUserLocale));
        if (matchedIndex !== -1) return _constants__WEBPACK_IMPORTED_MODULE_1__/* .AVAILABLE_LOCALES */ .SC[matchedIndex];
    }
    return _constants__WEBPACK_IMPORTED_MODULE_1__/* .DEFAULT_LOCALE */ .Xn;
};


/***/ }),

/***/ 302722:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EJ: () => (/* binding */ truncateText),
/* harmony export */   Zr: () => (/* binding */ capitalizeFirstLetter)
/* harmony export */ });
/* unused harmony exports truncate, sanitizeString, isCapitalized, startsWithVowel */
const capitalizeFirstLetter = (string = "")=>{
    if (string === null) {
        return "";
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
};
// write a function that takes a string and truncates it to the specified length
const truncate = (str, length)=>{
    if (!str) return "";
    if (str.length > length) {
        return str.substring(0, length) + "...";
    }
    return str;
};
// write a function that takes a string and removes all characters that could cause issues with the url and truncates it to the specified length
const sanitizeString = (str, delimiter = "_", length = 255)=>{
    return str.replace(/[^0-9a-zA-Z\-._]+/g, delimiter).substring(0, length);
};
const isCapitalized = (str)=>str.charAt(0) === str.charAt(0).toUpperCase();
const startsWithVowel = (str)=>{
    return /^[aeiouAEIOU]/.test(str);
};
const truncateText = (text, limit)=>{
    return text.length > limit ? `${text.substring(0, limit)}...` : text;
};


/***/ }),

/***/ 367365:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BZ: () => (/* binding */ ZIntegrationAirtableInput),
/* harmony export */   PH: () => (/* binding */ ZIntegrationAirtableBases),
/* harmony export */   ho: () => (/* binding */ ZIntegrationAirtableTokenSchema),
/* harmony export */   jj: () => (/* binding */ ZIntegrationAirtableTablesWithFields),
/* harmony export */   kx: () => (/* binding */ ZIntegrationAirtableCredential),
/* harmony export */   rO: () => (/* binding */ ZIntegrationAirtableConfig),
/* harmony export */   wh: () => (/* binding */ ZIntegrationAirtableTables)
/* harmony export */ });
/* unused harmony exports ZIntegrationAirtableConfigData, ZIntegrationAirtable */
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(545198);
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(965340);


const ZIntegrationAirtableCredential = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    expiry_date: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    access_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    refresh_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
});
const ZIntegrationAirtableConfigData = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    tableId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    baseId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    tableName: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
}).merge(_shared_types__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationBaseSurveyData */ .g);
const ZIntegrationAirtableConfig = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    key: ZIntegrationAirtableCredential,
    data: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(ZIntegrationAirtableConfigData),
    email: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().email()
});
const ZIntegrationAirtable = _shared_types__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationBase */ .U.extend({
    type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("airtable"),
    config: ZIntegrationAirtableConfig
});
const ZIntegrationAirtableInput = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("airtable"),
    config: ZIntegrationAirtableConfig
});
const ZIntegrationAirtableBases = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    bases: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
    }))
});
const ZIntegrationAirtableTables = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    tables: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
    }))
});
const ZIntegrationAirtableTokenSchema = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    access_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    refresh_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    expires_in: zod__WEBPACK_IMPORTED_MODULE_0__.z.coerce.number()
});
const ZIntegrationAirtableTablesWithFields = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    tables: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
        id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
        fields: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
            id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
            name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
        }))
    }))
});


/***/ }),

/***/ 816948:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gl: () => (/* binding */ ZIntegrationGoogleSheets),
/* harmony export */   Q2: () => (/* binding */ ZIntegrationGoogleSheetsInput),
/* harmony export */   qO: () => (/* binding */ ZIntegrationGoogleSheetsConfig)
/* harmony export */ });
/* unused harmony exports ZGoogleCredential, ZIntegrationGoogleSheetsConfigData, ZGoogleSheetIntegration, ZIntegrationGoogleSheetsCredential */
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(545198);
/* harmony import */ var _shared_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(965340);


const ZGoogleCredential = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    scope: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    token_type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Bearer"),
    expiry_date: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    access_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    refresh_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
});
const ZIntegrationGoogleSheetsConfigData = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    spreadsheetId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    spreadsheetName: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
}).merge(_shared_types__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationBaseSurveyData */ .g);
const ZIntegrationGoogleSheetsConfig = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    key: ZGoogleCredential,
    data: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(ZIntegrationGoogleSheetsConfigData),
    email: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().email()
});
const ZGoogleSheetIntegration = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("googleSheets"),
    environmentId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    config: ZIntegrationGoogleSheetsConfig
});
const ZIntegrationGoogleSheets = _shared_types__WEBPACK_IMPORTED_MODULE_1__/* .ZIntegrationBase */ .U.extend({
    type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("googleSheets"),
    config: ZIntegrationGoogleSheetsConfig
});
const ZIntegrationGoogleSheetsInput = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("googleSheets"),
    config: ZIntegrationGoogleSheetsConfig
});
const ZIntegrationGoogleSheetsCredential = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    scope: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    token_type: zod__WEBPACK_IMPORTED_MODULE_0__.z.literal("Bearer"),
    expiry_date: zod__WEBPACK_IMPORTED_MODULE_0__.z.number(),
    access_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    refresh_token: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
});


/***/ }),

/***/ 965340:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ ZIntegrationBase),
/* harmony export */   g: () => (/* binding */ ZIntegrationBaseSurveyData)
/* harmony export */ });
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(545198);

const ZIntegrationBase = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    id: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    environmentId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
});
const ZIntegrationBaseSurveyData = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    createdAt: zod__WEBPACK_IMPORTED_MODULE_0__.z.date(),
    questionIds: zod__WEBPACK_IMPORTED_MODULE_0__.z.array(zod__WEBPACK_IMPORTED_MODULE_0__.z.string()),
    includeVariables: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean().optional(),
    includeHiddenFields: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean().optional(),
    includeMetadata: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean().optional(),
    includeCreatedAt: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean().optional(),
    questions: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    surveyId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    surveyName: zod__WEBPACK_IMPORTED_MODULE_0__.z.string()
});


/***/ }),

/***/ 715521:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mp: () => (/* binding */ ZOrganizationRole),
/* harmony export */   rl: () => (/* binding */ ZMembership)
/* harmony export */ });
/* unused harmony exports ZMembershipRole, ZMember, ZMembershipUpdateInput */
/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(545198);

const ZMembershipRole = zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([
    "owner",
    "admin",
    "editor",
    "developer",
    "viewer"
]);
const ZOrganizationRole = zod__WEBPACK_IMPORTED_MODULE_0__.z.enum([
    "owner",
    "manager",
    "member",
    "billing"
]);
const ZMembership = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    organizationId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    userId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    accepted: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean(),
    role: ZOrganizationRole
});
const ZMember = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    name: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().nullable(),
    email: zod__WEBPACK_IMPORTED_MODULE_0__.z.string().email(),
    userId: zod__WEBPACK_IMPORTED_MODULE_0__.z.string(),
    accepted: zod__WEBPACK_IMPORTED_MODULE_0__.z.boolean(),
    role: ZOrganizationRole
});
const ZMembershipUpdateInput = zod__WEBPACK_IMPORTED_MODULE_0__.z.object({
    role: ZOrganizationRole
});


/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [8079,3073,7863,5069,255,9759,6626,5570,1238,2021,9069,7762,8728,9398,881,9358,4150,928,9470,7550,3687,5863,7043,8478,4908,7258], () => (__webpack_exec__(774837)));
module.exports = __webpack_exports__;

})();